{"meta":{"title":"花嫁達の部屋","subtitle":null,"description":"技术博客……或者一些私货。","author":"头蟹床(Headcrabbed)","url":"https://blog.mottomo.moe"},"pages":[],"posts":[{"title":"简单记录一下 GitHub SSH 主机密钥失效的问题解决","slug":"zh/2023-04-09-GitHub-SSH-Key-Error","date":"2023-04-09T10:37:00.000Z","updated":"2023-04-09T10:53:47.542Z","comments":true,"path":"categories/Tech/zh/2023-04-09-GitHub-SSH-Key-Error/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2023-04-09-GitHub-SSH-Key-Error/","excerpt":"","text":"3月23日的的时候 GitHub 错误地更新了主机的 SSH 密钥。这导致基于 SSH 的 Git 操作直到本地更新密钥之前都会失效。 由于我的博客是通过 Hexo-Git 部署的，所以这次一提交，也掉坑里了。 直接 hexo d，首先显示的是如下的错误消息（截取开头）： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! 接着阅读可以发现是检测到密钥不匹配，而且开启了强制密钥验证，为了防止中间人攻击，所以就报错了。因为我以前通过 SSH 方式进行过 Git 提交，所以本地的密钥数据库（.ssh/known_hosts）存在主机记录。所以先按那篇文章所说的，删除旧的密钥： ssh-keygen -R github.com 执行完成后我再尝试推送，但遇到了另一个问题： Error: Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 因为此时我还没有手工通过 SSH 方式提交，所以数据库不存在记录。为了解决这个问题，我在 GitHub 上加回了本机的私钥（忘了是什么原因没掉了，之前是2017年设置的，呜呜）。但是这个问题仍然存在。有没有能不通过 SSH 进行一次 Git 拉取/提交而刷新 SSH 密钥的方法呢？（明显，直接 SSH Shell 上 GitHub 是不可能的。） 我对 SSH 工具不熟，所以还是找了一下。根据这篇文章的指示，运行一下 ssh-keyscan 就行： ssh-keyscan github.com 然后将输出的内容加入到 known_hosts 里面。之后就正常了。 此外，还可以通过 -F 查询主机是否已知，或用 -l 列出所有已知主机： ssh-keygen -F ssh-keygen -l","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Unity Input System 的控制方案（control scheme）应该怎么用？","slug":"zh/2023-04-09-Unity-Input-System-Control-Scheme","date":"2023-04-09T06:26:00.000Z","updated":"2023-04-09T11:09:48.243Z","comments":true,"path":"categories/Tech/Coding/zh/2023-04-09-Unity-Input-System-Control-Scheme/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2023-04-09-Unity-Input-System-Control-Scheme/","excerpt":"从 Unity 2019.1 开始，Unity 提供了一个新的模块 Input System。它提供了方便的控制器切换、多控制方式可配置性、可扩展的控制器支持（例如映射虚拟控制器）等等。比起以前的 Input Manager 来说结构化了不少，不用每个游戏都自己再写一套映射系统了。关于它的基础使用我就不说了，网上在它发布不久早就有了许多教程。这篇博文要记录的是绝大多数地方都没提到的，它的“控制方案”（control schemes）的使用方法和适合场景。","text":"从 Unity 2019.1 开始，Unity 提供了一个新的模块 Input System。它提供了方便的控制器切换、多控制方式可配置性、可扩展的控制器支持（例如映射虚拟控制器）等等。比起以前的 Input Manager 来说结构化了不少，不用每个游戏都自己再写一套映射系统了。关于它的基础使用我就不说了，网上在它发布不久早就有了许多教程。这篇博文要记录的是绝大多数地方都没提到的，它的“控制方案”（control schemes）的使用方法和适合场景。 如果你使用的是 UGUI，项目中仅使用了 Input System（Player - Configuration - Active Input Handling 选择了 Input System），需要将其默认的 Input Manager 后端换为 Input System 后端。这里有操作指南。简单来说，直接找到场景中的 EventSystem 对象（通常是这个名字），将上面的 Input Module 换为 Input System UI Input Module。默认情况下，直接点击那个迁移按钮就行。 大多数情况下，你是不需要关心控制方案的，直接针对平台绑定输入源（按键、轴向输入）就行了。我一开始就是这么做的。这里以我做的玩意儿简化后的情况为例： 这张图值得注意的是，每个平台都分配了惯例的确认和取消按键（PlayStation 上用的是亚洲方案），即使它们的方位不一样。另外，所有控制都共享一个控制方案，没有独立的控制方案，这样的 input actions 资产应用后是这个样子： 这个文件粗看上去没什么问题。本地测试中，我测试了键盘和 XBox 手柄，两种控制器可以同时响应，手柄也是即插即用，不需要专门做控制切换的设置页面。（这是一个单人游戏，所以不用考虑本地多人之类的事情。） 然而，彩喵拿到 Switch 上测试之后反馈说，ABXY 根本没有响应。嗯？那 Unity 整一个专门的 Switch Pro Controller 控制器子类干什么呢？我不是针对这个 controller 分配了键 AB 吗？你怎么就设置设置得上，运行运行不起来呢？ 答：你不能直接使用 ABXY 绑定，而是需要用 GamePad.buttonEast、GamePad.buttonSouth、GamePad.buttonNorth、GamePad.buttonWest 来访问。也就是说整个 controller 必须退化成一个 generic D-pad controller，不能使用 Switch Pro Controller 子类。但是，如果你直接这么把原先分配给 Switch 的 A 和 B 替换成 buttonEast 和 buttonSouth，就会发现一个问题：虽然我们的目标是仅在 Switch 上使用它，但它在 PC 上也抢了 XBox 手柄的键位，导致 XBox 手柄的 A 和 B 变成了未定义行为。 到此直接分设备设置按键的尝试就失败了。怎么解决呢？我想到了分多钟控制方案。所以，第二版的是这样的： 首先在左上角添加四种控制方案：Keyboard、XBox、PlayStation 和 Switch。添加时记得把对应的设备需求选上。这里以 XBox 为例： 然后，在主编辑界面将每个按键分配给对应的设备。这里还是以 XBox 为例： 设置到 Player Input 上之后： 可以注意到在 Actions 下多了两项：Default Scheme 和 Auto-Switch。这两项的意义可以阅读工具提示来理解。前者控制的是默认的控制方案，如果未指定（&lt;Any&gt;）则会寻找第一个匹配到的；后者决定如果某个方案因为设备不满足而失效（例如，手柄断线），是否会尝试寻找并应用另一个可以匹配的。一般情况下，如果是全局只存在一个 Player Input，那选择 &lt;Any&gt; 和 auto-switch 是完全足够的。关于匹配过程可以参考 Input System 的文档，一句话概括就是匹配成功项最多者胜出。 看起来好了，那运行起来吧。等等，为什么手柄没反应，只支持键盘了？刚才不是好好的吗？我不是设置了 XBox 手柄的控制方案吗？为什么它没有同时启用呢？于是我开始找诸如“Unity input system control scheme”之类的网页，可惜基本没有解释。就算是 Unity 自己的页面，里面的演示视频也只是简单添加了两种 control scheme 然后就正常运行了，看起来能动态切换，和我实测的并不一样。 直到我找到 Unity 官方论坛上一个讨论多个控制方案的帖子。其中一个开发者的回帖解答了我的疑问。（我之前也找过 Input System 相关的帖子，也见过这位老哥，他应该就是 Input System 的主要开发者之一。）以下是帖子节选，我加粗了重要部分： … Control schemes are only really relevant if you want to separate multiple different means of controlling your game/app from each other such that they are mutually exclusive and such that you can know which one is active at any one time (e.g. to display control hints). So in effect, the intention for having two control schemes, one for keyboard and one for gamepad, would be that keyboard input is not meant to be used concurrently with gamepad input. While the keyboard bindings are active, the gamepad bindings will not be. If both are in the same control scheme, however, they will concurrently be active side by side. … 本质上，不同控制方案之间是互斥的，同时只能采用一种。如果你玩过一些老的主机移植游戏，就很好理解：那些游戏不支持同时使用键鼠和手柄，而且也未必支持动态插拔，如果你想换控制器就需要进入游戏里专门的设置页面去切换。 到此问题也就有了个答案。如果希望同时支持键盘和手柄，而且不想做专门的手动切换，那么就应该是按照游玩设备分类，而非控制器分类。将 Keyboard 方案重命名为 PC 方案，然后添加可选设备： 接着，将 PC 上可用的手柄输入也选上。这里以 XBox 为例： 图中 XBox 手柄的 A 不仅在 XBox 上有效，也在 PC 上有效。而在 PC 上，键盘也是有效的。（PlayStation 控制器同理。）所以，在 PC 上，你就可以同时接收到键盘和手柄输入了。 然而设置完毕后还有一个问题。可以见到对于“确认”行为，我们为手柄指定了三种按键： 需要 XBox 控制器（PC 上或 XBox 上） A（&lt;XInputController&gt;/buttonSouth） 需要 PlayStation 控制器（PC 上或 PlayStation 上） ○（&lt;DualShockGamePad&gt;/buttonEast） 需要 Switch Pro 控制器（Switch 上） buttonEast（&lt;GamePad&gt;/buttonEast） 如果我没设置控制器需求的话，由于 XInputController 是 GamePad 的子控制器类型，所以通用 GamePad 的设置也会被响应，就出现了前文的未定义行为问题。但是理论上，既然我设置了控制器需求，而且我没有接入 Switch Pro 控制器，那最后一条应该不能响应才对。但是在实测中，虽然 input system 自动选择了 PC 方案，但 Switch 方案仍然会被响应。我认为这是 input system 的一个 bug。 这个bug要完美解决的话比较麻烦。不过在我的目标工程里不需要搞手动选择也不需要考虑多人，所以可以通过以下方法绕过去：保持 Default Scheme 为 &lt;Any&gt;，但是把 Auto-Switch 关了。该方法在 PC 和 Switch 上测试通过。（所以为什么 Switch 上又能识别 Switch Pro 控制器需求——HID，但直接配置特化不行呢？神秘。） Input System 是带有调试工具的，可以方便地看到当前连接的设备、采用的方案、按键映射等等，还有一些其他功能（给虚拟设备和远程设备用的），直接单击任意 Player Input 右下角的按钮即可。比如，正确设置后，运行时可以看到如下的界面： 从图中可以看到： 连接了3个设备（展开后可以看到是键盘、鼠标和 XBox 手柄）。 识别了一个玩家（默认的使用例）。 玩家所占用的设备是键盘和 XBox 手柄。 因此选用了 PC 控制方案。 在 .inputactions 资产中定义的行为，实际被映射到了哪些控制器的哪些键/轴。 如果出现了上文的“未定义行为”，可以看到 Confirm 和 Cancel 两个行为都同时绑定了 buttonSouth 和 buttonEast，因此按下后实际触发哪个是不确定的。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://blog.mottomo.moe/tags/CSharp/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blog.mottomo.moe/tags/Unity3D/"}]},{"title":"关于联想Y540键盘停止工作的事","slug":"zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working","date":"2022-04-19T23:23:00.000Z","updated":"2023-04-09T06:24:30.413Z","comments":true,"path":"categories/Misc/zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working/","excerpt":"","text":"昨天晚上我的笔记本，联想Y540（9750H/16G/1650，在欧洲买的）的键盘突然罢工了。我本来想重启进 BIOS 开 VT 的，然而进入 BIOS 后键盘完全无法操作，只能电源键强杀。 再次开机，发现登录界面也无法用键盘控制（包括输入）了。没办法，先用屏幕键盘凑合一下。进去后打开设备管理器，发现键盘消失了，即插即用设备倒是多了一个无法读取设备描述符的设备（错误代码 2B）。禁用、卸载、重启数次依然如此。 由于我还有一个台式机，用的是 USB 键盘，所以先拿它来救急。我发现，在进入 BIOS 后，外置键盘是可以用的，笔记本自己的键盘倒是不行（CapsLk、NumLk 也不亮）。那么是不是固件问题呢？手动从 BHCN42WW 更新到 BHCN44WW，键盘依然无法使用。 这时候我发现了一个有趣但无法解决问题的事实。Y540 的键盘是有背光的，使用 Fn+空格调整亮度。现在，无论是在 Windows 下还是在 BIOS 中，这个功能都是可用的。另外，我能进入 BIOS，说明至少 F2 也是在那之前好好工作了的，要不根本没法进。也就是说，键盘的硬件（电路板、键帽、排线等等）应该是没问题的，大概率是软件出了意义不明的问题。 然后在联想自己的用户论坛上找到了这么一个帖子，让人把电池耗尽再开机。我试了试，断开电源，低电量时 Windows 自动休眠了。接回电源，再开机，键盘仍然没有恢复。我觉得这个方法行不通。但是在我第二天早上重启之后，NumLk 亮起来了。再一试，登录界面有响应了。也就是说，在接入电源后，你得再重启一次，让某个固件刷某个东西才行。 后来搜索发现，联想笔记本的键盘问题发生频率不低，断电法这种让人费解的办法甚至是一些网站推荐的在换修前的最终手段。也有因为联想自己固件更新导致硬件错误（而且无法回滚）的愤怒老哥，还有其他愤怒老哥（1、2）。究竟如何，还是大家评判吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"C# Tuple Element Names and Method Signatures","slug":"en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures","date":"2020-07-26T05:42:00.000Z","updated":"2020-07-26T15:25:39.292Z","comments":true,"path":"categories/Tech/Coding/en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/","excerpt":"Methods in C# have special checks if tuples appear in their signatures. Sometimes you can see confusing compile errors due to these checks, for example, in interface implementation. Unfortunately there is no such a “formal document” that defines these behaviors. So I note them down here, which may serve as a side note until the specification follows up (or not :D).","text":"Methods in C# have special checks if tuples appear in their signatures. Sometimes you can see confusing compile errors due to these checks, for example, in interface implementation. Unfortunately there is no such a “formal document” that defines these behaviors. So I note them down here, which may serve as a side note until the specification follows up (or not :D). I found this problem when writing a piece of code. An example is demonstrated below: using System; using System.Collections; using System.Collections.Generic; class Program { static void Main() { var e = new SomeEnumerable(); foreach (var x in e) { Console.WriteLine(&quot;({0}, {1})&quot;, x.First, x.Second); } } } class SomeEnumerable : IEnumerable&lt;(int First, int Second)&gt; { public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator() { throw new NotImplementedException(); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } } The code compiles. That’s expected. But then I began to think, that the tuple ((int First, int Second)) is such a burden, because it spreads everywhere. Several classes have the similar definitions and usages, and those tuples all have the same semantics. According to the C# syntax, tuples equivalence are compared structurally. Element names are just a syntax sugar backed by attributes. So, it should be okay to erase the names in the generics of interface, but keep them in the returned value to provide their semantics to the invoker. In other words, the code should be like this: // ↓ notice the tuple here class SomeEnumerable : IEnumerable&lt;(int, int)&gt; { // ↓ and here public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator() { throw new NotImplementedException(); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } } Guess what? I got a compile error. But what if I use the returned tuple without explicitly mentioning their element names? // ↓ directly deconstruct the tuple foreach (var (f0, f1) in e) { Console.WriteLine(&quot;({0}, {1})&quot;, f0, f1); } When SomeEnumerable is unchanged, the code above can be compiled without any error. Strange, isn’t it? It seems sometimes the tuples are structually equivalent, and sometimes they are not. Does it mean I have to keep all the frustrating (int First, int Second) pieces? Is it a negligence in language design, or some other problem? Therefore I searched the specification and other documents. Unfortunately, by now the specification is only updated to language version 5.0. Microsoft Docs only has the full reference until the draft of version 6.0 (and it is not even a specification). Tuples were introduced in C# 7.0 and there is only an incremental language reference (only mentioned the lowest language version but not in an explicit branch). Well, C# 9.0 will be out soon. Unfortunately, there is no documentation of the compiler behaviors I presented above. Then, according to the error code (CS8141) I was able to find dotnet/orleans#3421. One of its discussion mentioned dotnet/roslyn#20838, a pull request (PR) that relaxed the matching rules for tuple element names. In C# 6.0, the types System.ValueTuple&lt;...&gt; are supported but the compilation will fail if the referened assembly is authored in C# 7.0 and custom tuple element names are used (dotnet/roslyn#20528). dotnet/roslyn#20838 fixed that problem by allowing names mismatch under certain situations. That is to say, the code below (taken from dotnet/orleans#3421) could not compile before, but can compile after that PR was merged: using System.Threading.Tasks; public interface ISomeGrain { Task&lt;(bool someBool, string someString)&gt; Func(); } class Impl : ISomeGrain { public Task&lt;(bool, string)&gt; Func() { return Task.FromResult((true, &quot;&quot;)); } } However, this doesn’t solve my problem. My case is different from above and it can’t compile. According to dotnet/orleans#3421, this problem was fixed in .NET Core 2.1, but I still can’t compile on .NET Framework 4.7.2 and .NET Core 3.1 SDK. Is it a software regression? I couldn’t find other PRs related to fixing tuple behaviors, so I read dotnet/roslyn#20838 carefully. The thing that interests me is the testing code added in this PR. Its snapshot (of the full file) in July 2020 is here. After reading the tests I think I understand why it is like that: it is an error-tolerant design. All tuples (the ones that the syntax sugar use) are System.ValueTuple&lt;...&gt; types, and they can be assigned whenever implicit casts succeed. Moreover, you can use whatever name you like for the tuple elements (after C# 7.0). And those, may break code contracts and introduce subtle but deadly errors. Consider the code illustrated below: interface SomeInterface { (string Name, string Address) GetContactInfo(); } class SomeClass : SomeInterface { // notice the element names of the tuple here // and the one defined in the interface public (string Address, string Name) GetContactInfo() { // ... } } Calling GetContactInfo() via SomeClass or SomeInterface will give you confusing results. So the best solution is prohibiting the change in element names. Let’s head back to the problem at starting point. Unfortunately, if I want to preserve the semantics in code, I have to keep (int First, int Second) everywhere. I can’t omit some of them and write (int, int) instead. So be it. In the unit tests of CodeGenTupleTest.cs there are several error codes. After reading the invesigation process above, you should have understood why they are designed like that. However, the error messages are still unclear and confusing. They would be better with hints, like what GCC or Clang does. So here I will explain them with some examples. For each error there may be more than one way to be triggerred, and the examples below are the most simple ones. CS8139: Checked when overriding a method whose signature contains tuples. Thrown when element names in base and child classes differ. class Base { public virtual (int, int) TupleAsReturn() { // ... } public virtual void TupleAsParam((int A, int B) value) { // ... } } class Derived : Base { // ↓ CS8139: cannot change tuple element name when overriding method public override (int A, int B) TupleAsReturn() { // ... } // ↓ CS8139: cannot change tuple element name when overriding method public override void TupleAsParam((int, int B) value) { // ... } } CS8140: Checked when one of a interface I‘s generic parameter T is instantiated with a tuple. Thrown when the I‘s implementation implements multiple Is but Ts are the same tuple with different element names. interface IGeneric&lt;T&gt; { } // ↓ CS0528：IGeneric&lt;(int A, int B)&gt; already exists in the implementation list class Class1 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int A, int B)&gt; { } // ↓ CS8140：IGeneric&lt;(int A, int B)&gt; already exists in the implementation list, with different tuple element names class Class2 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int C, int D)&gt; { } CS8141: Checked when one of a interface I‘s generic parameters T is instantiated with a tuple. Thrown when Ts have different element names. interface IGeneric&lt;T&gt; { T Get(); void Set(T t); } class Class1 : IGeneric&lt;(int A, int B)&gt; { // ↓ CS8141: tuple element names must match with interface method public virtual (int, int) Get() { // ... } // ↓ CS8141: tuple element names must match with interface method public virtual void Set((int, int) tuple) { // ... } } class Class2 : Class1, IGeneric&lt;(int C, int D)&gt; { // ↓ CS8141: tuple element names must match with interface method public override (int C, int D) Get() { // ... } // ↓ CS8141: tuple element names must match with interface method public override void Set((int C, int D) tuple) { // ... } } CS8142: Checked when defining a partial method whose signature contains tuples. Thrown when element names differ in declaration and definition. partial class Class { partial void Method((int A, int B) tuple); } partial class Class { // ↓ CS8142: both parts of partial method must use the same tuple element names partial void Method((int, int) tuple) { // ... } }","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"English Version","slug":"English-Version","permalink":"https://blog.mottomo.moe/tags/English-Version/"},{"name":"CSharp","slug":"CSharp","permalink":"https://blog.mottomo.moe/tags/CSharp/"}]},{"title":"C# 元组元素名称和方法签名相关","slug":"zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures","date":"2020-07-26T05:42:00.000Z","updated":"2020-07-26T15:04:02.574Z","comments":true,"path":"categories/Tech/Coding/zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/","excerpt":"C# 中带元组的方法，在涉及继承、接口实现等等情况时遵循特殊的规则。可惜这部分并没有一篇文档记载，于是我就先记下来，以后如果这个规则正式成文了（或没成文），本文都可以起到参考作用。","text":"C# 中带元组的方法，在涉及继承、接口实现等等情况时遵循特殊的规则。可惜这部分并没有一篇文档记载，于是我就先记下来，以后如果这个规则正式成文了（或没成文），本文都可以起到参考作用。 这是我在写一段代码时偶然发现的。示例代码如下： using System; using System.Collections; using System.Collections.Generic; class Program { static void Main() { var e = new SomeEnumerable(); foreach (var x in e) { Console.WriteLine(&quot;({0}, {1})&quot;, x.First, x.Second); } } } class SomeEnumerable : IEnumerable&lt;(int First, int Second)&gt; { public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator() { throw new NotImplementedException(); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } } 以上的代码编译通过，没有问题。然后我就想，这个元组（(int First, int Second)）写起来太麻烦了，几个类里都有相似的使用的地方，语义都是一样的。而且根据 C# 的语法，元组是可以判断结构等同的，字段的名字只不过是个有特性支持的语法糖而已。那么，我就想将实现的接口相关类型的字段名称抹除，只在返回值提示字段意义。也就是说，改成下面这个样子： // ↓ 注意这里的签名 class SomeEnumerable : IEnumerable&lt;(int, int)&gt; { // ↓ 和这里不一样 public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator() { throw new NotImplementedException(); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } } 你猜怎么着？编译失败了。但是如果我使用的时候不加名字呢？ // ↓ 直接解构 foreach (var (f0, f1) in e) { Console.WriteLine(&quot;({0}, {1})&quot;, f0, f1); } 在保持 SomeEnumerable 为原状的情况下，上面这一段代码也可以正常编译。 怎么这么奇怪，有时候是结构等同的（只需要看字段顺序，不看字段名称），有时候不是结构等同的（字段顺序和名称都要看）？那岂不是我每个地方都得写上冗长的“(int First, int Second)”了吗？这是语言设计的缺漏还是其他什么问题？ 于是我去找了这部分的规范和文档。可惜，标准目前只到 5.0，Microsoft Docs 上只到 6.0 的草稿。而元组是在 C# 7.0 引入的，相对正式的文档也只有一个参考。另外，不久之后，C# 9.0 就要出来了。很遗憾，没有任何文档记录了我上面演示的编译器行为。 接着，我根据编译器输出的错误信息（CS8141），找到了 dotnet/orleans#3421。在其回复中提到了 Roslyn 的修复 PR dotnet/roslyn#20838。这个 PR 的内容是放宽对元组名称匹配的限制，使得元组能在不支持元组字段命名、但是能使用元组类型本身的时候（例如 C# 6.0，见 dotnet/roslyn#20528），允许元组字段名称的部分或者全部不匹配。 也就是说，以下这段代码（dotnet/orleans#3421 中的例子）在这个 PR 之前会报告编译错误，但是之后是通过的： using System.Threading.Tasks; public interface ISomeGrain { Task&lt;(bool someBool, string someString)&gt; Func(); } class Impl : ISomeGrain { public Task&lt;(bool, string)&gt; Func() { return Task.FromResult((true, &quot;&quot;)); } } 但是这仍然不能解决我的问题，因为我的代码不是这种情况，并不能编译通过。根据 dotnet/orleans#3421 的描述，在 .NET Core 2.1 SDK 及之后应该是得到修复的。可是我在 .NET Framework 4.7.2 和 .NET Core 3.1 SDK 上编译，仍然无法通过。难道它是一个回归错误（regression）？ 我没有找到类似的解决元组相关的 PR，所以就去看上面那个 PR 的内容。比较感兴趣的是加入的测试代码。现时点的快照是这样的。阅读了这些测试用例后才明白，原来这些编译错误就是防呆设计。理由也不难推测：元组的类型其实都是 System.ValueTuple&lt;...&gt;，而且可以任意修改元组字段名称；如果类型隐式转换通过的话，按照结构相等性，编译就会通过；但是修改字段名称就意味着修改代码约定，会引入难以排查的错误。考虑以下代码： interface SomeInterface { (string Name, string Address) GetContactInfo(); } class SomeClass : SomeInterface { // 这里的返回值和接口规定的意义不一致 public (string Address, string Name) GetContactInfo() { // ... } } 在通过 SomeClass 和 SomeInterface 分别调用 GetContactInfo() 的时候就会产生令人困惑的结果。因此最好的方式就是禁止元组字段名称发生变化。 回到出发点的问题。所以很不幸地，如果要在代码中保留语义的话，我必须在每个地方都写上“(int First, int Second)”，而没法在一部分地方简写成“(int, int)”。 在 CodeGenTupleTest.cs 的单元测试中出现了若干元组相关错误码。在阅读了上面的探索过程后，你应该理解了为什么它们这么设计。但是错误信息还是有点让人搞不清在说什么（GCC：我比你强），所以在这里简单做个整理。对于每一种错误，可能有多种触发方式，这里只举出简单直接的例子。 CS8139：在类继承时，被覆盖的方法签名中含有元组时检查。如果元组各字段名称在基类和子类中不同，则输出这个错误。 class Base { public virtual (int, int) TupleAsReturn() { // ... } public virtual void TupleAsParam((int A, int B) value) { // ... } } class Derived : Base { // ↓ CS8139：覆盖时不可以更改元组元素名称 public override (int A, int B) TupleAsReturn() { // ... } // ↓ CS8139：覆盖时不可以更改元组元素名称 public override void TupleAsParam((int, int B) value) { // ... } } CS8140：某个泛型接口的泛型的实例化类型为元组时检查。如果实现了相同的泛型接口，只有元组字段名称不同时，输出这个错误。 interface IGeneric&lt;T&gt; { } // ↓ CS0528：IGeneric&lt;(int A, int B)&gt; 已经在实现列表中 class Class1 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int A, int B)&gt; { } // ↓ CS8140：IGeneric&lt;(int A, int B)&gt; 已经在实现列表中，只不过元组元素名称不同 class Class2 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int C, int D)&gt; { } CS8141：某个泛型接口的泛型的实例化类型为元组时检查。如果实现时元组字段名称不同则输出这个错误。 interface IGeneric&lt;T&gt; { T Get(); void Set(T t); } class Class1 : IGeneric&lt;(int A, int B)&gt; { // ↓ CS8141：元组元素名称必须和接口方法匹配 public virtual (int, int) Get() { // ... } // ↓ CS8141：元组元素名称必须和接口方法匹配 public virtual void Set((int, int) tuple) { // ... } } class Class2 : Class1, IGeneric&lt;(int C, int D)&gt; { // ↓ CS8141：元组元素名称必须和接口方法匹配 public override (int C, int D) Get() { // ... } // ↓ CS8141：元组元素名称必须和接口方法匹配 public override void Set((int C, int D) tuple) { // ... } } CS8142：分部方法签名中含有元组时检查。如果定义和实现中的元组字段名称不同则输出这个错误。 partial class Class { partial void Method((int A, int B) tuple); } partial class Class { // ↓ CS8142：分部方法的各个部分必须使用相同的元组元素名称 partial void Method((int, int) tuple) { // ... } }","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://blog.mottomo.moe/tags/CSharp/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"麻辣土豆新动作的骨骼曲线表","slug":"zh/2020-05-07-MLTD-Skeleton-Curve-Table","date":"2020-05-06T20:15:00.000Z","updated":"2020-08-01T15:10:00.685Z","comments":true,"path":"categories/Tech/RE/zh/2020-05-07-MLTD-Skeleton-Curve-Table/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2020-05-07-MLTD-Skeleton-Curve-Table/","excerpt":"这次讲讲我是怎么得到土豆新动作的骨骼曲线表的。","text":"这次讲讲我是怎么得到土豆新动作的骨骼曲线表的。 我在土豆二周年之后就没玩土豆了。但是从2019年8月开始，陆续接到一些土豆文件变化的 issue。Unity 版本更新引起的问题这里不讨论。一个大的变化是土豆的动作文件不再公布源文件，只有“运行时”的文件。大多数动作还是有源文件的，仅有“运行时”文件的只有少数，估计是复杂舞蹈的技术限制（运行时生成内存爆炸？）或者是资源发布错误。总之两种情况都必须处理。 在老的资源列表中，这两个文件都会给出。比如，dan_shtstr_01.unity3d（Shooting Stars 的动作）就会附带一个 dan_shtstr_01.imo.unity3d。在这个 .imo.unity3d 中就可以看到序列化了的源文件。将它转换成完整的帧序列还是很简单的。 但是新列表就不再带这些 .imo.unity3d 了。在 issue 中提到了 Rebellion（dan_rebell_01.unity3d）。于是我只能去看这个文件的内容是什么。原来它是几个 AnimationClip，而且从结构和命名上分析，应该就是源文件“编译”之后的。也就是说，之前那些 .imo.unity3d 可能是不小心放进去的（自动构建时忘记排除）。也有可能是选择性地下载，如果网络差就下载源文件并在第一次播放时本地“编译”，这样可以减少数据传输量；如果网络好则直接下载成品。不管是因为什么，现在只有成品了。 那么第一步就很明显了：读取需要的 AnimationClip。这倒不难。而且由于土豆一直用的是 Generic 而不是 Humanoid，所以动作数据保存的是整个时间轴上的完整骨骼变换。也就是说，每一帧的所有变换的值都在。 接下来就有点麻烦了。可以看到骨骼动画中有180条曲线（curve）；那些源文件的曲线数量也是180，所以很大概率是一一对应的。但是这些曲线只有一个简单的索引值，并不像源文件那样写明对应的是哪个关节。这个索引肯定是在制作骨骼动画的时候自动按照某种规则指定的，而且应该是各文件统一的。所以，我们应该能找到一个静态的映射方式（映射表），得知某个索引对应的是哪个关节的什么变换。 我们先来看一下原来的顺序： (POSITION, AngleX) (POSITION, AngleY) (POSITION, AngleZ) (MODEL_00, AngleX) (MODEL_00, AngleY) (MODEL_00, AngleZ) (MODEL_00/BODY_SCALE/BASE, AngleX) (MODEL_00/BODY_SCALE/BASE, AngleY) (MODEL_00/BODY_SCALE/BASE, AngleZ) ... (MODEL_00, PositionX) (MODEL_00, PositionY) (MODEL_00, PositionZ) (MODEL_00/BODY_SCALE/BASE, PositionX) (MODEL_00/BODY_SCALE/BASE, PositionY) (MODEL_00/BODY_SCALE/BASE, PositionZ) 先试试这个顺序吧。但是结果很不妙。为了避免精神污染，我就不放图了。 嗯……怎么找正确的顺序呢？又到了找弱点的时间了。我认为，在上文静态表的基础上，还应该有附加条件： 这个表很可能不是随机的。如果是的话，美术方面的维护和调试会很麻烦。当然也不排除万代丧心病狂，写一个内部插件自动完成这件事——在国内还真的有可能，但是日本……不太可能。 项之间应该会呈现明显的逻辑相关性。 同一个关节的某种分量会分组。比如，MODEL_00 的三个旋转分量会成一组，三个位移分量会成一组。 有固定的层次上的先后顺序。比如，考虑 MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2 和 MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2/SAKOTSU_L，前者是后者的父关节。如果前者在后者之前，那么所有的父节点应该在其子节点之前，反之则是之后。但是不确定对称关节的顺序，可能是左前右后，也可能是左后右前。根据老的数据推测，是左前右后。 有可能遵循其他的简单先后逻辑或者它们的组合（可能性未知）： 关节名称的字符串顺序； 所有旋转在位移之后或之前； 同一个关节的旋转组和位移组相邻，组成大组。 考虑到骨骼层级，新顺序可能很大一部分的内部相对顺序都和原顺序中的一致。 我试了几个写起来简单的顺序，但是都不对。这下我就有点头疼了，毕竟可是有180条曲线啊。 突然，在调试的时候，我发现动画帧的数据好像有着很明显的模式。一个帧存着这帧对应时间点的所有关节的变换数据，所以看这个帧里的数组的时候相当于在对各个变换进行横向的比较。于是我就想到了一种方法：能不能通过分析这种模式来找出新顺序呢？ 说干就干。我写了两个小方法，将动画的帧输出到 CSV 文件中。用的分别是 dan_hmt001_01.imo.unity3d（Blooming Star）和 dan_rebell_01.unity3d。在 Excel 中打开： 可以看到，列之间显示出了很强的分组倾向。然后我们再将这些列的模式写出来（这一切发生在我的脑中，这里写出来更容易理解）： [rebell] #1: (~-0.00x approx, 0 const, ~-0.07 approx) #2: (0 const, 0 const, 0 const) #3: (~-0.00x approx, 0 const, ~-0.07 approx) #4: (0 const, ~+0.87 approx, 0 const) #5: (0 const, 0 const, 0 const) ... #60: (? var, ? var, ? var) [hmt001] MODEL_00#rotation: (0 const, 0 const, 0 const) MODEL_00#translation: (~-0.005 const, 0 const, ~-0.03x approx) BASE#rotation: (~+0.754 const, ~-78.6 const, ~-3.35 const) BASE#translation: (0 const, ~+0.87 approx, 0 const) ... SCALE_POINT#translation: (0 const, 0 const, 0 const) 有些分量是常数，有些是变化较小的（因舞蹈不同可能会有不同值，变化范围和速度作为分析依据不是很有用），有些是自由变化的（无法用作分析依据）。源文件中指明了一些曲线是常数，而且它们是0（比如 POSITION 的旋转分量）；这些是确定不会变化的，可以作为映射表结构的“基准点”使用。 考虑“是否为常量0”这点和基准值、变化速度，观察可以发现，中间一大块（人体关节）是有着完全相同的模式的。人体关节只有旋转。因此先假设这些关节顺序都不变。需要重点关注的是这几个关节：POSITION、SCALE_POINT、MODEL_00 和 BASE，它们一共有7个组（4个位移3个旋转）。只要搞清楚了这7个组的顺序，应该就能得到正确的结果。 接近了。 rebell 的最后分量都不是常量组，所以仅有的会出现常量的组（就是上面这几个）一定是排在最前面的。再考虑到组之间的逻辑关系，开头的应该是 POSITION（模型子空间）而不是 MODEL_00（实际的模型根关节），否者就会将 MODEL_00 的层次给破坏掉（因为必定造成 POSITION 或者其子关节 SCALE_POINT 和后面的身体关节相邻）。 那么第1组是 POSITION 的位移还是旋转呢？观察数据的模式（(?, 0, ?)），是位移。 第2组是什么呢？根据上面的大前提，有两种可能：POSITION 的旋转，或者是 SCALE_POINT 的位移。不知道，先放着。 这时候可以看到第4组的模式（(0, ?, 0)）——而这个模式，在7个组中只有一种可能：BASE 的位移。 于是我们现在可以得到这样的一个顺序： #1: POSITION#translation #2: ? #3: ? #4: MODEL_00/BASE#translation #5: ? #6: ? #7: ? #8: MODEL_00/BODY_SCALE/BASE/KOSHI#rotation（各个身体关节开始） ... 到这里应该很明显了。想想上面的大前提。如果在第1组和第4组之间插入任何的旋转，就会破坏整个逻辑。因此只有一种可能： #1: POSITION#translation #2: POSITION/SCALE_POINT#translation #3: MODEL_00#translation #4: MODEL_00/BODY_SCALE/BASE#translation #5: POSITION#rotation #6: MODEL_00#rotation #7: MODEL_00/BODY_SCALE/BASE#rotation 将这个顺序代入，就可以发现我们得到了正确的结果： 代码在这里。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"}]},{"title":"博客提交记录已经丢失","slug":"zh/2020-03-31-Site-History-Lost","date":"2020-03-31T09:49:00.000Z","updated":"2020-03-31T15:59:31.147Z","comments":true,"path":"categories/Misc/zh/2020-03-31-Site-History-Lost/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2020-03-31-Site-History-Lost/","excerpt":"","text":"在换了机器之后因为分类问题第一次更新博客。在数据迁移的时候，因为一个月前已经将源文件用 Git 管理了，所以我就没有完全复制博客文件夹里的内容，而是直接 clone 下了源文件做 deploy。当看到显示出许多的 create mode 的时候我就有一种不好的预感，一看出现了个 forced update，就知道完了。上一次删除 .deploy 导致博客的 repo 被 forced update 还是在2014年末。所以整个博客的提交记录相当于又被清零了。这次就吸取了教训，给这个 repo 也加上了提交保护。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"在 Foobar2000 中直接播放网易云音乐的缓存文件","slug":"zh/2020-03-23-FB2K-NEM-Component","date":"2020-03-22T23:20:00.000Z","updated":"2020-03-31T15:37:07.100Z","comments":true,"path":"categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/","excerpt":"又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。","text":"又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。 昨天晚上本来是计划做乐曲改编的。虽然源用的是网易云音乐，但是播放器我就不想用它，而是 Foobar2000。但是当我尝试下载的时候，却被提示仅允许付费/会员下载。 行吧，你是哪天买的版权（如果真买了的话，笑）我不知道；但是反正我没有很高的码率要求，默认播放的 128 Kbps 就行；而且如果这也不行，还有别的手段。这时候我就想到，虽然不可以下载，但是还是可以播放的啊。既然能播放，那么应该就缓存在本地了，除非产品设计抽风。 于是我就看了看缓存目录。结果发现了很多大小接近 128 Kbps MP3 的文件。（是不是有一种既视感？）主体内容应该是音频没错，但是经过了某种形式的加密。不过这次不是 CTF 了，所以就直接 Google 吧。已经有人搞定了。果然还是屈服于性能，只采用了简单的异或。哈。 那么现在的目标就是把这个逻辑封装为一个 Foobar2000 的组件，这样就可以直接在 Foobar2000 中播放了。虽然我写过简单的组件，不过这次不一样，用到的东西比 input_stub 要多一些。 这次稍微触及到了 Foobar2000 组件系统的核心之一，service_base。工程的目标是：实现一个文件流，对原文件流做一个读写封装。其实这次还算简单，是无状态的，简单异或每个字节就行了。但是麻烦在于 service_base 的设计。如果在 .NET 里面实现这个可是太简单了，继承并重写，重写中调用父类方法就行。service_base 是引用计数的，有点像 COM（接口查找和接口升级更像），但是（在 release 模式下）并没有虚表（V-table），成员查找完全依赖于模板。成员一般不使用原生指针，而是使用 service_ptr_t&lt;T&gt;。我本来就没做过 COM 开发，而且这玩意儿还是没有虚表的。 根据 SDK 附带的简单说明，继承自 service_base 的“类”实际上是接口（类似 IUnknown），不应该有任何字段和方法实现，实现细节相关应该在在对应的 *_impl 类中提供。等等，那我该怎么实例化我的 service 呢？我的指针模板应该填什么类型呢？怎么转换接口呢？ 看一下相关的定义。如果你知道 COM 的话这个看起来绝对不陌生。 class NOVTABLE service_base { public: virtual int service_release() throw() = 0; virtual int service_add_ref() throw() = 0; virtual bool service_query(service_ptr &amp; p_out,const GUID &amp; p_guid) = 0; // ... } class NOVTABLE file : public service_base, public stream_reader, public stream_writer { // ... } 但是要注意的是那些 NOVTABLE 修饰，这是和 COM 最大的不同。在 VC++ 的 release 模式下，它会被扩展为 __declspec(novtable)。这样尽管在逻辑上，file 继承自 service_base，但是在编译后它们并没有 V-table，因此不可以进行虚函数调用，dynamic_cast 也应该会失效。关于 __declspec(novtable) 对虚表和 vptr（虚指针）的影响可以参考这个回答。简单说，就是修饰 __declspec(novtable) 没关系，RTTI 和虚函数照常工作（除了在构造/析构函数中）。所以，直观的结论是，要让代码正常工作的话，抽象类（也就是 Foobar2000 中的接口）可以修饰，但是抽象类的非抽象子类不可以；抽象类自身也不能在构造/析构函数中使用虚表或虚指针相关。 怎么实例化呢？一种方法是使用工厂类（service_factory_base），不过过程就非常麻烦了。对于简单的接口，SDK 提供了一个非常方便的函数 fb2k::service_new()。只需要创建实现的实例，赋值给接口指针就行了。 在代码中，我定义了一个自定义文件流类型和它的实现： class NOVTABLE mapped_file : public file { // ... } // 注意这个 NOVTABLE，可以这么写是因为 mapped_file_impl_t 还是抽象的，实例化由 service_impl_t 负责，见下文 class NOVTABLE mapped_file_impl_t : public mapped_file { // ... } 在使用上就可以这样： service_ptr_t&lt;mapped_file&gt; ptr = fb2k::service_new&lt;mapped_file_impl_t&gt;(...); // 或者 service_ptr_t&lt;file&gt; ptr = fb2k::service_new&lt;mapped_file_impl_t&gt;(...); 有趣的是，service_new() 内部使用了 service_impl_t&lt;T&gt;。这个类型继承自 implement_service_query&lt;T&gt;，而正是 implement_service_query&lt;T&gt; 提供了新的 service_query() 的默认实现。service_impl_t&lt;T&gt; 则进一步提供了 service_add_ref() 和 service_release() 的默认实现。所以在写自己的类型实现（比如 mapped_file_impl_t）时，是不需要提供这三个方法的。因此，此时这个“类型实现”对于编译器而言还是抽象类型，不可以直接使用 new 实例化——将所有实例的创建过程进行托管，可以有效地消除某些 bug——这是一个附加的好处。service_impl_t&lt;T&gt; 正好可以作为使用模板来创建 mixin 的一个例子。 指针模板应该填什么类型呢？由于巧妙的向上查找方式（见下文），所以可以使用实现类型或者其任意的父类型。 怎么转换接口呢？其实这个组件的功能并没有涉及到这个问题，但是在开始摸索的时候，我也是实现了整个 mapped_file，所以大略知道一点。每个继承自 service_base 的类都要提供一个静态成员 GUID class_guid（用于特征萃取），在 service_query()（1.4 以后是 handle_service_query()）中进行判断。查询整体就是一个沿着继承链往上找的过程。思想则是，一个子类声明它能被转换为哪些父类。而这个继承链，实际上是编译期的，利用模板而不是虚表。可以看 handle_service_query() 的实现： static bool service_query_walk(service_ptr &amp;, const GUID &amp;, service_base *) { return false; } template&lt;typename interface_t&gt; static bool service_query_walk(service_ptr &amp; out, const GUID &amp; guid, interface_t * in) { if (guid == interface_t::class_guid) { out = in; return true; } typename interface_t::t_interface_parent * chain = in; return service_query_walk(out, guid, chain); } template&lt;typename class_t&gt; static bool handle_service_query(service_ptr &amp; out, const GUID &amp; guid, class_t * in) { typename class_t::t_interface * in2 = in; return service_query_walk( out, guid, in2 ); } 其中 t_interface 和 t_interface_parent 在接口的 FB2K_MAKE_SERVICE_INTERFACE 中被自动定义。其实就是宏的那两个参数。这里实现了自动沿着继承链向上查找的语义，终止则利用是模板参数的退化（不是无参特化，但是我不确定该怎么称呼）用一个重载实现的。 看来 Peter 也是把 C++ 吃透了。这些 API 的设计非常巧妙。 最终的成果是个小玩意儿。使用 VS 2019 编译。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Foobar2000","slug":"Foobar2000","permalink":"https://blog.mottomo.moe/tags/Foobar2000/"}]},{"title":"春天没有花儿","slug":"zh/2019-12-20-Spring-Leaves-No-Flowers","date":"2019-12-20T11:03:00.000Z","updated":"2020-03-30T22:34:35.453Z","comments":true,"path":"categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/","excerpt":"欢迎到作品的 Itch.io 页面去支持作者。另外这个系列目前由三个连续的故事组成：one night, hot springs、last day of spring 和本作 spring leaves no flowers。 本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。 我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。","text":"欢迎到作品的 Itch.io 页面去支持作者。另外这个系列目前由三个连续的故事组成：one night, hot springs、last day of spring 和本作 spring leaves no flowers。 本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。 我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。 我玩过的游戏中，针对单人、强调情感体验的不多；而让我称奇，甚至是给予我某个方面启蒙的，则是屈指可数。GRIS 和 Sayonara Wild Hearts 聚焦于短期心理状态，To the Moon 和本（系列）作品则偏向于展示某种长期的“异常”。（Sayonara Wild Hearts 我虽然很感兴趣但是没玩，因为光是看实况录播，它的美术风格就已经让我生物意义上地头疼了。） 故事的三个主角： 立花(タチバナ) 愛美(マナミ)（本故事主角） 永田(ナガタ) エリカ（第二部主角） 鈴木(スズキ) 悠人(ハルト)/ハル（第一部主角） マナミ和ハル是青梅竹马，和エリカ是高中同学。三人对“少数”的一致认同和宽容，才使得故事顺利展开。 游戏系统并不复杂，比 AVG 还要纯粹的 AVG。叙事并没有什么出人意料的地方。不过有意思的是，虽然很多选项被划了删除线而且是灰色的，是一般意义上的“不可用”状态，但是实际上那些才是让游戏进入正轨的选项。我想，这大概是作者 npckc 设计的隐藏表现方式，意思是说在角色心中这个选项就是默认不可选择的。这可能是个亮点吧。 剧情其实没那么复杂，不需要怎么解释。マナミ无法理解“亲吻”的特殊含义（在现代语境下），因此无法推断出另外两人关系的变化——更重要的是，无法真正理解自己的处境。给我冲击力的是角色所面临的问题。是的，我知道有的人是不擅长理解暗示，或者一些词汇的含义（常见于自闭症），但这些都是作用域更广泛的社会行为的，我并不知道更“私人”的感情受到这样影响是怎么样的。我曾经听说过“无性恋”，但我只是以为这代表“不喜欢任何人/对任何人都保持着中立的态度”。读到了这个故事之后我才知道，我错了。 タツヤ，您真是勇士。虽然在故事里，マナミ得到了所有人的接受（毕竟她们都有着各自的“异常”），但是现实生活中，恐怕活得要艰难太多了。 整个游戏令我震惊的就是新概念的引入。而且是实事求是的平铺直叙，不是被包装的拜金主义，因此才能给（就算不是这样的）人以共鸣。词条的解释是很可能客观公正的，但是它没有活生生的人。当你从一个人的视角，而不是从上帝视角，去看的时候，才会真正地萌生一种想法：“这个困难的根源在哪里？”进而再去思考需求和生产力的关系等等。 后来我把前两作读了一遍。这一读不要紧，第三部的印象崩塌了大半。不，不是因为歧视，而是因为总体的人物和剧情设置。 这次来总结一下，在看完三部曲后，完整的人物描述。虽然像是贴标签，但是对不起了，政治正确的气息太浓厚了。 マナミ：无性恋（asexual）、无浪漫（aromantic） エリカ：双性恋（bisexual）、纯素食主义者（vegan） ハル：跨性别者（transgender）、潜在的同性恋（推测） 她们都希望正常地活着——不是“矫正”，而是和其他人一样相互尊重。 但是一些剧情就有点……匪夷所思，或者说，如果真的发生了，想想还是可以理解的，但是概率太小了。 （第一部）ハル告诉エリカ说自己喜欢マナミ，不过マナミ已经有男朋友了所以说不出口。ハル可是认知性别为女的。……是心理上的百合倾向？还是生理上的激素作用？不得而知。而且喜欢很久了。 （第二部）与ハル的对话中，选错一个就会导致故事提早结束（bad end）。和另外两部不同，这里ハル在闹别扭，总觉得自己不值得参加活动，所以一旦选择了坦诚的选项，ハル就要不不接电话不回消息，要不就说干脆所有的活动都取消算了。但是老妹，你之前不是都去过温泉了吗？从那次事件中就可以见到人家品行如何。你这么缩着，说着不要再麻烦人家了，不是更给人添麻烦吗？ 这么看来，第二部的真的是死亡选项。其他两部就友好一些，第一部有“心”的提示（左上角；可以关闭），第三部选项状态就是提示（见前文），就是这第二部麻烦多了。 （第一部/第二部）エリカ费老劲地照顾ハル，从化解ハル（不想见到マナミ的男朋友）的尴尬提出和ハル一起去市内转（最后真的去了），到给ハル准备生日活动，到真情流露，最后甚至说想亲上去了。而且经历了上面的死亡选项后，明显能看出，虽然エリカ认为自己是在尽一个朋友的责任，但是这负担起的已经超出了朋友的范围……更何况エリカ还是个双（很早就跟ハル说过）。然而结局是 as a friend。（摊手） 第二部的后日谈中，ハル表示要真诚地跟マナミ谈一谈。虽然不知道是想谈第二部里各种别扭的根本原因，还是谈她对マナミ的感情。不管是哪一种，总之从第三部可以看到，作为本故事的引子，ハル和エリカ在一起了。等等？嗯？这跳跃是怎么回事？跃迁吗？ （第三部）ハル引导マナミ去寻找解答。虽然于情于理这个指引者都应该是ハル，但是考虑到ハル的想法……作者真喜欢插刀子。 ハル的话可以引起思考，也大致体现了真实的想法： ハル：我在各个意义上都是破碎的……怎么还会有人会被这样的我所吸引呢？ 以及： エリカ：（“悠人”）是你从前男生时的名字吗？ ハル：从前也不是男生…… 有意思的是，一些词汇被意译的情况下，另一些作为专有概念被音译了。温泉（温泉(おんせん)）就被普普通通地翻译成了“hot spring”。而旅馆（旅館(りょかん)）、公共澡堂（銭湯(せんとう)）、蜜柑（みかん）则分别被翻译成了“ryokan”、“sentou”和“mikan”。我想，这些玩意儿在西方语境下，哪一个都不是新鲜事物或者说异域风情啊。问问你们的先祖，要不听听人家吐槽也可以。精罗震怒 本文涉及的主题可能是目前我所有的博文中最容易引起争议的。游戏中说了这么多，其实都是陈述一些客观事实，以及中立的处理方式。真要从法律法规层面上实施起来，就开始碰到主观观点、碰到蛋糕了，和其他行为公认的（但是根据各种标准再细分，或“先进”或“落后”的）行为准则一冲突，也是很麻烦的事。比如，奥巴马的公共厕所指导条例，就是十分粗暴的尝试。如果你要问我怎么解决，我只能耸耸肩，说，我不是神，不知道最优解是什么，也不知道那个最优的平衡在哪里；但是也许可以渐进，近似出这个特定的函数。退一步来说，这个群体内部也是分裂的——就像是多组相互独立、每组内容易相互排斥的选项，就算是第一组都选了同一个，第二组不同，就会看不顺眼。从宏观到微观，人就是这么分裂。感受不到的话……可能是很幸运地选到了大众选项。 不管如何，我依然将其视为社会生产力发展的证明。这个观点来自于《在时间的长河里》中对于毕达哥拉斯学派素食规定的解读。小众的特化需求得到满足，必须是以高生产力为条件的。否则，他们就会成为主流（提供人类这一物种生存的保障的人）的负担，从而遭到排挤。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"小谈 .NET 和 Java 的并发容器 API 设计","slug":"zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API","date":"2019-12-19T07:49:00.000Z","updated":"2020-03-30T22:34:35.452Z","comments":true,"path":"categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/","excerpt":"今天看博客园，看到一篇文章。它的主要内容是： 为什么 ConcurrentHashMap&lt;K, V&gt; 不支持 null 值？因为这样就无法区分给定的键不存在还是对应值就是 null。 为什么 ConcurrentHashMap&lt;K, V&gt; 不支持 null 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。 文章内容不赘述了。 我看完之后想到的是，.NET 的并发容器（ConcurrentDictionary&lt;TKey, TValue&gt; 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 ConcurrentHashMap&lt;K, V&gt; 的坑联系在一起，可能会发现什么。","text":"今天看博客园，看到一篇文章。它的主要内容是： 为什么 ConcurrentHashMap&lt;K, V&gt; 不支持 null 值？因为这样就无法区分给定的键不存在还是对应值就是 null。 为什么 ConcurrentHashMap&lt;K, V&gt; 不支持 null 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。 文章内容不赘述了。 我看完之后想到的是，.NET 的并发容器（ConcurrentDictionary&lt;TKey, TValue&gt; 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 ConcurrentHashMap&lt;K, V&gt; 的坑联系在一起，可能会发现什么。 以前我笑话过 .NET 的容器 API 设计。我们知道，.NET 的 Stack&lt;T&gt; 和 Queue&lt;T&gt; 是基于数组的。这给予了它们一定的随机访问能力（不过没什么卵用，想想它们是做什么的），保持内存连续性（提高缓存命中率），但是坏处就是不适合频繁的扩容和收缩。（在提高数组的利用率上，Stack&lt;T&gt; 比较好办，Queue&lt;T&gt; 用的是循环缓冲区。）我想实现基于 LinkedListNode&lt;T&gt; 的版本，却发现 .NET 并没有提供 IStack&lt;T&gt; 和 IQueue&lt;T&gt;。简单搜索就可以找到 StackOverflow 上的问题。其中有那么一句话： As it pointed Queue and ConcurrentQueue don’t have that much similar to make them implement single interface. 我就顺着看了一下 ConcurrentQueue&lt;T&gt; 的 API，接着就被震撼到了。其他的容器也是类似的。这是什么玩意儿！相比之下，人家 Java，ConcurrentHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;，多么优雅。也就是说，理论上，我可以将某个类型为 Map&lt;K, V&gt; 的成员字段啊参数啊变量啊，从原来赋值为 HashMap&lt;K, V&gt; 的实例改为 ConcurrentHashMap&lt;K, V&gt; 的实例，然后瞬间就不担心这里的多线程问题了（假设其余部分正确实现）。这不是很爽吗？而如果我使用了 Dictionary&lt;TKey, TValue&gt;，由于其和 ConcurrentDictionary&lt;TKey, TValue&gt; 没有共同的基类或者适合的接口，所以我无法只使用一个变量就兼容二者。太麻烦了，就为了这个区别，也得开始使用策略模式吗…… 今天突然理解了。ConcurrentHashMap&lt;K, V&gt; 中的 null 是一个坑，而且“这种限制”这样的无聊问题会成为 Java 开发者懂不懂并发的其中一个筛子，很大程度上就是因为它实现了 Map&lt;K, V&gt;，而后者在设计之初就计划使用 null 作为键不存在的表示，从而没有其余携带信息的手段。这是不是设计失误我不敢下结论（不知道 Bloch 当初是怎么想的），但是一定是有问题的。 我们先来看看 ConcurrentHashMap&lt;K, V&gt; 的存取 API。由于实现了 Map&lt;K, V&gt;，所以签名是一样的： interface Map&lt;K, V&gt; /* ... */ { // ... public V get(Object key); public V put(K key, V value); // ... } class ConcurrentHashMap&lt;K, V&gt; /* ... */ implements Map&lt;K, V&gt; /* ... */ { // ... public V get(Object key); public V put(K key, V value); public V putIfAbsent(K key, V value); // ... } “无法使用 null 值”可以从“需要实现 Map&lt;K, V&gt;”这个前提推断出来： 必须实现 Map&lt;K, V&gt;，因此存取必须使用 get(K) 和 put(K, V)。 在 Map&lt;K, V&gt; 的大多数实现中，get(K) 对于不存在的键会返回 null 而不是抛出异常。 怎么判断返回 null 是代表键不存在，还是代表设置的值就是 null 呢？那就得在获取值之前先使用 contains(K) 检查了。 假设允许 null 值。一样会遇到2所示的问题。那么此时怎么判断是哪一种情况呢？还是先用 contains(K) 吗？这可是可能处于并发状态下的啊，两次操作之间或许这个容器状态就改变了，引发别的问题。因此，不可以使用预先判断。 现在唯一能表示键不存在的只有返回值了。在这里做文章，规定一个特殊值 null（有经验都知道使用特殊值一般不是个好主意），用它来表示键不存在。 由于 null 返回值在这个操作的上下文中有了“键不存在”的特殊意义，为了不引发冲突，容器内的所有值都不允许为 null。 可以注意到，状态附加、原子性保证，使得应用前提发生了变化。因此，ConcurrentHashMap&lt;K, V&gt; 不适合实现 Map&lt;K, V&gt;。 再来看看 .NET 这边。 interface IDictionary&lt;TKey, TValue&gt; /* ... */ { // ... void Add(TKey key, TValue value); bool TryGetValue(TKey key, out TValue value); // ... } class ConcurrentDictionary&lt;TKey, TValue&gt; : IDictionary&lt;TKey, TValue&gt; /* ... */ { // ... public bool TryGetValue(TKey key, out TValue value); public TValue GetOrAdd(TKey key, TValue value); public bool TryAdd(TKey key, TValue value); public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue); // ... } （或许你要问，其余对 IDictionary&lt;TKey, TValue&gt; 的方法实现，比如 Add(TKey, TValue) 呢？答案是它们都成了显式接口实现。） 可见，虽然同样是实现了字典接口，但是由于 .NET 这边并未采用特殊值，所以 TryGetValue(TKey, out TValue) 有很高的并发接口适应性。开发者不需要关心特殊值的问题，而是可以和普通的 Dictionary&lt;TKey, TValue&gt; 一样，使用 null 作为项的值，不需要抓破脑袋。 .NET 这样设计的一部分原因也可能是不得已而为之。因为在 CTS 中是有严格的值类型和引用类型的区分的。ConcurrentDictionary&lt;T&gt; 并没有泛型类型约束，因此可以用于这两种类型。如果想像 Java 那样找 null 这样的特殊值，是找不到的——值类型没有“空”（null）的概念，但是不排除有“空”（empty）的值，包括默认的全零值。因此，为了携带状态，就得多加参数。 这个设计带来的一个（可能是）意想不到的好处是，它将“检测并获取”作为一个原子操作（API 层面，当然不是指令层面），而且没有副作用。这样开发者过渡到并发反而容易了。 我们再来看看在队列上的区别。 interface Queue&lt;E&gt; /* ... */ { // ... // 失败抛出异常 public boolean add(E e); public E remove(); public E element(); // 失败返回特殊值 public boolean offer(E e); public E poll(); public E peek(); // ... } // 和 Queue&lt;E&gt; 一样，不赘述 class ConcurrentLinkedQueue&lt;E&gt; /* ... */ implements Queue&lt;E&gt; /* ... */ { // ... } class Queue&lt;T&gt; /* ... */ { // ... public void Enqueue(T item); public T Dequeue(); public T Peek(); // ... } class ConcurrentQueue&lt;T&gt; /* ... */ { // ... public void Enqueue(T item); public bool TryDequeue(out T result); public bool TryPeek(out T result); // ... } 在这个设计上，Java 提供了两套令人迷惑的 API。它们提供相同的功能，但是在失败时的行为完全不同。一套是快速失败（fail-fast），抛出异常，另一套是安全失败（fail-safe），返回特殊值 null。（说实话，如果不是这次我看了文档，否则我也不会知道两套的区别。）很明显，抛出异常适用于简单开发，而在复杂的并发系统中返回“失败”这个状态更好。但是由于使用的特殊值也是个合法值（null），因此 Queue&lt;E&gt; 一般是不允许其中的项是 null 的。（但是也有例外：LinkedList&lt;E&gt; 是允许 null 项的，因为用内部的 Node&lt;E&gt; 包装了。新的坑。）且不论两套 API 是否让人头大，针对 null 的行为已经让人头大。不过，和 Map&lt;K, V 到 HashMap&lt;K, V&gt;/ConcurrentHashMap&lt;K, V&gt; 的暗坑，Queue&lt;E&gt; 到 LinkedList&lt;E&gt;/ConcurrentLinkedQueue&lt;E&gt; 反而没什么坑。 当然，你也可以说 null 本身就是个 billion dollar mistake。在这种意义上，null 本来就不该出现。可惜广泛应用的语言大多都没有禁止 null…… .NET 这边的设计就有意思了。对于普通场景的 Queue&lt;T&gt;，失败都是抛出异常的。而 ConcurrentQueue&lt;T&gt; 入队失败抛出异常，后两者失败时是返回 false 的（从命名就可以看出来）。而且 ConcurrentQueue&lt;T&gt; 和 Queue&lt;T&gt; 没有关系（见上文），因此不提供相同的 API。失败行为和 API 对于是否支持并发时线程安全（和性能！）完全不同——这虽然“适应”了不同场景，让开发者只需要“自然地”使用，但这差异同样增加了认知的负担。 另外还有一个有意思的讨论。我们知道有 ConcurrentHashMap&lt;K, V&gt;，但是线程安全的随机访问列表实现只有 Vector&lt;E&gt;（或者使用 Collections.synchronizedList() 包装），而且原理还是全部加锁的。为什么没有 ConcurrentArrayList？（原文链接已经失效，所以只好引用译文。） 回答是： 很难去开发一个通用并且没有并发瓶颈的线程安全的 List。 像 ConcurrentHashMap 这样的类的真正价值并不是它们保证了线程安全，而在于它们在保证线程安全的同时不存在并发瓶颈。…… 比如，调用 contains() 或者 indexOf() 的时候，最坏的情况下需要搜索整个列表，所以必须锁定整个列表。这个时候如果要修改列表（增删改）那必然会引发瓶颈。 相比之下，ConcurrentHashMap&lt;K, V&gt; 在修改/搜索的最坏情况下最多只需要锁住其一部分（如果你疯狂构造哈希冲突；另参考 Java 7 到 Java 8 的实现变更）。ConcurrentLinkedQueue&lt;E&gt;/ConcurrentLinkedDeque&lt;E&gt; 则更简单，无法搜索，修改也只有一个/两个方向。因此它们的使用不会构成瓶颈。 我本来还想吐槽一下 wildcard capture 的，因为我记得以前在哪里看到过，它的不恰当应用会得出合乎语法却毫无意义的结果。我写这篇文章的时候找了很久，可是就是找不到了。不过反而有了其他的发现，比如这个和这个。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Java","slug":"Java","permalink":"https://blog.mottomo.moe/tags/Java/"},{"name":".NET","slug":"NET","permalink":"https://blog.mottomo.moe/tags/NET/"},{"name":"并发","slug":"并发","permalink":"https://blog.mottomo.moe/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Python 加速好帮手：Numba","slug":"zh/2019-12-06-Numba","date":"2019-12-06T14:08:00.000Z","updated":"2020-03-30T22:34:35.452Z","comments":true,"path":"categories/Tech/zh/2019-12-06-Numba/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/","excerpt":"一次无可奈何的 Python 提速。","text":"一次无可奈何的 Python 提速。 先简单介绍一下背景。 这门课是 Visualization，由两个作业组成。第一个作业的代码部分，要求补完一个体渲染器（volume renderer）。这个渲染器是完全软件渲染的，而且需要支持几种渲染方式（也就是几种软件着色器）：切片（代码已给出）、最大密度投影（MIP）、体元合成（compositing）。不管哪一种，核心都是 ray casting。严格来说，每一个都有“合成”步骤，不过最后一个实际上指的是最常见的、使用 Phong 模型的着色。 今年我就被一个认识我的人叫过去帮忙了。去年我修这门课的时候，用的是 Java。今年据说因为 Java 入门（一个 master level 的课程，本来在 Q1，也就是 visualization 的前一个 quartile）移到了 bachelor level 3，所以在改革之后这门课默认所有选课的人都没有 Java 基础。因此，使用的语言改为了 Python。 我不得不严重吐槽今年的老师，虽然我并不认识他。内容比较长而且跟题目切合度不算太大，所以就放在文末。 好，接着就讲优化的事。下文的渲染时间以提供的橘子的数据为准。 由于各种坑爹因素的综合作用，切片的每帧渲染时间就已经超过了2秒。至于体元合成，因为所有体元基本都要至少被投射一次，总时间可达每帧10分钟（600秒）左右。其他的已经实现了这个的小组也反馈说，用时10分钟“是非常正常的”。 正常个毛！作为读者而不是这个坑爹软件的使用者，你可能不是很清楚它对人精神的打击有多大。首先，切换到体元合成模式，渲染初始帧，10分钟。接着，你会发现默认的迁移函数（transfer function）效果很差，需要调整曲线。当你调整第一个数值的时候，新的渲染开始了，又是10分钟。在这段时间内，你对迁移函数的调整完全不会反映出来——因为上一帧还没有渲染完成，所有更改都不会应用。你根据密度直方图大致估摸出了一个曲线，但为了它能起作用，你必须在上一帧渲染完成后，再次触发更改（比如调整颜色）才能获得正确的渲染结果，于是又要等10分钟。然后，你会看到默认的视角并不能看到什么有意义的东西，于是你得尝试调整视角。跟迁移函数一样，如果正在渲染，则新的视角不会应用。这就是多个10分钟。在你获得最后的满意的图像之前，精神上要受到长时间的折磨。说“折磨”，是因为这个时间根本就是因为种种错误导致的浪费生命，而且不止是一个人的生命。 怎么办呢？我们来想想方案的必要条件： 使用 Python（恶心的规定） 非侵入式的 支持 GUI 实例 补充条件： 应用容易 其实说到底，就是加速。加速，无外乎就是提高硬件利用率、合理利用硬件。例如，并行（CPU、GPU）、更高效率的代码（设计上、编译后）、提高缓存命中等等。 各位或许听说过 Cython。但是很可惜，虽然 Python 代码是合法的 Cython 代码，但是为了让 Cython 达到最高效率，必须要将代码改写成其方言。这就违反了非侵入式的条件，代码提交后别人也不容易运行这些代码。 Python 以性能为代价提供了极高的自由，而这给解释器设计让生成高效率的机器码带来的巨大的困难。所以不可能寄希望于 Python 解释器自身给我们提供极致性能。 我也试过用 multiprocessing 模块来加速。然而这并没有什么卵用。需要优化的函数是一个虚函数，而且位于事件回调，跟 GUI 有相当的耦合。这就不像一些常用 multiprocessing 优化的模块，那些模块基本是用于数值计算。而且它们的函数是全局的（对于子进程来说是入口），参数也利于封送，运行时产生的都是后台进程。当我简单使用 multiprocessing 的时候，这个程序直接弹出了好几个窗口，把我吓了一跳——而且它们没有一个在干活。 threading？别忽悠人了。 还有一些其他的方法，不过投入的成本太高，对于一个作业，精力有限，做不起。（见文末讨论。） 这时候偶然搜索到了 Numba。它和 Cython 的思路是相似的，在一定条件下，转换成 C 代码后编译运行，利用 C 的速度优势（“C 的速度优势”不是很准确，但是在此不展开了），提高代码执行效率。在满足一些苛刻的条件时，甚至还可以应用并行化，进一步提高执行效率。 就使用体验而言，Numba 总体来说还是相当友好的。在正式用到作业项目之前，我用一篇文章中的示例简单测试了一下优化效率。 import time from typing import Callable import numpy as np from numba import jit def pairwise_python(X: np.ndarray) -&gt; np.ndarray: M = X.shape[0] N = X.shape[1] D = np.empty((M, M), dtype=np.float) for i in range(M): for j in range(M): d = 0.0 for k in range(N): tmp = X[i, k] - X[j, k] d += tmp * tmp D[i, j] = np.sqrt(d) return D @jit(nopython=True) def pairwise_numba(X: np.ndarray) -&gt; np.ndarray: M = X.shape[0] N = X.shape[1] # https://github.com/numba/numba/issues/3993 # Use float_/int_ instead of float{XX}/int{XX} D = np.empty((M, M), dtype=np.float_) for i in range(M): for j in range(M): d = 0.0 for k in range(N): tmp = X[i, k] - X[j, k] d += tmp * tmp D[i, j] = np.sqrt(d) return D def pairwise_numpy(X: np.ndarray) -&gt; np.ndarray: return np.sqrt(((X[:, None, :] - X) ** 2).sum(-1)) def run_python() -&gt; None: X = np.random.random((1000, 3)) pairwise_python(X) def run_numba() -&gt; None: X = np.random.random((1000, 3)) pairwise_numba(X) def run_numpy() -&gt; None: X = np.random.random((1000, 3)) pairwise_numpy(X) def time_it(name: str, func: Callable[[], None]) -&gt; None: time_start = time.time() func() time_end = time.time() print(f&quot;{name} used {time_end - time_start} second(s)&quot;) if __name__ == &quot;__main__&quot;: time_it(&quot;raw python&quot;, run_python) time_it(&quot;numba&quot;, run_numba) time_it(&quot;numpy&quot;, run_numpy) 在我的机器上运行，结果： raw python used 5.295958518981934 second(s) numba used 0.3148195743560791 second(s) numpy used 0.05596804618835449 second(s) 可见，仅仅是转换成等价 C 代码（还没有并行）并编译，就已经获得了巨大的效率提升。当然，这还是比不过 NumPy 的向量化操作（ufunc）。 不过，在这个作业里，每个最终像素点的实际生成过程是异构（heterogeneous）的，因此无法将其向量化，自然无法充分利用 NumPy。使用 Numba 并行是可能的；考虑到作业中的这个函数远比上面的简单例子复杂，尤其是输入的参数，所以尽管理论上可能，我也没这么多精力去适配它的条件了。 我们继续来看 Numba。Numba 提供了两种模式，一种是 nopython 模式，一种是 object 模式。前者不需要涉及 Python 的解释器，后者需要。什么时候需要呢？访问除了特定受支持的数据类型（int、float、numpy.ndarray 等等）之外的，尤其是自定义的复杂类型（简单类型可以用 @jitclass）。很明显，一旦和 Python 解释器扯上关系，那么效率就得大打折扣。再加上 JIT 是有开销的，所以最后总体甚至会慢于直接在解释器中执行。因此，一般都得用 nopython 模式。 接下来就是痛苦的转换了。毕竟 Numba 要能应用，是有限制条件的。 所以第一步，就是尽量做到与 OO 无关，而是回退到面向过程的方式。毕竟文档自己说了“越像 C 越好”（笑）。拆！拆！拆！好在原程序大部分都是不需要跟对象进行交互的，因此将主体变换为面向过程的方式并没有太复杂，就是繁琐一些，花一个小时就搞定了。同时考虑到 Python 无法内联的特性，分块大小偏大，减少调用开销。 不过里面有一个问题如鲠在喉；甚至说，如果不将它解决，那么其他的优化都无法生效，Numba 必然会回退到 object 模式。在循环的最深处，需要根据迁移函数获取在该视角（viewpoint）下某个体素（voxel）的对应颜色值。这可是插在层层循环中最深的地方的一个钉子。而必需的迁移函数，在实现上是一个复杂对象，@jitclass 还不支持。嗯，仔细观察一下，颜色计算其实是根据一张表实现的，而这张表在单次渲染中不发生变化。所以我就写了一个计算量不大的函数，将迁移函数的内部状态提取到了一个 ndarray 中，并修改颜色计算使其用这个 ndarray 而不是原来的迁移函数对象。这样核心计算就可以在 nopython 模式下进行了。 目前（0.46）Numba 还不支持 MAKE_FUNCTION opcode。Numba 只会报错说“op_MAKE_FUNCTION 未实现”。这么一个莫名其妙的错误信息还是得猜一下。结果是，它不支持函数内定义的函数，无论内部的函数是否形成闭包。所以我只好又违反了模块化原则，把一些内部的小函数提出来放到全局范围里。 最后优化到了什么程度呢？原先的每帧渲染时间是大约600秒，优化后冷启动24秒（含 JIT 时间），多次运行18秒。整整33倍！而且这仅仅是将 Python 代码 JIT 的结果，甚至都没有并行化。这个函数输入太多，签名复杂，所以我就不浪费时间去做并行化了——软件本身只是用来出结果的，后面还有报告呢，这时候离截止日期已经不远了。比起再花几个小时尝试优化到最佳状态，还不如就18秒先用着，毕竟看模型又不是重复数十次上百次的重复劳动，最后总计花费时间也不会太久。 接下来就是纸上谈兵环节了。 我们看到了解释代码到原生代码的效率提升。如果要进一步优化异构任务的话，该怎么办呢？在这里再加一个前提：跟宿主语言无关，也就是要找一个相对通用的解。 一个很容易想到的方案是使用传统的 GPU。将计算逻辑变换成 shader，输入变换为顶点数据，输出从图像中解码。使用的 API 可以是 OpenGL（vertex/fragment）、Direct3D。这种做法别说现代 GPU，老一点的 GPU 都支持。缺点就是结果的复杂度不能太高，毕竟单元输出最多只有4个单精度浮点数。 如果使用 GPGPU，就可以避开许多输入输出的限制。可以使用的有 OpenGL（compute）、DirectCompute，以及 OpenCL 和 CUDA。其中一些还支持异构设备计算。 以上的方案，只要所使用的语言提供对应的绑定，就可以使用。 如果放宽“语言无关”限制，只针对 C/C++ 的话，有 OpenMP、OpenACC 和 SYCL。它们的效率提升方式不尽相同，有自动多线程并行的，有（合适时）使用 GPU 的。但是它们几乎可以和 C/C++ 无缝集成，而不需要将计算逻辑分离到独立的管线中。 对这个老师的吐槽。 客观来讲，他犯了一个严重的选型错误。他应该是这么想的，Python 不是什么“新时代的基础语言”、“万能胶水语言”，“上手十分简单”嘛。但是很明显，Python 和 VB 一样，学习曲线的上升幅度开始平缓，接着立马就极端地陡峭，也就是易于上手，难于深入，更难于精通。Python 的运行效率不能说差，但是很不擅长计算密集型的任务（至少在包括默认的 CPython 上的大部分实现，因为有 GIL）。（另外插一句，PEP-554 安排在 Python 3.9 了，所以现在也用不了。）而这门课要做的是一个软件渲染器，不仅是一个计算密集型的任务，而且是一个异构任务（不能简单地通过向量化完成）。写出逻辑是很简单的，但是一旦运行起来，就会发现它的运行时间无法忍受。想优化？对不起，优化异构任务的难度，已经远远超出了花样使用 NumPy（优化同构任务）；后者也早就不是初学者范围内的东西了。也就是说，这个作业在目标之外设置了一个巨大的障碍，而所有人不得不做出选择——要不就克服这个障碍，要不就得忍受折磨——而几乎没有人有能力克服。这是完全没有意义的精神消耗，至少对于学生而言。（现实工作中也有可能会遇到这样的问题，不过都已经到了工作了，自然就不能假设有保护了。） 他貌似对自己的水平没有准确的估计。由于很多人被折磨得死去活来，所以他似乎收到了一些问问题的邮件。将这些整理成 FAQ 之后，其中就有令人哭笑不得的回答。在程序中有一个 bug，它导致计算出的图像不会绘制到窗口中，也就是体现为“看不见”。这几乎是致命的问题，自然有人会问。而他的回答呢？“看不见图像的原因，很可能是因为你的计算机在计算上出了问题。”我真不知道该说什么好。 在代码上，可以明显看出 Java 移植的痕迹。在命名上和一些辅助类的结构上就看出来。除了 GUI 部分的代码遵循 wxPython 的一般规则、OpenGL（仅用来画包围盒）用 PyOpenGL，其他都是 Java 的简单移植。不过要说命名，Python 本身就已经很混乱了，缩写的、连写（无分隔）的、snake_case 的、camelCase 的，乱成一锅粥。以颜色的记录来说，OO 的组织方式比较利于理解，而直接使用 ndarray 更利于和 NumPy 交互，也利于优化。这更多地是一种设计选择，但是我认为有经验的话不会做出这样的选择。 程序本身交互极差。上面也提到了一部分。这个作业在最后还要完成第四种模式，将你所选定的可视化方式应用于分块的体数据。这相当于有一个一级列表，让你选择某个物体，然后再有一个二级列表，选择其在某个时间点下的数据。但是要进入这第四种模式可不是那么简单。这个模式对应的单选框默认是无效（灰色）的，你得先手工选择两个文件夹（体数据索引、各个时间），再选定了其中一个物体的其中一个时间点后，这个单选框才会激活。要不然，想切换都没法切换。这个操作本身就非常反直觉，如果没有那同学的讲解，我恐怕也得摸索个几分钟。在代码逻辑上，单物体（直接打开体数据）和多物体（本段所述的分块选择）的交互是两套代码…… 由于不断地有人哀嚎渲染一帧实在是太久了，这老师在截止日期前几天发了一则公告，说如果想加速的话推荐使用 Numba。然而他在给出的例子是切片——最简单的渲染模式，基本上就是简单的 ndarray 读取，没有复杂循环，没有合成。这个直接套个 @jit(nopython=True) 就搞定了，非常简单。然而真正有优化需求的体元合成，要用上 Numba，那得知道 Numba 是怎么工作的、它对数据结构是怎么支持的、Python 本身的瓶颈在哪里、什么时候 Python 解释器是必需的（例如让人又爱又恨的 inspect），这样才能知道什么能加速什么不行，如果不行能不能换成等价的写法使得它能被加速。这在我看来，对知识厚度的要求远远超过这门课。将这种任务放在一个作业里，就是高射炮打蚊子。而且看来，他也没有对任务难度的合理估计，以为后面都只是像他给的例子那样，直接加个装饰器（decorator）那么简单。 不过，不是没有厉害的老师的。在我选过的课里面，就发生过： Foundations of Machine Learning。老师讲得很好，而且看代码也是简明扼要，清晰易懂，几乎没有冗余。 Recommender Systems，和 FML 是同一个老师。在第四个作业中，我们要实现一个 VAE。其中助教提示的是“别忘了用 flatten() 调整数据的形状”，但是在查阅资料后我判断应该用 batch_flatten()，就这么写了。后来在作业的点评里这一条被专门指了出来，说确实应该用 batch_flatten()，是他失误了。 VLSI Programming。就是我之前写过的老先生。图的构造代码写得非常漂亮，而且指出过我的一些 pythonic 的写法（例如列表推导）有效率问题——在这门课里，效率是一个很重要的衡量因素。 Programming Methods。这门课其实是一个本科3级的课程，偏向于软件工程，我自愿选的。最后的一个作业是写一个 Takuzu（类似于数独，不过只填入0和1）的求解器，而且是可视化的。这个程序本来是用作各种设计模式的练习的，不过它的交互设计和代码水平都很不错。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Python","slug":"Python","permalink":"https://blog.mottomo.moe/tags/Python/"},{"name":"Numba","slug":"Numba","permalink":"https://blog.mottomo.moe/tags/Numba/"}]},{"title":"C++ 模板类的非待决名查找","slug":"zh/2019-10-06-Non-Dependent-Lookup","date":"2019-10-06T09:30:00.000Z","updated":"2020-07-26T13:49:08.003Z","comments":true,"path":"categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/","excerpt":"今天要做某个功能，其中我想用一个单一参数的宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）： #define DECLARE_CLASS(this_class, base_class) \\ typedef base_class MyBase; \\ typedef this_class MyClass 对于普通的类，实现起来是这个样子： #define DECLARE_ROOT_CLASS(class_name) \\ typedef class_name MyClass #define DECLARE_CLASS(class_name) \\ typedef MyClass MyBase; \\ typedef class_name MyClass 使用： class Base { DECLARE_ROOT_CLASS(Base); }; class Derived : public Base { DECLARE_CLASS(Derived); }; 很明显，这样利用 typedef 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 typedef 而不是更现代的 using，这在这里只是风格问题，对语义无影响。 对于模板类，我打算如法炮制。可是，问题出现了。","text":"今天要做某个功能，其中我想用一个单一参数的宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）： #define DECLARE_CLASS(this_class, base_class) \\ typedef base_class MyBase; \\ typedef this_class MyClass 对于普通的类，实现起来是这个样子： #define DECLARE_ROOT_CLASS(class_name) \\ typedef class_name MyClass #define DECLARE_CLASS(class_name) \\ typedef MyClass MyBase; \\ typedef class_name MyClass 使用： class Base { DECLARE_ROOT_CLASS(Base); }; class Derived : public Base { DECLARE_CLASS(Derived); }; 很明显，这样利用 typedef 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 typedef 而不是更现代的 using，这在这里只是风格问题，对语义无影响。 对于模板类，我打算如法炮制。可是，问题出现了。 我的宏定义是这样的： #define DECLARE_ROOT_CLASS_TEMPLATE(class_name, TArgs...) \\ typedef class_name&lt;TArgs&gt; MyClass #define DECLARE_CLASS_TEMPLATE(class_name, TArgs...) \\ typedef MyClass MyBase; \\ typedef class_name&lt;TArgs&gt; MyClass 然而在编译的时候，在第4行产生了错误： （Clang 提示说，）VC++ 认为，MyBase 等同于 MyClass（假设仍然使用后文的例子，则 Derived::MyBase 等同于 Derived 而不是期望的 Base）； Clang 和 GCC 认为，MyBase 未定义。 我就不理解了，为什么是未定义呢？似乎以前 stat 给 UB（两个把 C++ 玩出花的大佬）讲过 VC++ 有符号名称查找（name lookup）上的错误，与标准的不符。但是，Clang 和 GCC 是怎么回事？这里的 VC++ 又是怎么回事？ 所以我就问了 stat，如下的例子中为什么 TBase 处出错了。 template&lt;typename T1, typename T2&gt; class Base { typedef Base&lt;T1, T2&gt; TBase; typedef TBase TThis; } template&lt;typename T1&gt; class Derived : public Base&lt;T1, T1*&gt; { // 后注：在提问时我手写的；不过这样写在所有编译器中都不能通过编译，出问题的还是“typedef TThis TBase;” typedef typename TBase::TThis TBase; typedef Derived TThis; } stat 想了一会儿，说：“TBase 是 non-dependent，第一遍解析的时候找不到。” 什么是 non-dependent 呢，就是 dependent 的反义词咯。那什么又是 dependent 呢？我就搜索了一下。全称应该叫做 dependent name，具体还可以分为 type-dependent 和 value-dependent。（不是 argument-dependent lookup！） stat 所说的“第一遍解析的时候找不到”，指的是对模板类中符号的二次查找。这里由于 MyBase（TBase）是一个普通符号，而不是 type-dependent（SomeTemplate&lt;T&gt;::TBase、TBase&lt;T&gt;）也不是 value-dependent（SomeTemplate&lt;N&gt;::TBase、TBase&lt;N&gt;），所以不能通过一次扫描来确定合适的上下文。也就是 stat 说的：“（解析）模版的时候 TBase 是不知道是基类的 typedef 的”。 不过，我并不知道中文该叫什么，本文标题里的“待决名”是将语言切换到中文后显示的翻译。 下一个问题，VC++ 这里的行为是怎么回事。让我们看看文档和开发博客里是怎么说的。VC++ 默认遵照的不是标准行为，而是往里面加了点毒。在进行二次查找时，查找的位置错了。就从文章中的例子来看看： #include &lt;cstdio&gt; void func(void*) { std::puts(&quot;The call resolves to void*&quot;); } template&lt;typename T&gt; void g(T x) { func(0); } void func(int) { std::puts(&quot;The call resolves to int&quot;); } int main() { g(3.14); } 标准行为是，在模板类/模板函数中使用的符号，其查找位置为定义处，也就是说，要查找这个符号，范围应该从开头至此处。“定义”指的是模板的定义。而 VC++ 的行为是，查找位置在实际使用处。 按照这么个逻辑，上面的例子结果就很明显了。 在标准行为下：g() 对 func(0) 的调用会被解析到 void func(void*)。因为在此时（直到 func(0)）编译器只知道这个声明，而且隐式转换是可以接受的。 在 VC++ 行为下，会被解析到 void func(int)。因为在此时（直到 g(3.14)）编译器知道两个重载了的声明（void func(void*) 和 void func(int)，而其中根据参数类型决断，更合适的是后者。 同理，也就产生了上面的问题。在代码中，如果 MyBase 的使用晚于 MyClass，就会产生 MyClass 已经被重新 typedef 的情况，从而让 MyBase 指向错误的类型。当然，就算是顺序恰巧对了，在某些情况下（比如调用前出现了多种特化/偏特化），还有可能因为非标准行为而产生难以预料的后果。 另外偶然看到的一个有意思的“可选命名参数”实现思路和代码。调用效果类似 C# 的可选命名参数： void Test() { CallSomeMethod(param2 = &quot;Param2Value&quot;, param1 = param1Value); CallSomeMethod(param1 = param1Value, &quot;Param2Value&quot;); CallSomeMethod(param1Value, &quot;Param2Value&quot;); } 副作用就是会有少许污染。 在移植的时候，在变量上我使用了和原来代码相同的命名，其中就包括 xor。结果编译器就报错了。 一查，才知道原来 C++ 还有一串运算符的替代表示法。在默认情况下，这些替代名称是启用的，除非使用选项关闭。以链接中的例子来说，这样的代码虽然看上去很奇怪，但也是可以正常编译的： %:include &lt;iostream&gt; struct X &lt;% compl X() &lt;%%&gt; // 析构函数 X() &lt;%%&gt; X(const X bitand) = delete; // 复制构造函数 bool operator not_eq(const X bitand other) &lt;% return this not_eq bitand other; %&gt; %&gt;; int main(int argc, char* argv&lt;::&gt;) &lt;% // 带引用捕获的 lambda auto greet = &lt;:bitand:&gt;(const char* name) &lt;% std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name &lt;&lt; &quot; from &quot; &lt;&lt; argv&lt;:0:&gt; &lt;&lt; &#39;\\n&#39;; %&gt;; if (argc &gt; 1 and argv&lt;:1:&gt; not_eq nullptr) &lt;% greet(argv&lt;:1:&gt;); %&gt; %&gt;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"CPlusPlus","slug":"CPlusPlus","permalink":"https://blog.mottomo.moe/tags/CPlusPlus/"}]},{"title":"哈哈","slug":"zh/2019-04-23-Misc","date":"2019-04-23T10:56:00.000Z","updated":"2020-03-30T22:34:35.452Z","comments":true,"path":"categories/Misc/zh/2019-04-23-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/","excerpt":"技术长草。","text":"技术长草。 今天讲到 Kahn Process Network（KPN），我看到图示之后立刻反应过来，这结构不就是消息队列（message queue）吗。噫，消息队列“天然地”支持分布式架构，我理所当然地就接受了，因为有一点工程经验它就显得很自然了。没想到也是有一个理论支持的。 讲到并行化的实现思路（也即 parallelism），一般分为两类。多线程实现的“并行”，虽然在具体实现中是不可或缺的，但是只能说是技巧（technique），而不是架构（architecture）。这门课针对的是 parallelism by design，是架构上的并行，而且在系统设计时就有着确定的行为。（注：KPN 中各个过程是可以并行的，但是整个系统仍然有着确定的行为。这是 KPN 的一个特性。）在课程描述里还讲到有一个叫做 parallelism by compilation 的，我不知道是什么（毕竟 compilation 可能指常见的“编译”之外的更泛的意思），所以就去问了。教授（略有学究气的老先生）回答说，如果编译器足够智能的话，就可以将过程分离（注：原话用的是“process”，不过并不是指进程，而是抽象出的过程——粒度可以是大到功能模块，也可以小到一个原子操作），并抽取出可以并行的部分，自动并行。说完之后，他盯着我，很认真地（从语气和眼神里可以体会到）说：“我坚信确定的并行化（parallelism by design）是最好的方案，虽然很少人这么想。”我不知道该说什么好了。我大概能猜到他的心情；不过总有一种“力挽狂澜”之感，专门开这么一门课。 这又让我想起了复杂系统的设计方式，构造和自组织。我的思想仍然受到这篇文章的影响。或许以前我引用过，但是在这里我还是想引用一次： 但我并不认为 Java 有很大的机会，因为它本质上是为构造大型复杂系统而设计的。什么是大型复杂系统？就是由人清清楚楚描述和构造出来的系统，其规模和复杂性是外生的，或者说外界赋予的。 而 AI 的本质是一个自学习、自组织的系统，其规模和复杂性是一个数学模型在数据的喂养下自己长出来的，是内生的。 不过，我仍然认为关键系统需要人为地设计其架构。“it just works”地在精细尺度上的、不可预测的并行，虽然显得很迷人，却是非常危险的。 想起编译器优化的同时我又想起了之前和“博导”（我以前的一个同学，高中去了美国，大学读的……好像是电子工程；反正一直碾压同龄人）的一段对话。以下是节选： （前略） 我：这算什么，原教旨？（注：指纯 C 写移动设备 app） 博导：算是吧，C 系手动内存正统，Java 等 GC 语言异端！我要确定性，掌控每一行代码！ 我：抱歉，指令预测真的可以为所欲为。除非不断加 memory barrier，要不严格来说你无法掌控“每一行代码”。 博导：我知道 Intel 内部运作，知道 reordering 和 uop，所以是掌控的。（注：uop = micro-operation） 博导：当然更加知道 GCC 每一行代码会编译成什么。 我：（图片：熊猫膜拜） 博导：其实 Intel 8卷读一遍就知道了。 我：（图片：许多熊猫一起膜拜） 不知道放哪里好，就放这里吧。 原文： In a sense, the specular term gets “dibs” on the incoming light energy, and the diffuse termcan only use its “leftovers”. 译文： 某种意义上，specular项指着入射光能量大喊“归我了”，然后diffuse项只能用“剩下的”。 我读到这里的时候哈哈大笑。虽然这个翻译仍然有可以提高的地方，但是这个版本很有画面感。 某种意义上，高光（specular）项占了入射光能量的大头，散射（diffuse）项就只能利用余下的能量。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"几种斐波那契数列项算法的复杂度分析","slug":"zh/2019-04-07-Fibonacci-Implementations","date":"2019-04-07T12:44:00.000Z","updated":"2020-03-30T22:34:35.451Z","comments":true,"path":"categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/","excerpt":"GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 BEATLESS。 “回字有四样写法，你知道么？” 而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。","text":"GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 BEATLESS。 “回字有四样写法，你知道么？” 而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。 一、前言今天在面试的时候被问到了这样一个问题：求斐波那契数列的第 $n$ 项，你能想到多少种算法？ 自然，猴子都知道简单递归。再进一步，黑猩猩都能看出来递归可以用一个额外的表来速查（空间换时间）。有递归就自然要想能不能迭代。稍稍想一下的话可以知道是能迭代的。 然后又问，时间和空间复杂度是多少？ 迭代简单，$T(n) = O(n)$，$S(n) = O(1)$。递归我就炸了（所以说我太水了），时间分析就满脸问号（用表的话……优化是优化了，但是和迭代也没差多少了，却还多了调用开销；简单递归分析卡壳了），没答上来，面试官也就没问空间复杂度。所以我当时只想到了两种；后来因为提到迭代的空间复杂度为 $O(1)$，面试官可能没太听清，说道：“（时间复杂度）$O(1)$ 的解法也是有的，不过你用了迭代只能是 $O(n)$ 了。”虽然和我的回答意思相差了一些，但是我还是惊诧了一下（没出声）：“这个 $O(1)$ 是怎么来的？” 所以下午我就搜索了一下。 ……连个本科生（复杂度计算本科生都会）都比不过，我自裁罢。 二、准备斐波那契数列 $f_n (n \\in \\mathbb{N})​$ 的定义如下： f_n = \\begin{cases} 0,\\quad &n \\lt 1\\\\ 1,\\quad &1 \\le n \\le 2\\\\ f_{n-1} + f_{n-2},\\quad &n \\gt 2 \\end{cases}之后的代码以此为准。 为了简单起见，在之后的代码中使用 int，而不是更大的 long long，懒得用无符号数，也没有防溢出机制。 三、直接的代码解法这部分的方法就是只用到代码、基础算法和优化，几乎不需要数学。 3.1 递归法递归就是最简单直接的方法了，代码形式和数学形式接近，理解很好理解，大部分工作交给计算机完成。 3.1.1 朴素递归朴素递归应该学过代码都会，代码就不需要多讲了。 int fib(int n) { if (n &lt; 1) { return 0; } else if (n &lt;= 2) { return 1; } else { return fib(n - 1) + fib(n - 2); } } 对应的调用如下： int result = fib(15); 这个算法的空间复杂度比较好分析（虽然有点绕），是 $O(n)$。令初始调用为第0层，调用一次加深一层。可以知道，在某一层的所有调用结束之前，不会产生新的调用（即，栈深不会增加）。那么栈深最深的是什么时候呢？画一棵调用树就可以看出，是从 fib(n) 开始到 fib(1)（实际上可以算到 fib(2) 为止）的这条“单刀直入”的路径。或者可以这么想，每次 fib(n) 执行实际计算（求和）的时候，fib(n - 1) 已经计算完成了。所以空间复杂度是 $O(n)$（更准确地说是 $\\Theta(n)$）。 那么，时间复杂度是多少呢？许多文章直接就说结论是 $O(2^n)$，但是也没给出推导过程，或许也是因为太简单了。观察调用树可以知道，一个非叶子节点最多有两个子节点，而树的深度是 $O(n)$；在每个节点的操作都是简单加法，时间为 $\\Theta(1)$；所以总计就是 $O(2^n)$。 但是大多数人没想过，这是一个好的估算吗？我们知道，大 O 函数只是给出上界；给出比一个已知上界更高的上界也不算错。也就是说，我可以胡扯说复杂度是 $O(2^{2^n})$，你也不能说我错了，只能说这个上界“质量不好”。 再次观察调用树，可以很明显地发现不管树高度如何增长，总是有不可忽视的一部分节点“缺失”了。因此，很明显还能找出比 $O(2^n)$ 更紧的上界。 为了计算这个上界，我们不妨来观察函数调用的过程。设 fib(n) 的调用时间为 $t{n}​$ ，我们可以知道：$t{n} = \\Theta(1) + t{n-1} + t{n-2}​$。那么，这不是和原来的斐波那契数列形式完全一样吗？回到原点了。 但是等一下！斐波那契数列是可以求出通项的（见 4.3 节）。提取“公因式” $\\Theta(1)$（不是公因式，不过在复杂度分析中可以视作等量级；另外这个 $\\Theta(1)$ 虽然上面是出现在递归式里，但是在通项中可以化为一个系数——这么讲不是很准确，不过意思就是这样）之后可以知道： \\begin{align} T(n) &= \\Theta(1) O((\\frac{1+\\sqrt{5}}{2})^n + (\\frac{1-\\sqrt{5}}{2})^n)\\\\ &= O((\\frac{1+\\sqrt{5}}{2})^n) \\end{align}$\\frac{1+\\sqrt{5}}{2} \\approx 1.618$，虽说看起来好像比2差不了多少，不过对于 $n$ 很大的时候差距就比较明显了。这个上界明显比 $O(2^n)$ 要好，也是能获得的最紧的上界。 3.1.2 尾递归既然朴素递归开销这么大，有没有可能用无敌的尾递归想想办法呢？毕竟一些现代编译器是支持尾递归优化为循环（迭代）的。（注：其实尾递归并不是无敌的，有着严格的应用条件；这里只是玩梗。） 我们知道，尾递归的一个重要条件是对调用自身后返回的结果不可以进行处理（即，尾调用——对自身的调用必须是返回前的最后一条指令）。那么我们将对之前的两个状态的操作（相加）转移到参数中，不就成了尾递归了吗。代码如下： int fib(int x1, int x2, int n) { if (n &lt; 1) { return 0; } else if (n &lt;= 2) { return 1; } else if (n == 3) { return x1 + x2; } else { return fib(x2, x1 + x2, n - 1); } } 对应的调用如下： int result = fib(1, 1, 15); 这个的复杂度分析要考虑一下编译器。对于支持尾递归优化的编译器，这实际上跟下面的迭代是一样的，所以时间复杂度同为 $O(n)$，空间复杂度同为 $O(1)$。对于不支持的编译器，时间和空间的复杂度都很好分析，看参数 n 的变化就行——单次调用开销为 $\\Theta(1)$，所以总复杂度同为 $O(n)$。 3.2 迭代法不管是否想到了尾递归的方法，迭代都应该比较容易想到。如果想到了尾递归的话，很自然地可以进一步到迭代。 想法直截了当：既然每次只需要前两项的结果（状态），而 $f{n-3}$ 并不会被 $f_n$ 及之后的计算直接用到，那么为什么要保存其他状态呢？$f{n-1}$ 和 $f_{n-2}$ 已经很好地充当了“缓存”的功能。代码如下： int fib(int n) { if (n &lt; 1) { return 0; } else if (n &lt;= 2) { return 1; } else { int n1 = 1, n2 = 1; int tmp; for (int i = 3; i &lt; n; ++i) { tmp = n1 + n2; n1 = n2; n2 = tmp; } return n2; } } 调用如下： int result = fib(15); 显而易见，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$（更准确地说是 $\\Theta(1)​$）。我觉得分析都不用写了。 四、含数学分析的解法简单暴力的代码解法毕竟是太拿衣服。要往深了优化（或者给出无法继续优化的证据）还是得要数学。 4.1 数列分析为了理解接下来的分析，首先要知道特征方程。数列的特征方程我记得是高中讲过的，可是后来一直都没怎么用过（高数里也是）；加上本来我数学就弱，所以基本就是忘光了。对不起了，宋老师。 斐波那契数列是一个二阶的递推数列，一般形式为 $x{n} = c{1}x{n-1} + c{2}x{n-2}$。假设能找到两个数 $p$ 和 $q$，使得 $x{n} - px{n-1} = q(x{n-1} - px{n-2})$，移项得 $x_n = (p+q)x{n-1} - pqx{n-2}$。所以有 $p + q = c_1$，$pq = -c_2$。不难看出 $p$ 和 $q$ 的地位是相等的，因此消去任意一个（以 $q$ 为例）可得 $p^2 - c{1}p - c_2 = 0$。这就是二阶递推数列的特征方程。求解该二次方程，两个实根（如果有）就是 $p$ 和 $q$。 代回原来的数列形式，若 $p \\ne q$，则通项为 $x_n = \\frac{x_2-qx_1}{p(p-q)}p^n + \\frac{px_1-x_2}{q(p-q)}q^n$；若 $p=q$，则通项为 $x_n = (\\frac{px_1-x_2}{p^2} + \\frac{x_2-px_1}{p^2}n)p^n$。 将斐波那契数列代入（即 $c_1 = 1, c_2 = 1$）可以解得 $p = \\frac{1+\\sqrt{5}}{2}$，$q = \\frac{1-\\sqrt{5}}{2}$（$p$ 和 $q​$ 可互换）。 4.2 改进的迭代：矩阵快速幂（是搜索之后才知道有可以应用“矩阵快速幂”这么一类问题的。我没参加过 ACM，所以渣了。） 从 4.1 节可知，存在符合条件的 $p$ 和 $q$。于是，就可以将每次求值化为矩阵乘法。 对于 $k$ 阶线性递推数列 $xn = c{1}x{n-1} + c{2}x{n-2} + \\cdots + c{k}x_{n-k}$，每次递推可以表示为： [x_n, x_{n-1}, \\dots, x_{n-(k-1)}] = [x_{n-1}, x_{n-2}, \\dots, x_{n-k}] \\times \\mathbf{M}其中大小为 $k \\times k$ 的矩阵 $\\mathbf{M}$ 就是……呃，好像没有标准称呼？就叫递推矩阵好了。由此可见，由于 $\\mathbf{M}$ 在递推过程中不变，计算 $x_n$ 就被转化为了计算矩阵的幂的问题。这个矩阵受初始值选取和递推公式两方面的影响。 对于斐波那契数列，给定初始值 $[1, 1]$，可以得到 \\mathbf{M} = \\begin{bmatrix} 1 & 1\\\\ 1 & 0 \\end{bmatrix}虽说是矩阵快速幂，但是对幂函数的计算优化其实和数的是一样的，只不过乘法的定义略有不同。 要计算一个数 $a$ 的 $n$ 次幂，最直接的想法是连乘，时间复杂度为 $O(n)$。但是只要见过质数筛这类的问题，或者是插值函数优化，就马上会意识到，其中许多次的乘法是多余的，结果是可以缓存的（甚至可以不用缓存）。那么，如何剔除这些多余的计算呢？ 不是有对数函数嘛。大杀器。 考虑到实现的便利性，一般就取 2 为底了。将幂次 $n$ 分解为 2 的幂的和：$n = c{0}2^0 + c{1}2^1 + \\cdots + c{m}2^{m}$，其中 $c_i \\in {0, 1} (0 \\le i \\lt m), c_m = 1$。进一步展开到乘法，就可以看到，$a^n = a^{c{0}2^0} \\times a^{c{1}2^1} \\times \\cdots \\times a^{c{m}2^m}$。这样，从前往后“扫描”，由于 $a^{2^n} \\times a^{2^n} = a^{2^{n+1}}$（废话），所以只需要保存最近的中间结果，就可以依次得到正确的乘积，并最终得到 $a^n$。代码如下： // 简洁起见，仅处理 a &gt; 0, n &gt;= 0 的情况 int pown_fast(int a, int n) { int result = 1; int cur = a; while (n &gt; 0) { if (n &amp; 1) { result = result * cur; } cur = cur * cur; n = n &gt;&gt; 1; } return result; } 可以见到，pown_fast() 的时间复杂度为 $O(\\log n)​$，空间复杂度为 $O(1)​$（$\\Theta(1)​$）。对于矩阵的幂，由于斐波那契数列相关的递推矩阵大小是常数，所以时间和空间复杂度都和计算数的幂是一样的。再考虑初始值的输入等等，最终的时间复杂度为 $O(\\log n) + \\Theta(1) = O(\\log n)​$，空间复杂度为 $\\Theta(1) + \\Theta(1) = \\Theta(1)​$。 也有用类似思想，但不是快速幂的解法，而是采用新的递推公式，参见[1]。 4.3 通项公式将 $p​$ 和 $q​$ 的值代入 4.1 节的通项公式可得： $f_n = \\frac{1}{\\sqrt{5}}((\\frac{1+\\sqrt{5}}{2})^n + (\\frac{1-\\sqrt{5}}{2})^n)​$。 按照这个通项计算 $f_n​$，理论上可以达到 $O(1)​$ 的时间复杂度。 很美妙，不是吗？$O(1)$ 和 $O(1)$ 啊！但是简单地计算依然会出问题。这个公式中，多处涉及了（在最终结果前）无法约简的无理数。在现代的计算框架中，如果按照一般的思维，用浮点数来表示这些无理数，进行计算的话，一定有因浮点数的不精确性导致的误差。$n$ 越大，误差越大。且不说“四舍五入”这个行为在此正不正确，当误差超过 0.5 的时候，舍入都救不回来了。所以在实践中，这个方法是不可取的。 当然不是没有能保证精度的方法。采用符号代数就可以了。而且这个计算过程中的无理数只有 $\\sqrt{5}$ 一个，而且 $(\\sqrt{5})^2 = 5$ 还是个整数。不过计算过程就得根据二项式定理展开，然后累加并分类求和，所花的时间肯定会多于 $O(n)$，空间开销也不会小。 五、结论以上我们见到了五种计算 $f_n$ 的方法： 朴素递归，$T(n) = O((\\frac{1+\\sqrt{5}}{2})^n)$，$S(n) = O(n)$； 尾递归，在有优化的情况下 $T(n) = O(n)$，$S(n) = O(1)$； 迭代，$T(n) = O(n)$，$S(n) = O(1)$； 快速幂，$T(n) = O(\\log n)$，$S(n) = O(1)$； 通项，$T(n) = O(1)$，$S(n) = O(1)​$。 在几种方法中，时间和空间复杂度都是从前往后越来越好。但是通项由于需要用浮点数表示无理数的值会导致误差所以基本上不能用。所以综合各种因素考虑，最优的算法是采用快速幂计算 $f_n$。 参考： [1] 五种方法计算斐波那契数列的第n项 [2] 斐波那契数列的三种解法及时间复杂度 [3] 斐波那契数列数列的三种时间复杂度的实现方法 [4] Time complexity of recursive Fibonacci program","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"算法","slug":"算法","permalink":"https://blog.mottomo.moe/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"随便写点什么","slug":"zh/2019-03-06-Misc","date":"2019-03-05T17:33:00.000Z","updated":"2020-03-30T22:34:35.451Z","comments":true,"path":"categories/Misc/zh/2019-03-06-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/","excerpt":"GRIS 的文章呢？ 别急，不会鸽的。 二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。 那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。） 反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。","text":"GRIS 的文章呢？ 别急，不会鸽的。 二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。 那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。） 反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。 昨晚又小小地反向了一把，对象是京东娃娃项目东京偶像计划（プロジェクト東京ドールズ）。关于结果 esterTion 应该已经更新在他的文章里了。 其实只是蹲坑的时候刷 Google Play，给我推荐了一个这玩意儿。看着画风还行，打开看看。嘛游戏内容（小人打架加一些反应要素）我就不感兴趣了（而且世界观的建构更是让人一脸问号），但是一些图啊模型啊还是不错的。（“穿着偶像衣服却不干偶像的事。” by 群友）饰品分离目前我只见过 Square Enix（SGS、京东娃娃）和 Konami（心跳凉凉）做过，大概还有一些参考价值？心跳偶像本来我想着跟土豆一样反向的，但是安卓严重混淆，我又没有越狱的 iPhone，没办法；后来……它就停服了。 有点远了。这次反向其实还挺简单的，esterTion 已经找到了关键的类和方法，所以省了很多事，只要耐心读就行了。他大概只是心急失手了而已。如果他又想吹我，您别听他的；我只是个弱渣。 IL2CPP 的反向比一般的原生代码要简单的一点是，它保留了很多 IL 的特征，C++ 编译器无法完全将它们优化。比如在这次挨个设置密钥数组元素的时候，就出现了很明显的一种模式： if (array.metadata.length &lt; 0) throw_index_out_of_range_exception(); array.elements[0] = elem0; if (array.metadata.length &lt; 1) throw_index_out_of_range_exception(); array.elements[1] = elem1; if (array.metadata.length &lt; 2) throw_index_out_of_range_exception(); array.elements[2] = elem2; if (array.metadata.length &lt; 3) throw_index_out_of_range_exception(); array.elements[3] = elem3; 在反编译的代码中，上面都是用偏移表示的。虽然在没看 IL2CPP Array 的源代码的情况下，并不清楚这个结构每个偏移是什么（快去看，懒虫），但是根据这么几个连续的偏移规律，也能摸个大概。再想想对应的 C# 是怎么样的： arr[0] = elem0; arr[1] = elem1; arr[2] = elem2; arr[3] = elem3; 在实际使用中，这个索引测试一般不是手工做的。因此可以猜测是在 IL2CPP 变换的过程中自动插入的片段，以保持语义一致（ldelem.*）。 与此类似的还有 IL2CPP 类型初始化（不是 .cctor）、IL2CPP 实例初始化（不是 .ctor）、加载静态的引用类型字段等等，生成的代码一看就知道是干什么的。这些重复的模式比起“一般的” C++ 来说要仁慈多了。 当然 C++ 编译器也不是吃素的，明显能优化的地方一定会优化。比如简单的 getter/setter，尤其是简单类型的自动属性，会被直接内联。我就说怎么一些属性的 getter/setter 无法被 xref，结果一看只要是简单赋值，全都跑到实际使用位置去了。而且恶心的是，这通常指的是指针+偏移访问。这就防住了简单的使用检索（find usage），如果是关键属性的话会非常头疼。 IDA 的 F5 并不能完美地反编译，有时候需要进入函数再出来，让它更新函数签名，特别是变参函数和看上去参数奇怪的函数调用。再比如，在 MakeUrlCore() 的关键调用签名更新完毕后，会发现有返回值没被使用的情况。而这些函数并没有修改 call site 所在实例的内部状态，这时就根据下文推断返回值使用的地方，而且可以回到汇编窗口验证。对，我说的是获取 UTF-8 字节数组之后计算 MD5 hash 的那一块。 如果对 .NET 比较了解，少数虚函数表里的调用也可以根据上下文推断。string + Encoding.MethodX() -&gt; A; HashAlgorithm.ComputeHash(A)，那么这个 MethodX() 就极有可能是 GetBytes()，即使是虚函数，而且（在 F5 中）缺少实参来判断。再比如，StringBuilder.MethodY() -&gt; B; string.Concat(B, ...)，那么这个 MethodY() 就极有可能是 ToString()，即使因为虚函数表+静态分析的原因无法看到实际调用的是哪个函数。这种思路跟中学的化合物推断是很相似的。 说到反向，还有有趣的事情。上一周有一次组会的时候，我们预订的是学校最新的大楼的一个房间。那里面就有一个无线屏幕，可以把设备的屏幕无线地投射到显示器上。一个组员（本科生）说，他在另一门课（好像是 IoT Security 还是什么的）的小组就对这个屏幕使用的客户端下手了，写了一个非官方的客户端，能绕过一些限制来登录。 这肯定让我玩心大发啦。简单看了一下客户端，是一个无任何混淆的 WPF 应用程序。迅速扒光。然后跟着进入 P/Invoke 的原生库，稍微摸了一下结构。另一个是 C++/CLI 的 wrapper，依赖的是 C++ 的。在找不到公开文档和调试信息的情况下，后者基本是不可能静态分析的。 根据我原来看到的信息，我觉得这个系统的验证是存在漏洞的，理论上可以很容易地伪造用户登录和播放任意内容。不过刚才我看了更多的资料和代码之后否定了之前的想法。任意登录下降为可能的，在服务器配置存在特定配置缺陷的情况下；同时对登录有比之前所见的更大的限制。这就带来了攻击成本的上升和回报的下降，导致显得不划算。不过，反跟踪仍然是可以使用低成本的方式做到。 关于这个 WPF 程序的软件质量，我要称赞它，是软件工程的范本。遍地都是契约检查、防御性编程、打印日志（而且模糊了隐私信息），很专业嘛。 啊，本来还想着也许能做个白帽黑客的，不过现在看起来这个案例可能没什么能让我出手的地方了。 不过等到假期结束，我还是想亲手试试。 毕竟人家本科生都能做到的事情，我要是做不到，就太丢脸了。我虽然不知道他们做到了哪一步，但是必须要假设我想到的都已经完成了。 说到假期，这个星期是狂欢节假期。因为艾因霍温在南部嘛，而狂欢节是南部地区在庆祝，所以我们就有了这么一个假期咯。 上周六和昨天晚上去超市的时候，路上偶尔会看见一些穿着“奇装异服”的人。在上面的维基百科链接中可以看到大概的样子。你也可以在这里读到去年的样子。不过我没事又不经常出门，而且这还是在晚上，所以只能看见整个节日的一点点。狂欢游行什么的根本没有参与过，但是的确能在市中心看到不少散发着啤酒味的一次性杯子和几个临时的 live house。 前几天开始我的左耳突然出毛病了。最开始的时候是时不时堵着，就跟坐飞机一样；但无法通过活动咽喉来解决，只能手动按压通气。而后一天晚上玩了一下 The Witness，不过饱和度太高，不久就中等恶心（我玩大多数游戏都没有3D眩晕），受不了了。第二天起来还没发现什么异常，但是联机打了一局黑魂之后就发现对敌人的听觉定位不准了——正中的声源，会听起来偏右。再自言自语的时候就感觉颅内传导的声音，右耳出去了，但左耳好像碰到了什么，反射回来一部分，形成了混响。 虽说现在已经要找医生了，但是还得先处理别的麻烦事——验证邮件收不到，就无法完成电子身份认证，就无法预约。而现在正是狂欢节假期，不知道会不会影响。即使是能预约了，按照我的经验，也得等至少一个星期。这时候我就很怀念国内的挂号了。 所以……没办法咯，只好先习惯目前的处境，调整大脑的处理方式，希望之后不会耽误什么。 哇，如果听不见声音的话（或者只能借助于骨传导），我可会很难过的。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"手游","slug":"手游","permalink":"https://blog.mottomo.moe/tags/%E6%89%8B%E6%B8%B8/"}]},{"title":"新年","slug":"zh/2019-02-05-New-Year","date":"2019-02-04T23:42:00.000Z","updated":"2020-03-30T22:34:35.451Z","comments":true,"path":"categories/Misc/zh/2019-02-05-New-Year/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/","excerpt":"","text":"我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。 如果有人关注我最近的活动的话或许会注意到，这半年来我推代码的频次相较以往同期要少。嗯，首先是 CS 确实很有意思，而且以我的基础可以看得比较全面（能自然地看见“点”之间的“线”），这样要深挖的就多多了。HTI……我的思维运转方式不是那样的，所以除了课上讲的冰山一角，基本都看不清，所以业余时间都投入到代码上了。 还有一个原因是我希望做一个更有趣的人。除了抽象的代码，我也乐于欣赏艺术创作。欣赏久了，自然就产生了投身于创作的想法。就像笼中之鸟羡慕飞翔的鸟儿一样。以我的性格，要是只能代码一条路走到黑我肯定要抹脖子了。临渊羡鱼，不如退而结网。 在B站上我之前一般是做烧笋的创作谱面；去年因为造一些轮子所以发了一些成果视频。这是我放松的一个选择。但是这毕竟形式非常单一而且（我认为）总是摆脱不了无生命感。——写谱面，在许许多多的规则之下，发挥的余地其实比较少（我不是硬核玩家），而且普遍关注的是技术难度，缺少要表达的主题。每一种艺术都不过是表达的方式，私以为代码也是这么一种手段；有的人擅长这种，有的人擅长那种，仅此而已。当然观众也得有相应的鉴赏能力。 所以我就想了，要是投入等量的时间，能让一种技能从70上升到75，或者让另一种从0上升到15，该如何选择呢？事实上这和 RPG 游戏加点一样是个一直困扰着我的难题。我选择在艺术上从0加到15，很清楚这并不会带来“一技傍身”的优势，而是希望借由将自身化为艺术创作者，去理解他们的视角和思维，会遇到什么问题，我的方案比别人差在哪里或者好在哪里。 继最开始的简单剪辑（1、2）之后，我开始尝试其他的形式：混搭（1、2）、手书（1、2）、MAD 和改谱（远算不上编曲）。每个作品的个中滋味恐怕都不是一两段话能说完的，也并不只是视频简介里的那些。当然，创作水平肯定是无法一蹴而就的。所以除了我自己的练习和体悟之外，我希望寻找更新的想法，希望它们也确实地传达给观众了。反正又不图名又不图利，若是能被欣赏，或进一步地，在此基础上衍生创作，丰富大环境，那就是更好的了。 那么近况如何呢？我确实在大脑没退化的前提下比之前更快乐了。比之前整天在代码上挖掘，望天叹气要好多了。我觉得这偶尔的音乐、绘画和视频创作是有一份功劳的。自己有趣不有趣……还不知道。至于产出的效益，那要等时间来回答。 胡乱说了一些话，权当跨（农历）年的一篇吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"NW.js 的上下文问题","slug":"zh/2018-12-19-NWJS-Context","date":"2018-12-19T11:03:00.000Z","updated":"2020-03-30T22:34:35.451Z","comments":true,"path":"categories/Tech/Coding/zh/2018-12-19-NWJS-Context/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/","excerpt":"NW.js 有一个或两个上下文，使用时要多加小心。","text":"NW.js 有一个或两个上下文，使用时要多加小心。 最近因为做项目，需要用到 NW.js。在搭环境的时候，我自然要写一个最简单的功能来测试了。我的例子是一个关闭按钮。简明起见，下面的代码复现的是在第二次试验。注释“2”的是第二次测试添加的输出，“1”是第一次的。 bootstrap.ts： import * as main from &quot;./main&quot;; console.log(&quot;imported&quot;); // 2 main.bindCloseKey(); bootstrap.ts 是编译为 ECMAScript 5 之后，加了个简单的兼容片段（解决 exports 找不到的问题），直接从页面链接的。 main.ts： console.log(&quot;exported&quot;); // 2 export function bindCloseKey(): void { console.log(&quot;called&quot;); // 2 const button: HTMLButtonElement = document.querySelector(&quot;#close&quot;); if (!button) { console.log(&quot;Button not found: &quot; + selector); // 1 } else { console.log(&quot;Button found&quot;); // 1 button.addEventListener(&quot;close&quot;, () =&gt; { window.close(); }); } } 主要功能如上所示，功能很简单，如果找到按钮就尝试绑定事件，不管找没找到都有一个输出。 但奇怪的是，实际运行的时候，点击按钮没有反应；打开开发者控制台（直接按 F12）却看不见任何输出。 于是加了几条注释之后再跑，只见到了第一条输出，也就是“imported”。 那么其他的输出在哪里？功能到底执行了没有？我猜想是目标问题，于是切换到 ECMAScript 6，顺便认识和试用了一下 ESM（就是那些 .mjs 文件），但问题还是没有解决。 无奈之下只好谷歌了。但是大多数人是希望将开发者控制台的输出重定向到系统控制台（确实有解决方案，在 package.json 里加入 &quot;chromium-args&quot;: &quot;--enable-logging=stderr&quot;），我是纳闷为什么看不见开发者控制台的输出。结果发现了答案，也就是该做的是手动右键检查背景页；F12 是审查应用的当前页，而 NW.js 的 app 是作为扩展载入的，所以两个页面不同。 考虑到项目完工时手动右键检查背景页未必可用，我想了一个变通的方法。console 看上去是个全局对象，实际上是 window 的属性。那么我将 window 的引用传过去不就好了？ bootstrap.ts： import * as main from &quot;./main&quot;; main.setWindow(window); main.bindCloseKey(); main.ts： let $window: Window = null; export function setWindow(window: Window): void { $window = window; } export function bindCloseKey(): void { const button: HTMLButtonElement = document.querySelector(&quot;#close&quot;); if (!button) { $window.console.log(&quot;Button not found: &quot; + selector); // 1 } else { $window.console.log(&quot;Button found&quot;); // 1 button.addEventListener(&quot;close&quot;, () =&gt; { $window.close(); }); } } 这次能看到输出了。但是显示的居然是“Button not found”！ 我再次确认了，HTML 页面是能找到这个按钮的元素的。好吧，手动执行一下试试。分别在 app 页和背景页的开发者控制台执行 document.querySelector(&quot;#close&quot;)，前者返回的是 null，而后者返回了一个 &lt;button&gt;。 这下我就知道为什么了。两个页面之间有一堵无形的“墙”，一个负责前台（Chromium 端），一个负责逻辑（Node.js 端），有点类似 WebWorker。但和 WebWorker 不同的是，这个隔离的双方都能访问通用全局对象（window 等等），然而访问的却不是同一个对象。上面 $window.console 来自“能和页面交互的” window，document（实际上是 window.document）来自“不能和页面交互的” window。 后来再看，原来是 0.13 加入的上下文分离，在 NW.js 的文档里其实也写明白了。调试不同上下文的代码则需要分不同的开发者工具。用 require() 加载的模块都会运行在 Node.js 上下文中，路径解析和能访问的对象都是和浏览器上下文不同的。Node.js 上下文中确实有一个 window 对象，但指向的是背景页。如果需要在 Node.js 上下文中访问浏览器的对象，包括全局对象，必须要将这个对象传递过去（就像我上面做的那样）。当然如果偷懒可以用文档后面提到的上下文混合模式（mixed context mode），但它有潜在的上下文不同导致的问题（路径、原型链；见文档）。所以最保险的方法就是在设计的时候就注意，尽量将前后完全分离，消息交换只用上下文无关的对象（例如普通的 {}、Object.create(null) 创建的对象）。 那么既然上面说在上下文混合模式下会有问题，那么默认的上下文分离模式（separate context mode）下，传递对象会不会出错呢？答案是不会。NW.js 自动处理了对象封送，在传递的时候切换了上下文。我们可以做一个小实验。 bootstrap.ts： import * as main from &quot;./main&quot;; console.log(&quot;From Chromium? &quot; + (window.close instanceof (window as any).Function)); main.testWindow(window); main.ts： export function testWindow(window: Window): void { window.console.log(&quot;Context of Node? &quot; + (window.close instanceof Function)); window.console.log(&quot;Context of Chromium? &quot; + (window.close instanceof (window as any).Function)); } 运行，结果： From Chromium? true Context of Node? true Context of Chromium? false 由于 main.ts 是被用 require() 加载的，所以它运行在 Node.js 的上下文下，直接访问全局的 Function 访问到的是 Node.js 的 Function。而传入的 window 参数，原对象是在 Chromium 上下文中的。访问它带的 Function（不会被重新指派上下文）访问的到的是 Chromium 的 Function。由此可见，在对象传递过来的时候，也包括传递回去的时候，对象的上下文都会自动发生变化。 可能要问了，既然是上古版本更新引入的分离，为什么我以前没发现呢？因为以前为了做即时示例，要在没有 Node.js 的浏览器环境下运行，所以都用了 Browserify。这样在 NW.js 中实际上所有代码都是在 Chromium 的上下文里执行的，不会引发问题。而这次我并没有想把它完全部署为普通网页，就用了分文件、模块加载（毕竟 NW.js 也支持 require()），这下上下文分离的事实立马就暴露了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"NW.js","slug":"NW-js","permalink":"https://blog.mottomo.moe/tags/NW-js/"}]},{"title":"老虎和兔子中的一段浪漫悲剧","slug":"zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny","date":"2018-11-12T12:33:00.000Z","updated":"2023-04-09T06:24:26.202Z","comments":true,"path":"categories/ACGN/zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny/","excerpt":"以前我写过钢壳都市雷吉欧斯中的告白台词。今天我又看到了一出打动人的浪漫戏，《老虎和兔子》（Tiger and Bunny）第15集。嗯，这集本身是一个插曲，但也是主线剧情的关键转折点之一。 注意：本文有（严重）剧透。","text":"以前我写过钢壳都市雷吉欧斯中的告白台词。今天我又看到了一出打动人的浪漫戏，《老虎和兔子》（Tiger and Bunny）第15集。嗯，这集本身是一个插曲，但也是主线剧情的关键转折点之一。 注意：本文有（严重）剧透。 这一集的主角是空天（スカイハイ，Sky High）。空天是所有英雄中最为单纯的一个人，这点在前面的剧情已经提及了。动作细节（本想直接拿苹果，但想了想，在衣服上擦了擦才伸手）和语言（还要算上声优表现出的语气）说明，他也是一个正统的绅士。 空天和神秘少女在公园的喷泉前相遇了。怦然心动。空天每天晚上都会巡逻。空天多次在喷泉前碰到少女。身在低谷期、人又不擅表达的空天，在多次向一直“聆听”的少女倾诉后，逐渐发现了怎么走出低谷。同时他也意识到了自己的想法。因为偶然，老虎和兔子在夜间抓到了邪恶的博士。博士说出了真相。 悲剧的因素齐了。 空天在不知情的情况下，亲手击毁了已经化为武器的人造人少女。讽刺的是，在处决面前这个“怪物”的时候，空天作为动力所回忆的，是那个少女。 虽说我早已猜到是这样，但是在表现手法等种种因素的作用之下，我还是唏嘘不已。 不过这还没完！事件结束后的这一段，才是最让我惊叹和赞美的。 从鼓励完老虎和兔子（约20:45）开始，是本集的第二高潮：空天前去和少女道谢。接下来的所有卡，空天的兴奋之情都溢出了屏幕。（分镜和演出，精彩啊！） 空天从镜头前走过。由于太近，只能看到他身体的中间部分。但是这个卡的重点是背景二人的惊讶表情。以他们这么久的合作对空天所知，在那么短的时间内就采取这么激进的措施，实在不像平常所为。很可能是冒失了。因此他们才会十分惊讶。 空天走出更衣室。这时候镜头给的是从后方，略低于小腿处看过去的背影。背景的视场（field of view）相比于上一卡突然变小了，观感上就增加了深度（过道的长度）。这个过道的另一端是白光，就跟影视作品常用的 HDR 效果差不多（现实中 HDR 没有这么强烈）。但是同时也有可能是在暗示“向着他的光明”（也就是少女）。这里的空天虽然还是在走，但是和前面对比可以知道，是加快了步伐的。 接下来是在花店买花。两个卡，一个背面的中景，一个前侧的近景。表情上看不出来什么，因为空天一般情况下都是微笑的。但是当他接过了红玫瑰和白玫瑰组成的花束后，停顿了一小会儿，把它微微地抱得更紧了。 镜头转到橱窗前。从倒影中（没想到啊，突然来了这么少用的一手）看出，空天无意间扭头，注意力转向了橱窗里的商品，面露少许疑惑。橱窗里是裙子、挎包和新款式裙子的宣传海报。他用手指轻轻了两下敲太阳穴，表情渐渐变回了微笑。（我一开始觉得也有把橱窗当作镜子，照镜子的可能；但是仔细一想，橱窗内无灯，外面是自然光，这样对着橱窗是看不清自己的镜像的。）他可能是在想如果成功后送给她的礼物。毕竟英雄这份职业的收入不算高（想想其他几位就知道了），价格是要考虑考虑的。这说明空天对这次见面的准备十分用心。 下一个卡中，空天已经来到了公园。镜头给了个大半身的中景。他从右向左走过画面。在画面正中央，扭头发现远景中在长椅上靠在一起的情侣时，他略微停了一下，接着快速把头转回他的前方，微微弓身前倾，小步跑了起来。 紧接着的卡，大楼的巨幕播放着他作为英雄时的英姿（之前，这块屏幕播放的是大红大紫的老虎和兔子）。这块屏幕也很有意思，从空中往下看，它是放在大楼这个长方形的角上的；为了容纳这么大的屏幕，大楼的最上面四层都像蛋糕被切开一样，从而造出一个大平台。屏幕中，作为英雄的空天是巨大的。屏幕下，与渺小的路人无异的他依然抱着花束，弓着身，急匆匆地跑过路口。一方面是公众身份，一个英雄；另一方面是个人身份，一个普通市民。他在之前与少女的交流中一直隐藏着英雄的身份，然而那却其实是他更广为人知的一面，他作为普通人，更是作为英雄，被少女所激励。经典的身份二重性。 接下来的卡，镜头大约在腰部的位置，朝向侧上方。空天从右下角的“远处”跑来（此时已经不弓着身了），到画面正中。他进入画面后本想呼唤少女的，但是嘴才微微张开（逐帧观察，不像是作画或上色失误；表情也略显得焦急），就立即合上了。接着立定，闭眼整理了一下心情，将花轻轻抱得更紧一点，恢复微笑之后，空天缓缓走向左下角的“近处”。为什么有这个反应呢？联系接下来的三个卡就知道了。 接下来的三个卡。 近景，半身，空天在画面右半边坐下。这里的镜头距离是，如果两个人靠在一起坐着，那么画面底部就刚好能被填满。可是这里长椅的一端是空的。但是感觉画面不算太空，是因为还有花束在。空天稍微定了定神之后微微扭头看向空出来的位置；镜头也配合地向左平移，虽然只有不到一秒。 他看到的只有长椅。此时镜头居然在拉远。为什么不是顺着空天的愿望去推近，而是要拉远呢？因为这是在陈述客观事实。 镜头再转回来的时候，已经看不到椅子，也就看不到另一端了。空天的肩膀占满了画面的底部。又这么凝视了一会儿，空天眨了眨眼，扭头，保持着标准微笑，目视前方（正对镜头）。 最后的一卡，用的是他们初次见面时最后的远景和拉远。但是这次，长椅上只在半边坐了一个人。喷泉没有喷。原本周边空荡荡的，仿佛二人世界；这回变成了空天一人，和空地上的数个市民。他或许找回了最初的动力，作为市民的榜样。但是也如暗示的，她已经不会再来了。作为观众，我们知道这个等待注定是徒劳的。但是按照空天的性格，他一定会等到最后。（知道真相的话会受到多大打击！然而他们这件事也没别人知道，见过少女外形的除了他，只有老虎和兔子。问的话那对粗心基友大概会想不起来，根本没留意。所以就更纠结了。） 其实喷泉很明显是经典爱情电影的隐喻，至少是桥段，比如《罗马假日》。这一集的配乐，对，就是那首舒缓的弦乐，仅出现在这一集；风格上我觉得会类似爱情电影吧。最后这段的镜头设计比起电视动画，更像是电影。哎其实我也没看过爱情电影，想想套路就觉得肉麻到不行，看别的去了。所以在讲述上面的镜头设计时文字苍白无力。 看了这第15集后，我就没再往下看了。剧情已经大概了解，但是很难说接下来会不会出现更亮的点，没有的话就会索然无味。 2022-05-10： 突然想起来，相爱但因为种种巧合认不出最后相杀的剧情设计，上述也早就不是第一个了：已经可以不用再战斗了，巴尼。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"The \"New\" Encryption of HCA Audio","slug":"en/2018-10-12-New-HCA-Encryption","date":"2018-10-12T13:34:00.000Z","updated":"2020-03-30T22:34:35.362Z","comments":true,"path":"categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/","excerpt":"中文版本见这里。 Recently CRI Middleware updated their latest ACB archives’ format, and they seemed to have updated encryption of HCA files as well. As a result, the old toolsets can do nothing on the updated files. After about 20 hours of research I finally found what they changed on the decryption. Might be the first in the world, again. This is what’s called “highlight moment” in reverse engineering. XD The final answer is somewhat simple: transform the decryption key, and use the transformed key to initialize the decryption table. The formula is key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2)) where key is the input key and k2 is a secondary key stored in the higher 16 bits of “field alignment” field, in each ACB/AWB file. This article is about the way and thoughts of finding this transformation. It is roughly recorded in time order. I hope these materials may help someone in the future. My result is based on various people’s works. Without thoses pieces, the whole puzzle cannot be completed. So a big thank you for everyone involved. Be noted again: the contents in this article must not be used for commercial purposes.","text":"中文版本见这里。 Recently CRI Middleware updated their latest ACB archives’ format, and they seemed to have updated encryption of HCA files as well. As a result, the old toolsets can do nothing on the updated files. After about 20 hours of research I finally found what they changed on the decryption. Might be the first in the world, again. This is what’s called “highlight moment” in reverse engineering. XD The final answer is somewhat simple: transform the decryption key, and use the transformed key to initialize the decryption table. The formula is key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2)) where key is the input key and k2 is a secondary key stored in the higher 16 bits of “field alignment” field, in each ACB/AWB file. This article is about the way and thoughts of finding this transformation. It is roughly recorded in time order. I hope these materials may help someone in the future. My result is based on various people’s works. Without thoses pieces, the whole puzzle cannot be completed. So a big thank you for everyone involved. Be noted again: the contents in this article must not be used for commercial purposes. * “Decode” in the text below may mean decode after decrypting when applicable. * Sorry about the broken tenses in the last paragraphs. I was too tired to fix them all. 1. PreludeAs the new game Dragalia Lost (ドラガリアロスト) is released, CRI Middleware revealed their updated audio technology. As for me, a guy who does not play games in the “normal” way, I care about resource extraction more than how it displays in the game. Forward thinking is what I should do as a game developer, and reversed thinking is for the cracker identity (not “cracker” as in “cookie” :P). This update updates ACB version from 1.29 to 1.30. Although it is a minor upgrade, it brings a trouble that, HCAs cannot be decrypted even with the correct key. It began with an issue created by FZFalzar. When I received the email, I didn’t know or understood what was going on. In the next day, esterTion posted a screenshot of a comment in his blog article, saying that someone is not able to decode extracted HCA with the game provided. I recalled that the key is the one I saw in that issue, so this must not be a coincidence. Together with the information FZFalzar provided, the new tools should have changed something, which might break backward compatibility. I could imagine if the same measure is applied on CGSS or MLTD, or other games, maybe, a doom for audio extraction. So I decided to challenge it. 2. Initial Analyses2.1 File AnalysesThe first thing to do is analyzing the files to see whether there are some “odd” values. Since I already had an ACB extraction tool (AcbUnzip), I directly dragged the attached ACB on it. Unexpectedly, AcbUnzip crashed, only throwing an exception and creating an empty file. I also tried VGMToolbox, which created 6 files, but all of the files were empty too. Since I wrote AcbUnzip, I could debug it. I found that the difference of the number of files is caused by the difference of the numbers of cues and tracks. There was only one cue, but there were 6 tracks (3 in internal AWB and 3 in external AWB). But the bigger problem was that, though I had the information of file entries, I could not extract them. The file sizes were negative numbers with extremely large absolute values! After narrowing down by instrumentation, I saw that the value of “field alignment” fields in AFS2 (the file structure used by AWB) was quite strange. According to VGMToolbox, it should be a 32-bit unsigned integer. From the past experience, the value is usually 32. However this time, it was far larger than the file size. The most common guess should be there is a mask. So I looked at the value in hex digits. The lower 16 bits were 0x0020, which is 32; the higher 16 bits were something unknown. Obviously, it is masked by 0x0000ffff. I successfully extracted all HCA files after doing this. The exception was the first piece of the puzzle. Besides applying a mask, it also exposed the fact that the layout of AWB had changed. As I said, since the field offset (32-bit unsigned integer) was usually 32, which is far smaller than 65535 (0xffff), its higher 16 bits were actually reserved. Here I began to doubt if CRI did use the higher bits as reserved and attached some other meanings to them. But I still could not determine whether they were random numbers (to disturb analysis) or they do have a meaning. After the HCAs were extracted, it was time to take a view on them. They looked normal: no unknown header parts or blocks, no out-of-range values, and no additional information added. The only recognizable thing was the size of HCA header extended from 96 (CGSS/MLTD) to 397. But except for known fields, the header was filled with zeros. Here I made 3 assumptions: The actual size of the HCA header can affect the decoding choices of the decoder. You can think it as a hidden version information apart from the “version” field in the HCA header. comp1 to comp10 (referring to the HCA decoder) were set to some meaning values that affect the decoding process. I did not know what those fields mean so I was unable to proof or deduce only by observing. Nothing was changed. The file was still a traditional HCA. All these assumptions were possible, requiring more materials to proof or falsify. At this point, the limit of file analyses was reached. 2.2 Next Directions of InvestigationJust as I replied in the issue, after some observations, considering the updating speed of the technology, iteration cost (time and finance), I thought of 4 most possible possibilities: The decoding process was changed. New branches were introduced in the decoding process. Precomputed tables were changed. Real decryption key was different from the input key. Of course their combinations were also possible in reality. Here let me explain the details of each possibility. The first possibility. The new decoder employed an entire new theory. This means huge changes in theory and code, which can be seen as a new audio format. CRI should not have enough time and financial support to do this. The second possibility. Think about the values of comp1 to comp10 mentioned above. Considering known code structure of the public decoder, if new branches were introduced to handle values that never appeared before (in the context of code, if), then new branches or new tables would be logical. I thought it possible, but proving is hard. It depends on the decompiled code. The third possibility. Since the core of decoding is value mapping using the precomputed tables, could the tables themselves were modified (the code should also be updated) so that input were mapped to different outputs? This thought also depends on decompilation. The fourth possibility. This is a two-phase encryption. The overall process was untouched but the key was transformed internally, or a decryption table different than the previous one was generated using the same key. Obviously this is the most probable way. All you need to do is adding a few lines of code, and all the public decoders stop working. The cost is close to zero. Combining with the decoding workflow of HCA, in validation, decryption and decoding, a process does not influence the previous one(s). So the key can be easily set to a new one. (By the way, this is also how hcacc works.) However my guess was that the key was modified before initializing the decryption table. For that I was wrong. 2.3 Initial FeedbackBecause I could only obtain a lite version of the SDK (ADX2LE SDK), which does not support encryption and decryption, and FZFalzar had the full SDK (ADX2 SDK), I asked him to start with some tests. While those tests are in progress, I began the initial reverse engineering on tools in ADX2LE SDK. I had a question above: is the new SDK backward-compatible? It can play the latest ACB, but can it play old ones? Whatever the answer is, it would help eliminate false guesses. My personal guess was the new SDK is not backward-compatible, but the test results disagreed. According to the fact I believed that there was not an all-new all-different decoder and tables were unlikely to change. The greatest change would be adding branches and tables, at most. If we got lucky, it would be much easier. 3. Following Analyses3.1 Following Analyses of ACBFZFalzar found out that the SDK cannot play extracted HCAs (not being packed inside ACB/AWB) with correct keys. He thought maybe the something got into the metadata of ACB. So I checked the new structure of ACB using utf_tab. The first apparent change was the update of format version. CGSS uses version 1.23.1, MLTD uses 1.29.0, while this one was in 1.30.0. From my experience learned from MLTD’s ACB upgrade (compared to CGSS), upgrading usually means adding new tables. Current ACB format can only use a limited number of fields (for easy coding?), so it reserved several slots in the end. CGSS (1.23.1) had 18 reserved slots (R0 to R17), and in MLTD (1.29.0) there were only 12 (R0 to R11). And this time (1.30.0), a new table SoundGeneratorTable was added compared to MLTD. Could this table influence HCA decoding? I thought not. In the sample ACB, the size of this table was zero. If this table is used as a switch, CRI could have chosen a much simpler type. If it is a table and it does have influence, it should not be empty, but filled with some meaningful data. I did not find other important differences in this sample ACB besides this new table. Some control tables, such as TrackCommandTable, SynthCommandTable and TrackEventTable is not yet parsed, they should not play such row because of their usages in history. To be sure, I modified some values and tested, with no luck. At this time, FZFalzer sent the player (Atom Viewer, 2.25.14) in the latest full SDK. Finally I was able to test the keys. During testing, I discovered something interesting. I mentioned before that in the header of AWB there were 16 unknown bits (2 bytes) in “field alignment” field. This time I tried to modify those two “garbage” bytes. I tested these combinations with the new player: ACB from CGSS (internal AWB), with no modification. (These 2 bytes were always 00 00 in previous ACBs.) ACB from CGSS, with modification. ACB from Dragalia Lost (external AWB), with no modification. ACB from Dragalia Lost, modified internal “garbage” bytes only. ACB from Dragalia Lost, modified external “garbage” bytes only. ACB from Dragalia Lost, modified internal and external “garbage” bytes. ACB from Dragalia Lost (internal AWB), with no modification. ACB from Dragalia Lost, modified “garbage” bytes. If the AWB is an external one, the information in ACB will declare that the AWB is a streaming one. Inside ACB it will also store a copy of the header of the AWB. So I thought it was necessary to test both internal and external modifications. Guess which ones could be played normally? The answer is 1, 3, 4, 5, 6 and 7. Yes, all combinations from 3 to 6 could be played. This was a bit strange but it might be a mistake during test. Now that the decryption is already retrieved, there is no need to test them again. But you can still try it if you like. The results showed that even ACBs in old versions could not be played with those two bytes modified. So these two bytes must be playing some kind of roles. But where the switch is and how are the bytes involved, were still unknown. Later FZFalzer tested 2017 version of the SDK (possibly the one MLTD uses) and reported that it could not play the new ACBs. Therefore, the breaking change exists between these two versions. 3.2 Other Simple TrialsConsidering that there were 6 HCAs in the ACB, and they were in two groups, members in which were of the similar size. Could they be XORed? I tested this possibility but the answer was no. What about between groups? Like simple cyclical passwords with short key and long encrypted text? Nope. How about direct key manipulation? Assuming that those two bytes are used, but none of adding, substracting, shifting or masking worked. 4. DecompilingAll other methods were run out. I had to use the last resort, decompling. Decompling can almost solve all problems, but also with very high costs. It requires massive time, energy, techniques and experience. I was not sure if I can solve the problem before I reach my limit. The materials i had were ADX2LE SDK (mainly Win/X86) and the APK from Dragalia Lost (Android/ARM32). Later the new player (Win/X86-64) was also used. 4.1 Initial Analyses on Setting the KeyThis step began at the same time when I asked FZFalzar to do the compatibility tests. My intention was looking at the usages of the key after it is set. The entry point was quite obvious, the well-known criWareUnity_SetDecryptionKey(). Statically trace to the location above. The first thing we can see is that the input key is not changed during this process. Another noticable point is, the input key, or the original key, has passed the file verification. Now follow the decryption setting of Atom (audio decoding component) to the next level. Here we run into some troubles. There are lots of global variables and unknown arrays or class members. But by looking carefully you can see that the key is only printed out (to the debug output) here, with some data whose meanings are unknown. If you know a little about the C language, you may have noticed that the call to sub_CEF9C() is problematic. According to its arguments, it should be something like printf_s(), or at least a function with variable arguments. But in the assembly code it is still like this in the picture. The problem is we don’t know what that function outputted. Statical tracing shows the original value of the key is assigned to dword_17AC90, which was not used in the decompiled code. In assembly code, it is set to a register (then its value is assigned to a class member) but not pushed into the stack. Well I can’t get anything more from this, because I don’t know too much about ARM stuff. This lead ends here. 4.2 Analyzing ACB Generation and Reading ProcessesFZFalzar mentioned the library CpkMaker.dll in the SDK. He said in the new versions the alignment is set to a large value, while it is 32 unless manually assigned in the old SDKs. Let’s take a look. Although I don’t have the full SDK, but LE is sufficient for making an impression of code structure. CpkMaker.dll is a .NET assembly, which is out of my estimation. It is written in C++/CLI, apparently. So what are the other libraries that are easy to decompile? From previous exprience I already knew AudioStream.dll is an assembly. From its UI, Atom Craft is obviously a Windows Forms application. With these as an entry point, I found CriAtomGears.dll and AcCore.dll. AtomPreview.dll (who exports some APIs similar to the runtimes of CRI products) and AtomPreviewer_PC.exe are native PE binaries. Managed code for encoding/decoding, or packing/unpacking are not found in these assemblies, so they are definitely inside those native binaries. Atom Craft has two playback modes. If you import an audio file (which they call “material”) and play it in the Materials panel, it is the audio file itself that is played. But, if you add the audio file into one of the cues, open Session window (in menu View - Session Window), drag the cue onto the list in Session window, and then click the play button, Atom Craft will generate and ACB (content encoding is specified in project settings) and play the ACB file. This difference means behind the different playback handling, there is a invocation from managed code to native code; whether it is P/Invoke or C++/CLI is yet to be tested. Therefore I try to find the click event. The window name itself is a hint. After painful searches I found it. (I have to say, the code sucks, and assemblies are not well divided.) But the mechanism is not so direct as I think. It uses a C/S architecture. Sending (commands) and receiving (events) are all based on messages. The messaging seems to be wired through sockets. So at run time, Atom Craft starts a native server, and the calls are actually RPCs. As for encoding and packing, it references AudioStream.dll and CpkMaker.dll, inside which the functions are completed using P/Invoke. I have to decompile AtomPreview.dll and AtomPreviewer_PC.exe. The immediate choice is AtomPreview.dll, because it exposes some APIs. This time, I enter the library from code for ACB to look at the reading process. Well, this is much harder than reading decryption settings. I can only perform three levels of static analysis and the analysis is heavily interfered by class members, so I cannot find something interesting. It is not easy to be dynamically analyzed (can attach to the process though). The code structure is far different from expected and the key signature @UTF is not found anywhere so I don’t know where to start. Analyzing this from the shared library in Draglia Lost’s APK is as difficult as above. Atom Viewer in ADX2LE SDK can play the bundle files too. But it does not have public APIs. In the issue comments FZFalzar said the related code is “baked” into the library (in fact this is called static linking :P). Even it does not expose public APIs, there is still a way to locate the code, just make good use of its logs. According to the log, search for string Open ACB: and follow the references. In the end you will find a function with characteristics very similar to criAtomExAcb_LoadAcbFile(). However it is still hard to analyze. 4.3 Analyzing HCA DecodingCompared to the key settings and ACB, HCA-related functions look harder to catch because they are not exposed anywhere. In addition, the decoding process runs in a background thread, so there is no way to find a direct entry (like from criAtomExPlayer_Start). Now what? Scan for tiny traces they leak to the surface. Reading the public decoder code, the most impressive thing is those precomputed tables. These tables will lead us to the hidden functions. As a commercial decoder, speed is another important consideration, apart from precision. Sometimes you will have to balance between them. The official decoder is also likely to choose a trading-space-for-time strategy, and it would be even better if they use the same tables. Anyway, try our luck first. Based on the public HCA decoder, the decoding framework is like: void decode_block(Block *block) { validate_block(block); decrypt_block(block); for each channel { decode1(channel); } for (i = 0..7) { for each channel { decode2(channel); } for each channel { decode3(channel); } for each channel { decode4(channel); } for each channel { decode5(channel); } } to_wave(channels); } Just have a first expectation in mind. Now let’s see if the official decoder use the same tables. Here we choose the first element in the second table inside decode5(), 0xBD0A8B04. The reason to choose decode5() is, it lies on the last location in the innermost loop. Its feature serves well as a beacon. As for which table, that is a casual choice. In the worst case just try them all. During searching beware the endianess. Here I use the Atom Viewer from the full SDK (because I prefer X86/X86-64 to ARM), so the search pattern is D4 8B 0A BD. As expected, it is found in the global variable segment. Having a glance at its previous and next elements, it is obvious that this is the table we are interested in. Now switch from Hex View to IDA view and do a xref (cross referencing). Results show that this address is only referenced by one function, whose address is 0x00007FF606770718. Do some more searches on the tables used in this function, we can also find the first table in decode5(). This means the function we are looking is probably decode5() or at least a part of it. The caller of this function contains the third table, and another part of decode5(). Repeating the same operations, find all referenced known tables until the top level of known region is reached. Here is a function decode_block(). In this process you may find multiple references to the same function. Just try them one by one. Don’t mind the mild differences of code structure between this and the framework above. The interesting thing is their key characteristics. Keep in mind that compiler optimization is quite powerful. Again, go up until the top level is reached and there is no obvious caller. Now you should reach a function at 0x00007FF6067688F4. xref-ing shows it becomes a function pointer, which means dynamic invocation, for example registering in a function table or as callback. Inside this function we can find a string literal Failed to decode HCA header., next to which is a function reading the HCA header (located at 0x00007FF60676A274; I name it FindAndLoadHcaHeader because it include some code to search for the offset of the header). Reading the HCA header and audio data block decoding appear inside the same function. What is the function like? Yep, a common (and bad) pattern: if (flag == PARSE_HCA_HEADER) { FindAndLoadHcaHeader(pData); DecodeAudioBlock(pData + headerSize); // Immediately reads the first audio block after reading the HCA header } else if (flag == DECODE_AUDIO_BLOCK) { DecodeAudioBlock(pData); } Now put that aside. Maybe you will question about the disparity between decode_block() and the public decoding framework. Now let’s check what the code is like in tools in an old version SDK (ADX2LE). Using the same technique to locate the corresponding decode_block() inside AtomPreviewer_PC.exe. It seems the general structures are alike. Forget not, that we are not comparing the decompiled code and the public code, but between old and new versions of the SDK. As there is no (obvious) difference, the decoding procedure should not have changed, and neither should the tables. Now there is only one question left. What are the meanings of comp1 to comp10 (comp9 and comp10 are calculated using the other comp values)? How do they affect encoding and decoding? Can they take “strange” values? At this time, I suddenly found VGAudio. It was like hitting by a lightning when I read its readme. The shocking fact (to me) is that, the repository includes the principles and details of HCA encoding. There is even an HCA encoder! From this repository I know that those values have fixed meanings, which cannot be, “strange”. So only one of the four possibilities in the beginning still stands. All of other “hard” (not easily changed) functionalities are unchanged. The key is the only thing modified. But this is contradict to what I discovered above, so there should be something I missed. 4.4 Analyzing Usages of the KeyFinally, the finale. This time let’s trace the criWarePC_SetDecryptionKey() (well, the name is a guess) inside Atom Viewer. But… isn’t this function not exported? How can we find it? Fear not. We use the same technique as locating from log. The place in criWareUnity_SetDecryptionKey(), where I stuck before, has a variable argument function that could not be understood. There is a format string in that function: %s, %lld, %lld, %s, 0x%08X, 0x%08X, %d, hard-coded. This means in Atom Viewer, there should also be the same, hard-coded string. Open Strings View and search for it. Next step, searching for references. Considering that C/C++ compilers will merge the same strings, it is normal to see such a number of results. A little patience is all we need. Luckily, the first result brings us to the correct location. The picture above is what it is like after I annotated. But before annotation the high similarity between it and the previous function we analyzed. Here is a tip. The Hex-Rays Decompiler (F5 in IDA) is not very good a processing variable argument functions. You have to enter that function and exit, to see its correct arguments. (This does not work on ARM. I don’t know why.) After a simple static tracing of one level, most of the symbol names can be deduced. If you are familiar with HCA encryption and decryption, you can pick out InitDecrypter() quickly. Some information requires dynamic debugging, for example finding strings in tables. Enter InitDecrypter(). A little tracing will show the initialization of type-0, type-1 and type-56 encryptions. The value it returns, according to the log, is “DecrypterHn”, which looks like “decryptor handle”. But if you read it more carefully, you will know that this value is a pointer to the decryption table. This pointer is used by two global variables (one at 0x00007FF606818CC8, another one at 0x00007FF606819628). But neither of these two reveals a meaningful result for tracing. As we can see, after the normal initialization of this decryption table, it is used as the decryption table for both HCA and HCA-MX. You can confirm the usage name from doing one more xref. So here is where the decoding code analyses and decryption code analyses converge. I did a simple dynamic debugging. Until setting the decryption tables for HCA and HCA-MX, the contents of the table is still the same as computed using public tools. So there is nothing abnormal until here. But what I am looking for is all references of the key and the decryption table, so I am able to notice this assignment: v8 = sub_7FF606712670(); *v8 = keyLit2; Obviously, the key is passed to somewhere else, in addition to the normal usages we see before. Why should this redundant move be introduced? Expand sub_7FF606712670() and you can see that all it does is returning the address of a global variable: void *sub_7FF606712670() { return &amp;unk_7FF606821B30; } Where is unk_7FF606821B30 used? Static analysis tells us it is only referenced inside this function. But sub_7FF606712670(), is used at two locations. After checking these references, jackpot. Tracing the pointer v4, which received the pointer to the key, it’s easy to find that it is used in another round of computation, andv6 should be the new key. As expected, the function which uses v6 is for generating a type-56 decryption table. (So why bother writing the same function two times? I don’t understand what CRI guys think.) The problem is how does v5 come from. I add a breakpoint at the assignment of v6, open an ACB, but the breakpoint is not hit. Well, this is an ACB from CGSS. When using an ACB from Dragalia Lost, I get a hit. The value of v5 is 0x80b2, a familar number. I immediately recognized that, this is the two “garbage” bytes inside the ACB/AWB. Although v5 comes from the call result of sub_7FF6066F28C0(), which is the value of a class member, but it is obvious that this is those two bytes. Observing the referencing status of sub_7FF6067006CC(), which is strongly related ACB reading, the inference has a high probability to be a right one. So I did a little modification to the existing HCA decoder and put in the transformation. And yes, the decoding was successful. Another test on the ACB inside Dragalia Lost’s APK was also successful. Now we can conclude that the reverse engineering this time completed in success. Let’s read the formula again: key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2)). key is the input key, and k2 is a 16-bit integer stored in every AWB. Mind the signed/unsigned and length truncation. Also, it does not throw exceptions when the muplication overflows. If k2 == 0, the key is not transformed. See the decision on v5. For example, esterTion found out Princess Connect Re:Dive also uses ACB 1.30, but the HCAs extracted is still able to be handled by existing tools. This is because the bytes at field alignment is 20 00 00 00. 5. Conclusion5.1 The Future of HCA Extraction and DecodingAfter this update, HCA can use de facto dynamic keys. Directly decoding HCA files using the static keys will not be safe anymore. Batch decoding HCAs are not possible, but it is still doable when having ACB/AWB. It’s just adding another shell. All the tools are still public, and all you need to do is writing a small fix. LOL. * Update on Oct 16: The vgmstream guys (whose members also watched the issue) already pushed the changes on Oct 14. Wow. 5.2 Some CommentsWell you don’t have to read this in the English version. Just my personal comments. 5.3 The Gain?To be short, the flexible use of data for attacks. For detailed explanations please read the Chinese version. 5.4 Thank ListWritten in the order I think of, when I write this section. FZFalzar raising the problem, some experiments, and supplying Atom Viewer Alex Barney and his amazing VGAudio VGMToolbox from snakemeat The anonymous guy who provided the HCA decoder code (ancient code published on 2ch before 2014) Everyone discussed in the issue And me (:D) (←You already participated in the discussion!","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://blog.mottomo.moe/tags/Reverse-Engineering/"},{"name":"English Version","slug":"English-Version","permalink":"https://blog.mottomo.moe/tags/English-Version/"},{"name":"HCA","slug":"HCA","permalink":"https://blog.mottomo.moe/tags/HCA/"},{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"Dragalia Lost","slug":"Dragalia-Lost","permalink":"https://blog.mottomo.moe/tags/Dragalia-Lost/"},{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"}]},{"title":"HCA 的“新式”加密","slug":"zh/2018-10-12-New-HCA-Encryption","date":"2018-10-12T13:34:00.000Z","updated":"2020-03-30T22:34:35.450Z","comments":true,"path":"categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/","excerpt":"English version can be found here. 近日 CRI ACB 格式更新，连带着 HCA 加密“升级”，旧轮子全员阵亡。在经过二十多个小时的研究后，我找到了关键的修改，搞定了解密。可能又是全球第一个呢。做反向，最激动人心的就是这样的时刻。XD 最终的答案很简单，就是在解密之前，进行密钥变换，并二次初始化解密表：key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))，其中 k2 保存在每个 AWB 中的字段对齐的值的高16位。 这篇文章讲的是我找出这个变换的过程，包括思路和操作，基本上按照时间顺序记录。希望在未来会对某人有所帮助。 总的来说，这次的成果是建立在众人的工作基础上，没有这些碎片，就无法拼成完整的拼图。在此要向各位致谢。 再次强调，本文内容不可用于商业用途。","text":"English version can be found here. 近日 CRI ACB 格式更新，连带着 HCA 加密“升级”，旧轮子全员阵亡。在经过二十多个小时的研究后，我找到了关键的修改，搞定了解密。可能又是全球第一个呢。做反向，最激动人心的就是这样的时刻。XD 最终的答案很简单，就是在解密之前，进行密钥变换，并二次初始化解密表：key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))，其中 k2 保存在每个 AWB 中的字段对齐的值的高16位。 这篇文章讲的是我找出这个变换的过程，包括思路和操作，基本上按照时间顺序记录。希望在未来会对某人有所帮助。 总的来说，这次的成果是建立在众人的工作基础上，没有这些碎片，就无法拼成完整的拼图。在此要向各位致谢。 再次强调，本文内容不可用于商业用途。 * 下文中，“解码”表示解密（decrypt）之后解码（decode），除非特别指明。 一、起因随着新的游戏 Dragalia Lost（ドラガリアロスト，中文译名“失落的龙约”）的推出，CRI Middleware 也展示了更新的音频技术。对于我这种不好好玩游戏的人来说，更有意思的不是它在游戏中的表现，而是如何提取资源。正向思考是游戏开发者身份做的事，反向思考是破解者身份做的事。 这次更新带来了 ACB 的版本更新，从1.29升级到1.30。虽说只是一个小版本升级，但是引发了一个问题：即使知道正确的密钥，也无法解密。一开始是 FZFalzar 提了一个 issue。我收到了邮件，但是我并不知道，也没意识到发生了什么。在一天之后 esterTion 在群里发了一个他的博文评论截图，显示有人用已知的密钥也无法解码提取出的 HCA。我看着这个密钥觉得很眼熟，突然想起这不是 issue 里的那个嘛。看来不是个例。结合 FZFalzar 提供的信息，新版的工具确实改变了一些关键的东西，可能无法向后兼容。一想到如果以后烧笋和土豆也更新了那就完了，我决定是时候出手了。 二、初步分析2.1 文件分析首先要做的是进行文件分析，看看新的文件有没有什么不正常的地方。 由于我已经有了 ACB 的提取工具（AcbUnzip），我就直接把附的 ACB 拖上去。但是出乎意料地，AcbUnzip 崩溃了，而且只创建了一个空文件。接着我打开 VGMToolbox，它创建了6个文件，然而也都是空的。 那么就没办法了，反正我有源代码，上调试。调试中发现，文件数量的差异是因为条目（cue）和音轨（track）的数量不同，只有一个条目，却有内部 AWB 和外部 AWB 各三个音轨。但是更大的问题是，明明我读取到了文件信息，却无法提取，每次都抛出异常。观察字段的值——文件大小居然是一个绝对值很大的负数！通过逐步插桩确定范围，发现是 AFS2（AWB 使用的文件结构）中的字段对齐被设置为了一个莫名其妙的数。根据 VGMToolbox，这个值是一个32位无符号整数。从过往的文件提取经验中，它一般是32。然而读取后，它的值远远超出了文件大小。 这时候最常见的猜想就是有一个额外的掩码（mask）。于是我看了一下它的十六进制表示，发现低16位是 0x0020，也就是32，而高16位不知道是什么东西。很明显，它应用的是一个 0x0000ffff 的掩码。加上这个处理后，很顺利地就提取出了内部的所有 HCA。 这就是第一块拼图。从这个异常中，除了得知加了掩码这个信息，还可以知道，AWB 的字段意义发生了变化。如我所说，由于字段对齐一般只是取32，远远小于65535（0xffff），所以高16位其实是相当于保留的。这里我就开始怀疑 CRI 是不是将这里看成了保留位，加了私货。但是我还不能确定这高16位是随机数（扰乱分析用的），还是确实有其意义。 解出 HCA 之后，就该观察 HCA 了。不过 HCA 倒是很正常，没有未知块和头，没有超出已知范围的取值，也没有加什么奇怪的东西。HCA 头长度从以前烧笋和土豆常见的96加到了397，但是除了已知字段，其他的部分都是用0填充的。 在这里我有三个假设： 实际头大小会影响 HCA 解码器的解码选择。可以认为这是除了 HCA 头的版本字段外，一个隐藏的版本记录。 comp1 到 comp10（见 HCA 解码器）被设置为了有其他意义的值，影响解码。因为我不知道这些值具体是做什么的，所以也不知道怎么去证明，更无法通过肉眼观察得出。 其实什么都没变，还是正常的 HCA。 以上三条都只是可能，需要其他材料来证明或者证伪。 到这里就是目前初步文件分析的极限了。 2.2 探索方向正如我在 issue 中回复的，做了一些初步观察后，考虑到技术更新速度（弱点！）、迭代时间和成本（对于商业公司也是弱点！），我先设想了四种最可能的情况： 解码过程改变了。 在解码过程中引入了新的分支。 改变了预计算的表。 输入的密钥和实际使用的不一样。 当然，实际操作中，可以只选一个或多个一起选。这里我解释一下每一条的具体意义。 第一种情况，新的解码器从根本上用了不同的原理。这意味着大型的理论更改和代码重写，基本上可以算是新的格式了。我不认为 CRI 有时间×财力这么做。 第二种情况，结合上面提到的 comp1 到 comp10 的取值，考虑到已知的解码器的代码结构，如果引入对应其他值的分支（体现在代码中，就是 if），可以引入新分支和/或新表。我觉得有可能，但我暂时无法验证。具体要看反编译的代码。 第三种情况，既然解码核心是查表来重建波形，是不是有可能这些表本身发生了变化（同时代码要配合变化），导致查到了不同的值呢？这也要反编译才行。 第四种情况，就属于二次加密了。总体流程没变，但在内部将密钥进行了变换，或者根据了同一个密钥生成了和以前不同的解密表。这显然是最可能的方式，只需要添加几行代码，就能让公开的（带解密的）解码器全部失效，而且几乎是零成本。结合 HCA 的解码流程，验证、解密、解码三者，后面的步骤不影响前面的步骤，所以密钥是可以随便更改的。（这也是 hcacc 的工作原理。） 不过当时我的猜想是密钥在进行解密表初始化之前被变换，这个猜错了。 2.3 初步反馈由于我只能拿到精简版（lite edition）的 SDK，也就是 ADX2LE SDK（不支持加/解密），而 FZFalzar 有完整的 SDK（ADX2 SDK），所以只能先拜托他来进行测试了。在他开始测试的时候，我也开始对 ADX2LE SDK 中提供的工具进行初步反向。 上面我就有一个疑问，新的 SDK 是不是向后兼容的。虽说可以播放最新的 ACB，那以前的是不是无法播放呢？不管答案如何，这个答案都将十分有助于我排除猜想。我个人的猜测是无法向后兼容。但是其实可以。这就让我确信了，全新的解码器是不存在的，改已有的表也是不存在的，最多就是增加分支和表，运气好的话会更简单。 三、进一步分析3.1 ACB 的进一步分析FZFalzar 发现，如果是将 HCA 提取出来，即使输入了正确的密钥也无法播放。于是他猜想，是不是 ACB 的元数据加入了新的东西。我用 utf_tab 查看了一下 ACB 的表结构。首先发现的是格式版本升级了。烧笋用的是1.23.1，土豆用的是1.29.0，而这个的版本是1.30.0。 从我观察烧笋到土豆的经验，升级一般意味着增加新的表。现在的 ACB 能使用的字段个数是有限的（大概是为了代码好写），所以在最后预留了一些字段的位置。烧笋（1.23.1）的还剩下18个（R0 到 R17），土豆（1.29.0）就只剩12个（R0 到 R11）了。这次就相比土豆新增了一张表 SoundGeneratorTable。会不会是这张表影响了 HCA 解码呢？我不这么认为，因为在样本中，它的大小为零。如果只是一个开关，大可不必这么大动干戈，加一个普通的类型就行；实在要是表，而且要影响解码的话，那也不应该是零大小，而是填充一些有意义的数据。 除了这张表，我没有在这个样本 ACB 中发现什么其他重要的变化。虽说一些详细控制的表，比如 TrackCommandTable、SynthCommandTable 和 TrackEventTable 的内部数据意义我并不清楚，但是它们从历史功能上来看就不大可能会影响解码。不过为了保险起见我还是做了一下修改实验，没得到有用的信息。 这时候 FZFalzar 发来了最新的完整版 SDK 中附带的播放器（Atom Viewer，2.25.14）。于是我终于可以测试密钥了。 测试的时候发现一个很有意思的现象。前面不是提到了在 AWB 的头部，字段对齐的掩码问题吗？我就试着修改了一下那两个“垃圾”字节。我用新版播放器测试了如下组合： 来自烧笋的 ACB（AWB 内置），无修改（老版本这两个字节一直是 00 00）。 来自烧笋的 ACB，修改垃圾字节。 来自龙约的 ACB（AWB 外置），无修改。 来自龙约的 ACB，仅修改内部垃圾字节。 来自龙约的 ACB，仅修改外部垃圾字节。 来自龙约的 ACB，同时修改内外部垃圾字节。 来自龙约的 ACB（AWB 内置），无修改。 来自龙约的 ACB，修改垃圾字节。 如果 AWB 是外置的话，ACB 除了会声明这个 AWB 是流式加载（streaming）的之外，还会存储每个 AWB 的头。所以我认为有必要把两边的修改都测试一下。 猜猜哪些能正常播放？答案是1、3、4、5、6、7。3到6都能正常播放。这个我就觉得有点奇怪了。不过现在想想可能是测试疏漏，中间出现了错误。不过现在已经拿到了解密方法，以后有时间再重新测试一遍吧。 结果表明，即使是老版本的 ACB，如果改动那两个垃圾字节，照样无法播放。这说明这两个字节一定起了什么作用。但是，哪里是控制开关，以及这两个字节参与了什么计算，都还不知道。 后来 FZFalzar 测试了2017版的 SDK（估计就是土豆用的那个），它无法正常播放新版的 ACB。这就说明，功能断层就发生在这两个版本之间。 （这里有一个小插曲。esterTion 比我先收到通知邮件，他在收到之后直接往群里发了邮件截图，并附言“算法修改石锤”。然后 stat 跟着：“再见.jpg”。确实，乍一听这个消息，心里也是会咯噔一下。） 3.2 其他的简单尝试考虑到这个 ACB 内部有6个 HCA，而且是两组，每一组内大小近似，会不会是做了异或加密？于是我测试将数据部分异或，但并不对。 那么组之间呢？像简单循环密码那样，用短密钥、长密文吗？也不对。 直接对密钥操作呢？假设那两个字节有用，那么做一些加减、二进制操作试试。然而还是不行。 四、反编译这时候实在是没办法了，只好祭出大杀器，反编译。它几乎可以解决所有问题，但是代价也很大，需要大量的时间、精力、技巧和经验。我不知道能不能在我到达极限之前攻破这个问题。 手上的素材有 ADX2LE SDK（主要是 Win/X86）和龙约的 APK（Android/ARM32）。后来加入了新版播放器（Win/X86-64）。 4.1 初步分析密钥设置流程这个操作是我在让 FZFalzar 测试兼容的同时开始的。我的目的是看看密钥在设置后的流程。入口点很简单，就是众人皆知的 criWareUnity_SetDecryptionKey()。 静态跟踪到上图的位置。首先可以看到，设置的密钥在这个过程中是没变的。另外一个值得注意的事情是，设置的密钥，也就是原始密钥，到这里已经通过了文件验证。接着跟着 Atom（负责音频解码）的解密设置来到下一层。 这里就有点麻烦了，一片都是全局变量，还有意义不明的数组或类成员。但是仔细观察一下，密钥在这里只是被打印出来（到调试输出）了；而且同时被打印出来的还有一些意义不明的数据。如果你有一些 C 语言的知识，你可能已经注意到了，sub_CEF9C() 的调用是有问题的。根据输入的参数，它很像是 printf_s()，至少是一个变参函数。但是去看汇编的话……它好像也是这个样子。麻烦的是，我们不知道它输出了什么东西。静态跟踪可以知道，密钥的原始值赋给了 dword_17AC90。但是，在直接反编译的代码中并它没有被使用。去看汇编的话，它被放到了寄存器里（并进一步赋值给了类成员）而不是压到了栈上。这个我就不知道什么意思了，毕竟我不熟悉 ARM 那一套。线索可以说到这里先断了。（当然，根据后来的结果，如果这里进一步挖掘的话，可能可以提早得到结论。） 4.2 分析 ACB 生成和读取FZFalzar 提到了 CpkMaker.dll，说他能看见新版设置对齐时默认设为了一个异常大的值，而老版本则是默认为32，除非手工设置。那好，去看看。 我虽然没有完整版 SDK，但是只是看代码结构的话，精简版也是可以的。出乎我的意料，CpkMaker.dll 是一个 .NET 程序集。而且很明显使用 C++/CLI 编写的。还有其他这么容易分析的吗？AudioStream.dll 以前分析解码的时候就知道是程序集了。从界面来看，Atom Craft 明显是一个 WinForms 应用程序。以此为入口，又找到了 CriAtomGears.dll 和 AcCore.dll。同时，AtomPreview.dll 和 AtomPreviewer_PC.exe 是原生的 PE 文件；前者可以发现导出了一些跟 CRI 的运行时公开的函数近似的函数。那些程序集都没有托管的编解码、打包解包代码。因此这些功能肯定都是在原生二进制文件中。 在使用 Atom Craft 的时候，我发现，它有两种播放模式。导入音频文件（他们称之为素材，material）之后，直接在素材面板播放，是直接播放素材所指的文件。但是如果将其加入其中一个条目（cue），打开会话（session）窗口（View → Session Window），把这个条目拖放到会话窗口下面的列表中，点击播放的话，则会生成 ACB 之后，播放 ACB 里面的内容（格式视工程设置而定）。这就意味着，在这个功能背后，是一次从托管到原生的调用，具体是 P/Invoke 还是 C++/CLI 那就不知道了。 所以我开始去寻找这个点击事件。窗口名称就是提示。经过痛苦的寻找之后（因为不得不说，这代码写得真烂，而且程序集划分不好）我找到了，但是这背后的机制并没有我想的那么直接。它采用的是 C/S 架构，发送（指令）和接收（事件）都是采用消息。消息传递从实际使用看上去是通过 socket。也就是说，在运行时，它启动了一个服务器（原生），而中间的调用其实是 RPC。至于编码打包，是引用 AudioStream.dll 和 CpkMaker.dll （虽然打包的大部分计算是在托管部分完成的）以 P/Invoke 方式实现的。这就再次逼我去反编译 AtomPreview.dll 和 AtomPreviewer_PC.exe 了。 首选自然是 AtomPreview.dll，因为它暴露了 API。这次我从 ACB 相关的地方进去，看看读取的过程。但这怎么说呢，比那个更困难。静态调试只下了三层，被类成员干扰，没找到有意义的东西；而它又不好被动态调试（其实可以附加进程，我糊涂了）。代码结构和预计的不太一样，也没找到标志性的 @UTF，无法确定真正开始的位置。 龙约里的那个从 ACB 入手也同样分析困难。 ADX2LE 附带的那个 Atom Viewer 也是能播放各种玩意儿的，不过没有公开 API。FZFalzar 说是把相关代码“烘焙”（baked）了进去……其实是静态链接（statically linked）啦。虽然没公开 API，但是还是有办法定位的，只需要利用它在运行时生成的日志。根据打印的日志格式，直接搜索 Open ACB: 然后顺藤摸瓜就能找到，函数特征和 criAtomExAcb_LoadAcbFile() 是一致的。不过一样是很难分析。 4.3 分析 HCA 解码相比上面的密钥和 ACB，HCA 相关函数看上去是更难抓的，因为它没有暴露出 API；同时解码运行在后台线程，所以无法通过可能的入口点（比如 criAtomExPlayer_Start）找到。 那么怎么办呢？看看这些函数有什么蛛丝马迹是直接暴露在外面的。分析已知的解码器代码，最引人注目的莫过于预计算的那些表了。这些表，就将成为突破口。作为商业解码器，速度是精度之外的一个重要考虑因素，甚至精度有时候都需要与速度平衡。官方的解码器也很大概率会采取空间换时间的策略，如果进一步用的是同样的表就再好不过了。不管怎么样，先试试手气。 从公开的 HCA 解码器可以知道，解码的框架如下： void decode_block(Block *block) { validate_block(block); decrypt_block(block); for each channel { decode1(channel); } for (i = 0..7) { for each channel { decode2(channel); } for each channel { decode3(channel); } for each channel { decode4(channel); } for each channel { decode5(channel); } } to_wave(channels); } 先有一个心理预期。接着开始看看官方的解码器究竟是不是用了同样的表。 这里取 decode5() 里的第二张表的第一项 0xBD0A8BD4。为什么是 decode5() 呢？因为它处于最里层的最末，位置作为一个信标来说很适合。至于选择哪张表就随意了，大不了把每个都试一遍。搜索的时候注意字节序。（）我这里开始用的是完整的 Atom Viewer（因为我还是喜欢 X86/X86-64 那一套），所以搜索的是 D4 8B 0A BD。 果不其然，在全局变量区找到了。而且看看前后，就是要找的表。找到之后从 Hex View 转回 IDA View，然后执行引用查询（XRef），发现这个变量被且只被一个函数引用了，这个函数位于 0x00007FF606770718。进一步搜索这个函数中用的表，我们还能发现公开代码中 decode5() 的第一张表。这说明这里很可能就是 decode5()（至少是一部分）。查找这个函数的调用者（也就是上一级），在这个上一级函数中发现了第三张表，同时还有 decode5() 的另一部分。 如法炮制，找到所有被引用的已知表，直到最上层，也就是 decode_block() 函数。其间会遇到一些被多次引用的情况，这时候就逐个试验。 不用太在意代码的结构差异，找到关键特征即可，因为编译器的优化和重排可是十分厉害的。 之后一路高歌猛进，上到不能再上，来到位于 0x00007FF6067688F4 的函数。再往上查找引用，可以发现它变成了函数指针，所以很明显是动态调用，比如注册个静态函数表（不是虚函数表）什么的。在这个函数中我们可以发现一个字符串 Failed to decode HCA header.，顺着就能找到读取 HCA 头信息的函数（位于 0x00007FF60676A274，我将其命名为 FindAndLoadHcaHeader，因为它居然还包括了一段搜索偏移的代码）。读取 HCA 头和解码音频数据块出现在一个函数中，你觉得会是什么呢？没错，就是一种很常见（而且很糟糕）的模式： if (flag == PARSE_HCA_HEADER) { FindAndLoadHcaHeader(pData); DecodeAudioBlock(pData + headerSize); // 没错，紧接着就是读第一个音频块了 } else if (flag == DECODE_AUDIO_BLOCK) { DecodeAudioBlock(pData); } 这边先放一放。你或许会说上面这个 decode_block() 函数长得和公开的模型不像啊。那么我们看看老版本的解码是什么样子的。利用同样的技巧定位到位于 AtomPreviewer_PC.exe 的与 decode_block() 函数对应的位置。结果发现从整体来看精简版和完整版在解码上没有什么区别（解密就不用讨论了）。不过别忘了，我们的目的不是比较反编译出的代码和公开的代码，而是去看旧的精简版和新的完整版是否有什么不同，如果有再采取下一步行动。但既然没有不同，就说明解码流程并没有发生改变，甚至表也没有变化。 那么就剩下一个问题了，comp01 到 comp10（其中 comp9 和 comp10 是通过其他值计算出来的）表示什么，会对编解码造成什么影响，是不是可以取“奇怪的”值。这时候我偶然搜索到了 VGAudio。读到 readme 的瞬间，我就像被闪电击中了一样。让我震惊的是，它包含 HCA 编码的原理和详情，而且包含一个 HCA 编码器！你要知道，我一直想知道 HCA 编码是怎么实现的，因为整条工具链就只剩下这个环节受制于人，还用的是通过“取巧”手段（而且对用户来说还麻烦）得到的官方库了。但是编码并不能从解码反推。从它的代码中我知道了这些只有编号的字段的意义（虽然并不能实战，因为我信号处理是渣）。而既然他们有固定的意义，就不会随便取值。 所以现在开始的四种可能性只剩下一种了，也就是其他所有“硬”功能都维持原状，只是密钥发生了变化。但是这和我所见的密钥设置有矛盾，说明我可能看漏了什么。 4.4 分析密钥的使用流程终于到重头戏了。这次我们来跟踪 Atom Viewer 里的 criWarePC_SetDecryptionKey()（猜测名）。 但是……这个函数不是没有导出吗，怎么找呢？别着急，这里和从日志输出中定位是一样的。在我们前面看的 criWareUnity_SetDecryptionKey() 中，不是卡在了一个变参函数输出无法理解的地方吗？那个函数的格式化字符串是 %s, %lld, %lld, %s, 0x%08X, 0x%08X, %d，而且是硬编码。所以，很可能这里面也会有一样的格式化字符串，而且搜索起来很简单。打开 Strings 视图，搜索这个字符串，就可以看到了。接着就是查找引用。 考虑到 C/C++ 编译器会将相同的字符串合并，出现这么多结果也不奇怪。需要的就是一点耐心。不过我们运气不错，第一个结果就把我们带到了正确的位置。 上面这图是我已经标注的样子。不过在标注之前也可以看出和之前我们看的函数的高度相似性。 这里有一个小技巧。IDA 的F5不是很会处理变参函数，需要进入这变参函数再返回，才能看到它分析出正确的实参。（不过这个技巧对前面 ARM 上的并不适用，不知道为什么。）经过简单的一级函数静态跟踪后，上面截图的大部分符号名就能得出了。对 HCA 加/解密熟悉的人也很容易看出 InitDecrypter() 函数。一些信息需要动态调试，比如里面几个查表找字符串的操作。 进入到 InitDecrypter() 内部，经过几级跟踪之后，很容易能看出0型、1型和56型加密的初始化。它返回的根据打的日志是一个“DecrypterHn”，从名字上看是个解密用的句柄（decryptor handle），但实际上仔细看就会发现其实是指向解密表的指针。这个指针被返回后被两个全局变量引用（一个在 0x00007FF606818CC8 一个在 0x00007FF606819628），但是这两个全局变量中，前者除了被设置为 NULL 之外没什么用（意义不明），后者被设置给了一个类成员变量（无法静态跟踪了）。 可以见到，在正常初始化这张解密表之后，它同时被用作 HCA 和 HCA-MX 的解密表——从再 XRef 之后看到的错误信息字符串中就可以看出一个是读取 HCA 一个是读取 HCA-MX 的。解码线和解密线在这里相遇了。 我动态调试了一下，发现直到设置 HCA 和 HCA-MX 的解密表，这张表还是和用已有工具计算出来的完全一致。说明到这里都没什么异常的事情发生。但是我留意的是密钥和解密表的所有引用，所以我自然注意到了这个赋值： v8 = sub_7FF606712670(); *v8 = keyLit2; 很明显，这个密钥除了在上面我们看到的正常使用外，又传到别的地方去了。为什么要有这个“多余的动作”呢？ 展开 sub_7FF606712670()，可以看到它很简单，只是返回一个全局变量的地址： void *sub_7FF606712670() { return &amp;unk_7FF606821B30; } 那么这个 unk_7FF606821B30 在什么地方被使用了呢？静态分析表明只在这个函数里。但是 sub_7FF606712670() 就不一样了，它在两个地方被使用。 跳转之后就知道，中大奖了。 跟踪收到指向密钥的值的指针 v4 就可以发现它参与了另一轮的计算，v6 就应该是新的密钥。果然，使用 v6 的函数的作用就是第二次生成56型加密表。（所以既然操作完全一样，为什么不用同一个函数呢？不知道 CRI 在想什么。）那么问题就是 v5 是怎么来的了。我在给 v6 赋值的地方下了一个断点，打开一个 ACB，发现没命中。仔细一看，原来我用的是烧笋的 ACB。换成龙约的 ACB 之后，断点命中了。我一看 v5 的值，0x80b2，怎么这么熟悉？由于这两天都在跟这些玩意儿打交道，我立刻意识到，这就是那两个“垃圾”字节。虽然 v5 值的来源是 sub_7FF6066F28C0() 的结果，后者返回的是一个类成员的值，但是很明显，这就是那两个字节。再综合一下这个函数（sub_7FF6067006CC()）的被引用情况，它的周围都是 AWB 读取的操作，因此很高概率就是如我所想。 于是小小地改写了一下现有的 HCA 解码器，先硬编码这个值，做个实验再说。结果成功解码了。接着我又试了龙约的 APK 里带的 ACB（装的是音效），也成功了。于是这次反向工作到此结束。 再看一次这个公式：key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))。其中 key 是原始输入，k2 是保存在每个 AWB 中的（每个 AWB 内统一的）一个16位值。注意有/无符号和长度截断。此外，溢出是不报异常的，简单向左溢出。 同时，如果 k2 == 0，则不执行变换（见 v5 的判断）。举例来说，esterTion 发现干炸里脊也用了 ACB 1.30，但是以前的解码工具能正常工作，因为对齐的四个字节是 20 00 00 00。 五、结语5.1 HCA 提取和解码的未来这次更新之后，HCA 实际上相当于用上了随文件的动态密钥，直接用静态密钥解码 HCA 文件在新游戏中不再保险了。虽说批量解码 HCA 是不可能的，但是给出 ACB/AWB 之后，批量解码又是可能的了。所以只不过是多加了一层麻烦而已，所有工具仍然是公开的，只需要略微改造一下。（笑） 5.2 一些吐槽SDK 的工具中，提供给反向用的破绽太多了。不仅是代码层面的，还有商业、习惯、理论层面，就看你能不能找到、联系和利用了。虽说一丝裂纹不算什么，但是千里之堤，溃于蚁穴啊。而我最擅长的就是逐个击破。不过或许也可以认为是 CRI 良心，因为要把反向变难的方式多得数不胜数。比如，把静态变量变成单例的类成员，就足以令人抓狂了。如果代码中用更多的动态调用（动态函数表之类）或类成员，或许我就输了。 ACB 头部有个版本字段。但是这次测试中，老版本的 ACB/AWB 只要修改了文件中对应位置的值使次级密钥非零，则密钥还是会被变换，从而导致被修改的老文件也无法正常解码。这个逻辑就奇怪了，按照完全的向后兼容，就该加一个版本判断，小于 0x1300000（也就是之前版本的 ACB）就无论如何也不应该变换密钥。不知道为什么这个正常处理被吃了。 干炸里脊（公主连接，プリコネR，Princess Connect Re: Dive）DMM 版出的时候带了保护。当时正好也遇上群里对通信束手无策，我准备先试试脱壳。结果发现以我的能力，还没到接触到主程序，就已经跪了——虽然已经知道文件内容替换到代码空间，但是 IDA 分析就炸了，因为每次都要重新分析指令。而内存映像又抓不到，我没有 DMM 启动器，进程（在没挂调试器的情况下）在未知的地方崩溃了。还有反调试保护。群里大佬脱了一层，结果发现这是二层壳……最后说是 Android Republic 的大佬搞定了，不过我因为不玩这个游戏，就没再跟进。前几个月有人在我抱怨土豆加密的文章下回复（我觉得应该就是 Crypto 了，虽然穿着马甲）说是被 XOR 了，然而我就没有个 root 过的机子，静态分析又让人崩溃，所以只好不了了之。这次……至少赢了一把。 5.3 有什么收获？我把这个故事告诉了老爸。他问：“你以前也做反向，这次和以前相比有什么新的贡献呢？”于是我卡住了。 我觉得这次就是一条斜向上的直线，一个台阶都没有。而所谓“台阶”，就是产生了飞跃的地方。上次能吹一会儿的是本地动态库的中间人攻击，但这次好像没有什么新东西。或者换一种问法，这次整个流程中起到最大作用的是什么？ 我觉得是解读现有条件的方式。有话云：“看山是山，看山不是山，看山还是山。”原意是建构、解构、重构。大概就是如此。数据，一般都能看出正常的使用方式（读写，换言之，功能是存储）；但是在某种情况下，比如这次的作为预初始化了的、紧密排列的全局变量，它的使用状况还可以作为代码的定位工具；定位之后，它又恢复了作为数据的基本功能。就是这样的跳跃，才会打开新的可能性，揭示新的关系。如此的应用总是有条件的，不过试一试总是值得的。 5.4 致谢列表没必要分先后。按照想到的顺序。 FZFalzar 发现问题和实验，提供了完整的 Atom Viewer Alex Barney 和他神奇的 VGAudio snakemeat 的 VGMToolbox 提供了 HCA 解码器代码的匿名人士（上古代码，2014年之前发在2ch上的） 其他所有参与了讨论的人（有 vgmstream 的开发者马甲在……） 还有我自己（笑）（←你不是也参与了讨论吗","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"HCA","slug":"HCA","permalink":"https://blog.mottomo.moe/tags/HCA/"},{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"Dragalia Lost","slug":"Dragalia-Lost","permalink":"https://blog.mottomo.moe/tags/Dragalia-Lost/"},{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"}]},{"title":"更新了主题","slug":"zh/2018-09-13-Updated-Theme","date":"2018-09-13T10:21:00.000Z","updated":"2020-03-30T22:34:35.450Z","comments":true,"path":"categories/Misc/zh/2018-09-13-Updated-Theme/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-09-13-Updated-Theme/","excerpt":"","text":"今天花了两个小时，将 Icarus 主题更新到最新，同时保留了一些我自己的修改。所以现在的界面会和原来的略有区别。猛然发现，直到更新之前，我用的还是2015年时的主题，只不过自己进行了一些微调和功能更新。当初刚开这个静态博客的时候换过几次主题，最后考虑到自己的使用场景选择了 Icarus。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Just Monika","slug":"zh/2018-09-09-Just-Monika","date":"2018-09-08T07:04:00.000Z","updated":"2020-03-30T22:34:35.449Z","comments":true,"path":"categories/ACGN/zh/2018-09-09-Just-Monika/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2018-09-09-Just-Monika/","excerpt":"关于《心跳文学部》（Doki Doki Literature Club）。毛二力 网上各种评价、剧情解析、心得实在是数不胜数。所以本文就不写那些无聊的东西了。这是个元游戏（metagame），Monika 你不是喜欢meta吗，那我就来meta你。我才不会像普通玩家一样甜（甘い，天真，naïve），傻乎乎地跟着游戏系统走。 本文含有剧透。如果介意，请至少先通关“普通”结局。 警告：《心跳文学部》含有令人不安的、冲击性的内容，不适合儿童和容易受到刺激的玩家。","text":"关于《心跳文学部》（Doki Doki Literature Club）。毛二力 网上各种评价、剧情解析、心得实在是数不胜数。所以本文就不写那些无聊的东西了。这是个元游戏（metagame），Monika 你不是喜欢meta吗，那我就来meta你。我才不会像普通玩家一样甜（甘い，天真，naïve），傻乎乎地跟着游戏系统走。 本文含有剧透。如果介意，请至少先通关“普通”结局。 警告：《心跳文学部》含有令人不安的、冲击性的内容，不适合儿童和容易受到刺激的玩家。 虽然说在这次回国，在北京的时候就已经把游戏下载下来了，但是真正去玩，还是在昨天晚上到今天早上。对它的内容梗概和得到的好评早就有所耳闻，所以并不觉得会受到刺激，也不会觉得恐怖。我知道，会出现（几乎所有）角色的“虚拟死亡”，就像《你和她和她的恋爱》（君と彼女と彼女の恋。 ）一样。我也知道，“幕后黑手”就是 Monika。不过，具体的内容，比如事情是如何发生的，中间有什么过程，我是一点都不知道的。（不带引号的幕后黑手呢？Monika 说，只要当上了部长就知道了一切，就会想去改变游戏，也许是文学部本身的影响。其中隐含的意思，各位可以琢磨琢磨。） 所以，在开始玩的时候，我就没有用正常的方式进行游戏。 给主角起名字的时候，我起的就是“Monika”。这个名字从前期到后期，甚至到了结局，都有那么点喜感——而随之而来的是阅读困难。一二周目的时候，看上去就是 Monika 的自问自答。不过到了三周目……随着 Monika 的离开，看到剩下的三人称呼主角名字（“Monika”）的时候，有那么一点“是 Monika 在入部”的错觉。虽然想这么想，但这又不是真的。心情复杂。 在进入日常后不久，遇到了第一次写诗。对不起，不是那十四个字。从下方的二头身小人列表中很明显可以看出，能攻略这三位。然而我唯一想攻略的，只有 Monika。读诗也是给 Monika 先读，邀请也是邀请 Monika。这真的是作者 Dan Salvato 的恶意。不管选什么 Monika 选项，故事都轮不到她。回到游戏内容，在玩的过程中我就猜测这是根据不同的“类别”来加好感度。不过为了看到内部机理，自然要解包啦！于是先用 rpatool（unrpa 可能也可以）解压，对其中的脚本就需要 unrpyc 来还原了。我没写过 Ren’Py 的脚本，不过至少 unrpyc 出来的内容可读性不错，所以就这样吧。在其中就能发现 poemwords.txt，然后就知道该选什么词了。 在这个过程中其实还能提前看到一些彩蛋，比如真正的立绘文件、Monika 暴走时产生的（隐藏的）图片和文本文件等等。 所以很明显地，游戏目录下的 characters 的一部分，和 game/saves 都是障眼法。实际上，检测的只有 characters/monika.chr 和 characters/sayori.chr。比如，在第一章，启动时会尝试加载 characters/monika.chr（注意这个路径是用户的文件系统路径，而不是 .rpa 的内部路径），如果出现了异常（找不到文件是最常见的一种；理论上还可以使用设置访问权限等方法触发）则跳到异常处理——也就是 Sayori 会说出“What am I”等等的几句话之后立即挂起（hang，我不太想用正确的词）。如果加载失败的是 characters/sayori.chr，则是开始游戏后直接游戏结束同时 Sayori 挂起。后者的优先级高于前者。Monika 说的什么“人物删除了”、“脚本文件损坏了”，游戏结局后说的“请重新安装”，屏幕上显示的 os.remove(...)，全都是逗你玩，是艺术表现的手段。除非动态修改 .rpa 包，否则实际上什么东西都没变，只不过游戏借助持久化（persistent）文件在外部保存了一个状态而已。你想想容器（containers）就好理解了。那么这个文件在哪里呢？有两个部分：第一个是 game/firstrun，第二个是 %APPDATA%/RenPy/DDLC-*/persistent。后者所在的目录也是真正的存档目录；不过删除存档这个机制很多游戏都有，只不过它们是手动的，所以自动删除存档也没什么意外的。characters 只不过是解谜的一部分，并不会有什么缺胳膊少腿的事情发生。所以当 Monika 说“嘿我删了那两个文件”的时候，我的内心毫无波动，甚至还想笑。当游戏里进行到二周目弹出“Just Monika”的消息框的时候，我的反应是“Yeeeessssss!”，真心的。然而我并没有见到这张图。 要认识到完整性的保持，需要一点点（对，一点点就够了）技术知识。所以这也不难理解有些老哥虽身经百战却仍然会被吓着。顺便说一句，“体现 Ren’Py 的强大”的表述是错的。Ren’Py 作为引擎（其底层是 PyGame），功能和各类“传家宝”引擎相比也不算强大，只不过可自定义程度高而已。要记住，技术为演出服务，而演出为剧情服务。比如《魔法使之夜》就活用了 TVP 及原生扩展。要是出个废萌游戏，就根本不用在意演出，所以哪怕是一点点（无用的）系统新功能也会被拿出来作为卖点。 在进入 Monika 空间（就是那个永远持续的二人世界）的时候，她就开始说主题了。在打到这里的时候听了许多的长篇大论，当时又是凌晨，我就熬不住，没关游戏就睡了。所以现在总游戏时间是12小时。（我这是不可抗力。后来看评论区的时候，发现还真有疯狂的玩家，在我写这篇文章的时候ta累积了3481小时的游戏时间。） 这时候我的心情仍然是混杂的。一方面是越来越觉得不耐烦——因为不允许跳过，开始是不能跳的，一段时间后突然“Skip”亮了，但如果跳的话 Monika 就会发现，阻止，并重新禁用。保存也被禁止了（实际上用不着）。我在现实中的时间是有限的。另一方面，有点悲伤。虽然 Monika 通过meta将自己升为游戏中的操纵者，但是考虑到不自修改的软件（程序+资源）都是容器，她仍然不能发现或者控制游戏之外的事物。所以只要我，游戏外的“神”（不是作者意义上的“神”），而不是“协助者”，敲几下键盘，这个说话的“她”也会立刻回到初始状态。（题外话：自修改一般是脱壳用的，小游戏用不上。）而且她说的那些话，其实都不是“她”说的，而是作者借“她”的口说的，体现的实际上是作者的意志。 当一开始 Monika 说如果你觉得抑郁，应该不要害怕向心理专家求助的时候，我还认为 Monika:Dan（作者）=1:1。然后她继续说，如果你觉得网络浪费了你太多时间，可以考虑关闭社交媒体；如果你见到抑郁的人请给予鼓励，同时你在玩也说明有人在给予你支持；有粉丝建立了一个 Twitter 账号 @lilmonix3（这段文本大概是更新之后加入的），现在“她”在用；喜欢的恐怖（小说文本）是那种细微的、在观众/读者思维中刻下“好像有什么和正常的事物不一样”的恐怖。到这里我就开始觉得，Monika:Dan 越来越小了，后面的很可能都是明显的作者的话了。 我就猜到了，结合之前 Monika 的提示，为了进行到下一个阶段，听到 Your Reality，必须要删除 characters/monika.chr。这时我其实是不愿意的，但是在外界因素（时间）的作用下，我只有一种选择。另一种选择，慢慢将所有的选项磨完（我没看这一段的脚本），或许是可以的，但是代价我负担不起。删除之后 Monika 的反应是“你为什么要这样……我知道了，我自己消失，成全你”。这也是我整个游戏过程中唯一确实感到了内疚（而不再以玩弄万物的“神”的视角来看游戏）的部分，嘴里不断默念着“Sorry, Monika”。 可能对于我来说，这仍然是游戏世界，所以可以自在地操控。当现实也出现这样的事，而我不再是“神”的时候，大概才会体会到现在那些玩家所体会到的震惊、困惑和无力吧。 当 Sayori 告白的时候，我选的是“好朋友一辈子”。没错，我想都没想，直接发卡了。我说过，攻略目标只有一个，就是 Monika。我并不想去费劲收集 CG 达成网上所说的“真结局”。我只想有一条 Monika 线，选其他的角色则跟原来一样meta，选 Monika 则进入一个“正常”结局，然后幸福地生活在一起什么的。然而没有，唉。 从 Monika 空间中，Monika 的话里，可以看出作者希望玩家认识、关注抑郁症和抑郁症患者。我也希望读到这篇文章的你能这么做。学会分辨、理解和包容（不是纵容）脆弱的精神，给予适当的关心。虽然在你眼中，事情可能不值一提，但是对一些人来说就是天大的压力。你甚至可能无法理解或者认同抑郁的原因，所以需要倾听，需要（建立在理智基础上的）同情心和同理心。这能力因人而异，抑郁原因因人因事而异，也无法用文字来描述或者教导，所以只能寄希望于每个人的“悟性”了。 我希望各位这么做，怎么说呢，因为我也被击垮过一次。我算是从深渊回来的人。博客断更与这有一定关系。甚至可以认为，它会影响我之后的几年。我写了一篇（或者说两篇）描述整件事的文章，但是不确定是否应该公开发表。如果将来我什么时候发表了，那么各位也就能看到了。同样地，各位或许觉得诱因“不值一提”，但连锁反应发生后混乱的、真正可怕的、绝望的体验，我仍然记得，只是无法用语言描述。肉体的痛苦对我来说还不算什么（可能是因为我只是受过伤，没有缺胳膊少腿），但是精神的痛苦是持续的、逐渐摧毁意志的，可能是因为悲观的天性吧。所以我认为，我能些许理解这些人的感受。我不希望有（意志力薄弱的）人再次经历这个体验。 类似的目的，另外一个值得提的是《去月球》（To The Moon）。它关注的是阿斯伯格综合征（Asperger Syndrome，现在被归类到自闭症谱系中）。不过它的主题揭示得就更明显一些，因为 River 就是一名患者，游戏直接提到了；游戏过程中展现了典型症状，也展示了缓解措施（骑马）。 相比于以 River 的特殊情况为核心的 TTM，我并不理解为什么 DDLC 要提及抑郁症。也许是为了疏解因游戏内容而产生的抑郁和 PTSD？ 其实 DDLC 可以更meta一点的。除了硬核的自修改/数据本体修改外，还可以用过程生成（procedural generation），或者更复杂的修改检测和剧情逻辑。不过对于小游戏来说，不需要为我这种不合常理的1%玩家投入这么高的成本。 最后两个稍微放松心情的东西。 在二周目写诗的时候，如果选的词不是给 Natsuki 或 Yuri 的（她们不做出反应），有一定概率可以见到左下角 Monika 从超出窗口范围的地方跳起来，露出一点点头。当然，要见到二头身版的话，制作名单里就有。 Hej, hej Monika, hej på dig Monika（B站） Every day, I imagine a future where I can be with you In my hand is a pen that will write a poem of me and you The ink flows down into a dark puddle Just move your hand - write the way into his heart! But in this world of infinite choices What will it take just to find that special day? What will it take just to find that special day? Have I found everybody a fun assignment to do today? When you&#39;re here, everything that we do is fun for them anyway When I can&#39;t even read my own feelings What good are words when a smile says it all? And if this world won&#39;t write me an ending What will it take just for me to have it all? Does my pen only write bitter words for those who are dear to me? Is it love if I take you, or is it love if I set you free? The ink flows down into a dark puddle How can I write love into reality? If I can&#39;t hear the sound of your heartbeat What do you call love in your reality? And in your reality, if I don&#39;t know how to love you I&#39;ll leave you be What have the artists said about the song? In his panel about discussing the game at Crunchyroll Expo 2018, Dan Salvato wanted to make the ending song to feel as a complete package for the game, as there were no “satisfying ending” for the game to let the audience and players accept that there will no happiness for everybody in the game is the reality. In terms of story, Salvato wanted the song to be as much as a closure for the game, for the overall plot, and for expressing Monika’s feelings. In terms of the song’s creation, he wanted to create an ending theme that would be emotional and impactful, similar to the video game Portal’s ending theme “Still Alive”. With keeping on the idea of making simple music melodies, Salvato drew inspiration from Regina Spektor’s “Folding Chair” to create the basic chord progressions for “Your Reality”. 来源：https://genius.com/Team-salvato-your-reality-lyrics 怪不得我说这么熟悉。Still Alive 的感情基调和编曲思路，加上 Folding Chair 的和弦进行啊。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"心跳文学部","slug":"心跳文学部","permalink":"https://blog.mottomo.moe/tags/%E5%BF%83%E8%B7%B3%E6%96%87%E5%AD%A6%E9%83%A8/"},{"name":"游戏杂谈","slug":"游戏杂谈","permalink":"https://blog.mottomo.moe/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"}]},{"title":"准备恢复更新","slug":"zh/2018-09-01-New-Updates","date":"2018-09-01T08:42:00.000Z","updated":"2020-03-30T22:34:35.449Z","comments":true,"path":"categories/Misc/zh/2018-09-01-New-Updates/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-09-01-New-Updates/","excerpt":"","text":"因为这7个月（或许可以说是一年多）以来的种种事情，虽然有一些破碎的文字，但是没有写文章的动力，所以博客更新断了很多。雪球滚到后面，甚至都不想再打开来写了。 到现在情况稳定了一些。所以决定继续更新，并尽量将之前只有些许句子的东西写完。发布时间将仍然按照记录的时间，所以可能之后见到的一些更新是来自今年二月、三月等等的文章，首页可能就没太大的变化。还是 RSS 好啊。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"小事","slug":"zh/2018-08-20-Misc","date":"2018-08-20T09:10:00.000Z","updated":"2020-03-30T22:34:35.449Z","comments":true,"path":"categories/Misc/zh/2018-08-20-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-08-20-Misc/","excerpt":"今天在北京遇见的三件事。从中大概能瞥见一丝市井百态。","text":"今天在北京遇见的三件事。从中大概能瞥见一丝市井百态。 出租车司机的故事。 虽然举行了一次小型的同学聚会，但我是去北京办事的。 我原来就计划了地铁+步行的线路。不过出发的时候就已经掐着时间了。快走到地铁站的时候，发现有东西忘了拿，所以急忙跑回去。再坐地铁肯定是来不及的，那怎么办呢？打的吧。 路边基本都为了自行车道而设了栅栏，所以很难找到合适的位置。现在国内用得多的都是顺风车或者专车了，所以感觉出租车没有几年前本科在北京的时候那么好打了。最后总算在地铁口旁边找到一段看起来车流量较大，也容易停靠的地儿，拦下了一辆。 司机是一个壮实的天津汉子。我不擅长说话，所以最初的两分钟谁也没开口。不过就见他在车流中穿梭，驾轻就熟；“驾风”（如果以写文章作类比的话，就是文风吧）很犀利凶猛，大开大合。当时二环开始堵了，并稍微影响了我们上二环之前的道路。他看到其他的车道都开始拥塞了，就把车开上了公交专用道（上面写着是高峰时段专用，不过当时不是高峰时段）。我虽然心里着急赶时间啊，但是这种行为还是做不出来的，就说，师傅，不用这么着急。他说没什么，反正也不违规，他们不走这道是他们的事。从这里开始话匣子就打开了。 他说，开出租车要向公交车学习。为什么呢？公交车司机开一套路线，时间长得早就已经摸清了哪些路段在什么时候路况如何，（为了达到最高效率）在站和站之间走什么路，什么时候该变道，速度该开多快。于是我就问，听您说得这么熟悉，您也应该学到了这门本事吧。他说，差得远呢，不过每条路的“脾性”倒是略知一二。“毕竟到今年，我在北京开出租车已经开了15年了。”“那您之前是……？”“我之前是给领导开车的。”接着他就开始讲他以前的经历。 原来，在九十年代，他就出来做私人司机。当官员的司机可是一门很“讲究”的活儿。为什么呢？因为在接送的路上，乘客——也就是雇主官员，会在有意无意地透露出一些表面之下的消息。要不就是打电话，要不就是直接跟司机谈话。若是跟司机谈话，就会说起官场和天下之事，或者咨询（某种意义上也可以称之为考验）工作生活中遇到的问题。这司机要是机灵点（“这人可以用”），就有可能得到官员的赏识；要是不怎么机灵，比如智商、情商不够，那么多半过不了多久就会被解雇，毕竟这吃香的工作可是有不少人眼馋着呢。长此以往，被“筛选”出来的司机，除了为人处世得非常圆滑，还自然而然地掌握了官员的一些把柄。因此，司机也会被当做家人一般地看待，一方面是给予物质上的优待，收买人心，另一方面也是为了封口。当然，当司机可不仅仅是司机。由于司机基本上就只是为雇主服务，所以更像是被当做保姆使唤。接送家人（和小三，如果有）上下班/学，日常买菜买日用品，看到官员母亲咳嗽赶紧送到医院，都是基本功。当然这样累死累活的，也不是没有好处，只是需要熬出头。北京某厅长的司机，做了数年，深受赏识，被安排了个公安分局的局长（还是副局长来着）当，当着快活。二者就惺惺相惜，不仅是因为过去的关系，更是因为都对对方都知根知底。一方提拔有恩，另一方又知道内幕，形成了互相牵制的态势。 后来这位天津老哥为什么不做了呢？一部分原因是因为他洁身自好，虽然还吃得开，但是本来就不喜欢这个乌烟瘴气。最直接的动机是一次出差。雇他的领导带着几位小三去外地出差四五天，作为司机他当然得开车带着。但是这几天住还得跟着他们住啊（因为要短途接送），又不能自己跑回来。在这个时候他已经娶了媳妇（“又不是领导安排给的，怕啥”），她又是个暴脾气，就很不放心——你想想，两个男人，和几个女人，在外面好几天。过了不久，两人一合计，就把这个私人司机的工作给辞了。于是他改做出租车司机。 “一定要小心这种陷阱，万万不能贪图些啥把自己栽进去。”他说。 后来一路无话。 从这个故事中我也大致印证了玩政治的原理，就是组成利益集团。在组成的过程中，拿捏所在位置能提供的利益、实际提供的利益和提供利益造成的把柄（无论掌握的人是否处于利益集团内），是一项微妙的技能。同时由于这个链条图有传递性，所以一旦出现了一个老鼠屎，那么集团内的所有人很容易都变成老鼠屎；不变的人会在变的人处于优势时被尽快清除出这个集团。而夹在集团之间的人，没有太多力量，日子是最不好过的，所以大家会避免落到这样的境地。 同时我也知道了，在我很向往的“小时候”、中国信息技术拓荒的年代、这70年来中国经济发展速度最快的时候，底下仍旧容着千百年来同一滩死水。 可是我也不喜欢这一套。但或许这就是人性中恶心的一部分。 他没有改变什么。可能是因为他没想到过去改变什么，也可能是他也没法改变什么。 搬家工人的故事。 朋友租的公寓位于东城区和朝阳区的边界上。这里楼房还是六七十年代的水泥箱子，也就是五六层的样子。但不仅外表，内在也并没有显示出多少朝气，处在居住和拆迁之间，衰败的气息都溢出了。但正因为如此，这里的房租才会低一些，虽然离地理意义上的“市中心”比较近。 在回来的时候经过一个这条街上比较繁华的十字路口。这个路口的一角有一家大型超市。而在路口的西边，停着一些小面包、三轮、小吃摊的手推车。在这里等待和歇息的人并没有多余的肉。 我经过的时候是中午，刚好碰上有一个搬家师傅，看上去是和媳妇一起干活的，有一辆小面包，体格结实。他在往地上放一块木质棋盘。与这个棋盘相称的，不是啤酒盖大小的小棋子，而是直径和一个乒乓球相当的、厚实的大棋子。坐在他对面的是另一个搬家师傅，精瘦。开面包车的师傅拿出两个小板凳；两人坐定。书上说的“在路边看人下棋”，我以前可是一次都没试过。所以我停了下来，站在一边观战。我注意到，（直到结束）加入围观的人只有三四个，而且除了我，都是四五十岁的农民工模样。 开战了。结实的师傅执红，精瘦的师傅执黑。开始的几手红黑双方都是毫不犹豫，迅速出招。寥寥数手，就已经一边丢了一匹马，一边丢了一架炮。移动和吃子的时候，棋子和棋盘磕得啪啪响。落子时还嚷嚷。“我吃你马！”“换子啊！好啊，换就换！”这并不“文雅”，却也不“俗”。 这时候双方陷入消耗战。红黑都在相互试探，试图打穿对方的防守；对方也在迂回，伺机反击。虽然一次次的攻防都不是很激烈，时常还是换子，但是随着时间推移，战局不知不觉进入了尾声。红方略占优势，士相全，仍有一车二马，四个兵；黑方缺一象，有一马一炮，三个卒。 这个时候精瘦师傅的手机响了。他掏出手机来，跟话筒另一边的人说了几句，“那你到路口的时候再打电话通知我一声啊”，挂了电话。然后他向结实的师傅解释，这个客户本来约定了这个时间搬家，但是现在对方有事，得推迟。于是棋局继续。然而精瘦师傅出招不慎，被对方用一个车卡住了脖子。虽然他仍然想要用马和炮，加上士、相逼将，但是（据我看）走错了一步，差距拉得更大了。在车和马的追击之下，他陷入了步步被将的局面，招架已经很难，已经显出穷途末路的样子，根本无力反击。这会儿精瘦师傅落子的速度明显慢了下来，而结实师傅每次都早有准备。黑炮没了。又过了几个回合，结实师傅把精瘦师傅给将死了，车和帅锁住两条线，马和兵将军。 收拾棋子的时候我就提出了对刚才错误的一步的想法。反正离终局也不远，这时候的棋子布局大家都记得。但是结实师傅说，你这样也没用啊，只要将车架到什么什么位置，依然会败下阵来。由于我太久没下象棋了，虽然他指出了之后的几步，但是我思考已经跟不上了。所以我只好含糊答应了几声，但并没有真正模拟出来。 第二局。风水轮流转，这次结实师傅在我还没反应过来的时候就已经落败了，所以我并不记得这局大概是怎么样的。时间总共也没五分钟。 恰好这时候精瘦师傅的手机又响了。这次客户是真的快到了，所以他就起身开始准备前往。棋局结束了，围观的人，包括我，就散了。 一位小孩子的故事。 由于朋友租的公寓里的厨房处于事实上不用的状态（何等的惨状……），所以他们中午在公司解决，晚上都是出去吃。我也没办法，晚上就去附近的肯德基吃肥宅快乐餐。 我买了两份套餐，因为一份根本吃不饱，两份勉强。本来就这点的话我五六分钟就能解决，不过我恰巧听到有意思的对话，所以就放慢了速度，细嚼慢咽，装作一般人正常吃东西的样子。 在我斜对面的桌子，坐的是两位妇女，看上去都是三十来岁。一位比较……超重，从脸上看就是普通的肉乎，身材可是接近标准美国人。（后文就以“胖”“瘦”代称。）另一位比较正常。从她们的对话中我得知，这位胖阿姨有一个儿子，推测是四五岁。 胖：“小孩子长身体，要蛋白质嘛，我就特意去买了最贵的最高级的海参，做好了以后剁碎了加在饭里给他吃。但是他只是看了一眼，就直接说：‘不吃！’嫌这饭脏！第二天他爸把（海参末）加到面里，他还是不吃。最后还是他奶奶吃了。” 瘦：“哎哟这孩子怎么这样呢！” 胖：“还没完啊。小的时候他对鸡蛋过敏。后来长大了免疫力不是变强了吗，但是鸡蛋还是碰也不碰。……他一点都不吃肉。别的小朋友都喜欢吃麦当劳、肯德基，但他一点都不碰。” 瘦：“那他吃什么啊？” 胖：“他只吃素，只吃有限的几种蔬菜和水果。每天早上都是辣椒，中午是烙饼和大葱，晚上只吃白萝卜。……不光如此啊，就连水果，他也只吃苹果、桃子和□□（我没听清）。有一次我们一家去亲戚家摘樱桃。我说宝贝，这樱桃好吃，很甜的。他是看是我们自己（在亲戚家里）摘下来的才吃了几颗，给面子。要不然，他平时碰都不碰樱桃。……在幼儿园他也是不吃肉。老师也急了，中午就让他坐在中间吃饭，同学围成一圈看他吃饭，跟看戏一样，小朋友们看着都在笑。……我很喜欢吃零食，但怀他的时候就不敢乱吃东西，只吃素，所以他是胎里素。生他的时候我还担心他太瘦了。结果他出生的时候很健康，个头挺大的，重量中等偏上。虽然他只吃素，但是到现在也很健康……” 我就听到这里了。毕竟一我早就吃完了，二我还是不太喜欢干坐着，三我还得回去测试土豆的动作。这就当故事记录下来了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"麻辣土豆模型和动作提取：六、物理","slug":"zh/2018-08-07-MLTD-Dancing-6","date":"2018-08-07T01:12:00.000Z","updated":"2020-03-30T22:34:35.449Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-07-MLTD-Dancing-6/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-07-MLTD-Dancing-6/","excerpt":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 这篇文章讲一下土豆的物理。物理我没完全做好，但是至少做到了可以接受的程度。一些改进的想法我放到了代码注释中，有兴趣的人可以尝试实现一下。","text":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 这篇文章讲一下土豆的物理。物理我没完全做好，但是至少做到了可以接受的程度。一些改进的想法我放到了代码注释中，有兴趣的人可以尝试实现一下。 在每个身体和头的模型里，都有一个名为 xxx_sway 的 TextAsset。它里面就描述了这个模型的物理，包括 SwayManager、SwayCollider 和 SwayBone。我对 Unity 导入模型之后生成的 GameObject 不是很熟悉，所以不能下结论说土豆用的是什么样的物理系统。所以请忘记我在视频简介里说的“土豆用的不是 Unity 自带的物理系统”的话。不过，考虑到类似的工具是存在的，所以万代可能是自己做了一套。 上面不是关键的问题。关键的问题是，怎么把它转换成尽量和 MMD 兼容的东西？ MMD 使用的物理引擎是 Bullet，所以 PMX 支持三种碰撞体类型，分别是盒（box）、球（sphere）和胶囊（capsule）。还好，在土豆的物理数据中，大多数都是属于这三种类型的。如果忽略里面的一些参数，直接转换过去还是比较简单的。（不过我没做旋转的变换，所以胶囊都是沿着X/Y/Z轴方向的，如果是给 MMD 用的话，也就是做成 TDA 式，物理信息就是错误的。以后有空再说吧。）转换的同时要识别一下这些刚体属于哪个组，加上合适的非碰撞标志。还要注意的是，土豆的刚体的路径指的是其父关节。比如路径为 MODEL_00/BODY_SCALE/BASE/KOSHI/skrt_GP/skrt_F0 的 SwayBone，对应的骨骼就是 MODEL_00/BODY_SCALE/BASE/KOSHI/skrt_GP/skrt_F0（下一级是 MODEL_00/BODY_SCALE/BASE/KOSHI/skrt_GP/skrt_F0/skrt_F1）。这个刚体就该加在 skrt_F0 和 skrt_F1 之间。我一开始直接将刚体放在了对应名称的关节上，结果整个模型都软得不行，甚至会变成一滩水。这是典型的新手错误。 除了刚体，还需要加入一些铰链。铰链我就只在直接连接的刚体之间加了，比如头发的逐级连接。不过如果参考一些 MMD 的模型的话，应该在两根头发的同级刚体之间再加铰链。这跟我们上学期做的布料模型比较相似——当时我们只是加了结构弹簧，但实际上还有抗扭转弹簧（交叉位置的线性弹簧）和抗折叠弹簧（相邻三节点的角弹簧）。不过目前的简易方案已经能取得较为满意的效果，所以我就没去研究稍微复杂的铰链阵列了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"麻辣土豆模型和动作提取：五、表情和口型","slug":"zh/2018-08-06-MLTD-Dancing-5","date":"2018-08-06T13:33:00.000Z","updated":"2020-03-30T22:34:35.448Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-5/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-5/","excerpt":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 这篇文章里，我讲一下土豆的面部操控（表情和口型）。","text":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 这篇文章里，我讲一下土豆的面部操控（表情和口型）。 在做土豆表情之前，我不知道土豆是用什么方法实现的。但是，MMD 的我知道啊。在 PMD/PMX 中，有一种东西叫做 morph，其中就包括 vertex morph。（当然还有其他的 material morph、UV morph 等等。）MMD 就是调整了每个 morph 的比重，来实现骨骼之外的模型变化。比如 vertex morph，存储的是一个列表，指定了受其影响的顶点在这个 morph 的比重达到1的时候，所加上的偏移。比如，在默认的姿势下位置在 (1,2,3) 的点，应用了比重0.5的偏移 (2,3,4)，就会移动到新坐标 (2,3.5,5)。据此一个模型可以做出不同的表情和口型及它们的混合。 我怀疑 Unity 中也有类似的东西，但是我不知道叫什么。我觉得，模型的 asset bundle 里就应该包含这个信息。所以我启动调试器，逐个属性地查看读取的模型信息（当然，要看头而不是身体啦）。随后我发现，BlendShape 的数组不是空的，而且它们的名字看起来就是操控面部的预定义变化的。于是我去找了找，原来这是 Maya 里的技术，Unity 同样支持。在功能上，它就等价于 PMX 的 vertex morph。有了这个发现，之后的东西就简单了，因为就是两个等价的结构的互相转换。首先将这些 BlendShape 转换到 vertex morph，然后在 PMXEditor 中对它们进行测试，尽量找到对应的 MMD 常用面部控制名称，最后应用表情权重。 接下来就该看看是怎么动态控制的了。之前我探索过谱面所在的那个 scrobj_xxxxxx.unity3d，里面的 scenario 毫无疑问存放着表演数据。但是元素太多了，而且核心是个杂糅的结构体，经常出现字段共用。当时想，在无法看源代码的情况下，很难分离出不同类型的控制指令。这次我就对着 Blooming Star 的视频（因为只有一个人，干扰小，适合通过时间查找），先找出了控制口型的，然后是表情。其他我能肯定或者大概率是的一些类型也写在了代码中。口型还好办，对着歌词的时间看，就是直接设置为あ/い/う/え/お/ん或闭嘴。表情就麻烦一些，并不像 VMD 那样给出每个 morph 的权重，而是只有一个表情索引。也就是说，要先找出这个索引对应的是什么表情，然后再调出各个 morph 的权重，最后保存为表中的一个项。Blooming Star 还算简单，只有三种表情；其他的歌（和日常 commu）有更多的表情——至少有30种，而且受到 MV 摄像机限制，不是所有的都容易看到或者看清楚。不过这只是简单重复的工作，需要时间和耐心罢了。 表情的控制需要注意避免冲突。土豆的眨眼是和表情分离的，而有些表情需要闭眼（比如微笑）。所以一定要解决这个冲突，否则就要产生不合理的权重和诡异的表情了。（morph 的叠加只保证线性，权重归一化要自己保证。）口型也是如此，要注意口型变化的过渡时间。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"麻辣土豆模型和动作提取：四、摄像机","slug":"zh/2018-08-06-MLTD-Dancing-4","date":"2018-08-06T07:50:00.000Z","updated":"2020-03-30T22:34:35.448Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-4/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-4/","excerpt":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 这篇文章讲解土豆的摄像机数据。 10月更新：近日在测试玩具的时候，发现 Unity 是直接支持 F-Curve 的（见 KeyFrame 的文档），而且其构造函数已经清楚地说明了值的意义。是我孤陋寡闻了。","text":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 这篇文章讲解土豆的摄像机数据。 10月更新：近日在测试玩具的时候，发现 Unity 是直接支持 F-Curve 的（见 KeyFrame 的文档），而且其构造函数已经清楚地说明了值的意义。是我孤陋寡闻了。 首先要清楚的是，摄像机的平移和旋转和模型、动作的一样，都是适用于 Unity 坐标系的。 打开摄像机数据的 asset bundle，里面同样有四个 Imas.CharacterImasMotionAsset 实例 idl、apa、apg 和 cam。同时还有两个用于竖屏（从名字可以看出，tate=縦）的镜头。（由此可以推测，apa 和 apg 是用于 fever 的特写镜头的。） 接着又看到了熟悉的 Curve 数组。但是有点不一样的是，这里的 key_type 都是 FCurve。property_name 的字段意义太过简单就不讲了。那么 FCurve 类型的 Curve 该怎么插值呢？我一开始也是不知道的，所以谷歌了一下。从 Blender 的手册中我对F曲线有了一个直观的认识。 Although F-Curves are very similar to Bézier Curves, there are some important differences. For obvious reasons, a property represented by a Curve cannot have more than one value at a given time, hence: When you move a control point ahead of a control point that was previously ahead of the point that you are moving, the two control points switch their order in the edited curve, to avoid that the curve goes back in time. For the above reason, it is impossible to have a closed F-Curve. 从这段话中，我推测，F曲线就是（三次）贝塞尔曲线在满足时间条件下的特殊情况。 从手册页面中，我们还可以得到一个重要的信息。在 Blender 中，调整F曲线形状用的是控制点（或者直译为句柄，handle）；从几种调整方式中可以看出，每个值点一般有三个控制点。（Vector 明显是可以指定离散值然后自动计算的。）其中有一个明显是调整值，那么另外两个呢？根据已有的知识，每个三次贝塞尔曲线段有四个点（两个值点，两个控制点），也就是说在这一段中，每个值有两个点（一个值点，一个控制点）。所以到此我们就可以猜想，F曲线的另外两个点是切线斜率的控制点了，分别控制左边和右边的斜率。虽然从数学角度想，它们也可以用来控制曲率，但这违反直观操作的习惯，而 Blender 不是面向数学家的，所以最有可能是斜率。 接着我们来解读存储的数据。从曲线数据中我们可以看出一些规律。我们取出 Blooming Star 中的镜头数据。这段数据的属性如下：path=&quot;CamBase&quot;，property_type=General，property_name=focalLength，key_type=FCurve。 [0] float data = 0 [1] float data = 35.19532 [2] float data = ∞ [3] float data = 0 [4] float data = 5.666667 [5] float data = 35.19532 [6] float data = 0 [7] float data = ∞ [8] float data = 5.683333 [9] float data = 64.44691 [10] float data = ∞ [11] float data = -6.156005 首先，从数字的大小和增减幅度来看，有几个数字（第0、4、8个）很可能表示的是时间。如果如此的话，那这四些数据可能就是四个数字为一组的了。这个曲线用于焦距的插值，常用的焦距，以 35 mm 镜头为例，在 35 mm 到 60 mm 左右；焦距再小就是拍广角，再大就是拍远距离特写。第1、5、7个数据的范围就大致在这个区间，所以它们可能就是表示曲线该点的值（表示位置的时候就是坐标，以此类推）。那么剩下的两个呢？根据上面的预备知识，可以推测是左边和右边的斜率。合理性？观察一下，数字2（可能是第一个点的左斜率）是无穷，斜率无穷可以表示不存在，也就是这个点是不连续的。之后右斜率为0，下一个点左为0右不存在，再下一个左不存在右为-6.15。连续性匹配了，而且这些斜率（和标准视频）对比一下还挺合理的。因此就应该是左右斜率没错。 你可能要问，如果是真的不连续，那么两个相邻的曲线点的时间应该是一样的啊。不过你仔细看一下，5.666667和5.683333，考虑到单精度浮点数的精度，相差正好是\\frac{1}{60}，这就是上一帧和下一帧嘛。 含义问题解决了，现在来看看怎么插值。我们有的数据是斜率，那么怎么找到两个控制点呢？从一份讲义（第26页）上可以知道，三次贝塞尔曲线（b_{0}、b_{1}、b_{2}、b_{3}）两端的斜率（也就是在该点的左/右导数）分别是 3(b_{1}-b_{0}) 和 3(b_{3}-b_{2})。这样控制点就很容易算出来了……等等，知道了斜率，还需要知道长度才能计算控制点位置。经过实验，我发现这个长度不是常数，应该是与区间长度（时间）有关。最后取的长度是 \\frac{1}{3}(t_{2}-t_{1})。 土豆的摄像机和 MMD 的略有不同。定位方式是小问题，前者用的是 eye+target，后者用的是 eye+orientation。最大的问题和身体动作一样，土豆的各属性插值曲线是独立的，MMD 又㕛叒叕是合在一起的。所以还是老方法，逐帧计算。在转换的过程中可能还有额外的变换（估计是因为我用 OpenTK），详见代码。结果可能还有一两个小错误，有时间再推敲一下？ 需要注意的是，VMD 只支持整数 FOV，而逐帧计算必然会用到浮点 FOV，所以镜头导出到 VMD 不是一个好的选择。MVD（MMM 用的改进的 VMD）支持浮点 FOV，所以我默认选择生成的是 MVD。所以如果想看土豆的镜头，只能用 MMM 而不能用 MMD。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"麻辣土豆模型和动作提取：三、与 MMD 的兼容","slug":"zh/2018-08-05-MLTD-Dancing-3","date":"2018-08-05T00:03:00.000Z","updated":"2020-03-30T22:34:35.448Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-05-MLTD-Dancing-3/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-05-MLTD-Dancing-3/","excerpt":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 有了前两篇文章打下的基础，终于到了最重要的一个部分，就是动作数据在两套骨骼之间的变换。 这里要特别感谢丧丝，他在转换烧笋（CGSS）到 PES（实况足球）的时候想出了这个方法的大概，不过“还是很模糊，不知道是怎么做出来的”。我不过是将其证明了而已。方法的核心也是非常之简单。 后面讲土豆骨骼和 MMD 骨骼的异同，以及如何（与 TDA 式）做到较好的兼容。这部分其实不看也行，如果你比较熟悉 MMD 的话。比如标准 T-pose 变换为其他样式的初始姿态（比如 TDA 的±34°），这一步也可以通过 PMX Editor 搞定，不过我还是想程序一步到位。反正我不熟，所以大致地讲一些经验，能有原理就最好。 对了，还有 IK。","text":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 有了前两篇文章打下的基础，终于到了最重要的一个部分，就是动作数据在两套骨骼之间的变换。 这里要特别感谢丧丝，他在转换烧笋（CGSS）到 PES（实况足球）的时候想出了这个方法的大概，不过“还是很模糊，不知道是怎么做出来的”。我不过是将其证明了而已。方法的核心也是非常之简单。 后面讲土豆骨骼和 MMD 骨骼的异同，以及如何（与 TDA 式）做到较好的兼容。这部分其实不看也行，如果你比较熟悉 MMD 的话。比如标准 T-pose 变换为其他样式的初始姿态（比如 TDA 的±34°），这一步也可以通过 PMX Editor 搞定，不过我还是想程序一步到位。反正我不熟，所以大致地讲一些经验，能有原理就最好。 对了，还有 IK。 这个方法的核心思路如下。 首先考虑两副关节初始姿态不同，而外形完全一致的骨骼。什么意思呢？就是每个关节的世界坐标都一样，但是关节自身的变换可能不同。此处记为 \\mathbf{M_{aw}}(0) 和 \\mathbf{M_{bw}}(0)。接着考虑模型上的一个点，其初始位置为（向量）\\mathbf{P}(0)，在动画过程中的某个姿势下，经过骨骼变换之后变换到了 \\mathbf{P}(t)。那么这个变换就是 \\mathbf{P}(t) = \\mathbf{M}(t) \\times \\mathbf{P}(0)，其中 \\mathbf{M}(t) 是总的变换矩阵。 变换过程是怎么样的呢？比如受到 \\mathbf{M_{a}} 影响的点，新的局部变换矩阵为 \\mathbf{M_{a}}(t)，其亲变换矩阵（亲关节到世界）为 \\mathbf{M_{ap}}(t)，那么就可以知道 \\mathbf{M}(t) = \\mathbf{M_{ap}}(t) \\times \\mathbf{M_{a}}(t) \\times \\mathbf{M_{aw}}(0)^{-1}。它的意义很好理解：首先将静态模型上的点通过 \\mathbf{M_{aw}}(0) 的逆矩阵变换到该关节的初始局部坐标系，然后应用局部坐标系的变化（注意此时坐标系就到了亲关节的坐标系了），最后从当前亲关节的坐标系变换到世界坐标系。 同理，对于 \\mathbf{M_{b}} 也有 \\mathbf{M}(t) = \\mathbf{M_{bp}}(t) \\times \\mathbf{M_{b}}(t) \\times \\mathbf{M_{bw}}(0)^{-1}。注意到这是对同一个点的变换，原位置（\\mathbf{P}(0)）和新位置（\\mathbf{P}(t)）都相同。从而我们可以知道，这两个变换矩阵是完全相同的。所以就有 \\mathbf{M_{ap}}(t) \\times \\mathbf{M_{a}}(t) \\times \\mathbf{M_{aw}}(0)^{-1} = \\mathbf{M_{bp}}(t) \\times \\mathbf{M_{b}}(t) \\times \\mathbf{M_{bw}}(0)^{-1}。 现在来整理一下已知量和未知量。假设 A 系列是土豆自己的骨骼和动画信息，而 B 系列是 MMD 的骨骼和动画信息。显然 \\mathbf{M_{aw}}(0) 、\\mathbf{M_{a}}(t) 和 \\mathbf{M_{ap}}(t) 都是已知的。MMD 的所有关节初始变换都是默认值，也就是位移 \\mathbf{t} = (0,0,0)，旋转 \\mathbf{q} = (0,0,0,1)，缩放 \\mathbf{s} = (1,1,1)。所以 \\mathbf{M_{bw}}(0) 也是已知的（= \\mathbf{I}）。同时，如果逐级求解，求解一个关节时其亲关节的变换一定已经计算完成，所以 \\mathbf{M_{bp}}(t) 也是已知的。那么我们要求的就是 \\mathbf{M_{b}}(t)，这正好是 VMD 中必需的信息，同时也是未知量。 \\mathbf{M_{b}}(t) 很容易就能解出：移项可得 \\mathbf{M_{b}}(t) = \\mathbf{M_{bp}}(t)^{-1} \\times \\mathbf{M_{ap}}(t) \\times \\mathbf{M_{a}}(t) \\times \\mathbf{M_{aw}}(0)^{-1} \\times \\mathbf{M_{bw}}(0)。 看，这个方法（丧丝称之为“求解逆变换”）的数学原理就是这么简单。它适用于一套动作数据在任何两副初始姿态不同而外形一致的骨骼之间的变换。当然，动画数据要适合其中一副骨骼。 土豆的骨骼层级（hierarchy）和 MMD 常用的骨骼不太一样。同时，它们的关节作用也不太一样。这就导致二者之间兼容是比较困难的。在 MMD 中，模型的移动方式是控制“センター ”的位置；在土豆中，是控制“MODEL_00”的位置。但如果以此为基准，下面就对不上号了，因为 MMD 的旋转以“腰”为基准点，而土豆是“MODEL_00/BODY_SCALE/BASE”。从层级上来看，它们之间产生了错位。所以只好采用不同的映射，并自动生成 MMD 的几个关节。我将两个映射表都放入了代码中。 还有一个问题是二者的初始姿态不同。土豆的动画是以双手平举为基准的，而 TDA 式是以向斜下（34°）为基准的。这也体现在二者的默认骨骼和刚体上，打开 PMXEditor 就能看得很清楚。动画错误的话，差异还是比较明显的，可以比较索引中的 IK 测试和动作修正两个视频。所以为了让土豆的模型使用 MMD 的动作，必须要调整手臂的旋转。这一步我目前是用代码完成的，不过手工也比较简单，在 PMXEditor 中修改保存即可。 最后，MMD 中大量使用了 IK，而土豆的模型是没有 IK 关节的。怎么办呢？生成呗。原理还是很简单的，对着模型照猫画虎，找规律就行了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"麻辣土豆模型和动作提取：二、身体动作","slug":"zh/2018-08-04-MLTD-Dancing-2","date":"2018-08-04T07:22:00.000Z","updated":"2020-03-30T22:34:35.447Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-04-MLTD-Dancing-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-04-MLTD-Dancing-2/","excerpt":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 在这篇文章里，我讲一下土豆的身体动作数据。","text":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 在这篇文章里，我讲一下土豆的身体动作数据。 这里先我简单说一下我用的工具。以前我为了读取土豆的谱面，写了个 MonoBehaviour（在 Unity 中使用时，实际上是继承自 ScriptableObject 的类）的反序列化工具，因此读取动作数据也是十分的简单。我这玩意儿比 Unity 自身的要方便一些。Unity 反序列化 ScriptableObject 用的是 AssetBundle.LoadAsset&lt;T&gt;() 方法，其泛型参数指定的就是对应 ScriptableObject 的真实（运行时）类型。（怎么看呢？去看 MonoScript，从那里面推断正确的类的完全限定名。）我的玩意儿比 Unity 好用一些。首先它不严格验证要反序列化的类型的全名，而如果这个名称与 asset bundle 中记录的名称不同，Unity 就会拒绝反序列化（返回 null）。其次 Unity 的反序列化只能作用于字段（带有 SerializableAttribute 修饰的那些），我这玩意儿可以用于字段或属性，只要是指定的名称。第三我这玩意儿还支持一些高级功能，比如重命名字段、自定义命名风格、自定义类型转换、自定义缺省值设置策略等等。它的速度自然是要比 Unity 的要慢一些，不过这没什么太大要求嘛。 总之，根据出现了的信息写出对应的实体类，加上合适的特性（attribute），马上就能反序列化出来。 接下来我们看看总体结构。首先，一个动作数据的 asset bundle 里有四个同样的实例，分别是 apa、apg、idl 和 dan，类型都是 Imas.CharacterImasMotionAsset。从名字上就可以看出，idl 是 idle，dan 是 dancing，作用也就如字面意思。不过我还没理解 apa 和 apg 是什么。 下面我们看实体类的信息。就从最常用的，也是我们首要目标的 dan 下手。可以看到，动作数据的基本单元是 Curve，它有 path、attribs 和 values 三个字段。path 和 values 的意义都非常明显；不理解的话，去看它们的值。稍微非常规一点的就是 attribs，明显指定了这个曲线的属性。不过它的设计也很蛋疼，用了一个字符串数组去存储各个属性的键值对。先不这么吹毛求疵，看看它的值。在动作数据中，键值对有两个，一个是 property_type，一个是 key_type。前者很好理解。后者看看取值范围，它是一个枚举，在文件中出现的有 Const、Discreate（笑）和 FullFrame。这三种其实都不麻烦，非常直白，一看就懂。稍微有点额外信息的是 FullFrame，从歌曲的总时间和其元素数可以推断出，土豆的动画帧率标准是 60 fps。 如果你仔细看的话，会发现 path 是形如“MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2/SAKOTSU_L/KATA_L/UDE_L/TE_L/OYA3_L”的字符串。其实我在研究土豆动画（非彼“动画”；所以说百万什么时候动画化呢？）的时候我是先从动作数据入手的，所以这样的字符串让我有了对土豆骨骼层级的第一印象，而不像 VMD 那样根本看不出。你可能要问了，为什么是这种格式呢？我一开始也以为只是万代的开发人员自己玩耍随便定的，但当我去用代码控制 Unity 的动画系统（Mecanim）之后，发现它原来就是 Mecanim 的记法。 在新版的 Mecanim 中，动画是预制的，用 Animator 控制。（从土豆的模型 bundle 来看，有 Animator，用的应该是新版。）我想播放自定义动画，然而并不知道 Animator 怎么去用（对不起，没经验）；不过传统的创建 AnimationClip 的方法还是能查到的。其中就有添加动画曲线的方法：AnimationClip.SetCurve(string path, Type animatedType, string property, AnimationCurve curve)。可以见到，第一个参数就是 path，它表示的是以模型为原点（&quot;&quot;），要控制的 GameObject 的相对路径。结合模型的层次关系，很容易就将它们对上号。所以从 CharacterImasMotionAsset 到 AnimationClip 的转换非常容易。 但是如果是自己的动画系统呢？我想了一个偷懒的办法，就是将所有的动画曲线展开，计算其在每一帧的值。不过这可能也不算偷懒。VMD 和 Mecanim 的曲线最大的不同在于，对于一个组合变量（比如四元数表示的旋转，由 X、Y、Z 和 W 组成），VMD 在设置关键帧时只能同时设置所有分量，而 Mecanim 则可以对每个分量单独设置。这就决定了，如果要求结果100%相同，必须要计算各个分量在所有帧的值，用离散模拟连续。毕竟视频是由离散的帧组成的，物理效果也是逐帧计算的，所以如果生成的动画序列将时间精确地分割到每个单元（也就是帧），就能获得和自动补间一样的结果。这个方法的最大问题在于，它生成的 VMD 关键帧非常多，一首2:20的歌在300万左右，MMD 根本无法处理（32位只能处理30万，64位60万），只能用 MMM。不过 MMM 倒是一点都不卡。之后还会碰到两个系统关键帧设定粒度不同带来的问题，那个以后再说。 8月27日追记：前些日子我改进了代码，大大减少了生成的关键帧数量（也减少了生成的文件大小），所以 MMD 理论上应该是可以处理的。不过由于 MMM 和 MMD 的坐标系不同，所以实际上 MMD 仍然无法使用生成的 VMD——导入之后整个人都变形了。可以通过再写代码修正，不过我懒得做了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"麻辣土豆模型和动作提取：一、模型和骨骼","slug":"zh/2018-08-03-MLTD-Dancing-1","date":"2018-08-03T09:13:00.000Z","updated":"2020-03-30T22:34:35.446Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing-1/","excerpt":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 在这篇文章里，我讲一下土豆的模型网格（mesh）和骨骼（skeleton）。虽然贴图是我后来才加上去的，不过考虑到叙述顺序，还是放到这里一起讲。","text":"系列目录 * “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 在这篇文章里，我讲一下土豆的模型网格（mesh）和骨骼（skeleton）。虽然贴图是我后来才加上去的，不过考虑到叙述顺序，还是放到这里一起讲。 读取模型的网格还是很简单的，Unity Studio 里有比较详细的代码。由于我的应用场景不同，自然要保留它的核心逻辑，调整接口。顶点所包含的信息包括位置、法向量、切向量和 UV。一些额外的信息还有“皮肤”表（见下文）和顶点索引。顶点和顶点索引就不用细讲了，对于会用 3D 图形引擎的这都是基础知识。我绘制选择的是 OpenTK，很快就把白模显示出来了。 麻烦的地方在于，OpenTK 是右手系（Y 轴朝上），而原始数据适用于 Unity（左手系，Y 轴朝上），之后还要放到 MMD（左手系，Y 轴朝上）中。平移的变换还是很容易推导的，X、Z 两次镜像即可。不过旋转，我就没用 OpenTK.Quaternion.FromEulerAngles() 算出过正确的值。后来在 Gist 上有人写了一段代码，我最终采用的是下面评论中的函数。虽然没有仔细去理解它的计算过程，不过既然能用那就先用着吧。 可以看到，每一个网格中一般都有数个子网格（submesh）。每个子网格对应了一种材质（material），每一种材质有一个 shader，同时最多有一个主要贴图（main texture）和次要贴图（sub texture）。子网格和材质的对应顺序就要去检索 MeshRenderer 了。顶点信息中包含了 UV，所以很容易就可以将贴图贴上。通用过程应该是，用子网格索引检索材质，从而检索使用的贴图，并自动导出和链接。在这个过程中，还可以自动除重。不过我为了简单（毕竟这些自动化流程可以以后再加），直接每一个子网格分配一张贴图，剩下的自己去尝试。所以每搞定一个模型的贴图需要花上那么十来分钟。 有意思的是，土豆的位置设置是，模型面朝 +Z 方向，摄像机面朝 -Z 方向。而我在 OpenTK 中想做的是也是如此；到了 MMD 中，就变成了模型朝 -Z 而摄像机朝 +Z。所以在转换到 MMD 坐标系的时候，实际上并不用另一轮变换。 土豆的动画使用了 Unity 的动画系统。可想而知，它的骨骼也使用了 Unity 的骨骼支持。骨骼在 Unity 中的表示形式就是 avatar（翻译成“形象”好像也不对味，就保留原文吧）。如果你用过 MMD4Mecanim，很可能会见过它。MMD4Mecanim 转换生成的骨架使用的是通用（generic）avatar；如果这其实是个人物模型，可以将 avatar 的类别改为类人（humanoid），这样在应用动画和物理计算的时候似乎效果会好那么一点。转换过程和类人骨骼的要求就不多说了，各位可以自己去做实验，同时也可以参考一下这个页面。在改变类别时，Unity 会自动识别对应节点的关节。 通过上次和杨彦君玩的简单 MMD 动画系统（这玩意儿到现在还漏洞百出呢，笑），我才理解，所谓“关节”其实就是一个变换矩阵（transform matrix），“皮肤”就是作用于顶点的矩阵和对应权重。这一切都是线性的，意味着可以进行矩阵加和（权重要先归一化），再进行变换。所以，在实际动画控制中，真正变化（animate）的，是平移、旋转和缩放的值。这个，在 Unity 中就是 Transform，包含平移、旋转和缩放。Transform 是依赖于 GameObject 的，所以每个 GameObject 有它自己的 Transform（GameObject.transform 属性）。同样的层级关系实际上保存在了两个地方：avatar 和各个 Transform 实例。骨骼的总体信息也保存在了两个地方，avatar 和 SkinnedMeshRenderer 实例。Transform 和 SkinnedMeshRenderer 都是借助了 asset bundle 内 asset preload data 的序列化，通过 PPtr&lt;T&gt; 的方式保存引用，从而相互链接的。 土豆的每个模型都分为身体和头部两块。（为什么？难道……将来可以随便换头吗？我的意思是，自己的动画系统中确实可以随便换，不过土豆是按照命名规则搜索的资源，所以实际上现在一加载就是正常的一对。）这两块都有自己的骨骼，不过根关节不同。身体的是 MODEL_00，头部的是 KUBI。在动画过程中，二者的运动是同步的。但是在动作数据（下一篇会讲到）中，并没有出现任何头部关节。所以这就是一个暗示，可以将两副骨骼拼接起来。在我的实现中，我改变了骨骼的层次，将 KUBI 设置为 MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2/KUBI 的子关节，同时将头（KUBI/ATAMA）的运动反馈给身体（MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2/KUBI/ATAMA）。经过如上的处理，这一套合并的骨骼既适用于土豆的动作，也适用于 VMD 的动作。至于土豆中是怎么实现的，考虑到 KUBI 的初始位置就是在身体的颈部（而不是原点），我猜是先计算身体，然后同步两套 Transform 的值吧。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"麻辣土豆模型和动作提取","slug":"zh/2018-08-03-MLTD-Dancing","date":"2018-08-03T04:27:00.000Z","updated":"2020-03-30T22:34:35.446Z","comments":true,"path":"categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/","excerpt":"","text":"* “土豆”指的是偶像大师百万现场剧场时光（ミリシタ/MLTD） 最近做了一点微小的工作，提取了土豆的模型和动作，并（可选地）转换到了 MMD 系的格式。为什么是 MMD 呢？虽然它的功能十分简陋，但是毕竟是当今最大的爱好者所使用的、较为开放的平台。 下面这个系列文章的目录。 一、模型和骨骼 二、身体动作 三、土豆与 MMD 动画信息的兼容 四、摄像机 五、表情和口型 六、物理（不完全） 以后可能做（做了以后找时间写）也可能鸽的： 七、高级 shader 八、场景 代码位于 GitHub。 我肯定不是第一个完成这事儿的人，因为早就有列表了。上面标称是“トレス”（trace，临摹），但那精度怎么看都像是直接提取的。还有，我前几天玩 VRChat 的时候，就发现有人把土豆的剧场都做进去了：入口、几个房间、舞台（甚至还有一周年的舞台！），一些模型（能看到有bba的限定泳装，说明是不久前弄的)。在游戏中搜索“iDOLM@STER”就能找到。因此我推测有一个十分便捷的工具或者方法，能将 asset bundle 里的模型整体地提取出来或者以其他方式使用，但是我还不知道。我没去 XeNTaX 看过，不过那地方高手云集，应该也有人做了。 我已经将工具公布了。我并不会像某位仁兄一样拿着别人的成果到国内某视频站上不加来源（我开始还以为是他自己完成的，结果我还没问他就自己爆料了还行），吊人胃口，然后在私人群里二次配布（无论有没有获得初次提取者的授权）。以上属于二级信源，并没有完全确认。我写这个系列有两个目的，一个是科普，另一个就是狠狠打脸。这些数据的版权万代肯定是不会下放的。所以各位也自己注意点。 相关测试视频： 花ざかりWeekend✿ 动作测试：验证提取的模型网格（白模）和身体动作数据 Blooming Star 动作测试：测试转换模型和动作到 MMD 体系 Blooming Star 动作/镜头测试：测试转换镜头到 MMD 体系 気まぐれメルシー IK 测试：测试自动生成 IK 骨，让 MLTD 模型可以使用一般的给 MMD 制作的动作 気まぐれメルシー 动作修正：修正 T-pose 差异 気まぐれメルシー 面部表情测试：测试转换模型包含的表情和口型模板到 MMD 体系 Blooming Star 表情/口型测试：测试播放提取自 MLTD 的表情和口型数据 Blooming Star 物理测试：测试根据 MLTD 的物理数据自动生成的 MMD 物理 自分REST@RT 综合测试：测试以上的各项在 MLTD 多人场景下的表现","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"ACGN","slug":"Tech/ACGN","permalink":"https://blog.mottomo.moe/categories/Tech/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"3D","slug":"3D","permalink":"https://blog.mottomo.moe/tags/3D/"}]},{"title":"小品曲名","slug":"zh/2018-05-28-Tasting-A-Song-Title","date":"2018-05-28T14:25:00.000Z","updated":"2020-03-30T22:34:35.446Z","comments":true,"path":"categories/Misc/zh/2018-05-28-Tasting-A-Song-Title/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-05-28-Tasting-A-Song-Title/","excerpt":"《超能力女儿》（ひなまつり）的ED，《鮭とイクラと893と娘》。附带一些科普和私货。","text":"《超能力女儿》（ひなまつり）的ED，《鮭とイクラと893と娘》。附带一些科普和私货。 曲子很好听，一下子就吸引了我，所以就收入了歌单。大概是因为我比较喜欢1980-2010这段时间的轻摇滚和流行风格的歌曲吧。 今天突然意识到了，这个标题非常有画面感，四个词就成了一幅画。虽然其中一个动词都没有，但是却写出了（可能的）场景、动作，联系作品内容又能大概猜到人物的神态。这在其他的OP/ED中并不多见。下面来讲一下这幅画的构成。 “893”指的是黑道（ヤクザ），或称“极道”（極道/ごくどう）。日语有独特的数字简称系统，这比汉语中网络用语的数字谐音要复杂。汉语由于每个字恒定为一个音节（但是有音调啊），而且数字中没有多音字，所以在无法准确读出原词的时候靠谐音解决，比如“94”（就是）、“555”（呜呜呜）。每个日语的单个汉字占用一个到多个音节。对于同一个汉字，根据所在的词语不同，有音读和训读；音节有清浊音。前二者构成了数字简称的基础，后者则提供了近音的变种。日语数字一般都有多个读音。比如偶像大师（读音梗成群，笑）的事务所名称： 事务所 读音 读音分解 读音来源 捏他 765 なむご なな/む/ご 音读、训读、音读 Namco/南梦宫 876 ばなむ はち/なな/む 音读、音读、训读 Bandai Namco/万代南梦宫 961 くろい く/ろく/いち 音读、音读、音读 黒井（其社长的姓） 346 みしろ み/し/ろく 训读、音读、音读 美城（其社长的姓；动画化时确定） 283 つばさ ツー/はち/さん 外来、音读、音读 翼（翅膀） 最近的《DARLING in the FRANXX》中，第13小队全员名称实际上都是这样构成的（见文章最后附表）。所以一听到名字，马上就知道其编号是多少，这种双关命名方式应该只会出现在日语语境中。我时不时会想，这种系统是否完全覆盖了五十音呢？好了离得有点远了。不过至少现在清楚这是一种数字简称，893=や/く/さん。这位“黑社会”也就是本作的男主黄毛啦。 “娘”（女儿），指的是ヒナ（汉字表记为“雏”），黄毛“收养”的女儿。这个视角是在外人看来的。傲娇黄毛认为她是一个累赘；但是身体还是很诚实的。嗯。所以不管黄毛你怎么说，就是女儿了。 接着是“イクラ”（鱼子酱）。这是雏最喜欢吃的东西。鱼子酱大家应该至少有点印象，知道这是一个相当昂贵高级的食材。抱歉，我一种都没尝过，所以没法提出个人的评价。雏喜欢吃这玩意儿，幸亏黄毛收入（嘛就认为是收入吧）比较高，要不也得吃穷了。（在此基础上，黄毛的经济水平还能扛过时常发生的高级罐子破碎事件，斯国一！） 最后是“鮭（さけ）”。一般我们会听说“三文鱼刺身”、“三文鱼寿司”之类的食品，这里的三文鱼（salmon、サーモン）是对这一类鱼中数种的通称的音译，属于鲑科、白鲑亚科。而鮭在汉语中则是指大马哈鱼，属于鲑科、鳟亚科。（最近不是出了一个“淡水三文鱼”、的令人啼笑皆非的新闻嘛，其实这事儿很早就有人在果壳科普过了。这里我就引用其中一句话：“其实‘淡水三文鱼’这个名词的组合本身就很怪异和滑稽，这绝不仅仅是翻译的问题，而是一个充满了商业利益的故事。”）回到正题，“鮭”和“サーモン”在日语中指的也不是同一种鱼： 鮭とは 鲑鱼是什么？ そもそも鮭と呼ばれている魚も、元はたくさんいる鱒の一種にすぎなかったそうです。そして、数ある鱒の種類の中で最も大きい魚が、「鮭」と呼ばれるように。つまり、鮭と鱒は同じ種類の魚なのですね。 说起来，被称为鲑的鱼，原来也不过是许多种鳟鱼的一种而已。然后，少数几种鳟鱼之中最大的鱼才被称作鲑。也就是说，鲑鱼和鳟鱼是同一种鱼。（注：这里指的是两种鱼属于一个大类，而不是生物学意义上的“同一个种”。） そして鮭とは、川で産卵して海に下る海水魚のことを言います。鮭は国産のものが多く、天然モノで加熱して食べるもののことを指すのだそうです。ちなみにスーパーで一般的に見かける鮭は、シロザケという種類であることが多いです。 然后，鲑鱼指的是在河流中产卵并洄游到海里的咸水鱼。鲑鱼多为日本产（注：大马哈鱼又称日本鲑鱼、白鲑），生肉要烹制后食用。顺便说一句，在超市里常见的鲑鱼，多为白鲑这种鱼。 サーモンとは 三文鱼是什么？ 次に、一般的にサーモンと呼ばれているものは、正式にはトラウトサーモンのことを指すそうです。トラウトとは鱒のことで、トラウトサーモンは鮭とは違ってニジマスなどと同じ淡水魚なのだとか。お寿司屋さんでサーモンを頼んだ時に出てくるのは、このトラウトサーモンです。 接着，一般被称为三文鱼的鱼，正式名称是“trout salmon”。“trout”是鳟鱼，不过“trout salmon”和“鮭”不同，而是和虹鳟等等鱼类一样是淡水鱼。你让做寿司的师傅做三文鱼寿司的话，做出的寿司用的就是这“trout salmon”。 サーモンは鮭と違って海外からの輸入品が多く、また鮭は生食することができず加熱してから食べますが、サーモンは生食できるという違いもあります。 三文鱼和“鮭”不同，前者多为进口。而且二者之间还有这样一个不同点：“鮭”不能生吃，必须要烹制后食用，三文鱼则可以生吃。 我并没有找到这个“trout salmon”是个什么东西。唯一相近的是“salmon trout”（见这里），指的是硬头鳟（steelhead，虹鳟的一个会洄游的亚种）。不过“salmon trout”的解释页面本身由海产公司提供，可信度多少就不知道了。 很明显地，这两种鱼的食用方法不同。如前面所说，三文鱼一般是切片生吃；而鲑鱼一般是经过烹制，比如烤、熏、炒，然后才食用。二者的价位也不一样，三文鱼更高档，售价更高；而鲑鱼产量大，价格较低，不过营养价值高，味道也不错，是相当亲民的选择。 说实话，看到鲑鱼（さけ）的时候，我自然地就想起了酒（さけ）。然而我不知道讲话时二者是怎么区分的，只是凭上下文吗？查了一下，说是根据重音的位置来区分，前者是さけ（重音在前，降调），后者是さけ（重音在后，升调）。这也解释了一个问题，就是我在 Japan Expo 上看到的，或是金人社搞的金人祭的说明文本中，清酒的写法都是“saké”（有变音记号，读法跟法语类似），而不是像一般词汇那样只用罗马字就可以了。烤鲑鱼是不错的下酒菜（大概是因为肉多、肥瘦交织、骨头少而大？），在《和歌子酒》（ワカコ酒）中就是第一个出现的。 所以想了这么多乱七八糟的玩意儿之后，我对这个标题的发生地第一印象就是在小酒馆里。但是你想啊，雏是未成年人，按照法律是不可以喝酒的。作为一个公开的作品，这个戒可是不能破的。那么就再想，还有什么地方呢？嗯，家里，或者是餐馆。家里是一个可能选项；不过餐馆……如果餐馆提供鱼子酱（作为配料）的话，那就是高级餐厅咯，跟这个作品的背景关系不大。要不然就是寿司店咯，鱼子寿司还是相对常见的，毕竟量少，也不需要做得像鱼子酱那么精致。 然后继续想。这个标题直译是“鲑鱼、鱼子酱、黑社会和女儿”。很明显，“女儿”和“鱼子酱”是一组，“黑社会”（黄毛）和“鲑鱼”是一组。这么一看，两边的档次就有那么一些差距了。大概只是因为黄毛是个粗人，习惯、也比较喜欢吃鲑鱼，而不是也品尝鱼子（酱）吧。情景这么看来就应该是在用餐。如果对作品内容由一些了解的话，就知道雏根本不知道鱼子酱是多么高级的东西，只知道很好吃；黄毛口嫌体正直，挺无奈但也喜欢这样的日常，这从歌词中也能看得出来： さぁ好きなだけ 食えよ 食えよ 遠慮はいらねぇさ 在末尾我们来看看专辑的封面。不出意外地用了人物分开两边占据分块“质心”的构图（我不是这个专业的，姑且这么描述吧）。嗯，是在寿司店。（而且可能是比较高档的？）然后看二人的互动：雏光顾着眼前的寿司了，而且全都是鱼子寿司ww——就跟狂欢一样（ヒナまつり，笑），黄毛在一边用某种眼神（慈爱也罢，破罐子破摔也罢——哈，我又玩了双关）看着。托腮的动作表明黄毛在无奈地等，同时还要自己冷静下来（要不直接直直地坐着就可以了）。托腮在人坐在无靠背的高凳子（寿司店标配）上的时候能将颈部以上的重量分配到手臂，再到桌面上，而不是全压在腰椎上，所以是一个比较舒服的姿势；采取这个姿势，就有两种可能：已经等了很久，或者知道要等很久。所以，再说一遍，黄毛你就是个傲娇。 图片中还有三个有意思的地方。第一个是对“娘”的注音“おんな”（女，女人），不放大我还真不知道，我之前直接就读むすめ了。这个可能是反映了黄毛对雏的表面想法（碍事的女人；用词？毕竟黄毛是个粗人）和旁观者的看到的（女儿）。第二个是两边（已经吃完的）盘子的高度。哇。而且盘子不是严格对齐的哦。第三个是雏吃寿司的方式，我们只看到了这个瞬间；这是往嘴里扔呢，还是从一开始就用她的超能力隔空取物呢？这就不得而知了。 标题里不是有四样吗？那么……鲑鱼呢？大概已经吃完了。 附：DitF 13小队角色表 中文译名 原文 读音分解 编号 备注 广 ヒロ ひと/ろく 016 02 ゼロツー - 002 数字直接作为名字（广你的想象力实在是不行啊） 莓 イチゴ いち/ご 015 五郎 ゴロー ご/ろく 056 未来 ミク み/く 390 纯位数 ゾロメ - 666 这孩子皮的，自己取的名，不走寻常路 心 ココロ ご/ご/ろく 556 太 フトシ ふた/ひと/し 214 第二个数字没用首音节（用了就无法组成常见名字），可怜的肥宅又做错了什么 郁乃 イクノ いち/く/ろく 196 因为第三音节“ろ”音无法组成常见的名字，所以莓取了音近的“の”，见剧情 满 ミツル み/ツー/ろく 326 和郁乃类似（应该吧，有点忘了；如果是的话取名的是广不是莓） 直美 ナオミ なな/おー/み 703 “0”按照呼号读“oh” 两位负责人“哈奇”和“娜娜”分别就是“八”（はち）和“七”（なな）的音译，他们的编号直接就成（非正式称呼用的）名字了。（论前十的优势.jpg）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"所谓人生的无限可能性","slug":"zh/2018-05-16-Potential","date":"2018-05-16T06:35:00.000Z","updated":"2020-03-30T22:34:35.446Z","comments":true,"path":"categories/Misc/zh/2018-05-16-Potential/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-05-16-Potential/","excerpt":"","text":"想象一下你能选择无限多条路，每一条都有无限多的岔路，但是主干道之间并不相交。所以一旦你选择了一条，比如说去多伦多的路，你仍然有无限多的选择，不过它们之中没有一条会通往芝加哥。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"MLTD 用了新的加密","slug":"zh/2018-01-18-MLTD","date":"2018-01-18T10:15:00.000Z","updated":"2020-03-30T22:34:35.445Z","comments":true,"path":"categories/Misc/zh/2018-01-18-MLTD/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-01-18-MLTD/","excerpt":"","text":"应该是好几个月之前了，MLTD 用了新的加密额外的混淆和保护（AppGuard；不过仍然被大佬脱壳了），这次会检测程序完整性。因此之前取密钥的方式（中间人）就不能用了。可能以后真得要去hook系统 API，dlopen 什么的，或者自建沙箱。 关于它的网络部分，我已经没精力去做了。对我来说，双线作战，还要还原 D2D1，还有 Vanishing，工作量已经不小。还有一些内部因素。应该不会像以前那样能用整个晚上来跟踪和分析 ARM 汇编了。仔细想想开的项目全是个人项目，而且有些相当硬核，开得越多战线越长，渐渐就被拖垮了。啊好像草菇的网络也好久没去维护了。总之已经退出了第一线数月。 然而我的兴趣不是在查询和计分上。我又不打分，别人打不打我无所谓。而且就为了在游戏中打出高分的假需求，集成现有的 API，这种活儿太无聊了。一般用户希望拿到的是一个好用的工具，比如app，这对于他们来说是最容易理解和使用的。不过我是想去开辟可能性的，开发用户应用的就踩着我的肩膀前进吧。哦对还有，我大概是老古董了，对智能手机有着本能的抗拒。 MilliSim 其实也逐渐成在往通用引擎上走，就跟 osu Framework 那样。但是我在尽量解耦，也一直在想 MilliSim 的意义是什么。从一开始对谱面的系统感兴趣，做来做去发现也就是那么一回事；现在逐渐又想看小姐姐跳舞了，而且就算是音游也会有相应的 BGA；于是又在想我为什么想看小姐姐跳舞，音游这个载体（是音游，自然前景要有谱面，和背景是什么关系呢）对我来说是不是过时了。这样下去会成艺术指导吗？变来变去什么时候是个头呢？ 可笑，虽然能把计算机系统看得很清楚，但是对未来和目标（假如是唯一的话）却根本看不见。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"使用 FFmpeg 在 MonoGame 中播放视频","slug":"zh/2018-01-18-Video-Playback-with-FFmpeg-and-MonoGame","date":"2018-01-17T21:16:00.000Z","updated":"2020-03-30T22:34:35.445Z","comments":true,"path":"categories/Tech/Coding/zh/2018-01-18-Video-Playback-with-FFmpeg-and-MonoGame/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-01-18-Video-Playback-with-FFmpeg-and-MonoGame/","excerpt":"这篇文章本来想复用以前的 FFmpeg+SDL2 以及 FFmpeg+OpenAL 两篇。但是所用的语言不同，所以设计有差异；FFmpeg 的 API 更新（用的是3.4，当前最新的版本）也要求使用新的 send/receive 解码模型。这次的代码是从零开始一步一步写的，比起以前没搞懂，凭着模糊的直觉复制粘贴去做的那两篇，算是有所长进。我终于敢说，整个流程弄清楚了。 这个工程的考虑就不只是网上的那些“简单的播放器”的那么一点了，我本来也没想把它做得多“简单”，只是写得尽量简明。目标是一个成熟、稳定的库，就得十分注意正确性、鲁棒性和效率。编写过程中也碰到了一些困难，所幸都解决了。 文章分为六个部分。第一部分讲基本概念；第二部分讲视音频解码；第三部分讲同步控制；第四部分讲解码输出；第五部分讲工程中用到的一些细节的设计思路；最后一个部分讲一些对比和想法和现状讨论。（原本放在首页的大段文字都放在了文章最后部分，不想让“摘要”看起来太乱。） 代码位于 GitHub。","text":"这篇文章本来想复用以前的 FFmpeg+SDL2 以及 FFmpeg+OpenAL 两篇。但是所用的语言不同，所以设计有差异；FFmpeg 的 API 更新（用的是3.4，当前最新的版本）也要求使用新的 send/receive 解码模型。这次的代码是从零开始一步一步写的，比起以前没搞懂，凭着模糊的直觉复制粘贴去做的那两篇，算是有所长进。我终于敢说，整个流程弄清楚了。 这个工程的考虑就不只是网上的那些“简单的播放器”的那么一点了，我本来也没想把它做得多“简单”，只是写得尽量简明。目标是一个成熟、稳定的库，就得十分注意正确性、鲁棒性和效率。编写过程中也碰到了一些困难，所幸都解决了。 文章分为六个部分。第一部分讲基本概念；第二部分讲视音频解码；第三部分讲同步控制；第四部分讲解码输出；第五部分讲工程中用到的一些细节的设计思路；最后一个部分讲一些对比和想法和现状讨论。（原本放在首页的大段文字都放在了文章最后部分，不想让“摘要”看起来太乱。） 代码位于 GitHub。 1、基本概念1.1 容器和流平常我们所谓的“音频文件”、“视频文件”，实际上都是容器（container）。一个容器可以包含一个或多个流（stream），流的种类有音频流、视频流、字幕流、数据流（如 Matroska 内嵌字体）等等。每个流使用一种编码，对应一种编解码器（codec）。关于什么容器支持什么流、什么编码的流，请自行学习。 1.2 DTS、PTS、I/P/B 帧其实这几个概念在这里已经讲得挺清楚的了，这里稍微概括一下。 DTS 是解码时间戳（decompression timestamp，虽然写着是 decompression，不过可以近似认为是 decoding；这个帧应该何时解码），PTS 是显示时间戳（presentation timestamp；这个帧该何时显示）。I 帧是关键帧，P 帧是单向插补帧（比如从前面的 I/P 帧，加上差异计算得到），B 帧是双向插补帧（加上前后的差异）。 DTS 和 PTS 并不一定是顺序相同的。上面的页面展示了一个例子，不过这个例子是有错的。虽然顺序可能不同，但是所有的流都保证，DTS≤PTS。这个说明也可以在 FFmpeg 的文档中见到。其实想想这是很直接的，一个帧必须先解码才能展示嘛。所以那个例子应该修正如下： PTS: 1 4 2 3 DTS: -2 -1 0 1 Stream: I P B B 注意 DTS 是可能有负的。不过这对于程序而言不是什么事。 1.3 包这个可能是 FFmpeg 特有的概念。设计的原因估计是考虑网络传输，将一个或多个帧作为一个整体，也就是一个包（packet）来传输。这样一次解码整个包，得到一个或多个帧，可以一定程度上起到缓冲的作用。 1.4 平面我曾经在 FFmpeg+OpenAL 那篇文章里有过疑惑，什么是“planar”。现在看来它的确是“平面”的意思。这个概念在像素/采样格式转换的时候会碰到。维基的解释其实已经挺明白了。 我们常用的 RGB 图像只有一个平面，而 YUV 则是典型的多平面的空间（3个平面）。所以在 sws_scale() 中的参数中可以见到两个数组，数据和步长，每个元素就是对应平面的值。音频中的多平面则对应复杂声道（5.1、7.1等等）的情况。 了解之后，才会明白为什么 sws_scale() 和 swr_resample() 的一些参数是数组，以及为什么输出缓冲区只需要一个元素（RGB 和普通双声道都只有一个平面）。 2、解码2.1 解码准备在解码之前，要做一些准备工作。 首先先调用 avformat_alloc_context() 创建一个 FormatContext。它相当于容器的上下文，用来访问容器信息和其中的流。接着调用 avformat_find_stream_info() 获取流信息，因为有的容器可能没有格式的头信息，而这个函数会尝试进行初步解码来探测这些信息。 然后遍历流（formatContext-&gt;streams），找其中可能的音频和视频流。找到符合条件的流的同时记录这个流的开始时间，之后输出的时候会用到。 2.2 解码模型在当前的 FFmpeg（FFmpeg 3.4.x）中，解码过程遵循这样一个模型： var packet = GetNextTypedPacket(); SendPacket(packet); var (frame, state) = ReceiveFrame(); if (Succeeded(state)) { StoreFrame(frame); } while (SucceededAndStillHaveFrames(state)) { (frame, state) = ReceiveFrame(); if (Succeeded(state)) { StoreFrame(frame); } } 以上是伪代码，而且省略了很多细节，比如错误处理、额外信息的处理、数据结构构造。不过单次解码的框架就是这样的了。 GetNextTypedPacket() 的逻辑是，不断调用 av_read_frame()，直到得到了一个对应的视频或音频包。其余的包存在队列中等待另一侧处理。接着使用 SendPacket()（avcodec_send_packet()）将这个包发送到后台（内存映射？管道？套接字？没研究）等待解码。 发送包后调用 ReceiveFrame()（avcodec_receive_frame()）接收一个解码完成的帧，然后将这个帧保存到临时队列中。由于一个包可能对应多个帧，所以要用一个循环来保证所有帧都接收。对于视频最后的若干帧，要按照 FFmpeg 文档所说的，要继续尝试直到返回 EOF，因为有的解码器会在其缓冲区保留一些帧。 还有要注意的是，发送完毕后，解码不是立即的。所以接收的时候仍然有可能会碰到错误，视频帧会收到-11（device not ready）。这个目前我忽略了这个错误，直接继续循环。 2.3 视频解码在整体的解码模型下，视频解码的特点每个解码完成的视频帧是独立、数据量较大、播放时间较长的。因此在保存视频帧的时候，要使用一个对象池来保存这些帧。概括起来就是发一次，收一次，存一次，多个活动缓冲区（就是对象池啦）。 2.4 音频解码同样应用解码模型。不过音频帧有点麻烦。包和视频帧一般是一对一的，但是音频帧一般是一对多的。要说视频解码的循环是保险用的话，音频解码的可就要千万注意了。而且单个音频帧数据量较小，解码时间短，播放时间很短，比视频帧更连续。由于我们要用 OpenAL 播放音频，我们得自己管理缓冲区。为了最大化利用缓冲区的容量，不能直接将单个音频帧的数据输送到缓冲区，而是要做准备整体发送。概括起来就是发一次，收多次，存多次，一个活动缓冲区。 2.5 清理每次解码包的时候要注意释放包的数据和减少引用。FFmpeg 内部维护了包的引用计数，所以如果要进行包的拷贝等操作，要特别注意对应的释放。帧视作不可改变，不过可重用，这个就要通过对象池来管理。最后要注意退出的时候释放所有的包和帧，再关闭各上下文。这些是挺基本的操作，不过处理不好的话容易引发内存泄漏，或抛出异常。 3、音视频同步在1.2节我们讲了 DTS 和 PTS。这两个值就是同步的核心。由于无法保证任何一个流的解码时间稳定性，同步基准由外部时钟（一个 Stopwatch）担任。 怎么保证顺序呢？自然是用队列了。 由于存在 P 帧和 B 帧，帧的先后变得非常重要。不过别忘了，在解码之前，我们是不知道帧的，只知道包。FFmpeg 中，每个包（AVPacket）有一个 dts 字段和一个 pts 字段。dts 保存的是解码时间戳，pts 是预计播放时间戳。解码后的帧（AVFrame）包含的则是 pts，实际播放时间戳。对于音频，两个 pts 的值一般是相同的；视频则可能有差异，因为它的 PTS 是重新计算了的。 我们首先要保证解码结果的正确。解码所用的是 DTS，所以在包入队的时候，要保证队列开始的包的 DTS 永远是最小的。这里就有个坑了。在实际的视频文件中，一个包和下一个包的 DTS 不一定是递增或递减的；但是在稍大一点的尺度（我称之为“块”，block）上，一个块中 DTS 最大的包的 DTS 一定小于下一个块中 DTS 最小的包的 DTS。所以，在数据结构上，我们要使用一个非标准队列。SortedList 就是一个合适的数据结构。当然，我实际上自己实现了一个 PacketQueue，不过现在看来 SortedList，用 dts 作为键，已经足够了。在此基础上，我们得时刻保证这个队列有一定量的元素（除了视频结束之前），否则出队的元素之间很可能变得不连续。数值上，必须要保证队列中的元素数大于一个块的最大元素数。这个值一般在10以内。 在一帧解码完成后，就要根据这个帧计算后的 PTS 进行入队和排序。同样地，可以使用 SortedList。 同步的逻辑很简单，就是将音频和视频帧输出，直到遇到 PTS 在当前时间之后的帧，停止并不输出这个帧。这样能保证准确性，因为有可能帧与帧之间的间隔很大，比如00:00一帧，00:05一帧，但是在00:02的时候就不应该看到00:05的那一帧，而是00:00的那一帧。这就需要保留（retain）输出了的最后一帧的内容。 4、输出同样地，设计针对视频和音频，会有不同。 4.1 视频输出画面本身就是不连续的，而我们在一个时间点只需要看到一帧，所以只需要输出同步时保留的最后一帧就可以了。如果接下来的解码没赶上，就继续输出这一帧。将这个帧使用 sws_scale() 缩放（和调整像素格式）后，将像素数据复制到 Texture2D 中就可以了。 4.2 音频输出音频是连续的，所以要将此次输出的最终帧前的所有帧的数据输出到一个 AudioBuffer，来保证最大化利用这个 AudioBuffer。然后将这个 AudioBuffer 提交到 AudioSource 的缓冲队列中。最后更新 AudioSource 的缓冲列表，标记可以重用的 AudioBuffer。AudioBuffer、AudioSource 等等是我对 OpenAL 的封装。和视频对应，音频有 swr_resample() 来转换采样率和采样格式。 稍微吐槽一下。网上讲 OpenAL 的文章很少，讲用已知数量的缓冲区播放大文件的有一篇，而讲到我这种从不确定的流中来的动态分配缓冲就没有。最后是一边看着 Tizen 的指导（同样缺少缓冲管理，只是一个简单的死循环）推测内部过程一边摸索出来的。 5、一些设计5.1 多线程和之前（初春引擎和 FFmpeg+SDL2 的文章）的实现不同，这次为了保证播放流畅，用工作线程来进行解码和同步。和前端仅有的重叠部分就是写 Texture2D 的像素，不过这也用了一个锁来保证不覆盖（其实这里也可以用 swap chain，效率应该会更好）。音频是后台提交 OpenAL 播放的。 但是多线程有一个弱势，就是异常的捕获。主线程的异常很容易就由调试器捕获了，但是工作线程一旦发生异常，没有捕获的话，直接就导致程序崩溃。所以一开始的时候我是这么写的： try { while (true) { // ... } } catch (Exception ex) { ThrowOnMainThread(ex); } 这个 ThrowOnMainThread() 的技巧是使用主线程的 SynchronizationContext，借其 Post() 方法，用一个 lambda 函数将这个异常在主线程抛出。注意，如果 SynchronizationContext.Current 为 null，则需要新建一个。 虽说这样能抛出，但是堆栈跟踪的信息就全丢失了，异常的抛出位置变成了这个 lambda 函数所在的位置。怎么解决呢？用一个构造函数支持 InnerException 的异常，将原始异常包住就可以了。我用的就是 ApplicationException。调试的时候展开 InnerException 属性就能看到原始的异常和引发位置。 5.2 ASF/WMV 的处理ASF 这个容器很糟糕。在 FFmpeg 的文档中，AVStream 的 start_time 字段有这样一条注释： The ASF header does NOT contain a correct start_time. The ASF demuxer must NOT set this. 我一开始的时候没有使用 start_time 这个字段来计算真实的 PTS，结果其他视频还好，WMV（用的是 ASF 容器，VC-1 编码）视频全部出现了严重的延迟。所以我去查如何计算真实的 PTS，看到了 start_time。 但问题又来了。ASF 容器中，start_time 是错误的。但是没有这个值，PTS 就没法计算。摸索了一阵子之后发现了一个经验公式，不过我不知道原理何在： video_start_pts = avStream-&gt;cur_dts / 2 audio_start_pts = 0 这个公式谜之适合所测试的几个 WMV 文件，就先这么用着吧。 5.3 帧缓冲区和分配策略这个问题不能和同步时的特性分开。见第2.2、第2.3和第3节。 音频由于单帧数据量小，需要进行合并输出。视频不需要合并，但要及时抛弃不需要的帧。总之都要最大化利用缓冲区。视频需要一个对象池管理待输出的帧，需要N个帧缓冲区（实际上是 AVFrame）；而音频只需要在解码视频帧时“顺便”解码并输出，只需要一个帧缓冲区即可，内部使用 MemoryStream 进行合并。 5.4 视频帧缓存考虑到解码和 sws_scale() 都是开销较大的工作，所以在输出到 Texture2D 之前会先将数据放到视频帧缓存中。这个缓存一个视频只需要一个就够了。之后如果查询得知不需要解码新的帧，则会直接输出缓存的内容。当然，写 Texture2D 的时候也不用次次分配新的数组，这个是可以用单个缓存优化的。 音频帧就没有这个问题，因为缓冲区分配策略和输出策略不同，也不会重获取帧内容。 5.5 一些重用sws_context 和 swr_context 是可以重用的。有参数发生变化的时候只需要更新就可以了，不用每次都分配新的上下文。 使用的若干个对象池也是为了尽量减少缓冲对象的分配。 5.6 av_seek_frame() 的坑av_seek_frame() 的定义如下： int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags); 其中 stream_index 是目标流，-1表示所有流；time_stamp 的单位是对应流的 time_base。 在实际使用的时候： ffmpeg.av_seek_frame(FormatContext, -1, 0, ffmpeg.AVSEEK_FLAG_BACKWARD); 很奇怪，如果 stream_index 分别指定为视频流和音频流，分别去 seek 的时候，视频解码就会出错，错误码是-11，音频没问题。在表现上，就是前十秒左右画面都是静止的，内容是静止的这段时间的最后一帧，然后突然正常播放。如果用-1反而没问题，不知道为什么。 这个函数在 Reset() 的时候要用到。重新播放一段视频（而不先卸载）的情况下就需要这个。这是实现 IsLooped 属性所必需的。 5.7 FFmpeg 的 API 变更由于 FFmpeg 3.4 还比较新，所以没有多少人写关键的两个函数对 avcodec_send_packet/frame() 和 avcodec_receive_frame/packet()。许多教程还是停留在 avcodec_decode_video2() 和 avcodec_decode_audio4() 上。但是在 FFmpeg 更新之后，所有的编解码器都要求实现新的 send/receive API，而不保证兼容以前的 API 了。在实验中，使用老 API 的版本（是的，两个解码函数，每个都尝试了两套 API）工作就不正常。当然也有可能是我手滑了。 6、一些感受MilliSim 正在朝着使用 OpenGL+OpenAL 跨平台的方向前进，用 MonoGame 换掉原来的自制图形引擎（使用 D3D11）+NAudio（WAS API）。本文记载的内容原来是被设计用来替代 MilliSim 中用来播放视频的 MediaEngine，命名为 OpenMLTD.Projector，单独为一个项目。不过后来想到有一些通用的东西还可以加，于是重新规划为 MonoGame.Extended2 的子项目。 以前在做初春引擎的时候用的是 GebVideo.FFMPEG。虽说当时音频不会做，视频勉强播放起来了，但是还是有个严重的问题，就是这个程序集用的是 C++/CLI。C++/CLI 的缺点是和编译出的代码所使用的编译器版本、CRT 版本、平台、C/C++ 的内部结构定义都强相关。生成的程序集可能也使用了内部 API。所以如果要跨平台编译和运行的话，首选自然是 P/Invoke。 MonoGame 有多个平台的实现分支。其中 Windows 上后端是 D3D11+XAudio2；Windows/macOS/Linux 桌面环境（DesktopGL）上是 OpenGL+OpenAL；手机操作系统上的图形分别是 D3D11、Metal 和 OpenGL ES，音频则是各家的系统 API。有意思的是，其他的选择都有对应的 Video 和 VideoPlayer 实现，就 DesktopGL 没有。这应该就是授权的问题了，因为 DesktopGL 独立于平台，自然不能去调用平台相关的媒体 API。而媒体 API 背后，则是解码、同步、绘制等等一系列的功能。就说最关键的解码，你要说带个 FFmpeg/VLC 行不行呢？行，但是人家授权可是（主要是）LGPL 2.1，和 GPLv2 啊。所以 MonoGame 作为 MIT 授权的使用者，不会去用它们的。还有 MonoGame 的目标是封装系统中已有的功能，第三方库不属于这个范畴，除了可能在 Content Pipeline 中使用（如 SharpFont、FFmpeg），不会带到框架中的。 但做总是能做的，而且很可能有人做了。我虽然写了那么一个玩意儿，但是更想知道为什么这样的组件没人开源。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://blog.mottomo.moe/tags/FFmpeg/"},{"name":"MonoGame","slug":"MonoGame","permalink":"https://blog.mottomo.moe/tags/MonoGame/"}]},{"title":"在 WSL 上运行网易云音乐客户端","slug":"zh/2018-01-17-Cloud-Music-on-WSL","date":"2018-01-17T14:52:00.000Z","updated":"2020-03-30T22:34:35.445Z","comments":true,"path":"categories/Tech/zh/2018-01-17-Cloud-Music-on-WSL/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2018-01-17-Cloud-Music-on-WSL/","excerpt":"为什么要在 WSL 上运行呢？因为今天在虚拟机里测试的时候偶然发现，云音乐的 Linux 客户端无视了大部分播放限制，比起 Windows 客户端要不知高到哪里去了。——这是一条新的路，不是俗套的本地代理。我一直是挂着代理用云音乐，但是毕竟代理有速度（勉强能接受）和隐私两个问题；还有一个无法下载封面的副作用。 发现了这个有意思的东西之后，我首先测试这是不是因为网络连接方式的不同导致的。如果两个客户端的内部逻辑是一样的，那么在不在虚拟机内应该不会影响可播放与否。除此之外就可能是客户端的逻辑不同了。不管是哪一种，都需要 WSL 来测试。WSL 和主机是共享端口和硬件的，所以不存在虚拟硬件，也不存在桥接，在服务器看来和其宿主是一样的。正好作为实验组。 为了验证猜想，同时也是解决代理带来的问题，我决定在 WSL 上运行云音乐客户端。 摸索试验花了五个小时（包括本文开始写作之后），大概有了一套理论，不过仍然有暗坑。使用注意。","text":"为什么要在 WSL 上运行呢？因为今天在虚拟机里测试的时候偶然发现，云音乐的 Linux 客户端无视了大部分播放限制，比起 Windows 客户端要不知高到哪里去了。——这是一条新的路，不是俗套的本地代理。我一直是挂着代理用云音乐，但是毕竟代理有速度（勉强能接受）和隐私两个问题；还有一个无法下载封面的副作用。 发现了这个有意思的东西之后，我首先测试这是不是因为网络连接方式的不同导致的。如果两个客户端的内部逻辑是一样的，那么在不在虚拟机内应该不会影响可播放与否。除此之外就可能是客户端的逻辑不同了。不管是哪一种，都需要 WSL 来测试。WSL 和主机是共享端口和硬件的，所以不存在虚拟硬件，也不存在桥接，在服务器看来和其宿主是一样的。正好作为实验组。 为了验证猜想，同时也是解决代理带来的问题，我决定在 WSL 上运行云音乐客户端。 摸索试验花了五个小时（包括本文开始写作之后），大概有了一套理论，不过仍然有暗坑。使用注意。 首先，客户端在虚拟机（Ubuntu 17.10）里运行，一切正常。标称的最低支持是 Ubuntu 14.04。 开始进入 WSL。由于 WSL 不带图形界面，所以我们装一个。大体过程如这篇教程。不过注意 xfce4-terminal 要在 xfce4 之后安装，而且建议不要用那个下拉的终端模拟器（看个人，我是因为习惯从任何目录直接开终端，而那玩意儿不支持）。还有就是，和教程不同的，如果用的是较新的 WSL，那么 D-Bus 就不用修了。 装完之后安装客户端。一运行，怎么什么反应都没有？开控制台，启动 netease-cloud-music，看输出。结果发现了异常的原因是这样一个错误（类似这个）： Assertion ‘pthread_mutex_unlock(&amp;m-&gt;mutex) == 0’ failed at pulsecore/mutex-posix.c:108, function pa_mutex_unlock(). Aborting. 开始的时候我没注意看。客户端不是还依赖 VLC 嘛，所以我就打开了 VLC，结果同样无法启动，报告的是类似的错误。想了想应该是 PulseAudio 的问题。（以前在 WSL 上试过 ALSA 结果根本不能用……）找。顺着找到的东西继续翻，首先原因是这个，楼下有人提了简单的 workaround。不过我就没这个条件重新编译了，于是继续翻，果然有人做好了。于是添加 PPA 并重新安装 libpulse0（自然也要重新安装 xfce 和 netease-cloud-music）。 还有一些说明。不过里面的内容过时了。PulseAudio 的 Windows community port 版本才是1.1，太老了。自动安装脚本所安装的是版本6，也太老了——而且没法正常运行（路径问题）。 那怎么办呢？PulseAudio 的 FAQ 指出了一种方法，用 Cygwin 的组件。自然，作为一个合格的开发人员，Cygwin 肯定是有的。可以见到，此处的版本是11.1，比上面两个要新得多。安装之后，照着配置。稍微不同的是这里不使用 default-server 配置项，而是在 WSL 的 .bashrc 中加入： export PULSE_SERVER=tcp:localhost 但是运行又出了问题，报告“failed to create secure directory”。解决方法也是有的。不过为什么不更自动化一点呢？在 Cygwin 的 .bashrc 中加入： export PULSE_STATE_PATH=$HOME/.config/state export PULSE_RUNTIME_PATH=$HOME/.config/runtime 这样就能正常运行 pulseaudio 这个服务端了。启动之后，在 VLC 和云音乐客户端就能听到声音了。 不过可能你也注意到了，输出一直很糟糕。我们接着来解决播放的问题。 首先使用 -vvv 选项启动 pauseaudio。从输出中可以看到出现大量这样的消息： D: [waveout] sink-input.c: Requesting rewind due to uncorking D: [(null)] module-suspend-on-idle.c: Sink output becomes busy, resuming. D: [waveout] protocol-native.c: Requesting rewind due to end of underrun. （※这一条会出现多次） D: [waveout] sink-input.c: Requesting rewind due to corking D: [(null)] module-suspend-on-idle.c: Sink output becomes idle, timeout in 5 seconds. D: [waveout] protocol-native.c: Requesting rewind due to end of underrun. 会不会是 waveout 模块的锅呢？这个配置已经得到了修正。那只能猜想是 corking（自动降低音量）的问题了。我尝试取消加载 modue-role-cork，感觉上好一点了——至少只在开头的地方会出现噪音。搜索了一下之后我认为这应该是 VLC 播放对齐（aligning）的问题，比如这个讨论。 在折腾的过程中，我发现云音乐客户端有很大概率无法正常启动，进程挂在那里，窗口不出现。虽然尝试解决了一下，但是仍然十分玄学。随着后面 PulseAudio 的调整，启动成功率似乎高一点了。 为了减少它的烦人程度，不用每次都手动终止进程（ps -ef | grep xxx 然后 kill yyy），建议安装 xfce4-taskmanager。 对 PulseAudio 配置文件的修改： 在 default.pa 中—— 在“Network access”节增加： load-module module-native-protocol-tcp auth-ip-acl=127.0.0.1 auth-anonymous=1 取消加载 module-role-cork 模块（我们也不需要）： #load-module module-role-cork 在 daemon.conf 中—— 设置启动为守护进程： deamonize = yes 注意，一旦成为了守护进程，就看不到输出，就无法调试了。不过好处是启动后即使关闭了 Cygwin Bash，pulseaudio 仍然在运行。 修改 exit-idle-time，配合守护进程（要不过一段时间就自动退出了）： exit-idle-time = -1 仍然有的问题： 8-bit 音乐，比如这种，无法输出，全是卡顿。从调试信息中可以见到 CEF 除了启动了标准的声音客户端，系统还分配了一个“尖峰检测”客户端。我猜是这个平滑波形的问题。 类似地，根据乐曲开头的规则程度，会有不同时长的垃圾信号。这个接近玄学。 会变调。频繁卡顿过后有一段时间音调比原曲要高一点（大约3度），然后过一段时间就降回来了。这可能还是采样的缓冲问题。 总之就要接受这样一个过程： |-- t1 -&gt;|-- t2 --&gt;|-- t3 (~2s) --&gt;|-- t4 --&gt;| | 卡顿 | 音调异常 | 降调 | 正常播放 | 还有一点奇怪的是，尽管云音乐用了 VLC 作为后端，但是 VLC 在进行转到指定时间（seek）结束的时候还会像开头那样来一段卡顿，严重的甚至会影响视频解码（怎么回事？），而云音乐不会。不知怎么解释。 好像禁止了 module-role-cork 还是会出问题……虽说这个模块是调整麦克风输入的（检测到输入较大，如讲话时，降低其他应用程序的音量），其实跟输出波形也应该么关系（不带反馈），但还是不知道怎么回事。同一首几分钟的歌，有时播放了几秒就稳定下来开始降调了，有时候播完了都是卡顿。唉，玄学。只能说 Linux 的（普通）用户体验还是太差太差了，不要说什么“hackable”，我不想投入，也没精力投入在这些根本不是目标、不值得操心的事情上。而 Linux 下的应用软件，就是能工作了算是走运，不能工作，假如找到了某种方案，必须附一句 YRMV。而且还真的就是 YRMV。心疼巴塞罗那的市政局工作人员。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"WSL","slug":"WSL","permalink":"https://blog.mottomo.moe/tags/WSL/"},{"name":"PulseAudio","slug":"PulseAudio","permalink":"https://blog.mottomo.moe/tags/PulseAudio/"}]},{"title":"简谈手机游戏的 live 效果","slug":"zh/2018-01-13-Live-on-Mobile-Phones","date":"2018-01-12T20:49:00.000Z","updated":"2020-03-30T22:34:35.445Z","comments":true,"path":"categories/ACGN/zh/2018-01-13-Live-on-Mobile-Phones/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2018-01-13-Live-on-Mobile-Phones/","excerpt":"主要内容是在1月10日写的，发到了漫版群里。想了想这个问题抛出来也不错。博客的版本有修改，加上了由我之后的若干条回复组成的补充，和 MLTD 部分。 正文修改部分： 将宅向缩略语和部分恶意卖萌改为正式用语； 调整叙述顺序、合并内容； 增加细节、一些注释和前后文衔接。 “live”，要是准确翻译的话，得翻译成“现场演唱会”。但是每次都要把这么长的词讲一遍实在是费劲，而且土里土气。但要是简称“现演”的话……对，你们应该听过这相声，就不多说了。而且在手机游戏中其形式未必是演唱会。要是说“演出”，又太泛了，因为 live 特指唱歌跳舞的演出。作为动词可以翻译成“现场演出”，在常用语境中指的就是去表现这种艺术形式；名词是否也可以用“现场演出”，待定。所以暂时还是用原词“live”。 我可能会有用语上的失误和概念的不准确。这个我尽量用阅读百科的方式避免。不过如果发现了问题也烦请指正。 那么开始吧，手游的 live 怎么好看？（可愛くなりたい！） （2D live 方面请咨询作豚索尔。索尔最近正好在狂刷各种各样的动画 live。←其实只要是2D动画都可以咨询索尔）","text":"主要内容是在1月10日写的，发到了漫版群里。想了想这个问题抛出来也不错。博客的版本有修改，加上了由我之后的若干条回复组成的补充，和 MLTD 部分。 正文修改部分： 将宅向缩略语和部分恶意卖萌改为正式用语； 调整叙述顺序、合并内容； 增加细节、一些注释和前后文衔接。 “live”，要是准确翻译的话，得翻译成“现场演唱会”。但是每次都要把这么长的词讲一遍实在是费劲，而且土里土气。但要是简称“现演”的话……对，你们应该听过这相声，就不多说了。而且在手机游戏中其形式未必是演唱会。要是说“演出”，又太泛了，因为 live 特指唱歌跳舞的演出。作为动词可以翻译成“现场演出”，在常用语境中指的就是去表现这种艺术形式；名词是否也可以用“现场演出”，待定。所以暂时还是用原词“live”。 我可能会有用语上的失误和概念的不准确。这个我尽量用阅读百科的方式避免。不过如果发现了问题也烦请指正。 那么开始吧，手游的 live 怎么好看？（可愛くなりたい！） （2D live 方面请咨询作豚索尔。索尔最近正好在狂刷各种各样的动画 live。←其实只要是2D动画都可以咨询索尔） 0、前情提要被lan的一个截图吸引，我尝试了一下 AG（Alternative Girls，国内B站代理，译名为“妃十三学园”，不过到现在依然没开）。战斗系统是顺序回合制，技能装备属性加成相克这些设定的一想就能懂。我在其他游戏（CGSS、SGS、きらファン）中都见识过，所以一会儿就索然无味了，这类游戏能玩的总是欧皇、肝帝和石油王。当然现在的手游总是想增强用户粘性和氪金欲望，所以除了用属性和其他分类（如 AG 用的就是“武器”）来降低玩家抽出优秀卡组的概率，设定高得吓人的物品（升级、特殊物品）兑换比率（这两个真不人道），还会整出各种各样的子功能（这个挺人道）。AG 的卖点就是 VR 模式，戴上 VR 眼镜（放手机的那种）就如同身临其境。对于没有 VR 眼镜的用户，可以使用陀螺仪，以在空间中移动手机的方式观看；再懒就用普通的手指划动来移动镜头。在没什么特点的战斗系统之外，AG 却有着 VR live、温泉、照相模式和闹钟！所以我就吐槽 AG 就是个“换衣拍照唱歌跳舞”游戏。lan： オルガル难道不是抽卡换衣服唱歌跳舞游戏吗？ 顺便吐槽一下 SGS（Schoolgirl Strikers）。这个连战斗过程都是全自动的，纯粹拼点和运气了。然而在里面你还能： 滑雪 打保龄球 射击 花样滑冰 玩大富豪 这还是在我退坑之前。为了和 AG 对比我重新装了 SGS，发现现在还能钓鱼和玩超级玛丽。所以说这个游戏究竟想做什么呢？反正我没肝的目的，战斗也没意思，所以只是偶尔把它当成大富豪玩。大富豪确实挺好玩。 1、CGSS（草菇烧笋）我之前在群里说，草菇（CGSS，不是 CGVR）的演出方式朝着 MV（music video）的方向发展，所以很难应用 VR 了。我说这句话是因为我认为对于同样的设备（手机）的使用场景，MV 这种艺术表现形式和 VR 的应用约束有着不可调和的矛盾。我说的是应用约束，而不是技术约束。 CGSS 的 live 中，玩家是作为屏幕前的观众，欣赏一段剪辑好的演出。 CGSS 初期的 live 就是单一舞台，布景随着曲目不同而不同，但在演出过程中无变化。演员位置在出场时就已经确定了，接下来的舞蹈动作并不会在舞台上移动多少位置。摄像机是在动的。即使创新的技术已经成熟，在爱抖露们个人曲目中，仍然会采取这样的编排。虽然五个人的动作是完全一样的，但是这最好地区分了主唱和伴舞的关系。 创新萌芽期从2016年6月《Love∞Destiny》（原来写作“爱无命”）开始，一直到11月《Flip Flop》（原来写作“反转浮点运算能力”）体系基本成熟。当然对于 Cygames 来说，在重量级手游上不可能做实验（商业风险），所以《Love∞Destiny》实际上已经用了当时内部试验成熟的技术了。不过其实从观感来说，《Love∞Destiny》还是略显稚嫩，到了《Flip Flop》才稳定下来。 《Love∞Destiny》第一次引入了位置的变化，五个人的位置不再是静态、固定、线性的；在演出过程中，伴随着镜头的变化，人物会“瞬移”到场景的其他位置。同时，舞台不再是一个标准的演唱会舞台，而变成了一个半封闭空间。9月的《ラブレター》（原来写作“爱信”）中有一段 P.C.S. 三人位置快速切换（镜头缓慢前推，ABC→CAB→BAC），好像我前年还在打活动的时候就在群里提到过这个非常令人激动的镜头。《ラブレター》还有一个贡献就是第一个非标准人数（3人）live，可以想到系统为此做了改动；这也带动了以后的非标准人数 live（《Jet to the Future》，2人；《モーレツ★世直しギルティ！》，3人；还有其他不少曲目）。《Flip Flop》不再拘束于一个密闭的场景；从感知上来说，其中数个镜头是在“其他几个地方”拍摄的。后续还有改进。2017年1月《あんきら！？狂騒曲》中，两个角色可以做出不一致的动作。这个估计是来自于在 CGVR 中应用的技术。6月《Yes! Party Time!!》登陆 CGSS 的时候，就是通过各自独立的动作来还原其在 CGVR 中的演出。 有一个视频展示了《Flip Flop》中这个“其他地方”背后的景象。也就是说，在世界中角色并没有移动位置，不过是在镜头前面加了布景和物件而已。但是，这的的确确地表现了演出空间的不连续性。时间的不连续性是 MV 的固有属性，所以从《Love∞Destiny》开始就有了。再说《ラブレター》中的角色切换，这在虚拟空间中，在技术上非常好实现，移动三个模型的位置就行。真人 MV 可以通过多次拍摄和后期剪辑来实现。但是，这在真实、单一视角、连续的演出中是不可能出现的。屏幕前的观众在观看的时候对它的预期就是剪辑的成品（尽管是实时渲染的），是加工过的，而不是连续、原始状态下的演出。在 VR 的体验中，时间和空间都是连续的，符合直觉。要是强制将不连续——无论是时间还是空间的不连续——的因素应用于 VR，就会给观众带来疑惑和混乱。因为手机的存储和运算能力有限，所以 CGSS 在 MV 中才会尽量减少素材（asset）使用量，降低渲染复杂度，采取视觉欺骗的方法。不过你也可以大概设想一下，前面的视频，即使是全场景渲染，但采取观察者瞬移的方式来观看，那也不会让人舒服。 我 CGSS 已经基本弃坑，所以没怎么关注更新，但是偶尔还会看一看。在去年年末的时候《Trinity Field》（原来写作“Triiinityyy Fiiiiiiiiiield”）的 Master+ 难度引起了议论，所以我顺便也看了一下 MV（这个“MV”指的是游戏中的 MV 模式）。令人意外地，这首歌并没有采用 MV 的方式表现，而是回归传统的演唱会方式。不过和同为 Triad Primus 的 《Trancing Pulse》 一对比就能看出改进如何。《Trinity Field》作为演唱会形式的演出，所以没有时空上的突变（尽管 Cygames 已经把这一套玩得滚瓜烂熟）。为了增强视觉效果，他们引入了动态的舞台：舞台不再只是由一块木板组成，而是三块；同时开始的镜头让人以为这还是 MV，但是当舞台一打开，空间从密闭变为开放，原来之前的是内侧摄像机加上荧幕形成的效果。同时演出的舞台的安排不再是靠墙，而是全方位开放的，这和现实中的武道馆很接近了。同为改进后的演唱会，《Jet to the Future》则保持了以往的设计，可能是和摇滚主题和“小众圈子”的概念有关。如果《Trinity Field》的这个演出加入 CGVR，我认为效果也会相当不错，至少没有冲突，连续性得到了保持。 小空间 MV 可以考虑看《リトルリドル》，也是十来平方米，大量运用特写镜头和（精心组织的）背景。 2、Alternative Girls注：AG 部分的链接链接到的是 PV，而且观感不怎么样，所以不用仔细看，就是给大家听歌的。云音乐上不全，要不我就链接到云音乐了。 在1月10日在群里发表的时候，AG 我解锁了三个live：《もっと Be My Power!》（原来写作“再多成为我的抛瓦！”）、《笑顔でgoing up!》（原来写作“带着笑容上升！”）和《Heart Cleaning》（原来写作“心脏清洁”）。 AG 因为卖点是 VR，所以很难像其他游戏那样去录制标准的视频。没法录制，网上就基本找不到。所以我先为没玩过的各位大略讲一下 AG 里的 live 是什么样的。标准场景是在一个十几平方米的卡拉OK包间里，对面墙上挂着一个大屏幕电视，玩家坐在沙发上，对着电视。选择的角色开始时会在初始位置（沙发上坐着、门外站着），随着歌曲开始播放会走到房间中央开始跳舞，而且跳舞过程中一般会靠近玩家（极限为贴脸）并做出亲昵的举动。（我好像想到了什么不好的东西？） 解锁的三首里面，前两首是标准的这种模式，很单调，乏善可陈。《Heart Cleaning》出现了场景切换，从房间里切换到公园。但是冲突还是存在，玩家仍然是不动的，无法像摄像机那样可以相对自由地移动到编排好的位置，去展现空间中更丰富的内容。角色的动作、目光和表情交互，都是对一个超近距离的定点的。所以整个过程中只有一次场景切换，没有机位切换，没有蒙太奇（见《Love∞Destiny》开头），玩家就是一块木头。实际上，过近距离的贴脸会使玩家在转向那个方向的时候屏幕整个被脸占据，而屏幕又是尺寸有限的，所以看到的总是脸的一部分，显得很怪异。 问题在哪里呢？第一，舞台小。为了保证无法移动的玩家第一人称能看得清，还要考虑手机性能，整个舞台就是房间那么大。所以要是想一直在玩家面前蹦蹦跳跳，那就不能超出这个范围。这种情况下，如果玩家不转头，那么可视角度最多只有53°左右，根本没法充分利用视觉空间。第二，AG 在战斗系统之外强调的一直是“交流”，交流对象很明确，就是屏幕前的玩家；而且玩家的空间位置是确定的。正常来说，在卡拉OK唱歌的时候，也不会这么卖力地去讨好另外一个人。所以这甚至不能用情侣行为来解释（更何况游戏中设定还没到这么深），只能让人怀疑是有点那个的那个了。第三，由于空间连续型不可以破坏，所以没法用 CGSS 那样的视觉欺骗来扩展空间。所以在最好最好的情况下，也只能用场景切换来做，还不能太频繁（依然要考虑手机性能；还要考虑人的接受能力）。不过切换后的空间，有效大小依然是房间那么大。所以总的来说，现场感是有了一点的，不过手脚没放开，也放不开。 到在群里发表的时候，看着 AG 的 live 让我有点失望，所以就想了想究竟如何调和，是哪里出了问题。我就等着解锁《リフレイン・ウォーズ》了，曲子从试听中可以听到。我认为这曲子是很适合开放空间 live 的，就看表现怎么样了。 1月11日，解锁了《リフレイン・ウォーズ》和《月下の軌跡》。 我是抱着很高的期待去看《リフレイン・ウォーズ》的。看完之后，我立马在群里说： 卧槽，AG的制作懂啊，黄毛的live效果很棒啊，略微超出期望值 lan也去看了看，然后说：“怎么中间突然换场景了？”我： 这首这曲子不换的话就是傻，毕竟这首是摇滚，空间又小，要是还是像其他的那样杵在座位上的话就很滑稽了。 我大致描述一下。开场的时候愛梨让玩家站起来，到房间中心一起唱歌（为什么只是看着）。前面和其他 live 一样，就是动作大一些、多一些（设定上愛梨的特点是気まぐれ，也就是很随性的）。接着到了高潮部分，切换场景。切换到的是一个圆形的小舞台中央，三个等距点摆放着爵士鼓、键盘和吉他，舞台外是手持应援棒打call的非洲人观众。随着歌曲节奏，还有喷火的特效（用喷火机）。愛梨接着会在整个舞台跑动，最后以空气吉他表演结束。 这首是这是唯一一个让玩家强制移动到舞台（房间）中心的。这样一来，就将观赏的角度，从180°（靠墙，实际上在50°到150°之间）增加到360°。他们可能是希望用这种方法来解决空间利用的问题。上文讲过，空间的连续性不能发生变化，所以既然没有大舞台来给角色进行大幅度直线移动，只好最大化用小空间，围着中央（“恰好”是玩家所在的位置）转圈。副作用也很明显，即使用手机横着看，依然很难跟上她所在的位置；晃来晃去还特别容易头晕。 为什么我很赞赏呢？这个 live，也是唯一一个不是“个人服务”的 live。上文说过，在 VR 游戏中是不可以使用 MV 那样用剪辑破坏连续性的形式的。那么就做现场咯。既然是现场，就要明确“观众”的概念，而不只是玩家。CGSS 中，如果是演唱会，时常会利用侧面和越肩镜头来告诉玩家，爱抖露们的表演是有人欣赏的，大家都情绪高涨。这才是演唱会嘛！这首就明确了，周围坐满了观众。表演的曲目是摇滚风格，激情迸发，所以需要大量的肢体动作来表现情感。这样，愛梨夸张的表演才是合理而且有意义的。让我有点意外的是几次喷火。这个舞台不像《Trinity Field》那样可以发生结构上的变化，所以添加了小物件/特效让静态的舞台活起来，变成半静态的。 《月下の軌跡》切换到的场景是亭子里，配合的是真知的世家设定。在场景中，背景有几个喷泉，作用和前面舞台喷火器是一样的。在中后期她还会掏出扇子，右手拿着扇子跳舞。由于这个处理加入了文化背景，所以尽管这仍然是以“个人服务”形式出现的，但是比无脑贴脸要合理多了。（不过为什么武将会去做艺伎的活儿呢？） 《Heart Cleaning》的背景同样出现了喷泉，但这个就是普通的大喷泉了。我忘了其中的水流是否是动态的，不过它最多起到了背景的功能，就是个摆设。 1月13日：解锁了《きゃっちあんどりりーす》，这个……虽然符合设定，但就有点令人不快了吧。 1月14日：解锁了《ほんとにほんと》。同样地，新的场景没有任何作用，纯粹的装饰而已。 就效果而言，大概是这样的： 曲目 评级 《もっと Be My Power!》 C 《笑顔でgoing up!》 C 《Heart Cleaning》 C+ 《きゃっちあんどりりーす》 C 《ほんとにほんと》 C 《リフレイン・ウォーズ》 A 《月下の軌跡》 B 嗯，精华拿到了，这游戏已经没价值了。 3、GF(♪)同为单人 live，GF(♪) 拿捏就没那么好。我在 GF(♪) 推出 live 模式之前就已经弃坑了，所以这次去官网看了看几首个人曲的 live。 我认为 GF(♪) 的编排受限于“屏幕=摄像机”的思维。因为只有一个人（只需要一个人），而且是固定、静态的场景，所以舞台非常小，空间有限。寒酸到我都不太确定它是否充分利用了 Unity 和手机的性能，毕竟它做的不是 VR 啊。人物在舞台上没有多少移动，加上空间小，所以人物在演出所在的整个空间中水平面上都没有太大的移动。 如果要算作 live，那么在整个演出过程中，“观众”的概念一直不明确——谁在看这个演出？CGSS 偶尔展示（见上一节），AG 就更不用说了。如果是作为 MV，那么对空间和不连续性（带来惊喜感）的运用实在是太寒酸了，整个过程就跟钉在杆子上的玩偶在动一样。 为了弥补观感的缺陷，Ameba 加入了“一键换装”和频繁的屏幕特效。换装的意义除了炫耀之外不知道有什么意义，因为没有观众，而且很显然这想做的不是强烈的自我表现。屏幕特效让整个演出看上去更像是动态漫画，而不是一个 live。所以说加入的补偿手法不能掩盖在空间处理上的贫弱。 4、MLTD（麻辣土豆）MLTD 在我退坑（不知道什么时候回坑）之前，live 的效果和 CGSS 初期差不多，系统也是那时候的样子。但是如果要做得更好，循着甚至超越 CGSS 的发展轨迹，以万代的美术和技术积累来说是可能的。不过加衣服模型不是正途啊万代！总之先期望在 live 改革之前先别关服再说。 5、结语以上就是简单的几个手机游戏的 live 效果啦。本来就是因为 AG 的前三首 live 让我失望，所以综合各种体会，一气之下写了一点破烂发到群里，然后现在发到了博客上。 哎，本来这些就是萌豚看着小姐姐们跳舞好舔哗哗哗氪金就行了的，也没必要较真。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"不只是技术","slug":"不只是技术","permalink":"https://blog.mottomo.moe/tags/%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%8A%80%E6%9C%AF/"},{"name":"手游","slug":"手游","permalink":"https://blog.mottomo.moe/tags/%E6%89%8B%E6%B8%B8/"},{"name":"live","slug":"live","permalink":"https://blog.mottomo.moe/tags/live/"},{"name":"Alternative Girls","slug":"Alternative-Girls","permalink":"https://blog.mottomo.moe/tags/Alternative-Girls/"},{"name":"GF(♪)","slug":"GF-♪","permalink":"https://blog.mottomo.moe/tags/GF-%E2%99%AA/"}]},{"title":"水","slug":"zh/2018-01-03-Misc","date":"2018-01-03T07:10:00.000Z","updated":"2020-03-30T22:34:35.444Z","comments":true,"path":"categories/Misc/zh/2018-01-03-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2018-01-03-Misc/","excerpt":"","text":"最近又跑去了海牙一趟。以及由于对 MilliSim 中自制图形模块的兼容性不满意，我正在用更通用的 MonoGame 来重写。途中免不了造了点轮子，静下心想了想，解决了几年前挖的坑。同时 Vanishing 复活了（其实是hth突然又活过来了）……于是又跟 Source 打交道，感受到自己确实有点长进，以及 Source 的设计其实是混乱的。 不知道有没有时间写这些玩意儿。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"一个小游戏：Vengeance（外一则）","slug":"zh/2017-12-23-Vengeance-Game","date":"2017-12-23T12:09:00.000Z","updated":"2020-03-30T22:34:35.444Z","comments":true,"path":"categories/Misc/zh/2017-12-23-Vengeance-Game/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2017-12-23-Vengeance-Game/","excerpt":"Game Off 2017 上的一个游戏。","text":"Game Off 2017 上的一个游戏。 Vengeance 这个游戏规则很简单，移动，射击，每次“杀死”所有敌人后立场（field，双关ww）会翻转，场上多一个人，而且其他人都会学习你用过的策略。接着就是继续移动和射击。 每次换立场时音乐都会加速（有上限）。每次杀死所有敌人后，都会出现一个“VENGEANCE”提示。每次被击杀，都会有一个煽动性的提示：“Never stop!”、“Kill them all!”、“Make them pay!”，然后游戏重新从1对1开始。 这个游戏吸引我的地方是它的“结局”。你可能要问，这样的游戏不就是挑战技术吗？其实要是想玩突突突也是可以的，只要技术过关（加上“龟缩”策略），刷上十几次完全没问题。 但是想过没有，什么时候是个头呢？直到想明白了这个问题，才理解它的名字“复仇”是个什么意思。 只要当你被击败之后，不再受到煽动，你就会看到—— I’m so sorry. I’m so very, very sorry. 紧接着就是对面朝着分界线的移动。而且此时是初始阶段，对面是不会射击的。在这个游戏中，这个动作就相当于将你手中的枪抵在对面的胸口上。 按下扳机吗？还是张开双臂去拥抱呢？做出选择你就能看到答案。 所以这个游戏操作不复杂，规则不复杂，场景只有一个，讲述了完整的故事。相当不错。 最后一件事。还有没有想过为什么你会将游戏里的三角形看作是有生命的，从而赋予“复仇”和“饶恕”的意义？见 An experimental study of apparent behavior，或者看一下其中的实验。 23日的时候通话。 我妈说：“你直到初中还相信有圣诞老人呢……而且还认为24日、25日两天晚上都会出现……” 大概可以作为黑历史了。不过我那时候在想什么呢？ 有很大概率是不存在的。但是这些玩意儿是哪儿来的？如果不存在，那就是某个地方买来的。问题是根据物品的种类，不是我所知道的地方能买到的东西；而且假如是针对我的话，却跟我的兴趣差距甚远，所以可能是随机的。这个结果无法解释，姑且假设是掉落的吧。后来突然有一年再也没有了，两天都没有。不过我其实也没期望这个，于是后来也再也不去收了。 我妈说：“哎想当时我和你爸都想不出给你买什么呢！” 我：？？？ 等会儿，隔了十年才说出来？而且等会儿，不是超自然的东西，而真是买的？那为什么是一些我不知怎么吐槽才好的玩意儿？为什么不直接取消，因为没人有这个需求，还让我更疑惑了？为什么不直接告诉我呢，我本来就没有相信啊？ 所以老爸老妈那个时候希望我能开心，这个我理解；但是其余的，比如选择那些玩意儿的原因，理解不能；具体是怎么买的我也没问，就让它随着历史去吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Game Off 2017","slug":"Game-Off-2017","permalink":"https://blog.mottomo.moe/tags/Game-Off-2017/"}]},{"title":"奇怪的梦","slug":"zh/2017-11-24-Strange-Dream","date":"2017-11-24T10:43:00.000Z","updated":"2020-03-30T22:34:35.444Z","comments":true,"path":"categories/Misc/zh/2017-11-24-Strange-Dream/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2017-11-24-Strange-Dream/","excerpt":"中午所梦，内容天马行空，我仍不知道它在暗示什么。 尽快、尽量地记录细节。语言就随便了，读得懂就行。","text":"中午所梦，内容天马行空，我仍不知道它在暗示什么。 尽快、尽量地记录细节。语言就随便了，读得懂就行。 开始记得的场景是一个房间，大小大约20平方米，方形。我背后的墙（朝南）实际上是一扇很大的窗，宽度与墙壁相当，高度比我略高一点。同时在室内面朝它的左边部分开着可以向外推的那种窗。正对着窗的是一扇深色木门，大小大概就是单人门的样子。 有两个人进来了。一看就是侵入者。我想起了上次遇到这种事件的时候，窗口开在门边，我举着她们“扔出”了窗口。这次我说，你们自己从窗口出去。于是挡着能开的那部分窗；此时摄像机切换左上大概30°的位置，对着的目标是我——我作为屏幕外的观众看着我的行为。歹徒就算是看着我这边，也没注意到后面有人出去了，直到我也从窗口撤退完毕。不过我的手还搭在窗口边上（此时我认为窗玻璃消失了，而我翻出来的时候正好在窗台的正中央，虽然其实前后位置对不上），右手手，期间还因为怀疑撑不住了，两只手往上爬了一下；然后左手打电话，打的是112（本地的报警电话），就听见电话里先是一段杂音，然后很弱的声音说“how may i help you”。窗口高度在我单手伸到最长时这时候左脚能点到一点地面。我一面将头露出窗口和歹徒回旋，一面降下来悄悄说“there’s an intruder in my home”。两个歹徒在房间里，我觉得他们要拿什么东西。我又想起来，要是只能带上最有价值的东西逃跑的话，就是窗边的笔记本电脑了。于是我最后一次升上去将电脑拉下来，然后落地。这时候楼的正门（在窗边，左下角）开了，其中一个歹徒冲了出来，将什么东西偷/抢走了。于是我就要追，就跟跑酷一样。不过我速度比他慢一点点，所以得一直寻找最近的路。比方说在商场扶梯的地方，他已经领先了我一层，还在往下一层跑，我只好双手抓住上边缘，跳下去（大概5米）。后来进入了一个似乎是有点污泥的地铁内部通道，我最终抓住了他，但他变成了一个类似核心/休眠体的东西。 我把这个东西带到一个房顶有斜度的平房，里面有两个女生。我将这个核心细心保存好，防止逃脱，然后决定明天去给一个什么教授检验。 下午，我走到一栋楼像是研究所的楼底下。这栋楼的墙是50年代那种石头墙，“人”字形，入口在交点处，有台阶和栏杆。地上有很多中等大小的鹅卵石。这时候我踢到了一块，它像蛋壳一样碎了。里面露出了片状玄武岩的板子，上面用更深的黑色写着什么字。看着它我突然想到了，我抓到的生物是黑兽。（不是那个动画，我只看过描述，也不喜欢）然后我看着许许多多的石头突然想到，恐怕是多元宇宙：既然从黑兽宇宙出现了黑兽这种生物，那XX宇宙、XX宇宙呢？（名字我现在忘了，但好像都是很奇怪的字。）不行，得赶紧回去报告。 时间转到晚上。我在马路上走着回去（平房），看到正左边地下车库出口（地形类似，但是铺着白色小鹅卵石；而且似乎是往下的，也就是我处于类似高度2m的天桥的位置，视觉右半边有一条柏油路上来；两条宽度都大约是一个车道）的地方，远远地（30-40m）有一个低着头的初中女孩走过来，穿着好像是水手服。她的行走速度是正常速度，但是我又突然明白了如果被她直接看到“会发生很不好的后果”。所以我加速向前走，前面右边的岔路上拐来一辆白色（底端草绿色）垃圾车，上面写着“河北省道路清理”。我有一个估计，这个司机估计会看到和被看到，然后我身后会发生“事故”。但是我管不着了，只能赶快跑。我的左边有一条路，像是写字楼底下、过去之后进入了一个小区的那种，但是也是铺满了白色小鹅卵石。同时，有墨绿色的栏杆。我走上鹅卵石的时候就听到身后呼呼作响，有可怕的寒气。这时我反应是，后面是寒冷女妖，如果被追上就不得了了。脚下虽然是白色小鹅卵石，但是却像冰面一样滑，这个速度根本逃不了。于是我只好用双手用栏杆加速和变向。中间经过了好几处像赛道一样的路，两边是3/4人高的栏杆，间距大约1.5人宽，转向时栏杆中间缺失了一部分，而我速度很大，要是变向有一丝误差都无法保证维持在“赛道”中——这样变向幅度大的话，我就无法利用栏杆本身的反作用力变向，而是得用手拉着提供向心力，手可能会断。虽然速度很快，但是我像是玩过许多次一样，没有出错。在最后一次利用反作用力加速（同时也是变向，因为接下来就不再有栏杆）的时候，离终点小平房大约三四十米，而门只有小小的一点——仍然是精准到达。 我赶紧开门——像是冷库的大铁门，进屋，关门，反身将把手往下死命按，想把女妖挡在外面。门外传来了声音：“要是我（进去）抓到你的话……”同时我发现不好，门没关好，是半固定的，露出了手大小的缝隙（但是没有风进来）。把手锁住的是往水泥地下打的一小截脆弱的不锈钢管。但是窗也没关好，我能看到一张脸想要进来。没办法，放下门，希望它能坚持住，然后来关窗。将窗关到严丝合缝之后死命拉下把手。前门虽然还在呼啸、冲击，但至少可能能挡一阵子。这时候后面的大窗出问题了。白纱窗帘吹得飘起来，都有大概60°了。但是我却知道，后门这个虽然也是冷的，但是不是刚刚追着我的，而是之前我看到、赶紧躲开的我认为可怕的。我有个假设，如果直接伸出手从窗帘下面过去关窗，手臂可能会冻成冰碎掉。所以我做了个实验，手伸到窗帘下，微微过60°、垂直于墙壁的平面。有两只寒冷的手抓住我的手臂，我心想果然，然后拼命挣脱开。然后用窗帘挡着（窗帘感觉好暖和），将这个窗拉上、把手拉下来了。 这时候前面又出事了。被严寒同化的（不知怎么回事，我知道是被人被同化而成的）一个类似狼人的生物在撞门，并大吼（用中年大叔音）开门。我大喊绝不。然后从这个手掌宽的门缝中我看到狼人指着我身后说，“你不开可以，但是她能不能坚持那么久我就不敢说了！”我看到一个女生已经蜷曲着倒在地上，脸发红，呼吸急促，生命垂危的样子。（别想多了）我正想着“那么久”是多久，另一个女的（站在房间中间）就说：“到长白山为止需要很长时间的。”（不符合语法我知道）我觉得这人可能救不活了。突然镜头一转，一个短发的大概也是初中的不知男女的人出现，用少年/少女的声音说：“那作为替代，你把我带走吧！”说着伸出双臂挡在我们和狼人之间。 “镜头”的意思是，先对着他，然后对着狼人向上缓缓平移，狼人做出惊讶的表情并“嗯？”了一声，然后镜头回到他。他背后发着强光，背景中是一个男的跪着准备抱起在地上的女的。由于是逆光，所以背后的都是人影，但是我虽然是旁观者，但却知道那就是我。这时候音乐响起，献身的音乐（大概这种），我鼻子酸酸的。 然后我就醒过来了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"JSON 校验","slug":"zh/2017-11-18-JSON-Validation","date":"2017-11-18T14:18:00.000Z","updated":"2020-03-30T22:34:35.444Z","comments":true,"path":"categories/Tech/Coding/zh/2017-11-18-JSON-Validation/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2017-11-18-JSON-Validation/","excerpt":"首先，天国的 Bulletproof。 这次讲一讲 JSON 的校验（validation）。本文水分充足。","text":"首先，天国的 Bulletproof。 这次讲一讲 JSON 的校验（validation）。本文水分充足。 SEBAS 中负责文本解析的是 Peg.js，用起来有点像 lex+yacc，准确说是因为它们的代码嵌入： _TimeSecondsValue = seconds:_FloatValue &quot;s&quot; { return wrapPrimitive(&quot;time&quot;, seconds.value); } 在这一段的最后就是一个函数体，对 _TimeSecondsValue 的解析返回的值就是函数返回的值。lex 和 yacc 也有类似的功能。不过用着真的有点不太习惯，因为编译前无法检测代码块里的错误，至少没有工具自动完成这个。 假设解析完成了，最后输出的是一个对象。我希望去检测这个对象，保证里面的成员存在性符合要求，值类型合法，格式合法，范围合法（比如视频的 AV 号必须是正整数），不冲突。一个解析器是不会给你干这个活儿的，你还得自己加个符号表，然后写一堆验证逻辑，还要递归。 所以我就突然想到了，你看，我得到的结果不也是 JSON 吗？很多网络服务也是使用 JSON 作为信息传递格式，那么为了鲁棒性，肯定会有人用某些方法去验证得到的 JSON 是否合格式要求。 所以我就去找了一下 JSON 的规范（schema，我不知道专业的怎么翻译，想写成“范式”，不过那是 form，和 schema 又不一样）校验。我用过点 Swagger，知道这玩意儿形式（不只是具体写法）如何，作用为何，怎么用。 JSON 的规范是有标准的。例子勉强够用。照猫画虎写了一些。 验证工具选择还是不少的。我一开始用的是 tv4，不过发现我得用到跨文件的 $ref 元素，而 tv4 无法处理。所以后来改用了 ajv，也懒得指定版本了，直接用最新的标准，反正向后兼容的。 基于此我写了一些规格测试，来保证返回数据的格式（同时也作为返回样例）。还别说，期间几次解析器的代码修改时真的导致了测试失败，幸好有规格测试，要不在使用返回的数据的时候就头疼了。这里是具体的测试，这足以保证返回数据里该有的都有，不该有的都没有。毕竟这是一个系统外往系统内走的环节，如果有人想在这个环节攻击，系统得有基本的防御。 不知道什么时候记的： 看现在 BAS 的样子，DIYgod 又要单刷，测试区都做了。不过这个项目虽然在 BiliBili 的账户下，不过看着各种方面，其实是他的一个个人项目而已……所以 SEBAS 就挂起了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.mottomo.moe/tags/JSON/"}]},{"title":"TypeScript 中的装饰器","slug":"zh/2017-11-17-TypeScript-Decorator","date":"2017-11-17T06:51:00.000Z","updated":"2020-03-30T22:34:35.444Z","comments":true,"path":"categories/Tech/Coding/zh/2017-11-17-TypeScript-Decorator/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2017-11-17-TypeScript-Decorator/","excerpt":"玩了一下装饰器（decorator）。这是个好东西，但我还是没法实现 @Sealed 啊。","text":"玩了一下装饰器（decorator）。这是个好东西，但我还是没法实现 @Sealed 啊。 最近看到 BiliBili 开了个 BAS，新的高级弹幕语言，于是启动了 SEBAS。不过想略微吐槽一下，功能只是 Mode 8 子集的子集，惨不忍睹。安全是安全了，不过再也做不出像3D球那样有趣的玩意儿了。另外，确定这语法不是拍脑袋想出来的？ 闲话少说，进入正题。在此之前，各位要先有点知识储备。当然如果了解 Python 的装饰器函数也行。不要吐槽为什么 TypeScript 网站的文档要把导航放最上面而且还要占用这么大尺寸。 装饰器可以对元数据进行修饰。这和装饰模式不同，并不是以包装的方式来实现扩展的。对于 Python 和 JavaScript 这种可以随便往对象上面挂成员（Ruby 可以开包，不过这个我不熟），而且函数是一等公民的语言，元数据和代码在形式上区别并不大。特性和注解是被动地存储信息，对成员的改动需要通过其他函数进行（或者编译时，比如辅助 AOP 的特性），行为要通过包装类改变；而对于 Python 和 JavaScript 而言，装饰器既承担了保存额外信息的功能，又负责对成员作改动。稍微花点时间适应一下这个变化。 好了该讲讲我为什么突然玩了玩这个玩意儿。 各位都知道，受到“类”在 JavaScript 中实现的限制，所有的实例方法都是像 Java 一样是默认覆盖（override）的。Java 后来引入了 @Override 注解，编译器可以帮助检查这个函数是否本来就是想覆盖的，以及基类型是否有待覆盖的方法。但是 JavaScript 没有，也没法检查（因为本身就没有继承），是完全动态的。我在编写 SEBAS 的时候，希望不要因为打错字而造成编译没错、运行出错（找不到成员）的事情，所以希望加入这样一个检查。所以我实现了 @Override 装饰器，进行运行时检查。是的，不是编译时检查，因为 JavaScript（在执行引擎之外）没有“编译”的概念。不过每个方法只需要在引入时检查一遍，所以应该还是可以接受的。 我们先来看一下核心逻辑。什么时候应该判断为合法？应用了 @Override 的方法覆盖了基类的同名方法。什么时候该判断为不合法？一个方法应用了 @Override，但无法在基类型中找到同名方法。至于没有应用 @Override 的方法，受到条件限制我们就管不着了。函数签名也管不着（Function.length 不能代表一切）。这就好办了，沿着原型链一直往上找就行了。 但是还有问题。TypeScript 中是可以定义抽象类的，有着“不可实例化”的语义。而在转译（transpile）到 JavaScript 之后，就变成了普通的函数，丢失了“不可实例化”的语义。在 TypeScript 中检查还是比较简单的，毕竟是单继承，一个是不可实例化，一个是 super.method() 不可访问（其中 super 指向一个抽象基类），这只需要考察一层继承。但是就装饰器所执行的 JavaScript 来说，丢失的东西太多了。所以还需要有一个 @Abstract 装饰器，表明这个类是抽象类。当分析到这个抽象类时，乐观假设指定的方法是存在的。也就是说，@Abstract 的设计是为了解决这种问题： @Abstract abstract class A { abstract method(): void; } class B extends A { @Override() method():void { } } 如果没有了 @Abstract，那么对 method 的检查是肯定要报错的。 至于我没法实现的 @Sealed，我的设想是与主流语言的语义保持一致：类型封闭，不允许添加和删除，不允许继承。这个行为介于 Object.freeze() 和 Object.seal() 之间，没有标准函数定义这个状态。而且关键的“不允许继承”是根本做不到的——访问原型是一直允许的，将一个函数的原型指向已有的原型也是一直允许的，但我们无法操控用户所生成的函数。因此继承是永远不可禁止的。哎，遗憾。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://blog.mottomo.moe/tags/TypeScript/"}]},{"title":"大概算一个简单的回顾","slug":"zh/2017-11-16-Review","date":"2017-11-16T15:03:00.000Z","updated":"2020-03-30T22:34:35.443Z","comments":true,"path":"categories/Tech/zh/2017-11-16-Review/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2017-11-16-Review/","excerpt":"回想了一下 JavaScript 的入门，觉得经历挺神奇的。可以作为实用主义的体现。","text":"回想了一下 JavaScript 的入门，觉得经历挺神奇的。可以作为实用主义的体现。 起因是这样的。2014年12月的时候，入宅也差不多一年了，这时候通过校内论坛签名的方式找到了 Bangumi。“分集记录”这个想法对我来说还比较新鲜，所以就玩上了。接着发现，看一集点一集，太麻烦了，而且还得设置追番，还要打分。这时候花园还健在，日常看番都是从花园上下载的。我访问花园的频率比 Bangumi 的高到不知哪里去了（毕竟不只是下载，还有讨论吹水什么的），所以为什么不做一个下拉框什么的，看完以后回到花园，一点，就自动完成了一堆事情呢？ 嗯对，最终成品就是这玩意儿。 当时我对网页一知半解，理解停留在 FrontPage，HTML（几种元素），和嵌入（inline）的 JavaScript 代码这个阶段。不过也只是“知道”，实际用倒是没用过。开发者工具也是没用过；流量劫持知道原理，不过面向的是专门的嗅探工具（当时用的是 IEInspector HTTP Analyzer）。 反正有了个目标，开工。 然后就发现，逻辑要用 JavaScript 来写，而我根本不会。于是就找了个教程，看到里面各种乱飞的名词：闭包、原型、AJAX……但是几个简单的例子怎么能说明问题呢？就算有个 Try It Yourself，一个完全的新手还是无法理解里面的玄妙。 目标是 Bangumi，略微搜索一下就会发现jabbany的作品（抱歉，当时连 GitHub 都不怎么会用）。但是，代码只能看懂一半，我甚至无法接受 JavaScript 的弱类型性——不知道是什么类型，怎么推测怎么用呢？举个例子： var xrequest = function (api, post, get, callback) { ... } 等等，几个参数的类型是什么？返回的类型是什么？由于缺乏文档，所以必须要看完才能推测。弱类型不是无类型，而且在调用的时候依然需要保证类型正确，所以看着十分痛苦。 this.authenticate = function(user, pass, callback) { ... } 等等，本来没有 authenticate 这个字段的啊？那别人怎么知道最终给出的 this 是带有 authenticate，这还是个函数的？ 另一个就更让人疑惑了。上面用的是 this.xxx，好不容易搞清楚了这个 this 指向的是定义其的函数（这里就和我以前所知道的“类”的 this 就有很大区别了），结果在另一个脚本中，又出现了这样的东西： Object.defineProperties(Function1.prototype, ...) 怎么回事？这又是什么意思？如果这能行，那上面的 this.xxx 和这个又有什么区别呢？对于当时基础等于零的我，根本就是云里雾里。 还有上文函数中的 callback。要正确使用，必须要理解变量捕获。我只观察到了现象，不过并不知道这个规则。 然后是发送请求。搜索的结果，AJAX 咯。照着骨架用了用 XMLHttpRequest。在空白页，控制台直接运行代码，能行。然而到花园页面上一用却没有响应，一看调试信息，等着我是一个同源策略错误。这又是什么？搜索了一番，才知道这是个大难题。如果网站不归你管（不能自己添加 Access-Control-Allow-Origin 头），请求发送也不归你管（浏览器禁止修改 Origin 头），那么一般也只能用 JSONP，借用无限制的 GET 了。但是某篇文章里说，&lt;iframe&gt; 不受限制，不过示例是让人在 &lt;iframe&gt; 中交互（点击、登录之类的），和我的需求有差异。哎，添加元素，这个我会，但是如何将信息传递进去呢？（所有操作在 &lt;iframe&gt; 内进行，所以不用考虑传出。）又搜索了一番，得知有一个 postMessage()，window 和 &lt;iframe&gt; 都有。而且它可以强制忽略 Origin。不过再一查，已经有人整合了，就是 Dojo 的其中一个模块。 但是使用上就有问题了。由于它依赖 Dojo，而 Dojo 的加载是这个样子的： require([&quot;dojo/request/iframe&quot;], function (iframe) { ... }); 这就要求在 &lt;head&gt; 内引入 Dojo 的代码，否则 require() 是没有定义的——但是在使用这个脚本的时候，不能保证在该页面内引入了 Dojo 的代码。要有鲁棒性，必须保证这段代码在引入了 Dojo 代码之后才能执行。于是又用了动态的 &lt;script&gt;（等同于懒加载），做了一点点兼容，才最终完成。 后来进一步发现，GreaseMonkey 就有一个 GM_xmlHttpRequest 函数，自带跨域。所以又加了一种实现，仅用于 UserScript 的，不过代码就简单多了。 所以学到了什么呢？ 回调和闭包 原型链 异步函数 AJAX CORS 懒加载 一点点 ES5 (postMessage) 后来发到花园上之后（原文转到了博客上），下面有个人回复：等等，这么深，这是你第一次接触 JavaScript？我：只是为了实现一个想要的功能而已…… 后来加入了漫版群，原来那是位前端大佬。 不过我真的只是要解决一个问题而已，为此破除路上的障碍，自然而然的啊？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.mottomo.moe/tags/JavaScript/"}]},{"title":"梦","slug":"zh/2017-10-31-Dream","date":"2017-10-31T13:19:00.000Z","updated":"2020-03-30T22:34:35.443Z","comments":true,"path":"categories/Misc/zh/2017-10-31-Dream/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2017-10-31-Dream/","excerpt":"这大概是最能绕过自我意识审查的东西了。虽然我记住了大部分内容，但是不清楚它是什么意思。","text":"这大概是最能绕过自我意识审查的东西了。虽然我记住了大部分内容，但是不清楚它是什么意思。 开始大概是这样的。我和A并排在类似长沙发的地方坐着，小茶几对面凳子坐着B。在场景开始的时候我就知道A是负责解答问题的、温和的，而B是不稳定的。A和B的形象都是我。房间是一个约20平方米的空间，四周密闭，没有门窗，没注意有没有灯，但有淡淡的黄光。布局如下： 然后A正说着什么问题来着，一道闪电下来，B变成了一个蓝色外皮的人。他的表情、行动和语气都透露出焦灼和愤怒。他（瞬移）到储物柜旁边，转眼之间就翻出了十几个黄色的、像海绵一样的、十厘米左右见方的块状物体，扔到了中间。在看到它们的时候我不知从哪儿就知道了那些是“食物块”。然后B声称，B（未变化之前的本体）十分饥饿。但是B也没有将方块吃掉，而是在不断翻找。 这时候A（也瞬移）过去，又是转眼之间就把其中一些方块随便堆起来弄成了支点，上面放着不知从哪儿来的长木板。看上去像跷跷板，左边接地。 A提议说：“既然这样那我们就来玩一个游戏吧。”B回头：“什么游戏？”我说：“这个游戏我知道，是用来诊断的。……（中间这里忘了说了什么）我们这个世界也很艰难啊。” 然后A叫我坐回去。我的右手多出了也是不知从哪儿来的小玻璃瓶，双臂抱着一个好像是枕头的东西，往后一跳，蜷缩着，把脚也放了上来，靠在了沙发上。这个玻璃瓶我直觉上认为是酒瓶（现实生活中我不到必要时候是不喝酒的），但非常细长，直径大概就五六厘米，长度上，瓶身有十厘米左右，瓶颈也有大概十厘米。在我靠上去的一瞬间，前上方显示出一个饼图，上面有三块，面积大概是（逆时针，0°开始）75%、20%、5%，每一项上写的都是“α -XX%”（“XX”是数字，但我没注意写的是多少）。 我认为这是我的动作对某个方面的影响。我正准备看清这个饼图、想是什么方面的时候，就醒了过来。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"布鲁塞尔的小毛贼","slug":"zh/2017-08-15-Thief-In-Brussels","date":"2017-08-15T15:01:00.000Z","updated":"2020-03-30T22:34:35.443Z","comments":true,"path":"categories/Misc/zh/2017-08-15-Thief-In-Brussels/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2017-08-15-Thief-In-Brussels/","excerpt":"在布鲁塞尔发生的一件不愉快的事。","text":"在布鲁塞尔发生的一件不愉快的事。 晚上从市中心吃完饭回来。我们住在 Bruxelles Midi（=Brussels Zuid=Brussels South），路上要经过一条主要的街道（地图上看了一下，是 Boulevard Maurice Lemonnier）。在快到的时候，大概就在靠南站的广场那边，老爸被一个笑盈盈的人问候了。这个人看上去是本地人（换言之，不是非洲啊中东啊之类的移民），不过肤色偏黑。接下来的故事，根据老爸所说，是这样的—— 我正走着呢，他凑上来，用中文说了一句“你好”。不是很标准，就是“nī hào”那样的。然后就伸出左手。我以为他要和我击掌，所以左手就伸过去了。这个时候他右腿就跨到我双腿之间，拦住我不让我走。我这下就觉得这小子不怀好意，赶忙就不击掌了，左手赶紧往下“刷”地一拍，他右手正在掏我钱包，已经掏出来了。我马上抢回来，用中文大喊一声“你想干什么”。那小子没得手，就退回去了。他过来“问好”的时候我有点放下了警戒心，但是他脚迈过来了——哪有这么问好的嘛！要是他手法再利索一些，或者我反应再慢一些，或者他的手以后撒腿就跑，这就没那么容易拿回来了。 在我的视角是这样的。当时我正在一边走一边给老爸讲如何认路，经过三个靠在街边护栏上的年轻人身边，其中一个就过来了。我是看了一遍地图以后基本上就不用导航的，老爸就只会跟着导航走；恰好苹果的导航很不灵光，所以他不时会走错路。老妈……呃，英文单词也只记得几个，其他语言就更别说了。（我认路不只是用地图，还会用自然辨向、标志物、路牌←词汇现学、车流、路径积分和其他零碎信息，所以不会迷路。）有点远了。当时我们从东北往西南走，在马路的东南侧，我靠马路。那家伙凑过来之后则是刚好在我以老爸为中心的对面。而且我他叫唤的时候我并没有理他，目光一直看着前面，余光观察两边。所以我只看到他开始弯腰，然后突然伸腿，接着就是老爸转身呵斥。老妈一直走在我们后面，老爸转身的时候她也在尖叫。声音一发出来，街上的人目光都往这儿看。所以另外两个也许就是同伙，如果老爸没反应过来，我上去追的话，可能也会被拦下来，这就麻烦了。那家伙悻悻走开之后，走出大概十米多，做了一个手势（我没注意看），并吐了一句FA♂Q。动作我没去注意，但这声音我还是听得很清楚的。这个距离老爸就听不清了（即使听清，在这时候也可能没反应过来吧），老妈是听不懂的。所以后来再讲这事儿的时候，最后这段我就没提，提了对谁都没好处。再往前走不远，护栏上倚着一个中年人，像是中东的（我一样是看着前面，余光扫的），他估计看到了整件事，老爸经过的时候，他对着老爸做出“安静”的手势，“嘘”，意思是不要声张。这位估计是在附近做生意/住的，知道那几个小混混的勾当，但是也不敢惹事。 后来讨论了一下，大概是专门挑亚洲人，甚至中国人下手的。中东都不太可能，因为周围是很多中东人开的店，而他们之间抱团的力量不可小视。 我仍然有点后怕。回到酒店的时候我的呼吸和肌肉反射仍然处于紧张状态。当时我也在怀疑那人想干什么（最初的估计是派传单→_→），但是针对摸口袋的反应却不快（要不就是我来制止了）。我自认为建立起了一套完备的防御体系（想摸我的包？那你得真的足够灵活而且懂得反反跟踪），但当这种事情真的发生的时候，我却在精神上松懈了。 忘记在哪儿看到的了，大概意思是说，如果你带着女朋友去餐馆吃饭，被小混混虎视眈眈（比如准备抢劫）怎么办？不吭声避让吗？练出一身肌肉吗？——不，要赚钱，让她能出入于没有小混混的餐馆。私以为，这个道理同样可以用在父母身上。我一定会实现这个目标。 女朋友？你这个死肥宅怎么会有女朋友？（笑）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"杂记","slug":"zh/2017-07-29-Misc","date":"2017-07-29T13:09:00.000Z","updated":"2020-03-30T22:34:35.443Z","comments":true,"path":"categories/Misc/zh/2017-07-29-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2017-07-29-Misc/","excerpt":"2017年7月26日，爱马仕12周年！","text":"2017年7月26日，爱马仕12周年！ 因为偶然接触到 CGSS，然后过渡到 CG，到本家。（ML 你好惨啊！） 略尝两口后就被折服了。这股巨大的能量是什么？太令人惊叹了。 相比之下，隔壁的暴发户嘴脸愈加明显了。 有点意思的事： 开始玩 CGSS 的时候我还是完全的萌新，连碎片和扭蛋机制都不知道。大手大脚地训练（レッスン）了几次之后：“诶？为什么我的卡越来越少了？”扭蛋则是看到够了250石头（普通单抽的份额）就去单抽，抽出个R还觉得很高兴……后来在活动中打歌掉了一个当期的上位SR（法子），这可是我第一个SR呢，高兴得不得了。后来就习以为常了。 后来一直玩这个号，到了四月还是五月的时候，赶上一周年送2500石头（十连的份额），新号也有，于是就手工抽了35次（当时还没有研究通信这一块，没写刷初始的程序——现在也没有写，只是因为不想刷），抽到了11张SSR。当然是一个号抽出一个，大约三分之二的号是没SSR的。这是一个多月后让欧皇选号的时候发的记录（最后欧皇从别人那儿买了个4SSR的→_→）： 4号抽到的是麻由，很早就自用了，就不提供了。 8号：姬川友纪 14号：佐久间麻由 15号：宫本芙蕾德莉卡 17号：二宫飞鸟 20号：宫本芙蕾德莉卡 23号：星辉子 26号：城崎莉嘉 28号：喜多日菜子 30号：双叶杏 31号：依田芳乃 嗯是的，第一个抽到的是まゆ（これは運命の出会いね、プロデューサーさん。私たちが本当に赤い糸で結ばれた。まゆより），所以就成了まゆP了。就是这样的。唔，要是芳乃不是Pa组、早被抽出而且当时已经付声的话，或许还有一点点的可能性。不过都已经决定了嘛。接着主号就变成了这个开局SSR的了。 后来有了一个平板之后将老号引继到平板上接着玩。第一个抽中的是仁奈。后来在大概十二月，老号也抽出了一张まゆ！考虑到当时已经有许多常驻卡分享那1.5%的概率了，你可以计算一下，在我这个只是兴致来了玩两局的无氪白嫖党（所以《Love∞Destiny》活动排名卡没拿、万圣节限定抽了所有石头没抽出来就作罢了）身上，发生这件事的概率有多大呢。但是它的确发生了。难以置信。 MLTD 开服的时候，是人手送一张SSR的。6选1（ML 三巨头、白石紬、桜守歌織，阁下）。（吐槽：既然都出了阁下的卡，为什么不把本家三巨头出完呢？）在整个765中，我是坚定站千早的，然而里面没有。所以只好退一步，瞄准被钦定的那位吧！抽了十几次都没出。就在我痛斥万代黑心，最后抽一次抽不中就不玩的时候，却中了…… 不过现在 CGSS 已经退坑了，MLTD 也是半退的状态，打歌实在是没时间。 嗯，看来音游，甚至看MV、二次创作等等，这些并不是真正的兴趣。不过仍然有一种宗教般的狂热，让我想把《蒼い鳥》或者《眠り姫》放到 MLTD 里。 那么追求的是什么呢？“构筑-破解”的循环吗？","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"WCF 真乃神器也","slug":"zh/2017-07-29-Amazing-WCF","date":"2017-07-28T20:20:00.000Z","updated":"2020-03-30T22:34:35.442Z","comments":true,"path":"categories/Tech/zh/2017-07-29-Amazing-WCF/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2017-07-29-Amazing-WCF/","excerpt":"受到 uTorrentAPI 的影响，我尝试使用了一下 WCF。之前在老周的一系列文章中读到过一点，不过由于讲的是比较深层的东西，所以感觉云里雾里。这次试用了一下，真是不错。","text":"受到 uTorrentAPI 的影响，我尝试使用了一下 WCF。之前在老周的一系列文章中读到过一点，不过由于讲的是比较深层的东西，所以感觉云里雾里。这次试用了一下，真是不错。 序列化的话，我们知道有 DataContractAttribute 和 DataMemberAttribute。用上这两个特性之后，一个普通类摇身一变，成了一个实体类。其中重要的是的契约（contract）思想，也即声明形式后，填充和检查由框架完成。 所以对应于数据上的实体类，WCF 遵循类似的思想，提出了操作接口。在一个接口上加上 ServiceContractAttribute，给各操作加上的是 OperationContractAttribute。这就相当于借用了接口的“实现”语义，来表达操作的“可用”语义。根据不同的具体操作类别，接口方法还会附加其他的特性。最后根据接口声明，类工厂创建出一个具体的实现以供使用。 多么美妙，这就包含了“描述问题，而不是描述解答过程”的思想。不再需要关心具体的业务逻辑，只需要声明；无法满足要求（如响应错误）时则会立即抛出异常。这样业务逻辑的代码就得到了极大的简化。 本次的软件，我是作为第一次真正的架构设计，认真写了文档的。其中考虑到实际场景，引入了 MEF 进行插件化。MEF 的核心仍然是契约思想——指定 ExportAttribute 和 ImportAttribute，由 MEF 自动在目录（catalog）中进行搜索和实例化。所以我觉得这次的经历改变了我对某些问题的思考方式。 看看我此次的设计。作为实际操作的载体，IUTorrentProxy 被分离了出来，通过一个代理类（NativeUTorrentClient）进行产生和调用。 图1 新版 UML 图（部分） 接口（IUTorrentProxy）声明（部分）： [JsonResponse] [OperationContract] [WebGet( BodyStyle = WebMessageBodyStyle.Bare, ResponseFormat = WebMessageFormat.Json, UriTemplate = &quot;/gui/?action=getsettings&quot;)] [NotNull] JsonObject GetSettings(); [OperationContract] [WebGet( BodyStyle = WebMessageBodyStyle.Bare, ResponseFormat = WebMessageFormat.Json, UriTemplate = &quot;/gui/?action=setsetting&amp;s={settingName}&amp;v={settingValue}&quot;)] [NotNull] EmptyResponse SetSetting([NotNull] string settingName, [NotNull] string settingValue); 使用（UTorrentClient）： public override string GetAutoLoadPath() { EnsureTokenIsNotNull(); var obj = _nativeClient.Proxy.GetSettings(); var settings = (JsonArray)obj[&quot;root&quot;][&quot;settings&quot;]; foreach (var t in settings) { var tuple = (JsonArray)t; var key = tuple[0]; if (key == UTorrentSettingKeys.DownloadPath) { string downloadPath = tuple[2]; return downloadPath.Replace(@&quot;\\\\&quot;, @&quot;\\&quot;); } } return null; } public override bool SetAutoLoadPath(string path) { EnsureTokenIsNotNull(); if (path.Length &gt; 0) { path = Path.GetFullPath(path); } _nativeClient.Proxy.SetSetting(UTorrentSettingKeys.DownloadPath, path); var setPath = GetAutoLoadPath(); return setPath == path; } 注意 IBtClient 才是本工程中对各 BT 客户端的操作的抽象，所以在更上一层的调用中调用的是 IBtClient 的方法，接着分发到 IUTorrentProxy 的方法。 以前的架构是这样的： 图2 旧版 UML 图（部分） 不同在于，中间有一个 WebAccessBase 层。这个类的作用就是提供一些 protected 函数和字段，专门用于网络访问（因为可能要涉及 cookie 等与状态相关的东西）。 使用上： public override string GetAutoLoadPath() { EnsureTokenIsNotNull(); var options = Options; var uri = Uris.GetSettings(options.BaseUri, Token); var responseText = HttpGetGetText(uri); if (responseText == null) { return string.Empty; } if (!DownloadPathRegex.IsMatch(responseText)) { return string.Empty; } var downloadPathMatch = DownloadPathRegex.Match(responseText); var downloadPath = downloadPathMatch.Groups[&quot;value&quot;].Value; if (string.IsNullOrEmpty(downloadPath)) { return string.Empty; } return downloadPath.Replace(@&quot;\\\\&quot;, @&quot;\\&quot;); } public override bool SetAutoLoadPath(string path) { EnsureTokenIsNotNull(); path = Path.GetFullPath(path); var options = Options; var uri = Uris.SetSetting(options.BaseUri, Token, UTorrentSettingKeys.DownloadPath, path); HttpGetAndDone(uri); var setPath = GetAutoLoadPath(); return setPath == path; } 嗯？HttpGetAndDone() 不是很简单么？不，这展开那代码和抛异常就多了。然而这些异常本来也应该属于标准过程的一部分，因为响应是要符合数据契约的，手写解析代码难以验证，容易错漏。比如，网络超时是不是要抛出异常？报文过长是不是要抛出异常？流读取过程中出错（比如编码无法识别）是不是要抛出异常？反序列化过程中结果不符是不是要抛出异常？如此等等。每一处都要好好想可能发生的情况，然后决定抛出什么样的异常，附加消息是什么，异常链上种类是否太多……头疼。 可以见到，旧版本中间被许多额外的代码干扰了。比如值的检测、URI 生成、状态管理（见 Token）。为什么新的实现少了这些东西呢？其实没少，只不过移动到了其他的地方。比如 token 的管理，就是由 IOperationBehavior.ApplyClientBehavior() 进行拦截和储存（到一个实现了 IChannel 接口的匿名类型的字段中），然后由 IContractBehavior.ApplyServerBehavior() 进行对请求的修改（查询字符串中加入 token=...）。这个 token 的验证机制是在背后通过这种过滤器管道来完成的，所以在业务代码中觉察不到它的存在——也不需要关心。（不过这个方法和 WCF 方面的代码不是我的，是 uTorrentAPI 的作者 Mike Davis 写的。这些代码正好给我作为 WCF 方面的入门材料来学习。） JSON 的反序列化也是类似的，这里就不举出例子了。 所以你看，只要实现了合适的特性，贴上去，就可以对通信报文进行加工，从而远程调用就变得跟本地调用一样简单——RPC 的精髓嘛。在 WCF 的架构下消息定制化十分自然，契约化的思想、加工管道的设计，太美妙了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"架构","slug":"架构","permalink":"https://blog.mottomo.moe/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"Reverse Engineering on MLTD: HCA Key Extraction","slug":"en/2017-06-30-MLTD-HCA-Key-Extraction","date":"2017-06-30T03:46:00.000Z","updated":"2020-03-30T22:34:35.362Z","comments":true,"path":"categories/Tech/RE/en/2017-06-30-MLTD-HCA-Key-Extraction/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/en/2017-06-30-MLTD-HCA-Key-Extraction/","excerpt":"中文版见这里。 THE iDOLM@STER Million Live Theater Days (abbreviation: MLTD) went online on June 28 (UTC +01:00). Similar to its sister app CGSS, it uses CRI Middleware’s audio solution. More specifically, encrypted HCA audio. We must obtain the decryption key to reveal the contents of those audio files. In this article, we discuss the concept and procedure of obtaining the key. Beware, MLTD does not have a game library for X86 processors, and it requires OpenGL ES 3.0. Don’t be surprised. So we cannot run it on normal Android emulators (there is one but it brings other restrictions), and we have to face ARM assembly language instead of usual X86 assembly language. I wrote this article to share the thoughts and the method I used. I appreciate the way of hackers in 1960s-1970s. Challenging and sharing. Exciting. Hope this article lights up more inspirations.","text":"中文版见这里。 THE iDOLM@STER Million Live Theater Days (abbreviation: MLTD) went online on June 28 (UTC +01:00). Similar to its sister app CGSS, it uses CRI Middleware’s audio solution. More specifically, encrypted HCA audio. We must obtain the decryption key to reveal the contents of those audio files. In this article, we discuss the concept and procedure of obtaining the key. Beware, MLTD does not have a game library for X86 processors, and it requires OpenGL ES 3.0. Don’t be surprised. So we cannot run it on normal Android emulators (there is one but it brings other restrictions), and we have to face ARM assembly language instead of usual X86 assembly language. I wrote this article to share the thoughts and the method I used. I appreciate the way of hackers in 1960s-1970s. Challenging and sharing. Exciting. Hope this article lights up more inspirations. 1. PreludeIn the old times, we can easily use Debug.Log() function provided by Unity to print out the key. This method is based on modifications on CLR assemblies. However, beginning from version 3.0.3, CGSS chose IL2CPP backend instead of Mono backend for code generation. So, bye-bye, CIL assemblies, and hello, libil2cpp.so. The latter contains pseudo-native machine code, which is much harder to read (in ARM assembly code), and nearly impossible to modify (unless some rare conditions are met). The initial release date of MLTD is later than the release of CGSS 3.0.3, and MLTD, unfortunately, also chose IL2CPP as its backend. Therefore, we can’t play the old trick anymore. We need a new weak spot. Now let’s begin our journey to take down the fortress. 2. Problem AnalysisThe audio part, CRI Middleware’s library, is independent. It is MLTD who integrates the library as one of its external components, instead of performing joint compilation of the library’s source code and the game’s code (after being processed by IL2CPP). So the CRI library will stay independent as a native library, and the game, developed in Unity running on CLR, must interop with the CRI library. Unity is cross-platform so C++/CLI is not a choice. The winner is: P/Invoke. In a P/Invoke procedure, CLR loads target native library, finds the external function, marshals data types from the CIL program, calls the function, and marshals back the return value and other values on stack. Now you see, the main program and the external library are separated, and CLR has no idea what the target library looks like. Compared to web communications, it is intuitive that an MITM attack should work. The people in Figure 1 are all famous ones appeared in cryptography. Cute little symbols. Now think about this: where should Eve be? Independent, inside Alice, or inside Bob? If the MITM part is not independent, we have to modify the code of the one it is in. It will be very, very painful. Remember, they are all native libraries. Actually we have no choice, but to make Eve independent. 3. Technical AnalysisNow that we have the concept, and what the technology it will be used against, let’s find a proper technical solution. It is quite straightfoward, per se. Eve will become a proxy library. As a hardworking eardropper, Eve will forward all function calls to the geniune library. She monitors the functions in which she’s interested, and secretly records the information passed on to these functions. In our case, the target function is criWareUnity_SetDecryptionKey(). Thanks to CRI Middleware, it provides a free SDK (with limited functionalities and a grace period) in which there are plenty of documents. Most definitions of the APIs of libcri_ware_unity.so can be found in there. For the rest, they can be completed by looking through IDA. Why don’t you use auto injection? I don’t think there is such a framework for ARM EABI programs for Android. 4. Precondition: Import TableSince the assembly is processed by IL2CPP, I wondered if the P/Invoke functions are converted to direct calls to target libraries, via a standard compile-link procedure. If this is the case, IL2CPP will definitely write the information into the import table and the entries may cause some troubles. This is proved to be false simply by checking it by readelf. No extra entries are found. Later when I digged into the assembly code, it appears that a dlopen()-dlsym()-dlclose() process is used in every P/Invoke function call. 5. ImplementationWell, if you have enough programming experience, this is the easiest step. Just make a proxy library that conforms all APIs of the geniune library. Pay attention to library file names and that’s all. For example, criAtomUnity_Initialize(). Declaration: CA(uint32_t) criAtomUnity_Initialize(); Definition: uint32_t criAtomUnity_Initialize() { CR(criAtomUnity_Initialize); return 0; } Definition of CR macro: #define CR(method, ...) \\ do { \\ try_load_lib(__func__); \\ DEBUG_LOG(&quot;Function call: %s&quot;, __func__); \\ if (CW_API_OBJECT_NAME . method) { \\ return CW_API_OBJECT_NAME . method(__VA_ARGS__); \\ } \\ } while (false) CA macro is a shorthand to declare API. A global function object is used in order to unify call attachment statements to one macro. All the information can be found in the source code. If you compare the declaration of criAtomUnity_Initialize() in the documents with its real form in IDA, you will probably notice that they have different return types (void vs. int32). This difference does not matter if the return value is not needed in game. Yes, conform with the game, and optionally, external libraries. This is because those functions follow CDECL calling convention: call stack is cleaned up by the caller. Also, note that the program is designed for ARM architecture, so the return value is passed by register R0 (and R1 if the value is 64-bit). So if we call a function returning int32 as if it returns void, we are simply ignoring the value of R0. Don’t worry, any conservative compiler will save the value of R0 and restore it after the call, so chained int32-void calls will not become a mess. 6. Packing UpCollect the libcri_ware_unity.so we compiled, rename the geniune one according to what it is expected to be, and place the proxy at the original position of the geniune one. After that, pack up and sign the APK. 7. Debugging and Collecting the OutputsUse adb logcat. I also recommend Android Monitor in Android Studio because it saves lots of efforts and have a much friendlier UI. Here it goes. Hacking to the Gate. 06-29 19:35:25.846 28259-28287/? I/fakecri: CriWare hack: loaded. 06-29 19:35:25.853 28259-28287/? I/fakecri: On load: lib handle = 0xae6ae004 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol JNI_OnLoad ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol JNI_OnLoad: address = 0x939bf601 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol JNI_OnUnload ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol JNI_OnUnload: address = 0x0 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol criAtomUnity_SetConfigParameters ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol criAtomUnity_SetConfigParameters: address = 0x939bf681 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol criAtomUnity_SetConfigAdditionalParameters_IOS ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol criAtomUnity_SetConfigAdditionalParameters_IOS: address = 0x939bf6fd 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol criAtomUnity_SetConfigAdditionalParameters_ANDROID ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol criAtomUnity_SetConfigAdditionalParameters_ANDROID: address = 0x939bf701 ... 06-29 19:35:25.866 28259-28287/? I/fakecri: Function call: criWareUnity_GetVersionNumber 06-29 19:35:25.867 28259-28287/? I/fakecri: Function call: criFsUnity_SetConfigParameters 06-29 19:35:25.867 28259-28287/? I/fakecri: Function call: criFsUnity_SetConfigAdditionalParameters_ANDROID 06-29 19:35:25.867 28259-28287/? I/fakecri: Function call: criFsUnity_Initialize 06-29 19:35:25.877 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigParameters 06-29 19:35:25.878 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigAdditionalParameters_PC 06-29 19:35:25.879 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigAdditionalParameters_IOS 06-29 19:35:25.896 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigAdditionalParameters_ANDROID 06-29 19:35:25.896 28259-28287/? I/fakecri: Function call: criAtomUnity_Initialize 06-29 19:35:25.908 28259-28287/? I/fakecri: Function call: criAtomEx3dListener_Create 06-29 19:35:25.909 28259-28287/? I/fakecri: Function call: criWareUnity_SetRenderingEventOffsetForMana 06-29 19:35:25.909 28259-28287/? I/fakecri: Function call: criManaUnity_SetConfigParameters 06-29 19:35:25.912 28259-28287/? I/fakecri: Function call: criManaUnity_SetConfigAdditionalParameters_ANDROID 06-29 19:35:25.912 28259-28287/? I/fakecri: Function call: criManaUnity_Initialize 06-29 19:35:25.921 28259-28287/? I/fakecri: Intercepted decryption key: (yep, here) 06-29 19:35:25.936 28259-28287/? I/fakecri: Function call: criWareUnity_Initialize 06-29 19:35:25.937 28259-28287/? I/fakecri: Function call: criWareUnity_SetForceCrashFlagOnError ... Then it crashes. But hey, we already got what we came for. Time to retreat. :P Writing detailed logs will help you in debugging. For example, the exact location of loading or calling failures. The default try-catch in IL2CPP’s P/Invoke template also helps. (Sweet!) The key turned out to be an interesting number. You will be amused if you are an iDOLM@STER fan. In the comments under the Chinese version of this article, logchan said another guy retrieved the key by only proxying the target call (i.e. criWareUnity_SetDecryptionKey()). I proxied all the APIs the game used. Since I don’t have much experience in remote debugging, especially a ARM library on IDA, I don’t quite understand how he did it, if he didn’t modify the constants table and some code in the game library.","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://blog.mottomo.moe/tags/Reverse-Engineering/"},{"name":"English Version","slug":"English-Version","permalink":"https://blog.mottomo.moe/tags/English-Version/"},{"name":"HCA","slug":"HCA","permalink":"https://blog.mottomo.moe/tags/HCA/"},{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"}]},{"title":"MLTD 逆向实录：提取 HCA 密钥","slug":"zh/2017-06-30-MLTD-HCA-Key-Extraction","date":"2017-06-30T03:46:00.000Z","updated":"2020-03-30T22:34:35.442Z","comments":true,"path":"categories/Tech/RE/zh/2017-06-30-MLTD-HCA-Key-Extraction/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2017-06-30-MLTD-HCA-Key-Extraction/","excerpt":"Click here to view the English version. MLTD（THE iDOLM@STER Million Live Theater Days，偶像大师百万演唱会剧场时光，俗称“麻辣土豆”）在6月28日（欧洲时间）正式上线了。在音频上，它使用的还是 CGSS 那一套 CRI Middleware 的技术，音频编码为 HCA。自然，这个 HCA 也是加密的，需要密钥解密。在昨天下午（欧洲时间，国内时间为6月30日凌晨），我成为了世界上第一个取得其密钥的人，然后这个密钥扩散到了日本和美国（似乎吧；我忘了triangle是在哪里的了）加拿大（感谢caimiao说明）的开发者手中。嗯，“第一个攻破”，这个感觉不错。上世纪六七十时代的先锋黑客们感受到的应该就是这种心情吧。 在这篇文章里，我就讲一下这次我是怎么取得密钥的。","text":"Click here to view the English version. MLTD（THE iDOLM@STER Million Live Theater Days，偶像大师百万演唱会剧场时光，俗称“麻辣土豆”）在6月28日（欧洲时间）正式上线了。在音频上，它使用的还是 CGSS 那一套 CRI Middleware 的技术，音频编码为 HCA。自然，这个 HCA 也是加密的，需要密钥解密。在昨天下午（欧洲时间，国内时间为6月30日凌晨），我成为了世界上第一个取得其密钥的人，然后这个密钥扩散到了日本和美国（似乎吧；我忘了triangle是在哪里的了）加拿大（感谢caimiao说明）的开发者手中。嗯，“第一个攻破”，这个感觉不错。上世纪六七十时代的先锋黑客们感受到的应该就是这种心情吧。 在这篇文章里，我就讲一下这次我是怎么取得密钥的。 一、背景在 CGSS 版本3.0.3（后来撤回了，3.0.1不更新到此版本，直接跳到3.0.4）这个“小”更新中，Cygames 引入了重磅的功能：Unity 版本大更新，同时编译器后端换成了 IL2CPP。（semver：你在逗我吗！）前者不打紧，后者是要命了。原来修改方便的程序集，突然就成了原生动态库。稍微有点两边经验的人都知道，汇编的阅读和修改难度都比 CIL 高到不知哪里去了。原因包括优化跳转、（全局）堆访问（这是 CIL 不具备的）和紧缩的代码空间。CGSS 在3.0.3推出了这个更新，紧随其后发布的 MLTD 一上来就这么干了。嘛，这是手游界的趋势，IL2CPP 运行效率更高，查看和修改更困难，同时不需要修改源代码，有源代码的那一方不会有额外的麻烦，对于开发公司来说有百利而无一害。为什么不用呢，对不。 还记得之前我们是怎么提取密钥的吗？对，加 Debug.Log() 的调用。而且写那篇文章的时候我只知道 ILSpy，所以才要用到底层的 CIL 修改；后来我知道了 dnSpy，借助 Roslyn，修改的时候直接写 C# 代码就可以，门槛一下子就没有了。门槛没有了，方便的还是修改器的制作者，所以 CGSS 的外挂会那么猖獗——懂一点 C#，用个 dnSpy 都可以改。所以你看，滤网口太宽，有些渣渣就混进来了。在 IL2CPP 应用之后，哀鸿遍野，里面许多人就是这个表情： 所以说，作弊有意思吗？没有。 现在问题来了，加 Debug.Log() 这条路，因为机器码的紧凑而基本上被堵死了。该怎么办？ 二、思路思路这东西是最重要的，它是经验的结晶，同时又是迈向下一个高峰的路。我能第一个提取出密钥，我认为有三个条件： 内在的技术理论体系； 敢开脑洞； 开完脑洞要有能力将其实现。 听起来好像是自恋的人在自吹……算了不吐槽这个。讲正题。 2.1 抽象部分或许你会说，密钥，会不会嵌入在代码中呢？答案是，不会。我之前也有这样的疑问：为什么代码中明明没设置 enableAtomDecryption，解密却能正常进行呢？后来结合一点点 Unity 的知识、ADX2LE SDK 中的示例工程和代码中提示了的结构，在原工程中，一定存在着一个 GameObject。这个 GameObject 上附加的是控制逻辑（由此 Atom 之类的组件能随着游戏每帧正常更新）和设置信息。也就是说，那几个选项是附加在这个对象上的，在游戏初始化的时候随着 Unity 加载场景而自动反序列化字段，设置对应值。所以插件代码中不会出现这些值的设置逻辑。 既然 Debug.Log() 不行了，那就找其他的日志记录方式嘛。不管是哪一种方法，核心的原理都是拦截对 criWareUnity_SetDecryptionKey 这个 API 的调用，从而得到密钥。当然，前提也是 libcri_ware_unity 内部不会对这个值进行二次加/解密。 方法呢，按照修改的部分，分为三种： 修改主程序（libil2cpp.so）； 修改音频库（libcri_ware_unity.so）； 不在任何一边。 按照修改的手段，分为三种： 替换指令； 插入指令； 其他。 明眼人应该一眼就知道哪些组合是走不通的。不是真的走不通，而是工程上绝对的不划算。 最后剩下了一个方案，选项3×选项3。可以吗？可以！ 得到的结果是什么呢？中间人攻击在动态库加载上的应用。 方法不算太偏门。而且，只要没有二次加/解密和动态库完整性校验，就是畅通无阻的。工程量和 API 数量、参数复杂度成正比，libcri_ware_unity.so 相对简单，所以可以手工写。更复杂的话我觉得可以借助 IDA 脚本来生成。（待学） 2.2 细节我们已知，在游戏运行时会加载 libcri_ware_unity.so 这个动态库。是怎么加载的呢？是通过名称找到的。这个名称指定在 DllImport 特性（attribute）中，是编译后不可变的。那么，我们只要伪造一个 libcri_ware_unity.so，在我们自己的库中暴露原有的 API，对这些接口的调用则转接到真正的动态库上。然后在对应的 criWareUnity_SetDecryptionKey() 中插入自己的日志代码，记录密钥，就可以了。 流程图如下： 为什么不用代码注入呢？嗯……要注入的是一个 ARMv7a 下的动态库（因为工具限制，见下文），我不会。╮(╯▽╰)╭好像也没有自动化工具来做这事儿吧。（要是谁知道请告诉我，谢谢！） 三、修改流程虽然思路有了，但是实际的操作过程仍然是很麻烦的。下面我慢慢讲解。 3.1 验证导入表我有个担心，libil2cpp.so 既然是原生库，那么其 P/Invoke 就有可能添加导入表信息。我们可能需要修改导入表，让其加载的是我们自己的动态库而不是真正的那个。不过这个担心是完全不必要的： admin@MACHINE:/mnt/c/Users/admin/Desktop/mltd/v106$ readelf -d libil2cpp.so Dynamic section at offset 0x21c3df4 contains 23 entries: 标记 类型 名称/值 0x00000001 (NEEDED) 共享库：[libstdc++.so] 0x00000001 (NEEDED) 共享库：[libm.so] 0x00000001 (NEEDED) 共享库：[libdl.so] 0x00000001 (NEEDED) 共享库：[libc.so] 0x0000000e (SONAME) Library soname: [libil2cpp.so] ... （赞美 WSL！） 可以看到，它的导入表中的依赖项并没有发生变化，所以我们就不用改了。 不过正好，来都来了，我们就来看看其中的 P/Invoke 长什么样子吧。 说到 P/Invoke，Unity 的博客上是对此有一些讲解的。其实稍微了解点 Unix 系统就会知道，这样的特性，是离不开 dlopen() 的。好，我们就以 dlopen 这个符号为切入点，看看能挖到什么。打开 IDA，在导出符号中选择 dlopen，用 Xref 菜单项（键盘 x 键）跳转几次，就会发现我们的目标函数，位于 01C2A218h。从它的调用规范和后面的逻辑来看，原型是这样的： int32_t call_lib_function(LPCSTR name); 在这个函数上继续 Xref，展现出了一大片的调用者。中大奖了！ 举个例子感受一下： .text:0152BF9C CriFsUtility$$criFsUnity_SetProxyServer ; CODE XREF: CriFsUtility$$SetProxyServer+90\u0018p .text:0152BF9C ; DATA XREF: .data.rel.ro:021751C4\u0019o .text:0152BF9C STMFD SP!, {R4-R7,R11,LR} .text:0152BFA0 ADD R11, SP, #0x10 .text:0152BFA4 SUB SP, SP, #0x20 .text:0152BFA8 LDR R0, =(_GLOBAL_OFFSET_TABLE_ - 0x152BFC0) .text:0152BFAC MOV R4, R2 .text:0152BFB0 LDR R6, =0xD8924 .text:0152BFB4 MOV R5, R1 .text:0152BFB8 ADD R0, PC, R0 ; _GLOBAL_OFFSET_TABLE_ .text:0152BFBC ADD R0, R6, R0 .text:0152BFC0 LDR R0, [R0,#(dword_229C954 - 0x229C7F0)] .text:0152BFC4 CMP R0, #0 .text:0152BFC8 BNE loc_152C030 .text:0152BFCC LDR R0, =(_GLOBAL_OFFSET_TABLE_ - 0x152BFDC) .text:0152BFD0 LDR R1, =0xFFBD9A3E .text:0152BFD4 ADD R0, PC, R0 ; _GLOBAL_OFFSET_TABLE_ .text:0152BFD8 LDR R2, =0xFFBDA143 .text:0152BFDC ADD R1, R1, R0 .text:0152BFE0 STR R1, [SP] .text:0152BFE4 MOV R1, #0xE .text:0152BFE8 ADD R7, R6, R0 .text:0152BFEC STR R1, [SP,#4] .text:0152BFF0 ADD R1, R2, R0 .text:0152BFF4 STR R1, [SP,#8] .text:0152BFF8 MOV R1, #0x19 .text:0152BFFC STR R1, [SP,#0xC] .text:0152C000 MOV R1, #0 .text:0152C004 MOV R2, #1 .text:0152C008 STR R1, [SP,#0x10] .text:0152C00C STR R2, [SP,#0x14] .text:0152C010 MOV R2, #8 .text:0152C014 MOV R0, SP .text:0152C018 STR R2, [SP,#0x18] .text:0152C01C STRB R1, [SP,#0x1C] .text:0152C020 BL call_lib_function .text:0152C024 STR R0, [R7,#(dword_229C954 - 0x229C7F0)] .text:0152C028 CMP R0, #0 .text:0152C02C BEQ loc_152C074 （问：为什么你能看到部分的名称呢？答：自然是这个啦！不过它只能用于 ARM 部分，不能用于其他架构。） 注意这是 ARM 汇编，BL 指令相当于 X86 汇编的 CALL 指令。每个 P/Invoke 函数都有类似的桩（stub），而 call_lib_function() 中有一个完整的 dlopen()-dlsym()-dlclose() 操作，这样就可以放心下结论了：加载动态库是每次 P/Invoke 时进行的，是一个动态过程。导入表真的不用管了。 3.2 编写代理库这一步难度不大，就是个体力活。 由于要代理的是 libcri_ware_unity.so，就要知道它的 API。嘛，只看着 IDA 来的话，数量众多的函数会吓到人的。于是我打开2.9.0的程序集，根据里面的声明抄了一份。 声明： CA(uint32_t) criAtomUnity_Initialize(); 实现： uint32_t criAtomUnity_Initialize() { CR(criAtomUnity_Initialize); return 0; } CR 宏的定义： #define CR(method, ...) \\ do { \\ try_load_lib(__func__); \\ DEBUG_LOG(&quot;Function call: %s&quot;, __func__); \\ if (CW_API_OBJECT_NAME . method) { \\ return CW_API_OBJECT_NAME . method(__VA_ARGS__); \\ } \\ } while (false) 这里面有几个 C++ 的技巧，就不细讲了。可以参考源代码来理解。 底层的调用其实就是每个函数通过 dlsym() 得到地址，然后调用。初始化参考 hacklib.cpp 中的 r 宏。 为什么每次都要有个 try_load_lib() 呢？因为我必须在第一次调用时加载动态库，并初始化代理。而我并不能保证一开始被调用的是哪个函数，所以每次都有初始化的流程。当然是有缓存的。而 DEBUG_LOG 宏的作用是调试，因为 MLTD 所使用的 libcri_ware_unity.so 版本比 CGSS 的2.9.0要新，在调用过程中可能会有错误，造成程序崩溃。因此打印最后调用的函数名，可以让我猜测是哪个函数出的问题，然后结合 IDA 进行修正。（实际过程中，必须尽快结束进程，否则会被 criWareUnity_GetFirstError() 给刷屏。）都是血与泪的经验。 调试过程也是挺艰苦的，从一开始直接崩溃（其实是我一个解引用写错了），到开始有输出，到最后获得想要的东西，其中的酸甜苦辣得亲身体验才能知晓。有些函数还真的是发生了变化，或者添加了新的函数，这些就要看着 IDA 来改了。 如果你阅读一下源代码，并和 IDA 与 P/Invoke 的版本做个比较，可能会发现这样一个问题：有些函数的声明返回类型不一致。就拿上面的 criAtomUnity_Initialize() 函数来说，它在 P/Invoke 中的返回类型是 void。这个有影响吗？全以 P/Invoke 为标准的话，是没有问题的；P/Invoke 要 void 实际返回一个32位整数也是没问题的。因为 Android 使用的是 cdecl 调用标准，调用者清理栈；而函数的返回值，如果是32位以内，是通过 R0 传递的（注意我们讨论的是 ARM，X86 中是 EAX）。P/Invoke 声明 void，实际上就是不管 R0 的值的意思。所以我们这边返回还是不返回 R0，都没有影响。不过要是 P/Invoke 需要返回值，那就得按照它那个来。 3.3 打包打包这一步以前也讲过了，不再赘述。 3.4 调试和收集输出开始我还用的是 adb logcat，不过不久之后我就发现 Android Studio 的 Android Monitor 明显更好用。总之，设置合适的过滤器，等着就行了。要注意的是 Unity 的消息（如找不到入口点，需要补充）和我们自己的库的消息。要是程序在某处抛出异常了，根据最后调用记录去找，并修改为合适的定义。 四、结果结果输出，各位感受一下： 06-29 19:35:25.846 28259-28287/? I/fakecri: CriWare hack: loaded. 06-29 19:35:25.853 28259-28287/? I/fakecri: On load: lib handle = 0xae6ae004 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol JNI_OnLoad ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol JNI_OnLoad: address = 0x939bf601 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol JNI_OnUnload ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol JNI_OnUnload: address = 0x0 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol criAtomUnity_SetConfigParameters ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol criAtomUnity_SetConfigParameters: address = 0x939bf681 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol criAtomUnity_SetConfigAdditionalParameters_IOS ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol criAtomUnity_SetConfigAdditionalParameters_IOS: address = 0x939bf6fd 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolving symbol criAtomUnity_SetConfigAdditionalParameters_ANDROID ... 06-29 19:35:25.853 28259-28287/? I/fakecri: Resolved symbol criAtomUnity_SetConfigAdditionalParameters_ANDROID: address = 0x939bf701 ... 06-29 19:35:25.866 28259-28287/? I/fakecri: Function call: criWareUnity_GetVersionNumber 06-29 19:35:25.867 28259-28287/? I/fakecri: Function call: criFsUnity_SetConfigParameters 06-29 19:35:25.867 28259-28287/? I/fakecri: Function call: criFsUnity_SetConfigAdditionalParameters_ANDROID 06-29 19:35:25.867 28259-28287/? I/fakecri: Function call: criFsUnity_Initialize 06-29 19:35:25.877 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigParameters 06-29 19:35:25.878 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigAdditionalParameters_PC 06-29 19:35:25.879 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigAdditionalParameters_IOS 06-29 19:35:25.896 28259-28287/? I/fakecri: Function call: criAtomUnity_SetConfigAdditionalParameters_ANDROID 06-29 19:35:25.896 28259-28287/? I/fakecri: Function call: criAtomUnity_Initialize 06-29 19:35:25.908 28259-28287/? I/fakecri: Function call: criAtomEx3dListener_Create 06-29 19:35:25.909 28259-28287/? I/fakecri: Function call: criWareUnity_SetRenderingEventOffsetForMana 06-29 19:35:25.909 28259-28287/? I/fakecri: Function call: criManaUnity_SetConfigParameters 06-29 19:35:25.912 28259-28287/? I/fakecri: Function call: criManaUnity_SetConfigAdditionalParameters_ANDROID 06-29 19:35:25.912 28259-28287/? I/fakecri: Function call: criManaUnity_Initialize 06-29 19:35:25.921 28259-28287/? I/fakecri: Intercepted decryption key: (嗯) 06-29 19:35:25.936 28259-28287/? I/fakecri: Function call: criWareUnity_Initialize 06-29 19:35:25.937 28259-28287/? I/fakecri: Function call: criWareUnity_SetForceCrashFlagOnError ... 虽然最后还是崩溃了（接下来就是 criWareUnity_GetFirstError 大军），但是我已经得到了想要的东西。撤退！ 密钥是一个挺有意思的数字。当我把密钥给开发群里的人看的时候，他们都笑出了声。 后记： CGSS 3.0.4 已经有了自动全p的挂了。原因是改这一项只需要改一个数字，能在汇编的限制下进行。 听说 MLTD 在某宝上已经有刷初始的工具了。啧啧啧，高效率啊，你们。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"HCA","slug":"HCA","permalink":"https://blog.mottomo.moe/tags/HCA/"},{"name":"MLTD","slug":"MLTD","permalink":"https://blog.mottomo.moe/tags/MLTD/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"}]},{"title":"微吐槽","slug":"zh/2017-05-06-Cygames-Bad-Naming","date":"2017-05-06T14:01:00.000Z","updated":"2020-03-30T22:34:35.442Z","comments":true,"path":"categories/Misc/zh/2017-05-06-Cygames-Bad-Naming/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2017-05-06-Cygames-Bad-Naming/","excerpt":"","text":"CGSS 的master数据库的 live_detail 表里，有几个带“guerrilla”字样的列。研究数据结构的时候，第一眼看上去并不知道这是什么——一个萌妹子音游，和游击队有什么关系？转了好大个弯之后才明白过来，原来这是日替（每隔一段时间轮换的曲目）的意思……这么一想，大概就是取其中的“运动”义吧。 这一条可能需要先了解 CGSS 的玩法，才知道我说的都是什么东西。服务器 API 里有一个 /live/supporter，这个是对应在选歌之后选嘉宾（guest）的。这次通信在对应的通信实体类为 LiveFriendListTask（响应体，主要是其对 Parse() 方法的重载）和 LiveFriendListTaskParam（请求体）。在 UI 中，对应的是 LiveSelectGuestSelectList 类。而“supporter”，也就是“支援”，在游戏中是有其他意义的，就是那10个不上场、用援力加分的爱抖露，相关方法如 WorkDataUtil.GetSupporterList()。你看，有意思吧？三种称呼。我不知道这是否是一种人肉混淆法，反正它在反向的时候对我的精神造成了极大的损害。Cygames 的家伙们对这乱七八糟的分布，估计看着文档也够呛。 CGSS 目前有5种活动类型：传统活动、大篷车（caravan）、3+1（live groove）、协力（little party）、公演（live parade）。它们在代码中的名称分别为 atapon、caravan、medley、multiparty 和 tour。转晕了没？虽说我一开始并不需要知道哪个是哪个，但后来因需求，得分清了，所以琢磨了一下。问我为什么传统活动叫做 atapon？我认为是这样的：atapon 是“アタシポンコツアンドロイド”（Atashi Ponkotsu Android）的简称，而根据百科这是第一期传统活动的活动曲，写的人绞尽脑汁想不出合适的词，因此代码命名就这么定下来了。虽然现在你们看不到了，但是以前 atapon 可是曾经骄傲地拥有一整个命名空间的，非常抢镜。 不是我黑，但是上面的例子看起来都像是临时工的大作。真的。 当然，这不影响万代躺着数钱。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Git 在远程创建孤儿分支并推送","slug":"zh/2017-03-05-Git-Create-and-Push-to-Remote-Orphan","date":"2017-03-05T14:29:00.000Z","updated":"2020-03-30T22:34:35.442Z","comments":true,"path":"categories/Tech/zh/2017-03-05-Git-Create-and-Push-to-Remote-Orphan/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2017-03-05-Git-Create-and-Push-to-Remote-Orphan/","excerpt":"今天有一个需求。本地有一个代码库，我希望推送到自己的远程代码库的master（A/proj.git）作为存储；同时还要发布到另一个人的远程代码库，作为一个全新的、不带他的提交历史的分支（B/proj2.git），因为二者文件完全不相关。不过，B/proj2的feat分支现在并不存在。首先想到的方案就是，在B上创建一个孤儿（orphan）分支 feat，然后本地master直接 git push B feat 不就好了？嘛，被 Git 的各种机制坑了。 PS. 2016年8月到今年1月的文章，以后会放上来……","text":"今天有一个需求。本地有一个代码库，我希望推送到自己的远程代码库的master（A/proj.git）作为存储；同时还要发布到另一个人的远程代码库，作为一个全新的、不带他的提交历史的分支（B/proj2.git），因为二者文件完全不相关。不过，B/proj2的feat分支现在并不存在。首先想到的方案就是，在B上创建一个孤儿（orphan）分支 feat，然后本地master直接 git push B feat 不就好了？嘛，被 Git 的各种机制坑了。 PS. 2016年8月到今年1月的文章，以后会放上来…… 我进行了这样的操作： git remote add origin A/proj.git git push -u origin 好，到这里都没问题。我已经在远程（BitBucket）上创建了 proj 这个项目，推送没问题。然后到了开orphan分支的事情了。然而 BitBucket 不支持创建孤儿分支（GitHub 也不支持），只支持从master创建新分支。那只好手工上了。 git remote add r B/proj2.git git push r +feat 我觉得，既然在本地创建了远程B，我的master分支应该不用跟踪proj2就能推送（而且我也不希望master跟踪proj2）才对。于是收到了报错： error: src refspec feat does not match any. error: failed to push some refs to &#39;B/proj2.git&#39; 我对 Git 分支的表示有略微了解，大概就是某个 refs/... 下的东西。于是略微谷歌一下，找到了一篇 StackOverflow 上的回答。照葫芦画瓢： git push r r:refs/heads/feat 然而又收到了一样的错误。哎，先将目标定为创建一个 B/proj2 的孤儿分支吧。遵循指导（1和2），在新的目录下： git clone B/proj2.git git checkout --orphan feat git rm -rf . 好了，到这里我觉得可以直接发布分支了，于是尝试： # 此时我是在刚clone下来的目录内 git push origin feat 然而无法推送。想了想，是因为没有提交吧！添加了一个空文件后提交，推送成功。此时 B/proj2 上出现了一个孤儿分支feat，带有一个提交。 但真正文件的推送还没解决。考虑到网上许多人都是checkout了本地分支后再操作的，好吧，我放弃直接在master上操作了，于是创建了一个新分支branch2： git checkout -b branch2 # 别忘了之前的远程r还在 git pull r feat 继续报错： * branch feat -&gt; FETCH_HEAD fatal: refusing to merge unrelated histories 历史冲突，那用本地孤儿分支又如何呢？ git checkout master # 由于有未完成的合并，必须强制删除（-D） git branch -D branch2 # 呃，这里为什么突然换成了feat作为名字，我不知道；如果严格按照“实验”来做，这里应该先试branch2 git checkout --orphan feat git rm -rf . git pull r feat 这次拉取倒是没问题： From B/proj2 * branch feat -&gt; FETCH_HEAD 然而我惊恐地发现，由于是孤儿分支而且进行了 git rm -rf，目录下空空如也。那赶快合并吧： git merge master 又是喜闻乐见的报错： fatal: refusing to merge unrelated histories 究其原因，是因为我之前为了在远程创建这个分支而提交的一个空文件导致了历史冲突。那……直接checkout呢？ git checkout master git branch -D feat # 这次就不是孤儿分支了，是带有master历史的分支 git checkout -b feat # 这里再次设置跟踪 git push -u r feat 这一次，出现了不同的东西： To B/proj2.git ! [rejected] feat -&gt; feat (non-fast-forward) error: failed to push some refs to &#39;B/proj2.git&#39; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. 好的，希望很大！看到这个提示，就表明推送是因为修改时间冲突（我先在本地提交，再去创建远程孤儿分支下的空文件）。既然如此，强制推送就行了： git push r +feat 现在就可以了。BitBucket 上显示，新分支feat有相对于B/proj2的master两个超前提交（我在本地的修改历史）和若干个落后提交（master已有的历史）。这是正确的。 不过好像有一个副作用，在推送之前我有个文件是有改动未提交的，经过这次推送后这个改动消失了，不知是不是某个操作隐含意义的问题。 总结：正确的创建和推送流程——推送到 B/proj2.git 的 feat 分支 在临时目录： git clone B/proj2.git git branch --orphan feat git rm -rf . # 这个文件名就随便了，会被覆盖的 touch orphan git add orphan # 这一条消息，以后也会被覆盖掉 git commit -m &quot;Initial commit&quot; git push origin feat 在工作目录： git remote add remote1 B/proj2.git git checkout master git checkout -b feat git push remote1 +feat 话说在各个命令间，“feat”是固定的吗？本地的分支和远程分支要同名吗？不确定，不过根据 PR 的两个相关分支间可以名字不同，猜测这里也可以不同。但为了不造成混乱，最好取一样的名字吧。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"NuGet 依赖管理的一个陷阱","slug":"zh/2017-03-03-Csproj-NuGet-Package-Trap","date":"2017-03-02T20:15:00.000Z","updated":"2020-03-30T22:34:35.441Z","comments":true,"path":"categories/Tech/zh/2017-03-03-Csproj-NuGet-Package-Trap/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2017-03-03-Csproj-NuGet-Package-Trap/","excerpt":"就在刚才，在重新组织项目结构的时候，见识到了一个 NuGet 依赖管理造成的bug。这个bug很隐蔽，症状让人莫明其妙，初见成功让我乱了阵脚。","text":"就在刚才，在重新组织项目结构的时候，见识到了一个 NuGet 依赖管理造成的bug。这个bug很隐蔽，症状让人莫明其妙，初见成功让我乱了阵脚。 直到 DereTore v0.7.1 alpha 的时候，所有的项目目录都是直接位于解决方案根目录下的。这个解决方案一共有23个项目，在首页长长一串是很吓人的，所以我就将项目分类，放到各类别的子目录下了。调整完后，重新导入项目。此时出现了奇怪的事情，有些项目的引用出现了黄色的三角叹号，这表明引用解析失败。但是，那些是 .NET Framework 的程序集，比如 System、System.Windows.Forms、WindowsBase。于是我将这些引用删除，重新添加引用。然而，添加完成后，这些引用依然处于解析失败的状态。错误报告表示，这些程序集在 GAC 中找不到。但是，只要本机的 .NET Framework 不出问题，应该不会出现在 GAC 中找不到 .NET Framework 自身程序集的问题。.NET Framework Repair Tool 的检测表明本机的安装并没有问题。我只好先将没有引用错误的项目编译测试了。 解决方案中存在三种项目： 基础类库，只引用 .NET Framework 自身的程序集； 基础类库，引用了一些 NuGet 依赖； 其他，多是引用前二者的。 此时1是没问题的，2和3仍然不行。为了编译3，先要解决2。于是我在几个第二类项目中，删除 NuGet 依赖引用并重新通过 NuGet 包管理器加入。然而，重新加入的引用也是解析失败的。我快崩溃了，这个问题完全没用头绪，怎么解决呢？ 首先排除代码错误导致这个问题的可能性。所有文件在迁移过程中都没发生变化，而代码的引用正确性是依赖于项目配置的，所以在代码发生错误之前，项目配置肯定出问题了。项目中的配置文件有哪些呢？ app.config，指定了应用程序所用的一些配置值，和引用映射； packages.config，指定了所引用 NuGet 依赖的名称和版本； 容易被忘记的 *.csproj（*.vbproj、*.fsproj）和 .sln，这里面东西就多了。 查看一下 app.config 和 packages.config，它导致问题的可能性几乎为零，毕竟里面并没有存储路径，最多不过是程序集 ID 和版本。继续看 .csproj。看着看着，突然就发现了一个疑点： &lt;Import Project=&quot;..\\packages\\System.Data.SQLite.Core.1.0.104.0\\build\\net40\\System.Data.SQLite.Core.targets&quot; Condition=&quot;Exists(&#39;..\\packages\\System.Data.SQLite.Core.1.0.104.0\\build\\net40\\System.Data.SQLite.Core.targets&#39;)&quot; /&gt; &lt;Target Name=&quot;EnsureNuGetPackageBuildImports&quot; BeforeTargets=&quot;PrepareForBuild&quot;&gt; &lt;PropertyGroup&gt; &lt;ErrorText&gt;这台计算机上缺少此项目引用的 NuGet 程序包。使用“NuGet 程序包还原”可下载这些程序包。有关更多信息，请参见 http://go.microsoft.com/fwlink/?LinkID=322105。缺少的文件是 {0}。&lt;/ErrorText&gt; &lt;/PropertyGroup&gt; &lt;Error Condition=&quot;!Exists(&#39;..\\packages\\System.Data.SQLite.Core.1.0.104.0\\build\\net40\\System.Data.SQLite.Core.targets&#39;)&quot; Text=&quot;$([System.String]::Format(&#39;$(ErrorText)&#39;, &#39;..\\packages\\System.Data.SQLite.Core.1.0.104.0\\build\\net40\\System.Data.SQLite.Core.targets&#39;))&quot; /&gt; &lt;/Target&gt; 所有的 NuGet 包都保存在解决方案根目录下的 packages 目录下。因此，这里正确的路径并不是 ..\\packages\\，而是 ..\\..\\packages\\。我明明使用 NuGet 包管理器卸载再添加了依赖，这里却没发生变化——难道是因为这个导致了全面崩盘？删除所有外部程序集引用后，保存项目，删除上面所示的节点，再让 Visual Studio 重新加载项目，添加引用。嗯，这次就没问题了。将所有出现了无法解析引用的项目都如此处理后，调整代码，重新生成解决方案，生成成功。 这还没完，还有坑在。本地全部重新生成成功后，我提交并开了 PR。然而，CI 却报告生成失败。（幸好之前就熬过阵痛应用了 CI，真是现代生产力必备啊。）错误信息提示说有一个 NuGet 包提供的引用并没有自动还原。明明本地生成成功了，怎么回事？打开对应的 .csproj 后发现，其中的文件路径同样是 ..\\packages\\，但是我手工删除了 &lt;Target&gt; 节点。这样，Visual Studio 并没有因为引用缺失而报错。这个不报错，对 .NET Framework 的程序集引用也没报错。然而实际上对应的引用是找不到的，运行时可能会出错（我没试过）。于是我将相关的引用在文件中全部删除，重新回到 Visual Studio 再引用一遍。这次是真的没问题了。 结论：如果要调整带 NuGet 引用的项目的位置，保险起见，先删除 NuGet 依赖后，调整位置，再重新添加依赖。因为 NuGet 引用的依赖路径是相对路径，而且不会自动更新。 进一步发问：为什么项目引用（解决方案内，一个项目引用另一个项目的输出）不会发生这种麻烦的事情呢？我们来看看项目引用的例子： &lt;ProjectReference Include=&quot;..\\..\\Common\\DereTore.Common.StarlightStage\\DereTore.Common.StarlightStage.csproj&quot;&gt; &lt;Project&gt;{abd7f1b5-c4e3-4200-8e44-98b183dfee2c}&lt;/Project&gt; &lt;Name&gt;DereTore.Common.StarlightStage&lt;/Name&gt; &lt;/ProjectReference&gt; 哎？这不也是相对路径吗？虽然是相对路径，也会出现黄色三角叹号，但是如果你使用 Visual Studio 删除引用，再在“添加”-“引用”-“项目”中添加项目引用，这一项的路径会随之更新。坑爹啊！为什么同样的操作就不会应用到 NuGet 依赖上呢？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"博客迁移到新的域名下","slug":"zh/2016-07-18-New-Domain","date":"2016-10-12T19:01:00.000Z","updated":"2020-03-30T22:34:35.441Z","comments":true,"path":"categories/Misc/zh/2016-07-18-New-Domain/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-07-18-New-Domain/","excerpt":"","text":"我申请了新的域名 mottomo.moe，打算以后就将此作为包括博客在内的杂物的存放地。这个博客所使用的 DNS 已经设置将对 http://uiharu.moe/ 的访问自动跳转到 http://blog.mottomo.moe/。（DNS 免费账户的配额满了……所以只好忍痛弄了个 VPS，配置 httpd 来跳转。） 为什么要从 uiharu.moe 迁走呢？uiharu.moe 是我刚入宅不久还处于初春饰利狂热的时候注册的。后来我发现，将自己绑在一个角色上是不可能的。并不是说让大家都成为我的翅膀，而是因为他们都有着不同的闪光点，让人高度肯定。 说起来有点意思，“一番萌え”（ichiban.moe） 是在lan姐手上的。他（再一次指明，没写错）非常喜欢这个域名的 domain hack。当初是丧丝提出 ichiban.moe 的想法，好像是在一年以前吧，我记得。lan查到这个域名没注册，劝他赶紧买下来；丧丝说好贵不买，于是lan就将其收入囊中了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"微信的两个反人类操作设计","slug":"zh/2016-07-23-WeChat-Interaction-Design-Failure","date":"2016-07-23T10:22:00.000Z","updated":"2020-03-30T22:34:35.441Z","comments":true,"path":"categories/Misc/zh/2016-07-23-WeChat-Interaction-Design-Failure/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-07-23-WeChat-Interaction-Design-Failure/","excerpt":"为什么六月下旬到七月这段时间基本上没文章呢？因为储备不够啦！没有做出值得写的东西啦！六月毕业后游戏颓废了半个月，回家后也不知怎的效率低了许多，多个方面碰壁。 两个月前写的，吐槽一下微信的两个毛病。 2017-02: 好多积压的文章……","text":"为什么六月下旬到七月这段时间基本上没文章呢？因为储备不够啦！没有做出值得写的东西啦！六月毕业后游戏颓废了半个月，回家后也不知怎的效率低了许多，多个方面碰壁。 两个月前写的，吐槽一下微信的两个毛病。 2017-02: 好多积压的文章…… 在手机版微信上，左手（我用手机一般是左手拿着，左手操作）拿手机下滑信息的时候，由于手指运动范围的缘故，下滑曲线很容易成为左上到右下的弧线。微信经常把这个弧线解读为向右滑动（“返回”操作），导致我在翻信息的时候总是翻一半就会被退到上一级，再回来的时候又到了最新接收的信息。当在几百条信息中查找时，这个bug非常令人恼火。想一下，翻了几百条，就因为一个恶心的产品缺陷，导致你不得不再花半分钟，加上等待分页信息的加载的分割感，来找到历史中的一条信息。难道把阈值调高一点就这么难吗？而且看看同门的手机QQ，它从来就没出过这个毛病。 在PC版微信下，窗口边框是有2像素圆角的。窗口在正常状态时看上去还可以，但是到了最大化的时候，就变成了圆角矩形内接于矩形，四个角上是没有点击响应的。我关闭最大化窗口的时候，不会去看关闭按钮在哪里，而是直接将鼠标大幅度移动到右上角（确保指针刚好在右上角角点的位置），按下鼠标。一般窗口是带有边框的，最大化时三边边框位于工作区域外，内容、标题栏和控制区位于工作区域内——相信做过 Windows GUI 的同学都不陌生。而PC微信，只有窗口内容，而这个内容还没占满工作区域。什么效果呢？当我按照习惯的关闭方法关闭微信的时候，关闭的永远是处于微信后面的（Z顺序在其之后一个的）无辜窗口。如果不是因为大多数软件有关闭确认，浏览器有历史记录，我早就不知道咒了PC微信多少次了。 除了收听班级事项之外，微信对我就没其他价值。这两个触发频率如此高的设计缺陷，还在一次次冲击我的耐心。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"毕业","slug":"zh/2016-06-18-Graduation","date":"2016-06-17T21:59:00.000Z","updated":"2020-03-30T22:34:35.441Z","comments":true,"path":"categories/Misc/zh/2016-06-18-Graduation/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-06-18-Graduation/","excerpt":"本科毕业典礼在今天举行。经过四年的学习生活，我毕业啦！","text":"本科毕业典礼在今天举行。经过四年的学习生活，我毕业啦！ 后记：其实前一天晚上喝了酒，允许了一次接近解除理性约束的状态。后来一到KTV就睡着了，大家开始撤的时候把我叫了起来，此时大概五点半，打车回到宿舍六点。输入上面的文字后眼皮实在不行了，保存睡觉去了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"荷兰反签签证和出生证明的双认证办理指南","slug":"zh/2016-06-15-Visa-And-Dual-Certification-for-the-Netherlands","date":"2016-06-15T06:06:00.000Z","updated":"2020-03-30T22:34:35.441Z","comments":true,"path":"categories/Misc/Records/zh/2016-06-15-Visa-And-Dual-Certification-for-the-Netherlands/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2016-06-15-Visa-And-Dual-Certification-for-the-Netherlands/","excerpt":"2019年了！不要再问我这些手续问题了！自己了解清楚！ 现在离写本文的时间已经快三年了，手续可能发生变化。 我不是负责这些事务的工作人员，我并不会去了解最新消息。 我不是专家，一切回答都是基于经验、记忆和推论。 每次回答这些问题，我都得重新回忆整个过程，很烦，要推敲，还未必准确（只能尽量）；而且我有时候会很忙，对于职责之外的事情会直接放鸽子，直到有空的时候。 一旦因为我的回答（或者未回答）而使得某人的人生有了重大损失，这个我绝对担不起。 所以以后再收到关于本文的问询邮件，恕不回复。 如果没有什么意外的话（别给自己插旗啊），我八月就要到 TU/e 开始研究生生涯了。在此特别感谢村长。 本日志记录了在拿到 conditional acceptance 之后，剩余的手续（主要是签证和双认证）的办理过程。注意今年是2016年，我在北京的荷兰大使馆办理，其余地区（广州、重庆、上海领区在对应领事馆）也应该差不多。 办理时参考了这篇帖子和村长给的3+2后续手续攻略，不过我碰到的情况和二者都不一样（时间不同、所需材料不同），所以在此记录我自己的版本。","text":"2019年了！不要再问我这些手续问题了！自己了解清楚！ 现在离写本文的时间已经快三年了，手续可能发生变化。 我不是负责这些事务的工作人员，我并不会去了解最新消息。 我不是专家，一切回答都是基于经验、记忆和推论。 每次回答这些问题，我都得重新回忆整个过程，很烦，要推敲，还未必准确（只能尽量）；而且我有时候会很忙，对于职责之外的事情会直接放鸽子，直到有空的时候。 一旦因为我的回答（或者未回答）而使得某人的人生有了重大损失，这个我绝对担不起。 所以以后再收到关于本文的问询邮件，恕不回复。 如果没有什么意外的话（别给自己插旗啊），我八月就要到 TU/e 开始研究生生涯了。在此特别感谢村长。 本日志记录了在拿到 conditional acceptance 之后，剩余的手续（主要是签证和双认证）的办理过程。注意今年是2016年，我在北京的荷兰大使馆办理，其余地区（广州、重庆、上海领区在对应领事馆）也应该差不多。 办理时参考了这篇帖子和村长给的3+2后续手续攻略，不过我碰到的情况和二者都不一样（时间不同、所需材料不同），所以在此记录我自己的版本。 一、出生证明的双认证1.1 所需材料注：1996年1月1日开始，全国启用了统一出生医学证明，所以所需材料会简单很多。我是1994年出生的，所以就多了几步；虽说这些内容也用不了多久了，不过能惠及后人就好。 由于 MVV 学生签证从办理后计只有90天有效期，所以到达荷兰后要在荷兰当地市政厅办理临时居住许可（VVR）。办理这个许可时需要出生证明，而中国学生的出生证明需要佐证材料。 出生时间所需材料1996年3月1日之前经认证的出生公证书；三种依据材料之一：父母户口本所记载的申请人出生情况；医院出具的**明确注明可用于办理户口的**出生证；出生地公安局/派出所出具的申请人出生证明。申请人所在的完整的户口本的公证书。1996年3月1日和之后出生医学证明原件（带至荷兰）；该证明的公证书。 注意： 办理的公证处必须有涉外公证办理资格； 所有公证材料都需要公证处进行翻译，附于公证书内； 翻译内容应该是“一比一”的，所有出现的中文文字内容都需要有对应的翻译，包括证件附注、印章等。 1996年3月1日前出生的同学，准备材料总结如下： 情况 所需材料(选项) 已迁户口、家庭户口本登记出生 1、出生公证；2、家庭户口本复印件三十三式公证；3、户口卡公证。 已迁户口、医院的证明可报户口 1、出生公证；2、出生证公证；3、户口卡公证。 已迁户口的其他情况 1、出生公证；2、公安局/派出所出具证明的公证；3、户口卡公证。 未迁户口 1、出生公证；2、家庭户口本复印件三十三式公证。 注： 三十三式公证为“复印件与原件相符，且原件属实”，三十五式公证为“复印件与原件相符”，明显三十三式更严格，且公证处责任更大。有些公证处默认开三十五式公证，这是不符合要求的。如果不放心，就提醒开三十三式，手续其实是一样的。 出生公证和户口卡公证都有固定格式，在公证处会有专门的类别； 户口卡公证和出生证公证都是非实体公证，办理的时候携带的材料和三十三式公证相同； 出生公证是实体公证，和出生证公证是两个概念，一定要注意。 所以在二月末拿到 conditional acceptance 之后不要太急着去办认证，因为公证书是有时效的，出生证明是六个月。但是要小心，接下来的整个过程要花费半个月到一个月的时间。 1.2 办理公证第一个是户口卡公证。如果户口在学校，就去学校管理户籍的部门申请借出户口卡，一般就能拿到，是一张蓝色的小纸条。拿到户口卡后复印至少两份，后面办签证还会用到。注意有借有还。如果不在学校，做户口本的公证即可。 第二个是出生公证。如果户口在学校，在借户口卡的时候工作人员问明目的是公证后提供材料（我们是提供父母的身份证复印件和自己的学生证）会同时开给公证处的介绍信。如果不在学校……网上应该有说明的。 第三个是其他材料的公证。这就需要相应的材料原件和复印件。 准备好以上材料后，再带上两张两寸照片、身份证和现金，就到公证处办理对应的公证吧。公证费用是有规定的，我的三项公证包括翻译在内一共花了400大洋。 这一步要注意，领到公证书后要仔细核对： 待证明文件内容； 证词； 翻译； 装订顺序（文件→证词→翻译）。 公证的周期能抵得上外交部认证和使馆认证两项的总周期，所以尽量不要在这个地方出岔子，否则一旦离开了公证处，基本上就是要重新申请办理了。 幸好我办理（在海诚公证处，学校介绍信中指定的）时见到的所有人都很好。首先是一个胖大姐，当时我去的时候我已经排在了涉外公证队伍的倒数第二个，轮到我的时候离停止接待时间（16:30）已经过了快一小时，前面还有一位从美国回来的华侨“在美国怎么怎么样，这里为什么就不能办”地磨嘴皮子磨了很久，到我的时候尽管压力很大还是很友好地进行了询问、材料审核等所有手续。然后是负责出文件的妹子，第一次我领到公证书后对出生证公证中的“凭此证可以申报户口”未翻译表示疑惑，她看到（她的办公室正对着为我办公证的公证员的办公室门，后者一直不在，我站在门前翻公证书）后把我叫了进去，听了问题后帮我问了翻译，一个胖胖的青年人。虽然翻译的“去荷兰的这一段通常不用翻译”这句话把我坑惨了，但是他指出出生证明的公证书上需要贴照片（所以我才提醒各位准备）；然后妹子就定了第二天处理的时间，第二天再去，直接找妹子把照片贴了盖了钢印。第二次是因为少了上面那句话被大使馆退回来之后（工作人员说加上这一段应该就行了，让我回公证处重出公证书），我再来到公证处，同样是在门口站着就被叫进去了，而且她还准确地抽出了存档。听了我的叙述后，她微笑着说“好吧，我们遇到过很多被大使馆以各种理由退回来的”，确认原件之后重新复印（我当时排队复印了，但是看起来效果不好所以她拿着跟复印的工作人员说要印得浅一点）、联系翻译、当场出新的公证书，我遵从“在这里等一下”的指示就一直在办公室里坐着看城区地图都有些不好意思了。说了这么多，我的意思就是，虽然之前说“基本要申请重新办理”，但是如果碰到非常放心的公证处，就非常幸福了。特别是后面这位妹子帮我省了一周的时间哪，这样我才能在户口卡被学校回收前办理完出生证明的双认证，否则我办到一半就得放弃所有进度回广州重新开始了，包括签证也得重来。所以说这几位都是恩人。 1.3 办理单认证在领取了三份公证书之后，真正的跑腿开始了。首先到当地的外事处提交外交部认证申请。外地的外事处一般在省会城市，然后它们会统一将文件发送至北京，办理完后发回，所以离省会越近、离北京越近办理速度会越快。 在北京办理这一项的地方在茂发国际旅行社认证部，位置在朝阳区三丰北里(外交部南街)6号楼悠唐青年公寓6层，地铁站2号线朝阳门站A口往南走的方向，在大大的“UTOWN”标志后的那一栋楼，消防站北边、外交部正东，从朝西开的一扇不太起眼的门进去。虽然名字听起来是一个民间机构，但这里可是外交部服务中心直属的，是正规机构。 进去后不需要预约、取号，看着哪位工作人员有空直接去办理就可以了。急件办理时间为三个工作日，实际上是： 办理时间 取件时间 -09:00 第二个工作日10:00后 09:00-11:30 第三个工作日10:00后 13:30-17:00 第三个工作日13:30-17:00 例如，我在星期二早上十点后办，则星期四早上十点后就能取了。 这里要跟工作人员说清楚做单认证、加急，费用为150元/件。平件办理时间为一周，费用为75元/件。（哇，与4年前相比，没涨价……）单认证的好处是时间可控，如果在这里申请双认证的话，完成时间是不定的。据说双认证时间在一周到两周不定，不过其实如果是全自己跑的话一周就可以了，所以自己稍微辛苦点吧。 办理完后，在公证书的最后一页背面会贴上一张特制防伪贴纸，上面有外交部领事司一等秘书的签名和领事司的印章，证明公证书上公证员的签名（印章）属实。注意：这不保证公证书的有效性，仅保证其真实性。 1.4 办理双认证接下来就该去荷兰使领馆了。在北京的荷兰大使馆位置在地铁10号线亮马桥站D口往东南走，使馆街（亮马桥南路）紧邻着联合国大楼西侧的就是。办理文件认证需要预约，详见荷兰大使馆的说明，注意领区划分。办理时间是周一至周五（节假日除外），09:00-12:00、14:15-16:00。 准备材料：身份证和护照（门卫用来验证）、预约结果的打印件、待使领馆认证的已经过外交部认证的公证书（门卫要检查）。 进去的时候要先告知门卫来意，如果他不知道如何处理，会叫出一位值守的工作人员。总之放轻松点就好了。进门（门口招待处一般没人，轻轻开门进去）后右手边就是一个取号机，取号后往下进门后正前方的楼梯，到休息区等待叫号即可。办理需要四个工作日（周一办，周四取），每一份文件190大洋。（受汇率影响，比四年前降价了……）注意取件时间是办理完成那天的13:30-14:00，过期不候。 办理好后公证书后会加上与外交部的贴纸类似的荷兰大使馆的贴纸。注意：这不保证公证书的有效性，仅保证其真实性。 推荐文件认证和签证一起办，可以少跑一次。 二、签证签证就简单多了。由于学校已经启动了申请程序，所以签证是反签（MVV-REF），只需要等待学校发的签证批准（转自 IND）的邮件即可。之前的手续就不说了，学校在确认邮件中或者是网站上应该是写明的。 得到批准邮件后，向使领馆发一封邮件，北京就发往 pek-visa@minbuza.nl。邮件内容大概是这样的（不怕献丑，我把我发的格式贴出来）： Dear officer, My name is XX XX and I have been admitted into Some University XXX Master program. I received an email from Some University stating that my application concerning my visa to the Netherlands has been approved and my visa has been sent to the Dutch Embassy in Beijing. My Vnumber is 0000000000. The key information required on the web page is as follows. Full name: XX XX Gender: Male Birth date: 1st January, 1994 Admitted by: Some University Hence I’m emailing to confirm when I can go to collect my visa. Thank you! 理论上应该会收到一封自动回复的邮件，内容是这样的： Please note that your request for a visa appointment or general information on visa procedures is no longer answered by the Embassy. You are kindly requested to contact TLScontact directly: Call within China: 400 625 6622 Call from overseas: +86 21 60168681 我收到的时候还真给这个号码打了电话，不过这就是一个自动转接台，而且主要是用来办预约的，还得知道自己的申请号（反签没有申请号，不是 Vnumber），也没什么用。到下一个工作日，应该就能收到答复邮件： Dear XX XX, Please find attached your MVV approval letter. 附件就是一个 DOC 文档（小小吐槽一下，PDF 比较专业啊），是给你的正式批准信。到这一步就可以准备前往使领馆领取了。以下材料都可以在荷兰大使馆的临时居留签证和长期学生签证页面找到。 继续进入预约系统（和文件认证是同一个）预约签证办理业务，并准备材料： MVV 申请表，这张表是可以在 Adobe Reader 中填大部分信息的，最后别忘了打印、签名； 两张 35 mm × 45 mm、白色背景的签证照，具体要求见文件说明； 护照（至少有一页签证页可用）、护照信息页的复印件； 户口本（与父母的信息页）的公证书（带翻译）的复印件，或户口本原件和其有内容页的复印件，或户口卡的公证书（带翻译）的复印件； 签证批准信（使领馆发来的邮件中的附件）。 带好之后前往使领馆递交材料即可。费用方面，在申请签证的时候学校已经代收并交付给了 IND 了，取签证不需要收费。办理时间在3-4工作日，不过不管什么时候办理，都是在办理时间之后的周五13:30-14:00取。 特别提醒一下签证办理时间的选取问题。拖延症救了我一命。TU/e 的 MVV 签证批准通知中关于时间的部分是这样写的： Once the IND (Dutch Immigration Service) has approved your visa you will have 90 days to enter the Netherlands. After entering the Netherlands you will have another 90 days to pick up your residence permit. The residence permit will be ready at (the end of August/beginning of September if you start your studies at TU/e at the beginning of the first semester and at the end of January/beginning of February if you start at the beginning of the second semester). Do not pick up your visa before June if you start at the beginning of the first semester and not before November if you start at the beginning of the second semester. You have 90 days to pick it up and if you pick it up earlier, you will not get your residence permit after arrival in the Netherlands. 总之我对这段话的理解有偏差，签证发下来的时候看到日期字段才完全理解。这里我讲最终的结论。 首先，MVV 反签是 D 类单次入境签证，有效期是90天，自申领之日开始计算。第一段的意思就是，在 IND 批准（也就是 TU/e 的 MVV 批准通知邮件到来）之后，有90天的时间去申领签证（对应“enter the Netherlands”），申领发下来之后就可以入境了（然而有效期仍从申领的日期开始计算）；在申领之后90天之内必须获得居留许可（对应“pick up your residence permit”），否则签证一失效，许可又没拿到，就是非法居留，将会面临永久拒签的危险。图形化的时间线见下图： 总之，安全的时间线就是操作日期的时间点永远在有效期结束之前。虽说学校已经启动了居留许可的申请程序，不过从去市政厅到拿到许可还有两三周的时间。所以第二段的意思也十分明显了，就是说即使 MVV 批准通知在五月份就到了，也不要在六月/十一月前领取签证，否则就是作死。合适的时间是什么时候呢？很明显，是出发（八月初）前三周左右和 MVV 批准邮件到来后的90天二者的最先的时间，条件是：户籍所在地（特别要小心毕业后的户口回迁）离使领馆所在地够近，而且各材料已经事先准备好。 我当初对这个“enter the Netherlands”理解为“入境”（实际上是“发放签证，可以随时购买机票入境”），如果我太勤奋，可能就在五月份办了。所以真是好险…… 另外，预约系统是有点问题的，一个人一天只能预约一个事项。如果想同时办理文件认证和签证，预约两个就会说当天已经有重名的人来办理业务而拒绝了。解决方法是预约一个业务，但是带齐所有需要的材料，办理完一个后直接排队或取号办理下一个。我是周一（6月13日）在去办理文件认证的地铁上收到签证批准邮件的，刚好我一个文件袋内装着所有所需的材料，就一天办理了两个。开始办文件认证的时候，到的时间已经很接近预约时间了，就直接进去了。刚好一个旅游团准备来办签证，工作人员就问我是否也是办签证的，我说“我不办签证”。出了大使馆，我在周边的打印店打印了批准信后又回去了。这次因为系统的问题没预约，我和警卫&amp;值守工作人员说明了情况后他们也让我进去了。一到柜台，当我亮出签证材料的时候，工作人员（和办文件认证时不是同一个人）说：“刚才说今天不办签证办文件认证的是不是你？”我：“我是在来的路上收到答复邮件的，所以刚才办的是文件认证，现在办的是签证。”总之气氛有点囧。文件认证周四取，签证周五取……所以我推荐如果要同时办的话，预约周二的工作时间。 三、总结说了这么多细节，这里就直接列一张概要表吧。 顺利的话，总计开销：400+150×3+190×3=1420大洋，不包括交通费等其他费用。插一句，我从北航到朝阳区的两个点（外交部、荷兰大使馆）跑这些事情，六月份主要是剩下的一份出生公证书的认证（因翻译没翻译出关键部分，被退回了）和签证，地铁开销都已经超过北京地铁的八折优惠线了，现在已经本月自动八折了。 3.1 双认证 推荐开始时间：五月初 所需时间：不定（公证处）+一周多一点（外事处、使领馆） 所需材料：见文章第一部分表格 所去地点和办理、领取相关： 公证处（领取时间由公证处决定） 外事处认证部门（加急则第三个工作日取，可以咨询工作人员） 使领馆（周一至周五13:30-14:00取） 3.2 签证 推荐开始时间：六月上旬（户口在学校而面临毕业回迁的）/七月中旬（户口所在地离使领馆较近的） 所需时间：一周 所需材料：见文章第二部分列表 所去地点和办理、领取相关： 使领馆（周五13:30-14:00取）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"CGSS 核心反向过程实录 | 八、成果应用","slug":"zh/2016-06-02-Reversing-CGSS-8","date":"2016-06-02T14:09:00.000Z","updated":"2020-03-30T22:34:35.440Z","comments":true,"path":"categories/Tech/RE/zh/2016-06-02-Reversing-CGSS-8/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-06-02-Reversing-CGSS-8/","excerpt":"索引 毕业设计完成，在毕业典礼之前的小假期有点时间写写文章。本系列主线终于结束了，接下来要做的就是周边开发内容和……荒废了半年的 Bulletproof。顺带说一句，第6篇已经解禁。 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 毕业设计完成，在毕业典礼之前的小假期有点时间写写文章。本系列主线终于结束了，接下来要做的就是周边开发内容和……荒废了半年的 Bulletproof。顺带说一句，第6篇已经解禁。 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、内容很少的一段在第三篇中我提到过，凭借网上流出的一个 HCA v1.2 解码器，我得以解码 HCA 音频。但是我觉得它可以作为小工具用，但是很难集成。因此我将其进行了动态库化：kawashima（现在已合并到 libcgss），提供一组 C 样式的 API，这样就方便其他的代码调用了。由此衍生的还有 foo_input_hca，给 foobar2000 用的 HCA 音频插件。 本来的目标就是做一个无限练手器，第一篇里已经分析了需要完成的几个功能。随着反向的完成，我开始重建各个部分。说白了，这玩意儿还是游戏，约等于代码+资源。对于游戏软件，代码也分功能性、辅助性和游戏性的，功能性代码部分就公开在 DereTore 这个 repo 了。由于我仿照 CGSS，引擎使用 Unity3D，因此这些就是 C# 代码了。整个新的软件是围绕着这几个功能做的，它们是骨架，整个软件是一个有血有肉的人。现在先将最容易定下来也最容易编写的的骨架部分公开，整个人嘛，有机会吧。目前包括 HCA 解码（P/Invoke 调用 kawashima，和纯 C# 解码两种方式）和 ACB 解包（改写自 VGMToolbox 的一部分）。现在已经完成了整个工具包的制作，从谱面，到音乐，到封面，都包含在这个工具包内。当然，为了避免和原生游戏内容相冲突，要玩的话还要有另外一个工具；不过玩的工具因可能会侵犯到游戏厂商的权益而不能公开，只能有限地开放给一小群人，而且禁止影响正常游戏秩序。 其他的东西包括： Starlight Performer：演示模拟器（制作中），对应于日方のんのん的 Deleste； Starlight Director：制谱器的下一个主要版本——DereTore 的工具包中目前那个是基于 WPF 的，效率略低，也有不少bug，在完成这个之前先继续顶着吧。 在制作 DereTore 的过程中，也会有其他的代码库和记录，日志的话就见带 DereTore 标签的日志吧。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"自动引用计数的实现","slug":"zh/2016-05-19-Auto-Reference-Counting","date":"2016-05-19T10:31:00.000Z","updated":"2020-07-26T13:48:50.864Z","comments":true,"path":"categories/Tech/Coding/zh/2016-05-19-Auto-Reference-Counting/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2016-05-19-Auto-Reference-Counting/","excerpt":"在帮同学调 Qt 的程序的时候，发现了很好用的 QString，和 MFC 的 CString 一样是对字符串的封装，提供了许多实用函数。不过 QString 给我感觉最实用的是自动的资源生命周期管理机制，而且很明显是基于引用计数的。由于新语言瘾又上来了，再加上想到了 TJS，我就想实现自己的用引用计数管理的类。原理很简单，不过由于我没有亲自写过，所以在实现的时候遇到了困难，幸好都分析解决了。 其实 C++ 新标准中有 std::shared_ptr&lt;T&gt; 类，但是我不喜欢 shared_ptr&lt;int&gt; p = new int[10]; 这样强制要用指针的写法，而且每次都要带一个 shared_ptr 太费劲。如果我需要一个自动数据类（例如字符串），如下写法哪个更简单： shared_ptr&lt;String&gt; pStr = new String(); // 写法1 String str; // 写法2 在用的时候，我关注的重点是 String 内的数据而不是 shared_ptr 的实现方式，所以 shared_ptr 能省就省。而且不是有人说过吗，要会用 Boost（shared_ptr 这个标准来自 Boost），更要理解它所使用的“奇技淫巧”的原理。所以为了掌握自主知识产权，还是有必要自己动手写一个引用计数管理的。","text":"在帮同学调 Qt 的程序的时候，发现了很好用的 QString，和 MFC 的 CString 一样是对字符串的封装，提供了许多实用函数。不过 QString 给我感觉最实用的是自动的资源生命周期管理机制，而且很明显是基于引用计数的。由于新语言瘾又上来了，再加上想到了 TJS，我就想实现自己的用引用计数管理的类。原理很简单，不过由于我没有亲自写过，所以在实现的时候遇到了困难，幸好都分析解决了。 其实 C++ 新标准中有 std::shared_ptr&lt;T&gt; 类，但是我不喜欢 shared_ptr&lt;int&gt; p = new int[10]; 这样强制要用指针的写法，而且每次都要带一个 shared_ptr 太费劲。如果我需要一个自动数据类（例如字符串），如下写法哪个更简单： shared_ptr&lt;String&gt; pStr = new String(); // 写法1 String str; // 写法2 在用的时候，我关注的重点是 String 内的数据而不是 shared_ptr 的实现方式，所以 shared_ptr 能省就省。而且不是有人说过吗，要会用 Boost（shared_ptr 这个标准来自 Boost），更要理解它所使用的“奇技淫巧”的原理。所以为了掌握自主知识产权，还是有必要自己动手写一个引用计数管理的。 引用计数的概念很简单，就是在对象内部维护一个计数器。引用到这个对象的时候，计数器增加1，这个对象的一个引用被解除的时候，计数器减少1。当计数器减少到0的瞬间，销毁这个对象持有的所有资源。以 QString 为例子，使用起来是这样的： QString g_str; void foo() { bar(); g_str = QString(); // 0 (释放) } void bar() { QString str = &quot;This is a string.&quot;; // 1 QString str2 = str; // 2 PrintString(str); g_str = str; // 3 } // 1 void PrintString(QString str) { std::cout &lt;&lt; str.toStdString() &lt;&lt; std::endl; // 3 } // 2 从上面的例子可以看清 str 所维护的数据的生存周期中，从分配到被定义域外的变量 g_str 引用，再到最后自动释放，整个引用计数的变化。由始至终没有一句手动释放缓冲区的代码，释放工作全部由 QString 自动完成，而且即使是函数内变量被外部变量引用，也能保证在使用着的时候一定不会提前释放。是不是很方便？ 我们来看一下在 C++ 中对象是如何传递的。重点是两个地方：拷贝构造函数，和赋值运算符。 对于一个类 Class1，如果不指定（仅仅声明空类），编译器会生成如如下形式等价的代码： class Class1 { Class1(); // 默认构造函数 public: Class1(const Class1 &amp;); // 拷贝构造函数 Class1 &amp;operator=(const Class1 &amp;); // 默认赋值运算 } 拷贝构造函数在什么时候调用呢？这种时候： Class1 c = Class1(); 在这个例子中，先构造了一个 Class1 的匿名实例，然后将这个实例的 const 引用作为参数，创建出 c 这个实例。 再看赋值运算符在什么时候调用呢？这种时候： Class1 another; c = another; 拷贝构造函数和赋值运算符一个在对象初始化（无值→有值）时调用，一个在对象赋值（有值→有值）时调用。不管是哪一个，都隐含了“所有权转移”的概念。所以如果要控制所有权（例如 RAII）的时候，必须同时重写这两个函数才能正确地处理转移逻辑。这里的“所有权”是数据所有权，在引用计数的情况下是比较简单的，对于单个实例，只有“持有”和“未持有”两种状态，只有在持有同一个对象的集合这个范围内才需要计算引用的次数，是最简单的情形了。 处理的时候也相对比较简单，我们声明增减计数的方法： uint32 Object::DecRef() const { if (--*_pReferenceCounter == 0) { _internalCollectingReference = true; delete this; _internalCollectingReference = false; return 0; } return *_pReferenceCounter; } uint32 Object::IncRef() const { return ++*_pReferenceCounter; } 当然，在实际应用中，必须保证增加计数和减少计数这两个操作是原子的（atomic），也即计数的更新是不可分割的，要不完全成功，要不完全失败。这里作为演示，直接使用自增和自减。常用库，例如 Qt，是使用 CPU 指令来实现原子操作的。 然后分别是构造和赋值： Object::Object(const Object &amp;other) { _internalCollectingReference = false; _pReferenceCounter = other._pReferenceCounter; IncRef(); } Object &amp;Object::operator=(const Object &amp;other) { DecRef(); __cloneFields(&amp;other); IncRef(); return *this; } 在析构的时候需要更新计数： Object::~Object() { if (!_internalCollectingReference) { if (_pReferenceCounter) { --*_pReferenceCounter; } } if (ShouldDestruct()) { delete _pReferenceCounter; _pReferenceCounter = nullptr; } } 这里 ShouldDestruct() 函数判断是否应该进行其他资源的回收工作（我觉得，统一用 Disposable 模式可能好一些）。要注意的是析构函数一定要是虚析构函数，才能利用 ShouldDestruct() 正确判断资源回收的时机。举个例子： String::~String() { if (ShouldDestruct()) { delete[] _str; _str = nullptr; } } 既然是引用计数，一个对象会被引用多次，就需要判断同一性。这个判断很简单，二者为同一个对象的条件是内部计数引用指向是一致的。 至此一个简单的引用计数基类已经完成，其他的类只需要继承它，注意处理自带资源的回收时机，以及关键的运算符覆盖（其中调用父类的函数）就可以实现自动的生命周期管理。试试输出一个对象的计数变化状况就知道了。 最后要提醒的是，单凭引用计数无法解决循环引用（A→B→C→A）的死锁销毁问题。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"CPlusPlus","slug":"CPlusPlus","permalink":"https://blog.mottomo.moe/tags/CPlusPlus/"}]},{"title":"CGSS 核心反向过程实录 | 七、重新打包","slug":"zh/2016-05-14-Reversing-CGSS-7","date":"2016-05-14T11:46:00.000Z","updated":"2020-03-30T22:34:35.440Z","comments":true,"path":"categories/Tech/RE/zh/2016-05-14-Reversing-CGSS-7/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-05-14-Reversing-CGSS-7/","excerpt":"索引 这文章一直了拖到6月2日啦！ 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 这文章一直了拖到6月2日啦！ 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、打包得到自己的程序集之后，我们要用我们编译的程序集替换原装程序集。 然而，在做了这次替换以后，文件内容就发生了变化。所以 MANIFEST.MF 是一定要修改的。好在这个不难，一段小程序足够： class Program { static void Main(string[] args) { if (args.Length &lt;= 0) { ShowHelp(); } else { using (Sha1Managed = new SHA1Managed()) { Sha1Managed.Initialize(); foreach (var path in args) { if (File.Exists(path)) { Digest(path); } else { Console.WriteLine($&quot;{path} &gt;&gt; (NOT EXISTS)&quot;); } } } } } static void ShowHelp() { var help = &quot;Usage: SHA1Digest.exe &lt;file1&gt; [&lt;file2&gt;, [&lt;file3&gt;, ...]]&quot;; Console.WriteLine(help); } static void Digest(string path) { var bytes = File.ReadAllBytes(path); var digest = Sha1Managed.ComputeHash(bytes); var info = Convert.ToBase64String(digest); Console.WriteLine($&quot;{path} &gt;&gt; {info}&quot;); } private static SHA1Managed Sha1Managed; } 用这个小程序就能计算文件的 SHA-1 散列值，并输出为 Base64 编码的字符串。用输出的值替换 MANIFEST.MF 中的原始值即可： F:\\TEMP\\cgss-managed\\cracked&gt;SHA1Digest Assembly-CSharp-firstpass.dll 将制作好的 APK 安装到设备中： F:\\Google\\Android\\SDK\\platform-tools&gt;adb install F:\\TEMP\\cgss-managed\\cracked\\cgss_cracked.apk 然而，弹出的是一个安装失败的错误，错误信息为缺少签名。如果要在 Android 中安装一个 APK，这个 APK 必须是经过签名的。它使用了一个密钥散列了所有的文件，记录在了某个地方（这个我没深究），保证文件的完整性，保证它们未被篡改。因此为了发布到真系统（是不是模拟器倒没关系，只要是放到非调试状态的 Android 系统下都需要），我们得要给这个 APK 签名。在测试用的版本（1.5.3）中 CGSS 主程序没有进行签名验证，所以我们才能运行自己的程序集。附带说一句，主程序里判断是否作弊，其中就有一段检测加载的程序集是否是白名单上的几个。我们修改的是 CGSS 自身的程序集，所以不会被检测出来——而且没有进行程序集的文件完整性校验。也就是说，在没启用 APK 签名校验和程序集完整性校验的情况下，整个反向才能完整进行。 根据网上的日志，使用 keytool（在 JDK 中）生成一个 keystore： set PATH=%PATH%;C:\\Program Files\\Java\\jdk1.8.0_40\\bin F:\\TEMP\\cgss-managed\\cracked\\keystore&gt;keytool -genkey -alias cgss.keystore -keyalg RSA keystore cgss.keystore 嗯，现在我们有了自己的 keystore，就该对修改后的 CGSS 安装包进行签名了： F:\\TEMP\\cgss-managed\\cracked&gt;jarsigner -verbose -keystore .\\keystore\\cgss.keystore -signedjar cgss_cracked_signed.apk cgss_cracked.apk cgss.keystore 等到签名完成，这个 APK 就能顺利安装了。能顺利安装还没完，还要测试运行，并从 logcat 收集输出信息。这部分其实很好做： F:\\Google\\Android\\SDK\\platform-tools&gt;adb logcat -d -s Unity &gt; log.txt 分析调试信息就不仔细展开了，这活儿也是很简单的。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"在 Windows 上编译带 ICU 的 Boost::Regex","slug":"zh/2016-05-11-Building-Boost-Regex-with-ICU-on-Windows","date":"2016-05-11T11:23:00.000Z","updated":"2020-07-26T13:48:41.481Z","comments":true,"path":"categories/Tech/Coding/zh/2016-05-11-Building-Boost-Regex-with-ICU-on-Windows/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2016-05-11-Building-Boost-Regex-with-ICU-on-Windows/","excerpt":"找遍了文档和文章，没有能直接解决问题的，就将我的方法记录下来好了。以及，明天周例行检查过了的话，优先把 CGSS 反向系列的剩下两篇写完。但是心好急啊，还没开始动工论文！ Boost 的 Boost::Regex 默认是不带 ICU 支持的。在这种情况下，它只能用来处理多字节字符串（MBCS）的正则表达式操作，而这个字符串是和系统的区域信息（locale）相关的。同样是简体中文区域，Windows 的字符集是 GBK，OSX 和 Linux 的字符集是 UTF-8。如果不给这个库增加其他字符集的支持，那它基本上就对多字节字符（汉字、喃字、假名等等）无能为力了，毕竟在表示“ASCII 以外的字符”这一个概念时不同编码方案码是不一样的。不过好在 Boost 的设计者很清楚这一项需求，在 boost/regex/icu.hpp 中定义了两个额外的正则表达式结构：wregex（处理宽字符）和 u32regex（处理 UTF-8、UTF-16 和 UTF-32），不过内部要依赖于 ICU。考虑到我准备使用 UTF-8 作为字符串的编码基础，必须要用上 ICU；而要用 ICU，就必须自己编译 Boost。 注意，接下来的部分过程只适用于 Windows，因为 Linux 一般是预置了 ICU 的，只需要简单指定就好，bjam 会自动完成设置。","text":"找遍了文档和文章，没有能直接解决问题的，就将我的方法记录下来好了。以及，明天周例行检查过了的话，优先把 CGSS 反向系列的剩下两篇写完。但是心好急啊，还没开始动工论文！ Boost 的 Boost::Regex 默认是不带 ICU 支持的。在这种情况下，它只能用来处理多字节字符串（MBCS）的正则表达式操作，而这个字符串是和系统的区域信息（locale）相关的。同样是简体中文区域，Windows 的字符集是 GBK，OSX 和 Linux 的字符集是 UTF-8。如果不给这个库增加其他字符集的支持，那它基本上就对多字节字符（汉字、喃字、假名等等）无能为力了，毕竟在表示“ASCII 以外的字符”这一个概念时不同编码方案码是不一样的。不过好在 Boost 的设计者很清楚这一项需求，在 boost/regex/icu.hpp 中定义了两个额外的正则表达式结构：wregex（处理宽字符）和 u32regex（处理 UTF-8、UTF-16 和 UTF-32），不过内部要依赖于 ICU。考虑到我准备使用 UTF-8 作为字符串的编码基础，必须要用上 ICU；而要用 ICU，就必须自己编译 Boost。 注意，接下来的部分过程只适用于 Windows，因为 Linux 一般是预置了 ICU 的，只需要简单指定就好，bjam 会自动完成设置。 一、编译 ICUICU 也是一个独立的库，和 Boost 是同级的关系。要用 ICU 的功能，必须要先编译 ICU。 到 ICU 的官网上下载源代码包（需要翻墙），编译很简单，打开 source/allinone/allinone.sln，编译就好。注意选择 Release 模式编译。 二、编译 bjambjam（b2）是 Boost::Build 的别称，是一个自动构建程序，附带在 Boost 源代码包中。正常的情况下，直接执行 bootstrap.bat 就能自动调用 Visual C++ 编译 bjam。 三、编译 Boost::Regex我之前将 ICU 放在了 F:\\icu，下面的路径按照需要更改即可。 执行 bjam 的时候它会先启用检测，输出类似这样的提示： Performing configuration checks - 32-bit : yes - arm : no - mips1 : no - power : no - sparc : no - x86 : yes - symlinks supported : no - junctions supported : yes - hardlinks supported : yes - has_icu builds : no 如果 has_icu builds 一项值为 no，按照说明中仅指定 ICU_PATH 是不行的，编译出的库照样不包含 ICU 功能（表现为链接时找不到与 ICU 相关的符号）。所以，只好想一种方法让 has_icu builds 这一项变为 yes 了。 检查错误日志 config.log 发现，这一项是用构建一段含 ICU 的代码来检测的。编译是通过了（如果没指定 ICU_PATH 就无法编译），但是说链接时找不到符号。这就好办了，加入静态库搜索路径和库名（注意按照 VC++ 的选项格式）执行，果然就能正常编译链接了，这一项也变成了 yes。 我现在所使用的完整选项如下： bjam boost.locale.icu=on boost.locale.winapi=off boost.locale.iconv=off boost.locale.std=off -sHAVE_ICU=1 -sICU_PATH=F:\\icu -sICU_LINK=&quot;/LIBPATH:F:\\icu\\lib icudt.lib icuin.lib icuio.lib icule.lib icule.lib iculx.lib icutu.lib icuuc.lib&quot; --with-regex --toolset=msvc-14.0 link=static threading=multi stage bjam 中的 -s 开关相当于设置临时环境变量，不是选项开关。你也可以通过 set ICU_PATH=F:\\icu 这样的语法，在命令提示符中设置。MSVC 14.0 工具集指的是 Visual Studio 2015 的工具链（cl.exe 版本 19）。 bjam 是带缓存的。生成的中间产物在 bin.v2/libs 下，成品在 libs 下。bjam 并不会检查当前的遗留编译结果是否是最新，只要文件存在而且大小不为零就会被跳过，环境改变（如 ICU 的存在性发生改变）也不会引发重新编译。所以清除缓存的话要删除这两个目录，强制完全重新编译。设置缓存在 bin.v2/project-cache.jam，如果初次检测的结果是 ICU 不存在，而后来配置好了 ICU，就需要删除这个文件并重新执行 bjam 来检测，否则一直会用其中缓存的结果。 四、用户代码首先更新包含文件搜索目录。加入 Boost 的头文件目录（boost/boost）和 ICU 编译后生成的头文件目录（icu/include）。 然后更新库文件搜索目录。加入 Boost 的静态库目录（boost/stage/lib）和 ICU 编译后生成的库文件目录（icu/lib）。 然后包含（注意 BOOST_HAS_ICU 的定义，及其位置）： #define BOOST_HAS_ICU #include &lt;boost/regex.hpp&gt; #include &lt;boost/regex/icu.hpp&gt; #pragma comment(lib, &quot;icuuc.lib&quot;) #pragma comment(lib, &quot;icuin.lib&quot;) #pragma comment(lib, &quot;icudt.lib&quot;) #pragma comment(lib, &quot;libboost_regex-vc140-mt-1_59.lib&quot;) 注意引用的库名字 libboost_regex-vc140-mt-1_59.lib 的含义如下： regex：正则表达式部分； vc140：用 VS 2015 的 VC++ 工具链编译（编译出的静态库需要用同版本工具链才能链接）； mt：线程模型为多线程（上面 threading=multi 指定的，这也是 VC++ 工程的默认选项）； 1_59：Boost 版本为 1.59。 在用在自己的工程中时一定要注意改名。当然这些库文件搜索也可以放到 VC++ 工程的“附加库文件”设置中。 此时就可以正常编译链接了。（又是一次数小时排错的过程……）","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"CPlusPlus","slug":"CPlusPlus","permalink":"https://blog.mottomo.moe/tags/CPlusPlus/"},{"name":"Boost","slug":"Boost","permalink":"https://blog.mottomo.moe/tags/Boost/"}]},{"title":"杂记","slug":"zh/2016-05-09-Misc","date":"2016-05-09T01:11:00.000Z","updated":"2020-03-30T22:34:35.439Z","comments":true,"path":"categories/Misc/zh/2016-05-09-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-05-09-Misc/","excerpt":"杂记。","text":"杂记。 05-06: 3日还在到大连的船上的时候收到了一封邮件，是一位也在向 CGSS 发起猛攻的同好发来的。6日的时候发邮件回复了。 首先，我曾经以为应该只有我想做而且在做一个练习器。一句“不过你现有文章写的东西基本我自己之前都走过一遍了”，我听到了什么东西碎掉的声音。毕竟又有大神盯上了…… 后记： 在聊天中，才知道已经有人攻破了 CGSS 的通信协议（是不是这位仁兄找到的方法另说，但是肯定实装了），再想想我对这一块的弱爆了的几句话，不管是技术上还是渠道上我都完败了啊。哎我真的不是核心音游或手游玩家，当初玩的原因只是练手，然而由于自身悟性差所以时间投入越来越多，所以一般降低频率到就一天一两次了。而且既然已经能玩 master 难度（虽然，没有一个，FC），觉得差不多该收手了，热情也在一天天消退，余下的完全就是对软件技术层面挑战的激情了。 ╮(╯_╰)╭ 05-08: 云音乐上收到了评论（这里）： 唔……怎么说呢 翻译辛苦了 不过错误非常多…… 语法一塌糊涂 还有一些只要查字典就懂的用词错误 建议po主 还是好好理解再翻译吧 我承认啦，当时就是翻了几首后上瘾了结果水平根本不够还不用心（只是为了完成自己的“量”的指标）一些歌就很不幸地被拖下水了。然而现在已经无法弥补，私信退翻译这数量实在是有点大。 最后一根稻草是这一条私信： 仅通知一下，是这样的，2nd其中一首比较难翻译的歌的歌词译者(我就隐去具体名字了)提出了抗议，说是如果我用你的翻译他会拒绝我使用他的翻译。这个情况我还在交涉中，我尽量争取一个和谐的结果，这也同时意味着我有可能还会再对你重新修改的歌词进行修改。 因为2日的时候收到了这样的私信： 同僚のプロデューサーさん、どうも！ 目前本人在施工CG 2nd LIVE的熟肉，预定会征用您所投稿的字幕，如果你拒绝，请回信告知，谢谢！ 如果您对所投稿的翻译仍有不满意的地方，那么这次是您填补遗憾的另一次机会！如果您有修改翻译的意向，敬请告知，谢谢！ 和 Angel Breeze 事件的时候一样，我是很高兴的。后来上面这一条消息一到，又如晴天霹雳。我是怀着苦闷的心情写下道歉的： 您好！感谢您的耐心协调。我去年秋天初学日语，翻CG系列歌曲的那段时间（十月到一月）即使不确定的句子也没有校对，两个月来在几首歌里都被指出了许多错误，想必已经有许多人“瞻仰”过（ta应该也是其中一位），把我钉在耻辱柱上了。这对于翻译而言是失职，这是我经历中抹不掉的污点。所以Angel Breeze那事出来以后，我感到水平未到的歌都没敢动，而且即使开工也会谨慎检查。如果某一首歌ta有自己的翻译版本，请选用ta的。 我很感激这次您施工2nd字幕而提供的机会，我把它看成一次重生的可能性，所以会用最严肃的态度来完成。无论如何我都会给您一份认真的翻译稿，如果ta坚持要求非此即彼，您可以忽略我提供的这些翻译；贴吧等地应该还有其他爱好者的翻译，不妨联系他们，带来的不便我很抱歉，但是我种下的恶果我要自己吃完。 再次感谢您提供的机会。无论是谁提供的帮助，iM@S社区整体前进了，我就由衷地感到快乐。祝好。 这位仁兄的气度令人称赞： ……您的肺腑之言我已经听到了，我会尽力争取的。作为本次的2nd字幕制作，歌词部分尽管大都取自各处爱好者所上传发布的翻译，但是这些都是对iM@S的爱所凝结的结晶，每一位的译者都应该受到尊重；同时意见想法也是可以交流的，所谓的润色修改也只是我们交流的一种手段。我也感谢您能够接受我突然的请求，能让我们的工作量能够稍微地减轻一些。同时我也肯定您热情负责的态度，也因此相信您能够拿出大家认同的优秀的翻译作品。 就我们来说，并不是什么特别专业的字幕组，也并没有什么很严格很效率的组织。我们仅仅是临时凑起来的5位因为对iM@S的爱而在一起伤肝劳神的头脑发热的青年而已。我们同样也只是想将让更多人能够跨越语言的障碍来感受iM@S的魅力。讲漂亮话，是结合社区内容；讲实际，其实也只是偷懒而已。 我本人再次感谢您的努力和支持，希望大家一起好好努力吧。 当时是凌晨两点半。对于几天来遭遇了多重打击的我来说，这一份回复就是黑暗中的灯火。噫！他可能不知道他一段话对屏幕那边的我来说会怎么样，但“三冬暖”差不多就如此吧。 9日到10日我以我现在的水平仔细校对了之前的翻译，选中的几篇中也存在许多完全错误的翻译，还有不少逻辑和原文不一致的，我自己都不想多看，是一边吐一边修的。说拒绝使用的那位哥们儿，我觉得我能体会到你的心情，如果是我我也不想让自己的作品与这样不负责任的作品同台。 10日我觉得已经是自己能做到的最好状态了，再请糖王菊苣帮忙修订。昨天（10日）晚上糖王发回了第一篇歌词的他的版本，看完之后我的感觉是：我能做到的最好的还有小错误先不说，语言包装上我又完败。我还自不量力地说“加署糖王的ID”呢，这下子直接把我删了算了，文字已经与我写的无关，完全就是糖王一人的嘛！既然在最终作品产生中没作用，相当于原作者被推翻，未发表时新作者重写，惯例上前者就没他什么事了。 所以记住了： 弱还想出去装X，打脸打得啪啪响。 不确定的一定要请菊苣看！一定要问！ 对于翻译这类严肃的职业，水平不够不只是被打脸，而且人品也会被连累。 这是血泪的教训。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"坦塔罗斯之苦痛","slug":"zh/2016-05-04-Tantalus-Pain","date":"2016-05-04T15:30:00.000Z","updated":"2020-03-30T22:34:35.439Z","comments":true,"path":"categories/Misc/zh/2016-05-04-Tantalus-Pain/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-05-04-Tantalus-Pain/","excerpt":"4日上午回到学校。一直到晚上都疼！虽然感觉上是腹胀吃不了东西，但是实际饿，低血糖。 心神不宁，什么都做不了，翻译啊代码啊论文啊什么的。","text":"4日上午回到学校。一直到晚上都疼！虽然感觉上是腹胀吃不了东西，但是实际饿，低血糖。 心神不宁，什么都做不了，翻译啊代码啊论文啊什么的。 05-11 后记： 先把前因后果补全。当时给这篇文章取名“坦塔罗斯之苦痛”的意思就是明明其实肚子很饿了，却吃不进任何东西，就快虚脱了。 五一的时候去青岛-烟台-大连走了一圈。在到烟台的第一天晚上（4月30日），应该是吃的蛏子不干净，第二天早上腹泻并有强烈的恶心感，吐了四五次，无食欲，四肢无力。瑞福和阿飞出去看城区了，我就躺在被子里。中午体温升上去了，下午高烧，傍晚半退，爬起来到巷子另一边去买了几个苹果（期间等着这整条巷子唯一一个卖水果的老太太给一对母女削完整个菠萝），吃了两个，继续倒在床上。晚上体温回落，能正常交流了，但是还是吃不了东西，只加了一个苹果。 第二天整体感觉好多了，就认为已经恢复，可以正常活动了。腹胀感还在，不过严重程度我认为正常。但是到了大连（2日晚）一餐杀猪菜又把我干倒了，又有了恶心感。之后两天都是在隐隐的腹痛中度过的。 4日中午（就是写上面的文字之前）去校医院看了一下（只有一个发热门诊是外科门诊啊），那医生一个劲地问我现在是不是发热——你逗我吗，我说了现在不发热，然而过去几天出现了呕吐和腹泻啊。然后我就收到了柴胡这样退烧的药方，还有一个铝碳酸镁咀嚼片还有一个味道奇怪的黄色小丸子（胃药）。中午吃了一套，晚上吃了一套，睡觉。 第二天早上六点多就被疼醒了，此时食道里还充斥着那黄色小药丸的味道。这一天刚好是预定的去沙河拍毕业照的日子，他们准备七点半过去，反正就撑着在走的时候由晓鸣和范成看着再到校医院看了一次，这次看的是肠道内科（啊范成直接挂的号，这锅我不背），医生认为是慢性胃炎，开了几个缓和慢性胃炎的药。问题是，我没有慢性胃炎。这时候已经因为几天几乎没吃东西+奔波，快没力气了。再回到宿舍后，不管三七二十一又吃了这一次的药，感到胃酸上来了就加了两片铝碳酸镁。差不多九点半的时候，第二波疼痛来了；我没看自己的脸色，不过可能就是蜡黄或惨白吧。跟家里打了两个电话后又向校医院进发，同时向班主任乔老师报告了当前的情况。接到电话后乔老师带着小郄就冲过来了，所以说不是我安利，乔老师是一个十分爱护学生的老师，真的是几辈子福气啊。这次再次来到发热门诊，医生还问我昨天是不是来过。“来过啊，医生，但那药完全没用啊。”做了血液检查后，医生说结果已经被药物干扰了（似乎是“中性细胞都到70了”这样的表述，不过我不懂；其实我不久之前才吃了缓解慢性胃炎的药啊），但是还是可能是发炎。不过我就腹部左侧（我自己的左侧）疼，其他位置（胸腔、腹部其余位置）没事，体温也不高（37度多一点点），挺难判断情况的。而且疼痛是一波一波来的，到就诊的时候已经降低到普通的痛感了。这次开了消炎药，回去下了一粒，吃了一点点小郄从食堂带的粥，继续到床上躺着。傍晚明显轻松了，腹胀感和疼痛大大减轻了，继续加一粒消炎药，睡觉。晚上精神也好了很多，去热水房打了一壶热水，泡了两包乔老师给的藕粉，这是几天来真正吃进去的东西。 不过到现在，消化系统还是没恢复到去青岛之前的健康状态，不要问我是怎么知道的，这是常识。 最后的结论：蛏子给我留下了阴影，就如同四年级的时候青岛的牡蛎，那味道我不想再体验了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"雷吉欧斯中的一段告白台词","slug":"zh/2016-04-27-Regios-Kokuhaku","date":"2016-04-27T06:41:00.000Z","updated":"2020-03-30T22:34:35.439Z","comments":true,"path":"categories/ACGN/zh/2016-04-27-Regios-Kokuhaku/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2016-04-27-Regios-Kokuhaku/","excerpt":"又有一些文章啦，但都只处于列了提纲的状态，放假回来再补完。（&lt;ゝω・）☆ （05-11：什么？我之前没说过什么话吧？） 总体来说，这动画看着就是掉智商的。据说把小说又改乱了——不过说真的，异世界开挂这种东西套路还是太多，个人并不怎么喜欢，就是小说也离我太遥远。 一句话概括：满级高手来新手村洗点，见证小白买外挂到续费失败全过程。 于是就把这当做吃饭时不用动脑的东西看了。看完之后除了吐槽各种不合理（吐槽我就输了）之外，就注意了一段台词，EP18 20:56。","text":"又有一些文章啦，但都只处于列了提纲的状态，放假回来再补完。（&lt;ゝω・）☆ （05-11：什么？我之前没说过什么话吧？） 总体来说，这动画看着就是掉智商的。据说把小说又改乱了——不过说真的，异世界开挂这种东西套路还是太多，个人并不怎么喜欢，就是小说也离我太遥远。 一句话概括：满级高手来新手村洗点，见证小白买外挂到续费失败全过程。 于是就把这当做吃饭时不用动脑的东西看了。看完之后除了吐槽各种不合理（吐槽我就输了）之外，就注意了一段台词，EP18 20:56。 レイフォン：「フェリ。」 雷冯：“菲丽。” フェリ：「疲労ひろうが回復かいふくするまで、念威ねんいの使用しようは禁止きんしられました。」 菲丽：“在从疲劳中恢复之前，我被禁止使用念威。” レイフォン：「そうですが。」 雷冯：“这样啊。” フェリ：「でも、あなたが望のぞむなら、端子たんしなしでも念威ねんいが飛とばせます！あなたが望のぞむなら、汚染獣おせんじゅうの鱗うろこの数かずまで数かぞえで見みせます。あなたが望のぞむなら…私わたしはそうします。どうしますか？」 菲丽：“但是，如果你希望的话，即使没有端子我也能放出念威！如果你希望的话，污染兽身上鳞片的片数我也会数给你看！如果你希望的话……我就会这么做的。你的选择呢？” レイフォン：「やめておきます。」 雷冯：“请别那么做。” 这一段结合菲丽的设定（脑中处理大量信息，所以难以表达情感），表演出来实在是带感。三句之间的停顿、渐进、高亢到柔和，中原麻衣表演很到位。而且这一段摆明了不就是表白嘛，不同于文科生的舞文弄墨，这一段可是相当的理科生——“缺乏想象力”，却充满了实用主义。不说花前月下，说的是能解决问题（菲丽是负责情报支援的，雷冯是攻击战力）。意料之外，情理之中，当人物做出了与平日相异、却是自身特性延展的举动的时候，最能让人会心一笑。 这段对话，也许不是最精致文雅的，也不是最别出心裁的，但这风味还是能好好咀嚼一番。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"为 NGUI 设置动态字体","slug":"zh/2016-04-20-Dynamic-Font-for-NGUI","date":"2016-04-20T01:20:00.000Z","updated":"2020-03-30T22:34:35.439Z","comments":true,"path":"categories/Tech/zh/2016-04-20-Dynamic-Font-for-NGUI/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-04-20-Dynamic-Font-for-NGUI/","excerpt":"","text":"Unity3D 工程中，UI 用的是 NGUI。在 3D 程序中，文字绘制并不像 GDI 的字体光栅化那么直接，除了 DirectWrite/Direct2D 这种结合 GDI 的，其他大多都是手工管理 sprite font。一般的字体应用方法，主要是静态和动态两种，区别就在于是读取缓存的贴图还是运行时生成贴图。 我开始是看着网上的教程，用 BMFont 生成了静态贴图——但是由于目标字符集是 Shift-JIS，这个量实在是很大，贴图的量看起来十分吓人。然后我才发现，新版本的 NGUI 是支持使用 TTF 作为源生成动态字体的。不过系统字体都是 TTC，要转换为 TTF。鉴于许多教程中提到的 TTCTools 不能用（这是 16 位应用程序，64 位系统不带 WOW16），于是找到了两种方法：UniteTTC，和 AiFont。我用的是后者，导出了其中一个字形（TTC 可以包含多种字形，比如常规、斜体、粗体、粗斜体、半宽）的 TTF，能正常绘制文字。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blog.mottomo.moe/tags/Unity3D/"}]},{"title":"为 Unity3D for Android 编译 SQLite 3","slug":"zh/2016-04-19-Build-SQLite3-for-Unity3D-for-Android","date":"2016-04-18T18:43:00.000Z","updated":"2020-03-30T22:34:35.438Z","comments":true,"path":"categories/Tech/zh/2016-04-19-Build-SQLite3-for-Unity3D-for-Android/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-04-19-Build-SQLite3-for-Unity3D-for-Android/","excerpt":"作为 CGSS 反向的成果聚合部分的一个环节，Unity3D 的 SQLite 插件是必经之路。在 Asset Store 里有，不过15刀的价格对于其功能而言还是有点高。研究了一晚上，最后结合 NDK 将 SQLite 3 编译到了 Android 环境上，整合到 Unity3D 中是第二天的事了。","text":"作为 CGSS 反向的成果聚合部分的一个环节，Unity3D 的 SQLite 插件是必经之路。在 Asset Store 里有，不过15刀的价格对于其功能而言还是有点高。研究了一晚上，最后结合 NDK 将 SQLite 3 编译到了 Android 环境上，整合到 Unity3D 中是第二天的事了。 一、最终的解决方案最终的方案其实很简单，在 GitHub 上已经有人写了自动为编译 SQLite for Android 的脚本。我做了一个 fork，增加了一些修正。 直接 git clone 之后，切换到该目录，make 就可以了。 编译完成之后，取出两个 libsqlite3.so，放到 Unity3D 工程的 Assets/Plugins/Android/libs 下的根据 CPU 架构命名的目录中。可以放到整个工程中的 Plugins，也可以放到“插件”（主工程也可以视为一个插件，我就是这么做的）的里面。目录结构大概是这样的： D:\\SOURCE\\UNITY\\DERETORE\\ASSETS └─DereTore ├─Plugins │ ├─Android │ │ └─libs │ │ ├─armeabi-v7a # libsqlite3.so │ │ └─x86 # libsqlite3.so │ └─Windows │ └─libs │ └─x86 # sqlite3.dll └─Resources 在 Unity3D Editor 中，选择这些动态库，在 Inspector 中为它们选择对应的平台和 CPU 架构。完成后编译工程，Android 的应该位于 ${APK}/lib/${ARCH} 路径下。 二、交叉编译初试我以前的应用场景多是 Linux 服务器，系统是 CentOS。这次一上手，就用的是 64 位 CentOS 的机器。在 SQLite 的下载页面，选择一个 autoconf 版的压缩包下载（毕竟名字都表明了嘛）。然后是一贯的搭建编译环境。 $ yum install gcc 接下来我是沿着前人的足迹前进的，“顺利编译了”X86 版本。（我们的目标是 Android，这里虽然编译链接通过，但是实际运行是跑不起来的，原因后面会说。） 接下来就要转到 ARM 移植上了。我一看需要一个 arm-linux-gcc，那肯定是需要安装的啦，赶快： $ yum search arm-linux 显示符合条件的只有一个 gcc-arm-linux-gnu.x86_64 包，那就安装吧。 $ yum install gcc-arm-linux-gnu 好了，根据前人足迹，换上这一套配置： $ cd ../arm $ ../../configure CC=arm-linux-gnu-gcc --host=arm-linux /root/sqlite/bin/arm/target $ make $ make install 然而却说找不到 arm-linux-gcc。网上还有很多教程都用的是（不知来源的）arm-linux-gcc，除了上文的，还有这个。难道一定要一个 arm-linux-gcc？有人甚至自己重新编译了一份，但是大多数教程用的都是由 ARM9 提供的一个很老的版本 ARM-Linux GCC 4.4.3。（现在 GCC 4.x 都到了 4.8.1 了！） 然后我尝试将 host 参数值换成 arm-linux-gnu，这样： $ ../../configure CC=arm-linux-gnu-gcc --host=arm-linux-gnu /root/sqlite/bin/arm/target 结果 configure 失败了，提示编译器编译出的东西不可运行，因此编译器不可用。 我认为是 64 位 CentOS 的软件包丰富度问题，换上了阿里源、网易源（我用的是 Conoha 的 VPS，默认使用日本某 FTP 源），都没有其他的包。然后我换了一个 32 位的 CentOS，甚至还没有这交叉编译包。 三、结合 NDK 的编译想到 CGSS 中见到的架构是 ARM EABI v7，是不是该搜索这个版本的 GCC？于是找到了有一个叫 arm-eabi-gcc 的东西，继续搜索，见到了科普。然后又在哪里看到的（我忘了），有人在 Ubuntu 上编译 SQLite for Android，既然能编译那么我也该试试，于是切到 Ubuntu 上。版本呢？我想着尽量减少交叉编译次数，就选择了 32 位的版本（14.04 x86）。 不过，看起来不管怎么样我都得需要一个 NDK。配置了 NDK 之后，继续尝试编译。这次我学乖了，首先看看 X86 的行不行： $ ../../configure CC=gcc CFLAGS=&quot;-nostdlib -I$NDKROOT/platforms/android-19/arch-x86/usr/include/&quot; LDFLAGS=&quot;-Wl,-rpath-link=$NDKROOT/platforms/android-19/arch-x86/usr/lib/ -L$NDKROOT/platforms/android-19/arch-x86/usr/lib/&quot; LIBS=&quot;-lc&quot; --prefix=/root/sqlite/bin/x86/target 看起来配置正常，make。然后在编译阶段就报错说 crti.o 和 crtn.o 找不到。这又是什么东西？从 StackOverflow 上我了解到，这是一个启动库（在 Windows 下，cl 会自动加 stub，Linux 下的 stub 就由这两个库构成）。至于 Android，它使用的不是标准 stub，而是 Android 自己的。上面的 -rpath-link 选项的解释在这里。 途中我还学习到： Linux 下的环境变量设置 用户环境变量直接使用 X=Y 就可以了，比如 X=Y gcc a.c -o a.out，在 gcc 看来，环境变量 X 的值就是 Y。 系统环境变量类似，因为本身是 bash 脚本，所以直接将类似的设置过程写入 /etc/profile，重启。 apt-get 和 yum 的使用差异 yum 有一个很好用的 yum search，对应的 apt-get 命令是 apt-cache search…… 接下来是几组我试过的失败的参数，各位有兴趣自己试试（错误提示忘了，还原一遍就知道了吧……）： $ ../../configure -host=i686-linux-android CC=$NDKROOT/toolchains/x86-4.8/prebuilt/linux-x86/bin/i686-linux-android-gcc --prefix=/root/sqlite/bin/x86/target $ ../../configure -host=i686-linux-android CC=$NDKROOT/toolchains/x86-4.8/prebuilt/linux-x86/bin/i686-linux-android-gcc CPPFLAGS=&quot;-I$NDKROOT/platforms/android-19/arch-x86/usr/include/&quot; CFLAGS=&quot;-nostdlib&quot; LDFLAGS=&quot;-Wl -L$NDKROOT/platforms/android-19/arch-x86/usr/lib/&quot; LIBS=&quot;-lc -landroid -ldl -lm -llog -lz&quot; --prefix=/root/sqlite/bin/x86/target $ ../../configure -host=arm-linux-androideabi CC=arm-linux-androideabi-gcc CFLAGS=&quot;-nostdlib -I$NDKROOT/platforms/android-19/arch-arm/usr/include/&quot; LDFLAGS=&quot;-Wl,-rpath-link=$NDKROOT/platforms/android-19/arch-arm/usr/lib/ -L$NDKROOT/platforms/android-19/arch-arm/usr/lib/&quot; LIBS=&quot;-lc -landroid -ldl -lm -llog -lz&quot; --prefix=/root/sqlite/bin/arm/target $ ../../configure -host=arm-linux-androideabi CC=arm-linux-androideabi-gcc CPPFLAGS=&quot;-I$NDKROOT/platforms/android-19/arch-arm/usr/include/&quot; CFLAGS=&quot;-nostdlib&quot; LDFLAGS=&quot;-Wl,-rpath-link=$NDKROOT/platforms/android-19/arch-arm/usr/lib/ -L$NDKROOT/platforms/android-19/arch-arm/usr/lib/&quot; LIBS=&quot;-lc -landroid -ldl -lm -llog -lz&quot; --prefix=/root/sqlite/bin/arm/target 我也试过 Roman10 的构建脚本，使用 ndk-build 编译，不过也没成功。 最后是用第一段所说的自动构建的方式编译链接完成的，无意中找到的 repo。ndk-build 的几个常用参数说明见这里。 要注意，SQLite 的源代码有两种发行版本，amalgamation 版是整合版（所有代码位于一个 .c 文件中），autoconf 在此基础上加入了一些 TCL 的配置脚本。后者更适合对于 PC 上的 Linux 的编译，不过这些自动配置对为 Android 编译来说反而是累赘。 四、Unity3D 中使用 SQLiteCGSS 有自己对 SQLite 的封装，编译失败的时候我差点就要用这些封装+它带的 libsqlite3android.so 了。 编译后我照着 Momo 的教程将文件放到了合适的位置、设置 Inspector 属性（这一步他没提，自己填坑）。终于，数据库的连接测试成功了。 但是在执行查询的时候没任何反应。使用一下 adb logcat -d -s Unity，发现这样的信息： 04-19 21:21:27.817 8205 8221 I Unity : EntryPointNotFoundException: sqlite3_column_origin_name 04-19 21:21:27.817 8205 8221 I Unity : at (wrapper managed-to-native) Mono.Data.Sqlite.UnsafeNativeMethods:sqlite3_column_origin_name (intptr,int) 04-19 21:21:27.817 8205 8221 I Unity : at Mono.Data.Sqlite.SQLite3.ColumnOriginalName (Mono.Data.Sqlite.SqliteStatement stmt, Int32 index) [0x00000] in &lt;filename unknown&gt;:0 04-19 21:21:27.817 8205 8221 I Unity : at Mono.Data.Sqlite.SqliteDataReader.GetSchemaTable (Boolean wantUniqueInfo, Boolean wantDefaultValue) [0x00000] in &lt;filename unknown&gt;:0 04-19 21:21:27.817 8205 8221 I Unity : at Mono.Data.Sqlite.SqliteDataReader.GetSchemaTable () [0x00000] in &lt;filename unknown&gt;:0 可以搜索到大概的原因，在 SQLite 的编译指导文档中可以确认。然后使用宏定义加入这个定义——注意，不是设置环境变量，而是加入到 CFLAGS（SQLite 仅使用了 C 编译器）这个特殊“环境变量”（内置宏）中，所以我最后是将这个定义加入了 LOCAL_CFLAGS 中。加入之后就可以正常查询了。 最后，Momo 还展示了一种很有趣的同时适用于 JNI 和 P/Invoke 的代码编写技术。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blog.mottomo.moe/tags/Unity3D/"},{"name":"Android","slug":"Android","permalink":"https://blog.mottomo.moe/tags/Android/"},{"name":"SQLite","slug":"SQLite","permalink":"https://blog.mottomo.moe/tags/SQLite/"}]},{"title":"软件工程中的“忒修斯之船”","slug":"zh/2016-04-19-Ship-of-Theseus-in-Software-Engineering","date":"2016-04-18T17:59:00.000Z","updated":"2020-03-30T22:34:35.438Z","comments":true,"path":"categories/Misc/Thoughts/zh/2016-04-19-Ship-of-Theseus-in-Software-Engineering/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2016-04-19-Ship-of-Theseus-in-Software-Engineering/","excerpt":"","text":"晚上洗衣服的时候刚好碰到一个同学，他说关于他们实验室正在写的软件，如果有什么不懂的能不能来问我。我了解到，他们做的是一个软件的二次开发，于是就对他说：“二次开发最难的不是在你写的东西上，而是在如何对接和使用宿主已有的功能。”我说他们写东西不难的意思是他们仅是一般本科生的水平，实干的是一些类似查询零件信息存入数据库之类的相对简单的活，作为毕业前的一次训练，正是所谓“不掌握核心技术”。我说，二次开发的一种策略是，先写一个最简单的，往工具栏上加入一个按钮，按下之后弹出“hello world”对话框，接下来函数啊属性啊什么的都好办。这个 hello world 确定了三点： 你的插件（或者类似物）能被正确加载； 这个插件提供了最基础的输出，一个按钮（显示的信息可用于调试）； 这个插件能和用户进行交互。 然后再在它的基础上开始写功能。就好像，要车，先造出一辆手推车，车架不散，轮子能滚。要加速？装上发动机。要省力？加上轮胎。这样一点一点改进，时间足够最终能造出跑车。怕就怕开始选个方轮子就直接开始造跑车了。 这方法比起测试驱动来说真的是老土多了，不过仍然能给他们上一课。不过今天的重点不在这里，我想的问题是，忒修斯之船的争辩是不是这种“框架式”（包括测试驱动）开发的思想基础呢？ 忒修斯之船的悖论产生自人对“整体”、“部分”，以及在第二问中加上的“时间”，这些要素的认知是不统一的。部分有机组合成的整体，是大于部分之和的，大于的部分就是人为赋予的“含义”，比如纪念意义。就拿工业产品而言，具有互换性的产品对于不同人来说还是不一样的，用工具用久了就产生了熟悉感甚至感情，这部分是不属于互换性的、使用中添加的“含义”。忒修斯之船之所以是一艘特定的船，是因为这个问题的提问者已经假设了它的独一无二性。 回到软件工程中。软件的标准之一，来自于算法，是可复现性——给定输入，环境相同，算法不变，输出就不变。在测试进程的眼里，整个程序由测试用例组成，这些用例只有“通过”和“不通过”两种状态。而不管用例内的代码是如何组织的、存在何等的关联，对于测试进程而言它们仍然是独立的用例。在这样的一个设定中，“程序”这个整体是由各个“用例”部分简单列出的，关系是整体等于部分之和。有了无关性保证，只要所有的部分不缺失（测试通过），就可以认为整体是完整的。 所以，当我按下按钮弹出“hello world”的时候，我就可以认为鼠标事件响应是没问题的了。之后无论这个处理函数内写了什么功能，和“可以响应”这个结果都无关。这是我挂在嘴边的“功能上等价”的内涵，也就是一些时候我看到或者做了非常抽象的功能实现，就认为这个结果已经表明最后很可能成功。他们总是将思维局限在当前这个“快照”（snapshot）上，而不是后面代表的设计上，所以不理解简单的示例的意义在哪。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Windows 10 10586.218 更新的灾难","slug":"zh/2016-04-17-Windows-10-10586-218-Disaster","date":"2016-04-17T11:31:00.000Z","updated":"2020-03-30T22:34:35.438Z","comments":true,"path":"categories/Misc/zh/2016-04-17-Windows-10-10586-218-Disaster/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-04-17-Windows-10-10586-218-Disaster/","excerpt":"收到了 10586.218 更新后我第一时间安装了。第二天早上起来，提示安装失败。我以为和前面的几个更新差不多，安装几次就好了，就再安装了几次。最后的确是没报告错误了，但是一进入系统我就发现了异常：风扇呜呜转得飞快。","text":"收到了 10586.218 更新后我第一时间安装了。第二天早上起来，提示安装失败。我以为和前面的几个更新差不多，安装几次就好了，就再安装了几次。最后的确是没报告错误了，但是一进入系统我就发现了异常：风扇呜呜转得飞快。 然后我更惊恐地发现：svchost 的 DCOM 服务器进程一直维持 18% 左右的 CPU 占用率。我机器上的 CPU 是四核，这就意味着一个核被榨干了。而且，我的 CPU 一般主频是 2.26 GHz，睿频是 3.1 GHz，在任务管理器的性能窗口中看到整个 CPU 在以最高主频运行！我去，这还不烧了 CPU？！ 赶快应用重启大法，还是不行！当时还能用 QQ，这是我发出的几乎绝望的信息： 补丁安装/卸载4次，DCOM那个还是无法解决，累觉不爱 已知的无法使用的东西： 各种浏览器（包括 NW.js、基于 Electron 的 Atom 和 VS Code）、MS Office、Steam 一切UWP App相关（1、尝试启动任何一个UWP App之后，或2、一段“宽限期”之后），包括Windows 更新、计算器、应用商店、信息中心和开始菜单（后面这两个可以在“宽限期”内多次使用，不计入第1条）、ProgMan的高级功能如Alt+Tab 能使用： VS、JetBrains的各个IDE （说着，现在开始菜单已经无反应了） 总之中期报告什么的，这电脑上就废了。编码么，电脑上开一个热点，查手册就要用手机……但是开发者工具怎么办？我想用JS REPL啊，Node不适合这个场景啊…… 总之，微软赶快出修复这个问题的补丁，我特么就算是手工下载也要修！ DCOM这个，CPU占用率应该基本上为零才对 然后我又发现：一切 DX 程序都不行了……我的毕设就是基于 DX 的，然而在创建 D3D Device 的时候就挂起（无 CPU、内存、磁盘活动）了。SharpDX+DX11 不行，C++ 下尝试初始化 DX9 也不行。 Media Creation Tool（一种利用 MCT 的偏门的“就地升级”的恢复方法）开始后挂起；系统映像选择“升级”后也挂起。 由于我安装的软件、配置的环境太多了，想尽量避免重装和重置（关于重置，大家自行搜索一下可能结果）。由于我没开系统恢复，而lan姐提到了 Dism++ 卸载并屏蔽更新（不过版本回退到164后问题还存在，看来是扎根了），我发现里面有一个自动修复的功能。搜索了一下，Dism 的修复： Dism /Online /Cleanup-Image /RestoreHealth /Source:F:\\TEMP\\w10crash\\install.wim /LimitAccess 不指定 /Source 就会从“默认源”（Windows Update）中加载，不过这永远是失败的。 install.wim 是怎么来的？是lan姐提取的 ESD（就在系统映像里），然后 ESD 转换为 WIM 的。虽然 ESD 是极端高压版 WIM，不过 Dism 并不认识 ESD，必须要转换。 不过还是失败了，不管是用164的源还是218的源。 在绝望之下，只好采用了 USB 加载 PE，选择从虚拟光驱文件启动，全新安装的办法。（由于原整个磁盘都已经是 GPT 分区了，所以记住打开 BIOS 中的 UEFI Only！）其实到了这一步，和用安装器直接展开 ESD 没什么区别了…… 哎，又得重新配置整个系统了。重装后文件安全信息中 SID 丢失的问题，又得遇到一次。 主要收获是 Dism 的用法。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"从一次失误中注意到的 System.Media.SoundPlayer 流读取","slug":"zh/2016-04-13-SoundPlayer-Stream-Reading","date":"2016-04-13T09:03:00.000Z","updated":"2020-03-30T22:34:35.438Z","comments":true,"path":"categories/Tech/zh/2016-04-13-SoundPlayer-Stream-Reading/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-04-13-SoundPlayer-Stream-Reading/","excerpt":"在 kawashima 主体完工之后我转向了 C# 的实现。自然，接口风格就要用 Stream 的风格啦。我已经做好了 kawashima 的流式封装，接着来做纯 C# 版的。虽说过程中遇到了各种坑，但是最后基本上都过去了，实现了文件从 HCA 到 WAV 的解码（固定逻辑）。写了流式封装之后要进行测试，最好的测试方式就是用 System.Media.SoundPlayer，它的一个构造重载接受一个 System.IO.Stream 类型的流，从中读取 WAV 数据，进而调用系统 API 播放。P/Invoke 版的就是这么测试的。 然而此次测试中发现一个奇怪的现象。新的 HcaAudioStream 支持从 HCA 到 WAV 的文件的解码，而且经过散列对比，这个文件和原始的 hca 生成的完全一致，SoundPlayer 也能播放，说明从流到流的解码应该是没问题。但是这个类直接传入 SoundPlayer，就会在一段时间后（我用一个属性验证过，解码结束了）抛出 InvalidOperationException，错误说明是“波形头已损坏”。对此我觉得很奇怪，文件能播放，直接传数据流为什么就不行呢？挖掘了一番，在 .NET Framework 中找到了一个错误。 不过，剧情再次反转，原来是我忘记使用了 offset 参数，而这个参数的作用……下文详细讲解。 总之这次给了我一个机会研究 SoundPlayer 的缓冲实现原理。","text":"在 kawashima 主体完工之后我转向了 C# 的实现。自然，接口风格就要用 Stream 的风格啦。我已经做好了 kawashima 的流式封装，接着来做纯 C# 版的。虽说过程中遇到了各种坑，但是最后基本上都过去了，实现了文件从 HCA 到 WAV 的解码（固定逻辑）。写了流式封装之后要进行测试，最好的测试方式就是用 System.Media.SoundPlayer，它的一个构造重载接受一个 System.IO.Stream 类型的流，从中读取 WAV 数据，进而调用系统 API 播放。P/Invoke 版的就是这么测试的。 然而此次测试中发现一个奇怪的现象。新的 HcaAudioStream 支持从 HCA 到 WAV 的文件的解码，而且经过散列对比，这个文件和原始的 hca 生成的完全一致，SoundPlayer 也能播放，说明从流到流的解码应该是没问题。但是这个类直接传入 SoundPlayer，就会在一段时间后（我用一个属性验证过，解码结束了）抛出 InvalidOperationException，错误说明是“波形头已损坏”。对此我觉得很奇怪，文件能播放，直接传数据流为什么就不行呢？挖掘了一番，在 .NET Framework 中找到了一个错误。 不过，剧情再次反转，原来是我忘记使用了 offset 参数，而这个参数的作用……下文详细讲解。 总之这次给了我一个机会研究 SoundPlayer 的缓冲实现原理。 这是失败的代码： using (var hca = new HcaAudioStream(fs, param)) { using (var sp = new SoundPlayer(hca)) { sp.LoadTimeout = 500 * 1000; sp.PlaySync(); } } 运行，解码完毕后（可以设置一个属性，报告目前解码了多少区块来确认）SoundPlayer 抛出了一个异常： InvalidOperationException`：波形头已损坏。 这不是莫名其妙么？那么为什么我 P/Invoke 的版本工作正常呢？于是我又用了一个 MemoryStream 来包装： int i = 0; using (var hca = new HcaAudioStream(fs, param)) { using (var ms = new MemoryStream()) { var buffer = new byte[1024]; while (hca.CanRead) { var len = hca.Read(buffer, 0, buffer.Length); ms.Write(buffer, 0, len); } ms.Seek(0, SeekOrigin.Begin); using (var sp = new SoundPlayer(ms)) { sp.LoadTimeout = 500 * 1000; sp.PlaySync(); } } } 更奇怪的是，这次居然是成功的！而且文件写入也证明，解码结果和 P/Invoke 版本完全一致，先解码到文件再用 FileStream 读取，也是可以播放的。 于是我做了一个假设。在之前的实验中，我知道 SoundPlayer 的源如果是个 Stream，则会用一个长度为 1024 的字节数组作为缓冲区来读取流的内容。所有 Stream 都需要实现这样一个方法：int Read(byte[] buffer, int offset, int count)，会不会是 SoundPlayer 忽略了其返回值呢？比如，假如流里还剩下 1000 字节，我返回 1000（读取到 1000 字节），如果 SoundPlayer 还按照读取到了整个缓冲区长度（1024 字节）来处理的话，在第一次读取波形头（长度 44 字节）的时候就会产生错误数据。而且，用 MemoryStream 的这个我控制的读取过程似乎证明了这一点。 但是推测还不够，要证明。于是我用 ILSpy，打开 GAC 内的 System.dll（.NET Framework 4），找到 System.Media.SoundPlayer。查找方向如下：PlaySync→LoadAndPlay→LoadSync→LoadStream→WorkerThread。然后就可以看到读取的核心： this.streamData = new byte[1024]; int i = this.stream.Read(this.streamData, this.currentPos, 1024); int num = i; while (i &gt; 0) { this.currentPos += i; if (this.streamData.Length &lt; this.currentPos + 1024) { byte[] destinationArray = new byte[this.streamData.Length * 2]; Array.Copy(this.streamData, destinationArray, this.streamData.Length); this.streamData = destinationArray; } i = this.stream.Read(this.streamData, this.currentPos, 1024); num += i; } 这一段和 List&lt;T&gt; 的数组分配策略很像。我注意到，这里并没有犯我所想象的简单错误。不过，它用了一个 currentPos 记录了当前最后有效数组元素的位置，并以此为依据进行数组扩充。在调用我的流的 Read() 函数的时候，streamData 永远是一个扩充好的（新）数组，而 currentPos 是永远递增的。问题就出在这里，我以为它用的会是一个固定缓冲区，这样 offset 会是循环的——而在我的例子中，其值恒为零。 我的实现也是有一个 Array.Copy() 的，从我的缓冲区复制到输出中。它的调用是这样的： Array.Copy(source, sourceIndex, buffer, 0, availableByteCount); 这样复制到的永远是 buffer 的开头，后写的数据把前面的数据都覆盖了。这就是为什么会出现“波形头损坏”。将 offset 加上后，果然可以正常播放了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"HackPKU 2016 结束","slug":"zh/2016-04-10-End-of-HackPKU-2016","date":"2016-04-10T13:42:00.000Z","updated":"2020-03-30T22:34:35.438Z","comments":true,"path":"categories/Misc/zh/2016-04-10-End-of-HackPKU-2016/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-04-10-End-of-HackPKU-2016/","excerpt":"简记。","text":"简记。 8日至10日，我和杨彦君去参加了 HackPKU 2016。黄可嵩大神顾念论文截止日期（杨彦君扔掉了→_→）就没去，最终我们这个报名意义上的队伍只剩下2人。组队的时候发现其实“缺口”还是很少的，最终和两位哈工大的大二学生组成了一个临时队伍。 总体来说，强度比 MCM 要轻一些，不过现场展示要严酷得多。结果是，惨败。队伍编制就十分不平衡——4个程序员，零策划/PM，美工弱，做到半成品demo就已经精疲力尽，更别提优化、美化、宣传了。我们因为擅长领域不同（PHP vs Unity3D），明显地被分成了两个部分，而且还没得到整合。对于 SDK、API 和其他现场技术（如 Kinect for Windows），4个找不到痛点的程序员对如何“不俗地”使用它们感到十分棘手。如村长所言，必须注重团队配置，而且时间非常重要！ 我们的半成品被切割成了两部分，一个是拍照登录，一个是 AR 游戏。虽然定了数据交换协议，但是 AR 这边进度一直没达到该通信的程度，所以展示的时候也只好分开来展示，没有衔接过程。反正我是 AR 这边的，能跳《お願い！シンデレラ》并同步音频（问：动作和音乐从哪里来的？答：不说。），但在加入点击操作时被一个问题卡得死死的，从凌晨两点一直到展示都没解决。简要概括这个问题，就是我们实例化（Instantiate()）物体在 PC 上成功，但手机上一直无法显示，还无法记录调试日志。所以在最后的展示中我们只好砍掉了操作部分，回退到纯观赏 AR。所以只好判定为未完成状态。 在最后的自由展示中，我真是见识到了我的创意缺乏。我选两个最后我觉得挺不错的项目说一下。 第一个是根据喜好标记出剧中出现某人的片段，原理是将视频中的人脸进行聚类（使用面部特征点检测 API），选择一个后再根据时间聚类。这个功能，据这个团队说，是为了方便那些追星（或球赛等等）的家伙去专门看喜爱的明星的镜头的。我反感这些对棒脑残粉和这些追星行为，但是不妨碍我给创意（以及其背后反映的思维方式）打出高分，而且demo的完成度、美观度和易用度都很高。毕竟我这个抵触社交的人和世界中社交狂热分子的思想并不会看到一起，自己往“个性化社交”的方向去想几乎是不可能的，并不理解那些人的需求和价值基础。 第二个是一个多人合作的音游。说是音游，其实说是 Kinect 简单应用还差不多。Paper.js 作页面渲染，Node.js 处理同步数据。令我惊奇的是他们的“分屏”概念，一些节奏音符在轨道上运动，而这些轨道是分布在多个屏幕（你没看错，多个设备屏幕的话，每个屏幕只显示部分轨道）上的，这些轨道的物理尺寸可以无缝衔接。不讨论实用程度如何，这个脑洞开得让人很意外。他们的另一个“亮点”是使用 Kinect 检测的身体动作来生成谱面以“增强合作感”——我觉得这个功能并不好，一群人打歌还要专门配一个生成谱面的？无必要的强制“合作”反而会遭到嫌弃，特别是在玩法限定了不对等的角色的情况下。这个五人小组的开发效率很高，在一天多一点的时间内就完成了从创意到完整的demo和配套环境的过程，而且方案如此优美，让人佩服得五体投地。 然后再概括三个我觉得很失败的、但入围前九的例子。心情日记——自恋的人才用这么麻烦的记事方式，每次记事还得强制自拍，还得联网（人脸校验）。AR 虫族作战游戏——我们和他们仅有的两个差距，第一个是也许他们的 Instantiate() 没诈和，第二个是我们没有四旋翼飞机来执行“从空中扫描纸片”的装X任务。随时随地浏览状态分享插件——这两位老兄写代码时就在我们对面，不怀疑效率、质量和嘴皮子，只不过做的东西一点用都没有，除非你是自曝狂。 这次 HackPKU，应该算是中国高校中举办的第一次黑客马拉松，经验不足是可以理解的。今天展示之前突然说我们的组号是41（由于是唯一临时组成的组，之前我们北航的几个是有固定组号的），然而和旁边展位的哥们儿（就是做插件那两个）的冲突了，弄得访客也混乱了，工作人员来了之后给了我们一个42号——一个根本不存在在展位指引表上的号码，所以也没人“按图索骥”。不过这几天至少伙食和零食（虽然就几种）还是有保证的。晚上禁止使用场地侧门（预防财物/信息安全事故？），因此也就到不了几步路之外的卫生间，必须得从正门出去走600米，拐十几道弯。 Unity3D 自从 Initialize on awake 的选项折腾了4小时之后就对其感到心累了，后面的 Instantiate() 简直是雪上加霜。还有混乱的事务安排！你见过安排屋子内一边坐着专心开发的人，而另一边则举办着赞助商指定的游戏活动（用麦克风的，还喊话）的行径吗？","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"SharpDX Direct3D 填坑：DataStream 和 Cubemap","slug":"zh/2016-04-08-Direct3D-DataStream-And-CubeMap","date":"2016-04-07T17:07:00.000Z","updated":"2020-03-30T22:34:35.437Z","comments":true,"path":"categories/Tech/zh/2016-04-08-Direct3D-DataStream-And-CubeMap/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-04-08-Direct3D-DataStream-And-CubeMap/","excerpt":"填上两个坑：DataStream 使用不当的内存泄漏和在 SharpDX 中使用 cubemap。","text":"填上两个坑：DataStream 使用不当的内存泄漏和在 SharpDX 中使用 cubemap。 SharpDX 中，DataStream 提供了一个托管内存向非托管内存写入数据的快捷方式。它的一般创建方式是这样的： static DataStream Create&lt;T&gt;(T[] data, bool readable, bool writable); 在 SlimDX 中，对应的是一个构造函数的重载版本。在将 CubeMap 示例改写运行起来之后，我就在场景里停留了两分钟，摄像机到处走。然后我发现渲染出现了卡顿的现象，从开始的零星卡顿到后来的帧率直降。我的第一个猜想就是垃圾太多，频繁触发垃圾回收，而任务管理器告诉我内存占用一直在疯涨。毫无疑问，出现了内存泄漏，从而加大了 GC 的压力。Visual Studio 2015 还有一个好工具，性能收集器，它告诉我内存占用是几乎线性增长的，而且有多个阶段都触发了 GC，后期 GC 频率很高。 内存泄漏对于托管代码来说几乎是不可能的，而且我在各个需要访问非托管资源的组件中都实现了 IDisposable 模式。问题出在哪里？ 在乍看之下无法看出的情况下，我又祭出了老招数，分块调试。幸好，组件化的设计让我很容易独立调试各个组件。经过几次缩小范围后我发现，内存泄漏发生在 ShapesScene.DrawInternal() 方法中。这一段代码并不长，所以我仔细检查了一下，包括是否有可能的引用类型浪费（例如 BufferDescription，可是经查看，它是一个值类型）。这一段代码分别绘制了几个物体，再缩小范围后发现，在绘制第一个物体（地面网格）的时候就发生了泄漏。核心是这样的： basicFx.SetWorld(world); basicFx.SetWorldInvTranspose(worldInvTranspose); basicFx.SetWorldViewProj(wvp); basicFx.SetTexTransform(Matrix.Scaling(6, 8, 1)); basicFx.SetMaterial(_gridMat); basicFx.SetDiffuseMap(_floorTexSRV); pass.Apply(context); context.DrawIndexed(_gridIndexCount, _gridIndexOffset, _gridVertexOffset); 数据中只有一个引用对象 _floorTexSRV，但是它自从初始化后内容就不变了。于是我只好翻开去看其他几个 Set* 方法。设置矩阵的那几个，由于矩阵本身是值类型而且不包含引用，因此也不会存在泄漏问题。然而，SetMaterial 是这样的： public void SetMaterial(Material m) { _mat.SetRawValue(DataStream.Create(NoireUtilities.StructureToBytes(m), false, false), Material.Stride); } 由于我从 DataStream 暴露出的成员中推断它是主动分配了非托管内存的，所以立刻就觉察到了：它的 Dispose() 调用在哪？ 还真想对了，这个函数可是每帧都调用几次的呢，虽然单次数据量小，但是帧率还是很高的，这样估算一下增速（3 MB/s 左右）是可以解释的。在加上了 Dispose() 之后就好了。我看了一下原始代码，也是没有释放的，运行时同样会出内存泄漏的问题。 SharpDX 的 ShaderResourceView 是不支持读取类型为 cubemap 的 DDS 纹理文件的。我的纹理读取是采用了 Stack Overflow 上的一个回答的方案。这个方案能正常读取普通纹理，如 PNG、JPEG 和类型为 Texture2D 的 DDS，但是在尝试读取 cubemap 贴图的时候失败了，报告说不支持头格式。（DXGI 会尝试使用 FourCC 来识别纹理格式。）我索性就用 texconv 将 DDS 转换成 PNG，直接加载，成了这个样子： 我觉得很奇怪，明明 shader 应该是没错的，而且我在代码里换了各种网格，为什么出来的都是立方体呢？而且，为什么只有前后有图，另外四个面全是 wrap 的结果呢？查阅资料后我知道了，原来 DDS 是支持保存 cubemap 而不仅是普通二维纹理的。 在原工程中，SlimDX 加载资源很简单，就一句： CubeMapSRV = ShaderResourceView.FromFile(device, filename); 但是，SharpDX 的 ShaderResourceView 就根本没有这个静态方法，或者其他从文件加载的手段。原来，SlimDX 中的这个方法是通过 C++/CLI 直接调用了 D3DX11CreateShaderResourceViewFromFile() 这个底层辅助函数。SharpDX 中是有，在 sharpdx/Toolkit，说是需要更新。简单说，就是在 SharpDX 中加载 cubemap，需要自己写。当然，在 DDS 页面中，微软说了可以去查看 DirectXTex 或者 DirectXTK 工程代码。我去看了，在 DirectXTex 里，但是各类之间有着很强的依赖关系，短时间内不好拆，也不好翻译到 C# 上。 但是网上的资源启发了我，不就是6个面么（DxTex 也是可以看到的）？偶然间我找到了这个回答，提到能将6幅普通纹理合成一个 cubemap 纹理。而且，这段代码很容易移植到 SharpDX 为基础的架构中。 接下来的就是尝试了。我通过 NVidia 的 Photoshop 插件 将 cubemap DDS 切成了6个普通纹理（DxTex 做不了），然后载入调试。一切看上去正常，但是在最后创建 ShaderResourceView 的时候总是报告参数错误。这个问题困扰了我一个多小时，最后又是偶然，发现了另一个帖子。根据后者，前面的一个创建参数（在 OptionFlags 字段，对应 C++ 中的 MiscFlags 字段）是错的，此时就应该指定创建 texture cube。修改之后终于运行起来了。效果： 如果不想上 GitHub 去看的话，这里直接给出创建 texture cube 的代码： public static ShaderResourceView CubeMapFrom6Textures(Device device, Texture2D[] texture2Ds) { Debug.Assert(texture2Ds.Length == 6); var texElemDesc = texture2Ds[0].Description; var texArrayDesc = new Texture2DDescription() { Width = texElemDesc.Width, Height = texElemDesc.Height, MipLevels = texElemDesc.MipLevels, ArraySize = 6, Format = texElemDesc.Format, SampleDescription = new SampleDescription(1, 0), Usage = ResourceUsage.Default, BindFlags = BindFlags.ShaderResource, CpuAccessFlags = CpuAccessFlags.None, OptionFlags = ResourceOptionFlags.TextureCube }; var texArray = new Texture2D(device, texArrayDesc); var context = device.ImmediateContext; var sourceRegion = new ResourceRegion(); for (var i = 0; i &lt; 6; ++i) { for (var mipLevel = 0; mipLevel &lt; texArrayDesc.MipLevels; ++mipLevel) { sourceRegion.Left = 0; sourceRegion.Right = texArrayDesc.Width &gt;&gt; mipLevel; sourceRegion.Top = 0; sourceRegion.Bottom = texArrayDesc.Height &gt;&gt; mipLevel; sourceRegion.Front = 0; sourceRegion.Back = 1; if (sourceRegion.Bottom &lt;= 0 || sourceRegion.Right &lt;= 0) { break; } var n = Resource.CalculateSubResourceIndex(mipLevel, i, texArrayDesc.MipLevels); context.CopySubresourceRegion(texture2Ds[i], mipLevel, sourceRegion, texArray, n); } } var viewDesc = new ShaderResourceViewDescription() { Format = texArrayDesc.Format, Dimension = ShaderResourceViewDimension.TextureCube, TextureCube = new ShaderResourceViewDescription.TextureCubeResource() { MostDetailedMip = 0, MipLevels = texArrayDesc.MipLevels } }; return new ShaderResourceView(device, texArray, viewDesc); }","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"SharpDX","slug":"SharpDX","permalink":"https://blog.mottomo.moe/tags/SharpDX/"}]},{"title":"在 //BULID/ 2016 上宣布的 Visual Studio 和 .NET 更新","slug":"zh/2016-04-05-VS-Updates","date":"2016-04-05T05:01:00.000Z","updated":"2020-03-30T22:34:35.437Z","comments":true,"path":"categories/Misc/zh/2016-04-05-VS-Updates/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-04-05-VS-Updates/","excerpt":"简要选了几点介绍。","text":"简要选了几点介绍。 Visual Studio 15（根据推出日期，很可能是 Visual Studio 2017）将采用轻量化安装。在 Visual Studio 2010 开始启用“臃肿安装”之后，微软终于下决心将组件分离了。说实话，我也不知道那十几个 GB 的体量是从哪里来的。我好像记得什么时候读到过，Visual C++ 的符号存储（$PROJECT.sdb）将考虑使用更小的数据库（比如 SQLite）替代 SQL Server Compact Edition——就不用安装那些从来就没用过的 SSCE 组件了，我又不是做嵌入式开发的。 Visual Studio 将支持直接以文件夹形式组织代码。用 Visual C++ 有两点蛋疼，切换工具链和项目组织。传统的 Visual C++ 项目是通过工程文件组织的，工程中的“代码文件夹”是逻辑上的概念，只表示一些代码是相关的从而成为一个组，和文件系统中的目录并不等价。而许多现代的语言是支持单文件编译的，组织上默认按照文件结构（“在里面的都是需要的，如何使用看配置”），让人神清气爽。你可以看看 Source SDK 2013，它的文件组织就是很传统的“抱团”，在工程文件中分组归类。你们感受一下： 终于，VC++、VB、C#、F# 一系列语言都可以按照流行的方式组织工程了。 Mono 应用 MIT 许可（公布于4月1日，但是不是愚人节玩笑）之后，整合进 .NET Foundation。最大的亮点在微软为新的标准库定的其中一个目标：掌握一个库而不是一个平台——以后真的就不会看到那些抱怨 .NET 运行时太大的家伙了。.NET 这一步学习 Java 是对的，用核心库+包来构建生态，或者至少进一步分离以适用不同的应用场景。（唔，说起来简单，但是 CLR 内部的依赖关系错综复杂……） .NET的未来包含一个开源的Mono 微软宣布VS 2015后继版本，可使用Visual C++ for Linux了","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"CGSS 核心反向过程实录 | 六、获取密钥","slug":"zh/2016-04-04-Reversing-CGSS-6","date":"2016-04-03T17:34:00.000Z","updated":"2020-03-30T22:34:35.437Z","comments":true,"path":"categories/Tech/RE/zh/2016-04-04-Reversing-CGSS-6/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-04-04-Reversing-CGSS-6/","excerpt":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 （3月8日） 在这篇文章的初版推送之后我又见到了几个已经攻破了 CGSS 的例子或人。因此我觉得，既然已经有不少人找到了门路，现在可以将这部分的内容公开了。 这种水平的文章，要有相应水平的人看，小白看懂了，不一定是好事。 ——杨彦君 谨记：吸星大法有反噬之险。 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 我相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、插桩在讲解之前，首先要知道什么是“插桩”（instrumentation）；如果不知道，至少得从经验中推导出这种方法。我是后者，直到半个月前读到《安卓动态调试七种武器之长生剑 - Smali Instrumentation》的时候才知道：啊，原来我当初用的方法是插桩，一种已经理论化的方法啊，并没有我认为的那么难想到。 插桩本来是用在软件测试中的，用作检测数据流的正确性，就如 Huang 在提出这个概念的论文 Detection of Data Flow Anomaly Through Program Instrumentation 中所描述的那样。这篇论文中的抽象理论总结起来其实挺简单：在正常运行的程序中，可以插入一些“探针”（probe），在不影响原程序运行的情况下获取运行中的状态信息。 我按照我的理解大致解释一下这句话。首先，程序运行的时候，可以认为是一个独立的子系统，这个系统具有有限个正常运行中会到达的状态，状态之间转移时下一个状态能获得上一个状态的信息。假设原来程序在状态A，运行一句代码后到达状态B，而我们想查看状态A时程序内部的信息。然而，状态A、状态B都不是我们所能操纵的，一般因为技术原因，比如函数过于复杂我们难以跟踪。那么我们加入一个我们所能控制的状态，状态C，在C内我们保存上一个状态的快照，输出快照，然后将状态恢复为快照所保存的状态。然后我们修改指令流，让程序从状态A经由状态C到达状态B，就能收到状态A的快照了。 如果用代码表示的话应该更容易理解。这是原始的程序： var a = 0; // 状态A a++; // 状态B 这是修改后的程序： var a = 0; // 状态A Console.WriteLine($&quot;a = {a}&quot;); // 状态C a++; // 状态B 当然，修改的前提是不能破坏原系统的完整性。由于C是原来不存在的状态，而对于系统内的所有状态，都只知道上一个状态的信息，因此对于状态A和B来说根本察觉不到状态C的加入，B仍然认为是在接收状态A的信息。在这样的条件下，插桩是可行的。显然，如果状态中的信息包含指令顺序的话，就不能插桩了： LONG eip1 = $eip; // 状态A // print_eip1(eip1); // 状态D LONG eip2 = $eip; // 状态 B if (eip2 - eip1 &lt; EIP_THRESHOLD) { do_something(); // 状态C } 上面的例子中，如果加入状态D，EIP 的差值就发生了变化。假如这里的 EIP_THRESHOLD 是一个刚刚好的临界值，例如2（X86 下一个 mov eax, eip 的长度），就强制保证了指令相邻。状态D的加入使得 eip2 和 eip1 的差值超限，状态C就无法达到了，执行流程就发生了变化。不过这毕竟是极其罕见的情况了。附：CALL 的长度计算就麻烦多了。 不过还好，此次我们插桩的目标是一个 C# 程序，其载体是 CIL，作为基于栈的中间语言，能保证我们插桩所需的条件。 三、插入点之前我们不是说过了吗，在 CriWareInitializer 中有一个很明显的函数调用： CriWare.criWareUnity_SetDecryptionKey(key, text2, this.decrypterConfig.enableAtomDecryption, this.decrypterConfig.enableManaDecryption); 很明显，我们要插在它前面。而且，这是一个 P/Invoke 调用，也就是说传递给未经修改的（CRI 应该并不会授权源代码重新编译，分发给使用者的应该是编译好的结果，所以应该能保证内部没有第三方的其他加解密）多媒体插件，所给出的密钥应该就是真实的、正式使用的。 由于这个 Assembly-CSharp-firstpass.dll 可能经过了混淆，不过再怎么混淆，反编译到 CIL 总是可以再编译回去的。CIL 运行时内部使用 UTF-8 编码，所以混淆时可能会被替换为不可见字符，这种情况就要写程序对字符串进行操作了。幸好这次 Notepad++ 足够用。反编译当然使用的是 ildasm： C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v7.0A\\Bin&gt;ildasm Assembly-CSharp-firstpass.dll /out=Assembly-CSharp-firstpass.il /utf8 然后我们找到 CriWareInitializer.Initalize() 方法，在大概第17671行，这里就是需要动工的地方。如果不确定在哪里，找一下 criWareUnity_SetDecryptionKey() 的调用就知道了。 四、输出信息由于 CGSS 是在 Unity3D 上（运行时是 Mono），运行在一台 Android 的手机（我的）上的，在这个环境下是没法使用 Console.WriteLine() 和 Debug.WriteLine() 的，用了也看不到它们的输出，因此要另辟蹊径。其实翻一翻 CGSS 的代码中，其实是能看到日志记录的方法的，看看 CriAtomPlugin.InitializeLibrary() 这个方法吧。然后我们就知道了，UnityEngine.Debug.Log() 方法是跨平台的大大杀器，不管在哪里都能输出到那个平台对应的调试器日志中，在 Android 上当然是 logcat 啦。那么，输出的重任就交给它了。 如果要看 logcat 中与 Unity3D 相关的调试信息： $ adb logcat -d -s Unity &gt; log.txt 我除了使用 UnityEngine.Debug.Log()，还用了一个 StreamWriter 将相关信息写入了一个文件中——这样就不需要每次去看 logcat 了，直接打开文件就好。 其实都到了这一步了，其他都很简单了，只要注意维持栈的平衡就好。我当时试了一天，最大的问题就是找到输出方法，以及选 Application.persistentDataPath 还是 CriWare.streamingAssetsPath 的问题。我当时还没做过 Unit3D 的东西，看代码似乎后者就是赋值为前者了而已，结果运行的时候总是崩溃。现在我绝对会坚定不移地选择前者。 首先，我们要有一个保存路径的变量，我设为 V_filePath。在方法声明中定义这个局部变量： .locals init ( // ... string V_filePath, // ... ) 然后在代码中： // var filePath = UnityEngine.Application.persistentDataPath; call string [UnityEngine]UnityEngine.Application::get_persistentDataPath() stloc.s V_filePath // filePath = Path.Combine(filePath, &quot;debug.out&quot;); ldloc.s V_filePath ldstr &quot;debug.out&quot; call string [mscorlib]System.IO.Path::Combine(string, string) stloc.s V_filePath 我们还需要构造一个 System.IO.StreamWriter，StreamWriter 的构造需要一个 Stream 对象，这里明显该用 FileStream。要先定义： .locals init ( // ... class [mscorlib]System.IO.FileStream V_fs, class [mscorlib]System.IO.StreamWriter V_sw, // ... ) 然后打开文件流，准备写入： // var V_fs = File.Open(V_filePath, FileMode.OpenOrCreate); ldloc.s V_filePath ldc.i4.4 call class [mscorlib]System.IO.FileStream [mscorlib]System.IO.File::Open(string, valuetype [mscorlib]System.IO.FileMode) stloc.s V_fs // var V_sw = new StreamWriter(fs, Encoding.UTF8); ldloc.s V_fs call class [mscorlib]System.Text.Encoding [mscorlib]System.Text.Encoding::get_UTF8() newobj instance void [mscorlib]System.IO.StreamWriter::.ctor(class [mscorlib]System.IO.Stream, class [mscorlib]System.Text.Encoding) stloc.s V_sw 关于枚举的使用，枚举是按照其实际值硬编码在 CIL 中的，这个特性我准备在另一篇文章中讲解。 然后我们来看一下究竟是否使用了解密： // V_sw.WriteLine(string.Format(&quot;useDecrypter: {0}&quot;, this.useDecrypter.ToString())); ldloc.s V_sw ldstr &quot;useDecrypter: {0}&quot; ldarg.0 ldflda bool CriWareInitializer::useDecrypter call instance string [mscorlib]System.Boolean::ToString() callvirt instance void [mscorlib]System.IO.TextWriter::WriteLine(string, class [mscorlib]System.Object) 答案是，虽然代码中好像没变过这个值，按照默认值应该是 false，但是它确实是 true。那么我们就有必要输出一下剩下的信息了。在使用了密钥的那个分支，输出密钥和附加的验证文件（别忘了处理逻辑跳转的关系）： // V_sw.WriteLine(string.Format(&quot;decrypterConfig.Key: {0}&quot;, this.decrypterConfig.key)); ldloc.s V_sw ldstr &quot;decrypterConfig.Key: {0}&quot; ldarg.0 ldfld class CriWareDecrypterConfig CriWareInitializer::decrypterConfig ldfld string CriWareDecrypterConfig::key callvirt instance void [mscorlib]System.IO.TextWriter::WriteLine(string, class [mscorlib]System.Object) // authenticationFilePath = this.decrypterConfig.authenticationFile; (这一段是反编译的内容) IL_0358: ldarg.0 IL_0359: ldfld class CriWareDecrypterConfig CriWareInitializer::decrypterConfig IL_035e: ldfld string CriWareDecrypterConfig::authenticationFile IL_0363: stloc.2 // V_sw.WriteLine(string.Format(&quot;decrypterConfig.authenticationFile: {0}&quot;, authenticationFilePath)); ldloc.s V_sw ldstr &quot;decrypterConfig.authenticationFile: {0}&quot; ldloc.2 callvirt instance void [mscorlib]System.IO.TextWriter::WriteLine(string, class [mscorlib]System.Object) 解释一下，上面的 ldloc.2 是因为验证文件路径这个变量原来就被声明到了第2位，是一个匿名变量。 在最后不要忘记调用 Dispose() 方法： // V_sw.Dispose(); ldloc.s V_sw callvirt instance void [mscorlib]System.IO.TextWriter::Dispose() // V_fs.Dispose(); ldloc.s V_fs callvirt instance void [mscorlib]System.IO.Stream::Dispose() 最后在持久化路径下就能见到 debug.out 文件，看看内容吧。顺带一提，这个路径就是 /storage/emulated/0/Android/data/jp.co.bandainamcoent.BNEI0242/files。 所有的 CIL 代码我都没做优化，因为如果做了会更难读，而且也没什么用，因为这里只会经历一次，这几句也花不了多少时间。总之别看这段代码简单，得出它的路程可是很艰苦的，这里我注释掉的失败尝试有一百多行，每次都是对其中的单步进行测试。特别要小心 call/callvirt、ldloc/ldloca 这一对一对的指令！如果不了解，请见 CIL 指令表。 讲个笑话，还试过用 HttpWebRequest 向本机（10.0.2.2:8080）发送，然后用 Fiddler 来截获……不过并没有什么卯月。 五、重新编译只要 CIL 没写错，就能正常编译。我们是用 ildasm 反编译的，那么编译回去就应该用 ilasm。Unity3D 到版本 5.3.4 用的仍旧是对应于 .NET Framework 3.5 的框架，因此我们编译出的程序集也应该和它保持一致。.NET Framework 3.5 的运行时版本是 2.0，我们用这个版本的 ilasm： C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727&gt;ilasm /DLL F:\\temp\\cgss-managed\\cracked\\Assembly-CSharp-firstpass.il /output=F:\\temp\\cgss-managed\\cracked\\Assembly-CSharp-firstpass.dll 一切正常的话，就能看到编译出的 Assembly-CSharp-firstpass.dll 了。这里特意指定文件名与原文件名相同，替换的时候就不容易出错。啥？怕在 Windows 上编译出来的这个 DLL 无法运行？别忘了其中的 CIL 是中间语言而已，是可以跨平台的。 编译出的程序集，保留了原程序集的所有信息，只不过多了我们的两个探针，CGSS 依然会认，可以正常运行。我们的探针究竟能不能探测到东西并输出呢？这就得调试了。不过由于我们修改了 CGSS 的文件，在文件完整性验证上会出错，这个部分就在下一篇文章中讨论吧。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"CGSS 核心反向过程实录 | 五、C# 代码反向","slug":"zh/2016-04-02-Reversing-CGSS-5","date":"2016-04-02T15:09:00.000Z","updated":"2020-03-30T22:34:35.437Z","comments":true,"path":"categories/Tech/RE/zh/2016-04-02-Reversing-CGSS-5/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-04-02-Reversing-CGSS-5/","excerpt":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 （3月3日，3月7日晚） 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 我相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、初探 CGSS 的程序集在 Unity3D 的程序集目录下，可以找到两个明显不属于 CLR 和 Unity3D 的程序集文件 Assembly-CSharp.dll 和 Assembly-CSharp-firstpass.dll。至于另一个 P31RestKit.dll，看文件名和上一篇的过程就知道，这是用来调用 prime[31] 的 RESTful 服务的，直接过滤掉。现在我们就该进入到程序集内部了，工具选择很多，各位随便：.NET Reflector、JustDecompile、dotPeek 以及 ILSpy。在以下的文章中，我用的是 ILSpy，因为比较熟悉。 可以看到，左边的 Assembly-CSharp.dll 明显是编译自 Spine（可以想到，Live 时的骨骼就是它负责了）的，而 Assembly-CSharp-firstpass.dll 则不知是什么来头。 三、CGSS 的反作弊措施在 CodeStage.AntiCheat 命名空间下可以看到，为了防止作弊（模块注入类、变速齿轮类和另外两种不知道是什么的），BNEI 的程序员们是下了功夫的。里面还有基础类型混淆…… 不过这也有（至少没有封上的）漏洞，提示：后台服务。不过别玩过火了，游戏是练技巧寻开心的，作弊赢的一点意思都没有。 四、Assembly-CSharp.dll 概览为什么是概览呢？因为我说过了不会给你们看关键代码的，有兴趣的可以自己看。 4.1 根命名空间众多的游戏类：骨骼动画、UI、碰撞检测，还有其他有意思的东西。要注意的有两个类：AudioManager 和 Debug。 4.2 Cute 命名空间很奇怪，为什么要叫做 Cute 呢？难道架构同志是专攻 cute 组的P？ 在这个命名空间下，主要是一些游戏逻辑（提供功能封装的）类，例如系统环境检测、支付、其他网络通信。 这个命名空间中最有价值的是 AssetHandle 类，它告诉了我们游戏资源是怎么保存和加载的。我本来是想看完整的保存逻辑，不过下载的代码反编译出来是这样的： [DebuggerHidden] private IEnumerator _Download() { AssetHandle.&lt;_Download&gt;c__IteratorD &lt;_Download&gt;c__IteratorD = new AssetHandle.&lt;_Download&gt;c__IteratorD(); &lt;_Download&gt;c__IteratorD.&lt;&gt;f__this = this; return &lt;_Download&gt;c__IteratorD; } 这看上去就是编译器自动生成的代码。不过我调试 async、yield 这些语法糖的经验不够，况且 ILSpy 是能自动处理以上两种情况的，所以我也不确定这段代码究竟启动了什么，看上去像是 yield。再想想，异步操作为什么是 yield（实质还是同步）呢？在玩游戏的时候，如果下载卡住了，过一段时间才会引发 UI 无响应，看上去不是简单的同步调用啊。至于 AssetHandle.Download() 方法，各位就自己看吧，带了一个委托的。在没确定调用链的情况下，不清楚调用的委托的代码是什么。 在我分析 AudioManager 类的时候，它的一个方法 AudioManager.AddCueSheet() 中就有对 AssetHandle.BuildLocalPath() 的调用。看到这函数名字和调用关系，AssetHandle 的这个方法一定是关键所在。果然，这个函数告诉了我们各个数据目录的意义。其中提到了 AssetHandle.cryptFilename 属性，这又告诉了我们文件名的生成方式。最后一击来自 AssetHandle._LoadManifestContent() 方法，还记得第一个分析中我们的主数据库吗，用它的内容和这个方法的代码就能看到整个实际保存的文件结构。 4.3 Cutt 命名空间各种 Live 相关的东西。 4.4 Stage 命名空间都是 Unity3D 组件，游戏 UI 和逻辑。 五、Assembly-CSharp-firstpass.dll 概览在打开这个程序集的时候我惊讶了，怪不得带一个“firstpass”，原来顺序上也应该是这个程序集在先的。查看依赖关系可以看到，这个程序集只依赖于 CLR 和 Unity3D，并被 Assembly-CSharp.dll 依赖。打开一看，命名空间只有4个，分别是根命名空间、CriManaPlayerDetail、Sqlite3Plugin 和 UnityStandardAssets.ImageEffects。嗯，数据库的访问就是在这里包装的。 还记得我们现在的目标吗，HCA 是谁研发的？CRI Middleware。其中，音频部分是 Atom，视频部分是 Mana。这个结论得出的过程很简单，看看根命名空间下的 Cri* 类就知道了。 仔细看的话，可以发现 Cri* 类大多是对 CRI Unity3D 插件的 C# 封装。我随便抽一个例子，打开 CriAtomEx 类，可以看到这样一个 P/Invoke 成员和对它的封装： [DllImport(&quot;cri_ware_unity&quot;)] private static extern void criAtomEx_SetRandomSeed(uint seed); public static void SetRandomSeed(uint seed) { CriAtomEx.criAtomEx_SetRandomSeed(seed); } 看到没有，DllImport，上一篇我说过什么了？对应的正是 libcri_ware_unity.so 中导出的 criAtomEx_SetRandomSeed() 函数。其他的以此类推。 可以看到，CRI 的插件包含几个组成部分，分别是 FS（独立的文件系统抽象）、Atom（音频）、Mana（视频，依赖 Atom，看初始化代码就知道了）、AtomEx（添加了功能，扩展 Atom，原因下文会说）。 我们先将目光放到 CriHcaDecoder 类和 CriPcmData 类上。CriHcaDecoder 是整个程序集中唯一名字上和 HCA 有关系的类，但是它的命运很糟糕。它的声明是这样的： public static class CriHcaDecoder { public static CriPcmData Decode(byte[] data); public static CriPcmData Decode(string path); public static AudioClip CreateAudioClip(string name, string path); [DllImport(&quot;cri_ware_unity&quot;)] private static extern bool criAtomDecHca_GetInfo(IntPtr data, int nbyte, out int sampling_rate, out int num_channels, out int num_samples, out int loop_start, out int loop_length); [DllImport(&quot;cri_ware_unity&quot;)] private static extern int criAtomDecHca_DecodeShortInterleaved(IntPtr in_data, int inbyte, IntPtr out_buf, int out_nbyte); [DllImport(&quot;cri_ware_unity&quot;)] private static extern int criAtomDecHca_DecodeFloatInterleaved(IntPtr in_data, int in_nbyte, IntPtr out_buf, int out_nbyte); } 咦，为什么我这里敢放上所有的函数声明呢？因为这个类根本就没用！查看一下 libcri_ware_unity.so 的导出表，根本就没有 criAtomDecHca_DecodeShortInterleaved 这样的导出函数。而 CriPcmData 是与 CriHcaDecoder 息息相关的，从名字上看这么底层的结构也应该只有底层 API 会用，所以很不幸地，它也没用到。那么问题来了，既然放弃使用 API 进行分步解码，那么音频解码在什么地方呢？ 问得好，这就是 CriAtomExPlayer 类存在的意义。我心中上演了一个小剧场：CRI Middleware 的那群人决定，每个数据包都用回调的形式来玩那真是暴殄天物，干脆就由我们的插件包了吧！于是我们就见到了 AtomEx 类别下的这一系列函数，比如 criAtomExPlayer_Start()、criAtomExPlayer_SetAisacControlById 和 criAtomExPlayer_AttachFader 等等。真的是包了一些常用的高级功能呢。这也进一步加大了反向的难度，因为既然不暴露底层的方法，只暴露出一个“包办”的接口（没错你看那句柄，真是招摇），那么解码器的配置也应该是在内部进行的，意味着要看到这些就得反向汇编代码。 不过天无绝人之路，很容易就能在一群类中发现 CriWareDecrypterConfig 类。这个类包含四个成员：key、authenticationFile、enableAtomDecryption 和 enableManaDecryption。哇，还有解密用的验证文件（内心一颤，难道是二重加密？），而且还能单独设置音视频的解密启用状态，真是体贴的服务。找这个类的使用场景，会发现它只在 CriWareInitializer 中出现过： public CriWareDecrypterConfig decrypterConfig = new CriWareDecrypterConfig(); 以及，作为一个配置信息类，必须有的读取操作，然后设置。在你们看到这一段代码的时候，心里也许会这么想：原来如此，这还不简单吗！但是我要告诉你们，这个 decrypterConfig 成员的各个字段值，由始至终都没变过，至少没有通过常规手段变过——甚至 useDecrypter 都好像一直是 false（意味着不进行解密，直接使用原始数据）。这和从外部表现推导的内部流程的完全不一样。我当时也是想，如果这里直接能找到在 C# 中读取密钥的代码我不是赚大了吗，结果就栽了一个大跟头。 线索就这么断了。攻克这个难题后来费了我两天多。 六、其他的尝试6.1 硬上反汇编3月3日晚，既然 C# 那边又撞墙了，只好硬着头皮上汇编了。手拿挂上了 Hex-Rays Decompiler 的 IDA，我开始反向关键的 criWareUnity_SetDecryptionKey() 函数，看看文件路径为空指针时的反应。然后发现这个情况最后很可能掉到抛出错误信息接着返回调用方的分支中。验证文件是通过 CRI 自己的 FS 部分加载的，然后进行一堆的计算验证，跟踪非常困难。 6.2 思想实验：音频交叉对比我也想过，不就是 264 种可能吗，反正音频文件也不长，如果撞上了呢。假设有个并行处理的机器，然后录下正确的声音，让这个机器去跑解密过程。不过这个方案有一个缺陷，就是输出都是非数字化的——因为从声卡录下的声音未必就是解码出的波形数据本身，所以要对比只能“听着”来对比，这就需要有一个感知上的音频对比引擎。而且，如果如网上所说的，随机数列导致的音频前期微小差别难以察觉的话，难道筛选出一部分可能的密钥（数量也许上千）之后还要拿长文件来测试吗？首先时间就划不来，而且还存在误报的问题（毕竟人的听力不是完美），我也没有足够长的样本，需要多长我也不知道。总之这只能是一个思想实验，正确性有可能，但代价太大。 6.3 强制跳过 HCA 加密类型判断我说过我找到了一个 HCA 解码器的源代码。我之所以相信它是正确的，是因为它能解码几个未加密的 HCA 样本，而且能正确显示 CGSS 所用的 HCA 信息。里面有一段是判断加密类型的，我想也许 CGSS 里只是玩了一个把戏，将未加密的文件写上一个“加密”头，欺骗破解者。于是3月7日晚（中间4天赶毕设了），我短路了加密判断代码，强制作为未加密的文件解码，不过得到的还是一片噪声。 6.4 截获网络通信继续，到了3月8日凌晨。既然密钥不存在于所有的代码中，有没有可能用了动态密钥呢，隐藏在每次的启动通信中？（杨彦君建议的……）不过其实再想想，其实是有逻辑漏洞的。第一次播放声音是在启动画面（5人的那张图片，见本系列的第2部分），当点击画面后才会进行第一次网络通信，然后是更多的载入。也就是说，文件解密是在网络之前的，用的至少也应该是本地缓存的密钥吧。而且，没有必要为了解密，每次都要浪费用户流量吧，这于情也说不通。 尽管如此，我还是用模拟器配合 Fiddler 抓了请求。里面至少没有明显的数据，所有的内容都是加密了的，除了每日通知的页面（也就是用上 Unity3D WebView 插件的地方啦）。我也不想花时间去破这个，为了一个手游投入破解商业密码的精力实在不值，毕竟我清楚手游的商业模型，也不会中招，别人往坑里跳我是不管的。不过在抓请求的时候，能看到一些有趣的东西，看请求头。 总之，以上的尝试都没有收到满意结果。但是，就是在3月8日凌晨，我开了一个大脑洞，出其不意（如果假想为一场战斗的话）地攻下了最后的防线。方法是想了，不过实行起来难度很大，而且还不知道是否可行，所以其实当时心里是一直没底的。详情请见下一期。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"CGSS 核心反向过程实录 | 四、Java 代码反向","slug":"zh/2016-03-30-Reversing-CGSS-4","date":"2016-03-30T05:07:00.000Z","updated":"2020-03-30T22:34:35.436Z","comments":true,"path":"categories/Tech/RE/zh/2016-03-30-Reversing-CGSS-4/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-03-30-Reversing-CGSS-4/","excerpt":"索引 唉！从17日开始写了几句话到现在，拖了13天，这病得治。 28日在博客园的本周回顾中找到了这样的一篇个人足迹。如果真的遇到这样的对手，我很荣幸。 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 唉！从17日开始写了几句话到现在，拖了13天，这病得治。 28日在博客园的本周回顾中找到了这样的一篇个人足迹。如果真的遇到这样的对手，我很荣幸。 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 （3月3日8时-12时） 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 我相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、APK 解包首先拿到 CGSS 的 APK 安装包。大家都知道，APK 源自 JAR，而 JAR 采用 PKZIP。如果要浏览、编辑，最简单最直接的工具就是 WinRAR。 打开一看，在根路径就出现了一个 classes.dex。什么是 DEX 呢？这需要对 Android 有一点了解。一般的 Java 应用程序都会编译为 .class 后封入 JAR 包，运行时由 Java 虚拟机读取并执行其中的字节码。而 DEX 则是为了 Android Dalvik 虚拟机设计的执行文件（可以想象成 CLR PE，是带元数据的），紧凑存储，更适合移动设备。这一步就需要将 DEX 还原为更常见的 JAR，然后再反向。选用的工具，自然就是 dex2jar。 同时注意另外的几个目录。assets 稍微浏览一下就能看出带有浓浓的 Unity3D 气息，lib 是针对不同平台编译的 JNI 库（.so 是 Linux 下的共享库，也就是动态链接库，的后缀名，然而 Android 下大量的 Java 代码为何要使用原生库呢？性能高嘛；那互操作方式就很可能是 JNI 了），META-INF 是清单文件存储的位置（和 JAR 类似），res 是界面布局和资源。AndroidManifest.xml 是这个 app 的描述和需求（如特殊权限），resources.arsc 暂时不知道是什么，不过这里没用到。 由于整个结构资源文件实在分析不出什么，就拿代码开刀。解压出 classes.dex 并用 dex2jar 还原为 JAR 等待分析。 三、类代码查看这一步比较蛋疼。在我试的时候，JavaClassViewer 报错，jd2 无法反编译 Unity3D 的混淆代码而且是输出“发生了错误”。幸好我还有第三件神器，基于 Procyon 的 d4j。这货居然顺利反编译了 Unity3D 的部分混淆代码，这在我发现调用本质的路上起了关键的作用。有些代码反编译不了不用管，我看了一下字节码，应该是人工构造了一些栈不平衡的指令（实际上不会执行），用来迷惑反编译器的，这手法在另外的地方见过，此处略去。 现在用 d4j 来看看这个 JAR 里的类们。 首先根据运行时的外部存储目录名字 jp.co.bandainamcoent.BNEI0242，顺藤摸瓜找到对应的包 jp.co.bandainamcoent.BNEI0242。不过很不幸，这里看上去只有一些字符串常量，而且不是我们需要的。就是，还有谁像 BiliBili WinPhone App 的团队那样把机密用一个一眼就知道是干什么用的字符串常量存着啊！ 接着我们可以看到 jp.cygames 包。Cygames 身为 CGSS 的发行商（运营商？根据后文，应该是运营商吧，我猜），往里面加入了自己的广告 SDK。另一个广告 SDK 是 App-AdForce（现在这个网站似乎转移了）的。很有意思的是，我用着的手机是华为的，内置 Google Services Framework 和 Google Play（虽然实际上都不能用），这就免去了找 GSF 和 Google Play 并 root 安装的麻烦——我并不喜欢随便 root 手机。在真机上玩的时候，只有第一次弹窗（弹出浏览器广告）了，弹出浏览器转向倒是在数据同步（引き継ぎ）时有一次，之后再也没烦过我。然而在一个安装了带 Google API 系统镜像的模拟器上，每次启动都会弹出广告。也许是因为我没有真正开始玩吧，不过我目前相信是一个“阉割”了的 GSF 有着“抗干扰”的副作用。——顺带，功夫网的一个积极作用就是保证我访问不了 Google Play，不剁手。 回到正题。还可以看到，这里面有一个 Unity3D 插件，提供游戏内的 WebView。其实抓一下就知道，每日更新的信息就是承载在一个 WebView 中的。bitter.jnibridge 放了一个 JNI 调用的辅助类，不过这个类在 jd2 中没有找到其他引用，或许是在混淆了的代码之中，所以就算了。com.prime31 则是 prime[31] 的 SDK，这是氪金的收费接口。FMOD 作为一个独立模块存在在内，是不是 Unity3D 打包的时候这么放的我不清楚。 大略浏览一下，可以发现这里面存在不少用 Java 写的 Unity3D 插件：Cygames 的（广告推送）、App-AdForce 的（广告推送）、Gree 的（WebView）。 四、寻找密钥吧上一篇中我们知道要找一个密钥，但是不知道它位于何处，也不知道什么时候会出现（静态字段还是动态生成）。解答这个谜题的感觉就跟探险一样，让人激动不已。 首先我们可以确定，最显眼的 jp.co.bandainamcoent.BNEI0242 中并不存在密钥。其余的很多东西，主要分为几类： Android 兼容所需； 第三方 SDK； Unity3D； FMOD。 密钥在前两者中出现的概率微乎其微。对于后两者，如果有了源代码，重新编译并将密钥作为一个字段嵌入并不是难事，所以是有可能的。我曾经怀疑过，但是经过仔细的搜查，里面还没发现密钥什么的代码。 五、Unity3D 和 JNI在反向的时候，我想着一个问题：这么一个 Unity3D 的游戏，为什么需要原生的共享库呢？一个很自然的想法，就是将密钥藏在更不容易被反向的原生代码中。这些原生库有两种可能的使用方式：JNI，给 Java 程序调用；P/Invoke，给 CLR 调用（Unity 内）。而且一个大大的“jnibridge”摆在那里，这是一个商业软件，也就是说应该是经过了最优化的（清除无用符号和指令、速度/内存优化、混淆、压缩），留下的组件被用上的概率很大，不明摆着可能用到了 JNI 吗？ 由于我不熟悉 JNI，我就找了一下。于是我找到了这篇文章（原文链接已经失效），讲到了 JNI_OnLoad 函数。一找，果然找到了。其实不用 IDA，用个文本编辑器什么的打开应该都能看到，导出表还是属于可读部分的。 但是这个分析也只能到此为止，拆开 JNI_OnLoad 去看初始化了什么，就是 C++ 级的反向了，代价很大。 但是问题来了，可以看到，除了 JNI_OnLoad，还导出了那么多函数，它们并没有在 Java 层被调用，应该就是 Unity3D 调用了。（而且名字 libcri_ware_unity.so 已经十分直白了。）搜索一下“jni_onload unity3d”，就能发现蛛丝马迹——它们，都是用 C/C++ 写的 Unity3D 的插件！由于插件数量未知，加载应该是使用依赖注入的方式进行，也就是类似枚举+反射的方式。但是，Unity3D 加载的应该是兼容 CLS 的程序集才对，Unity3D 的 Java 部分也没有写出要加载哪些库/程序集，入口点是什么。 那么我们换一个思路，既然都是插件，就看看 Unity3D 是如何加载插件不就好了？于是我们能找到简易的说明，并引导到官方文档。从这里能看到，Unity3D 的原生插件加载是通过 DllImport 特性（有 .NET 开发经验的应该不陌生）加上反射实现的。关于这个说法还有待验证，下一步进入到 C# 的反向时就能证明了。com.unity3d.player.NativeLoader 类和 com.unity3d.player.ReflectionHelper 类的存在，佐证了这种想法。 关于 NativeLoader，它的类文件是这样的： package com.unity3d.player; public class NativeLoader { static final native boolean load(final String p0); static final native boolean unload(); } 从两个方法名称就可以看出它们是干什么的。不过虽然 p0 这个参数我们还不知道是什么意思（大致能猜到），但是搜索一番，可以在 com.unity3d.player.UnityPlayer 类中找到这一段代码： private static void a(final ApplicationInfo applicationInfo) { if (UnityPlayer.q &amp;&amp; NativeLoader.load(applicationInfo.nativeLibraryDir)) { t.a(); } } 这证明有一个遍历载入的操作——JNI_OnLoad 有用武之地了。这就相当于 DllMain 的 DLL_PROCESS_ATTACH，在这个库被载入进程的内存空间时进行全局（相对于库而言）的初始化。这样，虽然之后的 P/Invoke 需要产生加载调用，但是此时这个库已经存在于与调用者相同的内存空间中——同一个“实例”中，此时 RVA 是同一段，不用担心进程隔离带来的非法内存访问。 什么意思呢？假设我有这么一个库，导出如下的两个函数： __declspec(dllexport) void *get_buffer() { return malloc(100); } __declspec(dllexport) void free_buffer(void *buffer) { free(buffer); } 然后由一个应用程序动态加载（不静态链接）并执行： int main(int argc, char *argv[]) { void *p = get_buffer(); free_buffer(p); } 中间有一个堆上的指针，这个指针在进程间是无效的，但是进程内是有效的。这个程序能否正常运行，就取决于应用程序和所加载的库是否在一个内存空间中。还可以证明，如果我放在库中并声明为静态的全局变量，在整个进程实例中是共享的——听上去就是一个放密钥的好地方，在库初始化时初始化密钥字段，然后其他 API 读取、操作什么的，岂不是能避开旁人耳目？ 不过尽量还是不要去跟原生代码较劲，太费力气。想到既然是 DllImport，进入到 C# 部分的话，即使是 P/Invoke 也是十分简单的事情。更重要的是，这个插件的一个导出函数引起了我的注意，它说明密钥的写入很可能不是在内部进行的，而是一个由外而内（假设 libcri_ware_unity.so 为内的话）的过程。 欲知后事如何，请听下回分解。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"杂谈","slug":"zh/2016-03-24-Misc","date":"2016-03-25T13:04:00.000Z","updated":"2020-03-30T22:34:35.436Z","comments":true,"path":"categories/Misc/zh/2016-03-24-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-03-24-Misc/","excerpt":"本文分为几个部分：软件中的唯一性资源、技术进步和社会平等、Batman v Superman 影评。 乱想乱讲的，轻拍。","text":"本文分为几个部分：软件中的唯一性资源、技术进步和社会平等、Batman v Superman 影评。 乱想乱讲的，轻拍。 各位应该听说过“注意力资源”这个概念。这个概念是谁最先提出来的，我没有找到确切的证明。1998年中国有人提出了这个名词，但是其论文中并没有给出一个逻辑解释；2005年有外国学者将其作为经济学中的一个模型提出。不过本文重点不在这里，而是讲一下与此相近的另一种资源——唯一性资源——在软件中的应用。 我认为，系统中的唯一性也是一种有限的资源。在系统整体性得到保持的情况下，唯一性资源是不可再生的。用人话说，就是在一个世界中，讲究“先来后到”。 还是用例子比较好理解。在 8.3 时代，将名字压缩到8个字符（范围还是 ASCII 的一个子集）内是一个艺术，由此也产生了一些常用的缩写“默契”——哪些字母省略之后还能让读者看出原本的意思。通常是省略元音字母，比如 SolidWorks→sldworks、PowerPoint→powerpnt（这些名字由于各种原因都流传下来了），还有词组压缩（iexplore）、公司缩写压缩（msword）等等常见手法。如此丰富的手段，都是为了能让自己的产品名优雅地、永久地、与其他已有文件无冲突地挤进这8个字符里。 这是一种占领行为。8.3 格式的解放和长文件名广泛应用缓解了这愈演愈烈的地盘之争。 然而，由于设计上的原因，划地盘的行为还在继续。 Linux 下，以 . 开头的文件/目录被认为是隐藏的，许多软件喜欢创建这样的一个隐藏文件/目录来保存设置。Git 的数据库就是 .git，JetBrains 一家子的配置目录是 .idea，Visual Studio 2015 一个看上去准备拥抱 Linux 的举动是用 .vs 来保存当前工程编辑状态，它的姐妹 Visual Studio Code 则用 .vscode。所以即使你的某款软件叫做 Vivid Symphony，为了不冲突，也请不要用 .vs 这个配置位置了。 还是 Linux 吐槽。用 Linux 的应该都喜欢用命令行，绝大多数为 Linux 设计的软件都提供命令行程序。为了能简单运行，最直接的方法就是将其添加一个符号链接，放到 init.d 里，这样随处敲命令就能执行了。于是，斗智斗勇的命名大赛又上演了。Yeoman Generator 的命令行程序叫做 yo，安装好之后不管在哪里，用 yo nodejs 就能在当前目录下新建一个 Node.js 项目。是不是很方便？但是如果我的程序也想用 yo 作为命令怎么办？为了不影响 Yeoman，请让路吧。Windows 的用户比较幸运，因为大多数时候各位都是用鼠标。虽然两个系统有着类似的文件搜索策略（不详述，不清楚的同学自行学习），但是一旦冲突发生，Windows 就比较麻烦了，只好争抢谁在 %PATH% 中比较早出现（Windows 7 之后可以用 mklink 创建符号链接）。 扩展名是让人第一眼大概知道文件内容类别的东西，在 Windows 上是资源管理器对文件类别识别的唯一依据（不要跟我说 shell hook，还是要先通过扩展名筛选才到 hook）。我经历过的最早的扩展名冲突的来源是 CLEO（一个给 GTA San Andreas 提供脚本支持、构建 mod 的软件），它的脚本文件后缀是 .cs。在我还只是 VB 小白的时候下载过一次一个 CLEO mod，根据直觉，那些最主要的功能文件就是 .cs 文件，而我此时还不知道 C#，搜索后缀名之后所有网页说的都是 C#……所以尽管我没看到，但是不难想象出小白看着 .cs 就拿 Visual Studio 打开的场景。这同时是一个知名度碾压的例子。 更别提各种包管理、作用域中的函数名等等成百上千的具体例子了。这就和论文一样，发表最早的就有话语权。 有时候，由于知名度的碾压，一个特定的字符序列几乎是不可能被赋予其他意义的，形成了“关键字”。当我们说起 Git 的时候，你或许就不会去想原本的这个词“小玩意儿”的意思了。更复杂的案例是各种商标和在法律框架之下的名称保护，最近刚刚就发生过 NPM 包解放事件，虽说 NPM 的操作是对个人权利的侵犯，但这个事件产生的原因就是两个世界的符号碰撞——商业名称和程序包名称，“恰巧”撞车了，刀光剑影之后后者出局。 是否该担忧，好名字都没了该怎么办呢？如果我就想创建一个名字叫“苹果”的公司呢？这么说吧，人是一种喜欢划分管辖领域的动物，“好名字”也是由于人类记忆力、生命和活动（物理和信息）能力有限的产物。在没人的情况下，这跟用无限的猴子打文章差不多。 再开一点脑洞，这完全是符号化的争执嘛。我们将其简化为“符号”的事物，都参与了进来。所以这一节原本的标题是“认知资源”，指的就是人将事物概念化、符号化后认知产生的这些斗争。 在《技术会带来社会平等吗？》一文中，虽说资本聚集、技术毁梯子这事早听过了而且也切实地看到了，但是这个“在虚拟中重构平等”的可能性还是第一次见到。唔，但是技术上的差距还是融合不了嘛，计算资源并不是无穷无尽的，想要在虚拟中“享受”仍然会分裂社会阶层。毕竟是分形。在作品中表达了这样的观点的请见《楽園追放》。 今天中午招新，中间杨彦君去取了一下快递，我孤零零地看展位。十分钟的时间，看着面前一个一个人走过而无人驻足（实际上，这段时间有4个人问了一下“这是什么”），心有戚戚焉。嗯，又是那反社会的老一套。然而我也很清楚，我只是在给过去的时代披上寿衣，为上个时代的最后一批人尽一份仁义。我很荣幸我经历了，并将会亲手终结这一切。 在最后一分钟，两个妹子经过，一个人惊呼“哦原来是(社团)啊”，另一位并不知道我们是做什么的，就过来问了一下，我做了解答。“不过我们都准备毕业了”，她们说。嗯，两天招新一共有9个人稍稍关注了一下，已经是远远超出“0”的预期了。不过重点是这两位妹子给我感觉还不错，而且是同级诶。哈，一面之缘，没后续的概率很大，见过就好。 这时候杨彦君拿快递回来（乐高，用于……机器视觉，像这种），看到她们俩问完刚走，问我：“你同学？”“不。”我说。 下午抽时间去看了 Batman V Superman: Dawn of Justice，看完这电影，我只能给 2/10 分。电影特效我一向的态度是不影响剧情就行，做得再“炫酷”也不会有任何加分。一分给 DC 和最后终于变成秃头的 Lex，一分给某些有亮点的翻译。 这次翻译质量简直是一半天堂一半地狱，这里只提三个我当时就记下来的有误部分。剧透注意！ “Projectile One”翻译成“自动弹射一号”是几个意思？（前文：超人将毁灭日送上太空，两人一起挨了一发核弹，军队监测到两个物体从天而降。这里应该翻译成“一号残骸”啊！而且翻译是不是把 projectile 和 ejection 弄混了？） “one round of ammo left”翻译成“还剩一轮弹药”是几个意思？（前文：蝙蝠侠准备了3发氪石雾弹，对付超人用了两发，和解后只剩一发对付毁灭日。这里的意思是“剩下的弹药只够再来一轮同样的战术”，但是对弹药就应该说“只剩一发”了。）* 大炮上的“US ARMY”翻译成“美国军队”是几个意思？（语言常识，是“美国陆军”，美国三军之间的勾心斗角还是很深的。） *3月30日修正：round 用作量词作“弹匣”解，如“5 rounds of ammo”就是“五弹匣弹药”的意思。这是这几天玩 PAYDAY 2 的时候看到的。啥？汉化补丁？我才不需要那玩意儿。 为了引出正义联盟，对设定大刀阔斧的改编也影响了剧情。因为是 Zod 改造的，所以大名鼎鼎的毁灭日（Doomsday）就这么被一根氪石棍子插死了？这就跟 MCU（Marvel Cinematic Universe，漫威真人电影世界观）中的钢铁侠创造 Ultron 一样糟糕。虽然我并不是硬核美漫粉，但是对两家的主要人物、队伍和世界线都有基础了解，跨界必需的素质嘛，别想随意糊弄我。只能说，DC 电影布局实在是晚了，现在两家的电影竞争也白热化了，只好各自创建自己的新的无逻辑世界线来拉拢爆米花观众。 毁灭日本来是一个精神符号。杀死了超人的它，与有“the man who broke the Bat”之称的 Bane，和击败了福尔摩斯的 Irene Adler，有着同样的知名度。超人有着超凡的力量和正义感（“正义联盟的良心”），蝙蝠侠凭一介肉身跻身三巨头、七元老之位，还是队伍中的军师，福尔摩斯无案不能破。它们都是读者/观众心中的理想的化身，存在和地位应该都是金刚不坏的，然而只有毁灭日、贝恩和艾琳打败了他们（艾琳不是唯一击败福尔摩斯的人，不过是其中唯一的女性），粉碎了读者心中的神像。万千英雄之中只有一两个成了绝对的精神偶像（神），这“绝对”又被巧妙地破坏了。这就是他们的魅力，也是至高的人物经历设置的魅力，也是作品的魅力。 然而这电影就是为了票房，把这些都毁成了什么样！ 即使这些都不论，毁片的能力也不如大战高潮超人和 Lois 切的那几个镜头。这几个镜头明显就是设计用来迎合无脑观众，看上去人傻钱多好赚钱的。整个影片节奏前面和007差不多，这里突然就成了泰坦尼克号，生硬的插入连公式化的美国个人英雄主义片都比不上。一个比喻，就是打歌的时候碰到乱出的note，让人怀疑谱面制作者的能力。 而且，老！爷！用！枪！啦！对，就是那个在梦境外拿着枪还伤了人（没杀）的场景！真的拿枪就往人身上打了！这什么鬼！ 那些植入广告镜头中，我觉得最好的应该就是 EMC（VMware 的母公司，去年10月被 Dell 收购）的了。蓝色的 EMC2 放在服务器上，如果不是从事这一行的还真是看不出，这比那些植入车植入手机的土豪镜头要优雅多了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"再谈透视投影","slug":"zh/2016-03-25-Again-on-Perspective-Projection","date":"2016-03-25T06:38:00.000Z","updated":"2020-03-30T22:34:35.436Z","comments":true,"path":"categories/Tech/zh/2016-03-25-Again-on-Perspective-Projection/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-03-25-Again-on-Perspective-Projection/","excerpt":"这是第三次将目光放到变换矩阵上。之前经历过初次提交和修正，不过，剧本果然越来越精彩。","text":"这是第三次将目光放到变换矩阵上。之前经历过初次提交和修正，不过，剧本果然越来越精彩。 首先是终于理解了三个矩阵。我是因为搞不清 HLSL 中莫名其妙的向量和矩阵的左右关系才去搜索 MUL 指令的，但是偶然从一篇讲解文章中理解了三个变换的意义： 首先明白观察矩阵的目的是：将一个世界空间的坐标转换到观察坐系中。即将一个由X,Y,Z轴构成的世界空间的坐标点调整到由摄相机的上向量、观察方向、右向量的空间中。在这里，摄相机的右向量（上向量与观察方向的叉乘）等同于世界坐标系中的X轴。上向量等同于Y轴，观察方向等同于Z轴。 …… 于是，我们可以知道，乘以观察矩阵，就相当于是把一个点以原点为起点，自己为终点，构造一个向量，然后求出自己在由摄相机的各个轴构上的投影。最后再根据摄相机位置移回原点的过程。 我一直用“MVP矩阵”的方法来记忆世界、观察、投影三个矩阵的顺序（MVP 嘛，不管是 Most Valuable Professional 还是 Most Valuable Player，随便啦），但是不理解为什么就该这么乘。现在我理解了： M（model），是将各个顶点从模型坐标系（局部坐标系）变换到世界坐标系（全局坐标系）的； V（view），是将上一步的顶点从世界坐标系（以世界坐标系中的原点为原点）变换到观察者（摄像机）坐标系（以世界坐标系中的摄像机坐标为原点）的； P（projection），是将上一步的顶点从三维世界空间中，按投影方式（常用：透视投影、正交投影）投影到一个屏幕长方体（X 和 Y 是二维屏幕平面，Z 是深度关系）中的。 结合观察矩阵的 XYZ 意义，很容易理解投影矩阵的生成。所以这就弄清楚了。 接下来是 DX 中渲染的问题：近剪裁面，零，还是非零。 在我的一个测试场景中，我期望的渲染结果是这样的： 然而出来的都是这样： 对此我百思不得其解。我明明启用了 Z Buffer，为什么会出现奇怪的先后绘制关系呢？在学长的建议下，我将变换后的顶点输出调试（后来发现这个变换也是错误的，左乘和右乘的问题），看不出什么说明原因的东西。然后我就开始调代码，先是将视图矩阵换成固定摄像机，接着将投影矩阵从我的临时方案换成大多数情况下能用的 SharpDX 的原始代码——自然要改近剪裁平面距离。在距离设为 1 之后渲染结果突然正常了！我想是不是矩阵计算发生了错误——但是我已经通过测试，在距离大于零时和原始代码结果应该是一样的。想想有可能又是我的代码出了错误，我吓出一身冷汗，毕竟之前因为同一个地方的问题提交过一次有缺陷的PR，如果这次再是我的锅，我就名誉扫地了。最终我认为不是我的过错，以及想起了我说过的，在原来用固定管线的时候遮挡关系就出错了这个描述。 在我担忧又毁了一个PR的时候，我看到邮箱里关于上次PR的评论收到了回应。仍然是 Alexandre Mutel (@xoofx，SharpDX 目前的主力维护者，感叹一下好脾气）： I’m not sure what do you expect from using a znear 0, as the result projection matrix column ending with zeros is perfectly normal and valid, that’s the formula. It is a degenerated case, but nobody expect to set znear = 0, so it doesn’t make sense at all. Not sure why you seem to be so annoyed by this. It is like complaining that dividing by 0 is not valid. If you want to use infinite projection matrix, you can use a different formula as described in Tightening the Precision of Perspective Rendering, and as you can note, that’s only the far plane that is discarded, not the near plane that need to be here in order to perform proper “clipping/clamping” of the zvalue when z approach the near plane. 我读完立刻产生了一种被白了一眼的感觉。好吧，我花样作死，图形学太烂。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"“川岛” HCA 解码库","slug":"zh/2016-03-19-Introducing-Kawashima","date":"2016-03-19T12:35:00.000Z","updated":"2020-03-30T22:34:35.435Z","comments":true,"path":"categories/Tech/Coding/zh/2016-03-19-Introducing-Kawashima/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2016-03-19-Introducing-Kawashima/","excerpt":"首先指出，原版，也就是 HCA 的解码核心并不是我写的。原来的是一个解码命令行程序，将 HCA 解码为波形声音。我的工作是将其封装为一个动态库，期望“Write once, compile everywhere”。本文记录的是测试过程中填上的一些坑。","text":"首先指出，原版，也就是 HCA 的解码核心并不是我写的。原来的是一个解码命令行程序，将 HCA 解码为波形声音。我的工作是将其封装为一个动态库，期望“Write once, compile everywhere”。本文记录的是测试过程中填上的一些坑。 原作者附上了代码，并有免责声明： ■ 免責事項 このアプリケーションを利用した事によるいかなる損害も作者は一切の責任を負いません。自己の責任の上で使用して下さい。 这里特意指出。而且 kawashima 也使用同样的免责声明： 免责声明 本程序作者不对使用本程序所造成的一切损失负任何责任。请自己担责使用。 Disclaimer The author of this application does not claim for any damage caused by its usage. Use at your own risk. 名字来源是纪念翻译事故中的大龄偶像川岛瑞树。 一、为什么要使用 P/Invoke由于我的设计选择语言就是 C#，所以一开始我是希望用纯 C# 实现 HCA 解码的，也就是将 HCA 解码器移植到 C# 上。但是在实际操作中，由于 C 指针的灵活性与调试的难度，移植很麻烦——困难不是很困难，但是容易出差错。 在原程序中，大量使用的解码表。而且保存的是浮点数据，解码用的是作为整数保存的浮点值，直接一个 unsigned int * 转换为 float * 然后从浮点指针去访问就可以了： void DecodeN() { static unsigned int uintTable[] = { ... }; float *t = (float *)uintTable; // ... float a = t[index]; // ... } 而在 C# 中，必须要写一个小函数，对每个类似 t[index] 这样的访问，将 uint 转换为 float。这样，原来一个类似数组访问的语句，就被完全破坏了可读性，变成了一个函数调用： static uint[] uintTable = new uint[] { ... }; void DecodeN() { // t 的赋值就没有了，因为本身指向的是固定的数组 float a = Helper.UInt32ToSingleBits(uintTable[index]); // ... } 如果对 t 的使用更复杂，那么翻译出的 C# 代码可读性就更差了。翻译之后，原来码表读取就成了一个复杂的长调用。 调试的困难在于，循环量很大，而且两边数据无法同步对比。每个声道有几个解码缓冲区，对翻译后代码的校准当然要比较运行到同样的循环次数时缓冲区内容是否相同了。但是这很难，因为这是两种语言，两种内存模型，运行在两个环境下。至少以我目前的能力，还没法写一个自动校验器，在出现不同时自动命中两边的断点。最后我只好采用土办法，自顶向下测试，最后能定位到循环量级，中间的数据校验只好用“抽查”的方式，而且比较的还是浮点数！这蛋疼的经历有多少就想跳过多少。我现在如果进展顺利的话（这么说是因为即使有数据自己心里还是没底），卡在了 Decode5() 函数上，看上去输入的数据应该没问题，过程就…… 然后，有同学应该知道 C++/CLI 吧！如果将 C++ 代码直接用 C++/CLI 做一个 wrapper，岂不是很方便？很不幸，我用 ildasm 观察了一下这样产生的程序集，里面嵌入了大量的 msvcrt，也就是 VC 运行时的信息。毕竟，目前（我已知的，退一步说，我有的）C++/CLI 编译环境是在 Windows 下，用 cl，使用微软的头文件和库文件来编译，出现以上的结果是必然。我的目标是“Write once, compile everywhere”，况且目标平台并不是 Windows，所以并不希望出现这么强的依赖。那么用 Cygwin 或者 MinGW 来行不行呢？我还没试过，而且看起来也很麻烦的样子，没精力去试。至于 MonoDevelop，我没有 Linux 环境（而且磁盘也……）去编译、测试，所以就没走 C++/CLI 这条路。 所以摆在眼前的最后的方法，就是 P/Invoke。 二、编译环境既然是“Write once, compile everywhere”，那么就应该选择一个交集。所以，再见啦，VC 环境。我选择的是 CLion+Cygwin+CMake（3C？），CLion 有 CMake 的集成支持，这个组合很好用，就我的目标而言。 这个环境选择对后面的过程是有影响的，所以列在这里。 三、适配 Linux 的符号导出导出是使用 StdCall 调用约定的： // ... #define DLL_PUBLIC // ... // ... #define EXTERN_C extern &quot;C&quot; #define STDCALL __stdcall #define KS_API EXTERN_C DLL_PUBLIC STDCALL 较新版本的 GCC 似乎是支持 __declspec(dllexport) 这个语法的，不过保险起见还是留了一个 __attribute__((visibility(&quot;default&quot;))) 的回退。我经常会忘记三项声明的顺序，虽然也只有6种可能顺序，不过既然这次结果是正确的，就用着吧。 一般来说，作为公共库，导出函数在符号表中应该是 C 样式的（无 C++ 的参数后缀）。不过在名称上我遇到了点麻烦。 指定导出的名称有两种方式，一种就是函数属性（目前采用的），另一种是采用 .def。前者声明后由链接器决定具体的符号表，后者比较灵活，可以指定顺序、导出为序数（ordinal，没有显式的函数名，但是可以用来链接）。对于 C/C++ 默认的 CDecl，Cygwin 或 MinGW 的工具链是可以自动处理的；但是我指定了 __stdcall（为了在 Windows 下调试；在 Linux 下测试时再试试是否应该根据平台指定不同的调用约定），根据编译器的不同，符号表中生成的名称会变得五花八门。 根据这篇指导，如果我希望导出 Windows API 风格的函数（Function，仅保留函数名），使用 .def 是最简单的。不过，我并不知道如何在 CMake 环境下指定这个——或许是在链接器参数中给 ld 用，以后再试试。所以我一直觉得很奇怪，在 GCC 下，我明明是使用 extern &quot;C&quot;、__stdcall，导出的却一直是 Function@N 这样的函数，而我以前在 VC 下没有经历过这么“离奇”的事件。 我找到的另一篇博文中说用 --enable-stdcall-fixup 来解决这个问题。我是这么设置的： # StdCall fixup set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -Wl,--enable-stdcall-fixup&quot;) set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wl,--enable-stdcall-fixup&quot;) 然而好像并没有什么卯月。倒是另一篇指出的 --kill-at 选项解决了这个问题： # Using --kill-at: http://www.cnblogs.com/lichmama/p/4126323.html message(&quot;Killing &#39;at&#39; symbols in exported functions.&quot;) set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -Wl,--kill-at&quot;) set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wl,--kill-at&quot;) 现在通过 dumpbin 查看的结果是这样的： ... ordinal hint RVA name 1 0 000060D2 KsBeginDecode 2 1 00006488 KsCloseHandle 3 2 000062CE KsDecodeData 4 3 00006417 KsEndDecode 5 4 00006577 KsGetHcaInfo 6 5 000061F8 KsGetWaveHeader 7 6 00006724 KsHasMoreData 8 7 0000660E KsIsActiveHandle 9 8 000066AC KsIsHcaCheckPassed 10 9 00005E72 KsOpenBuffer 11 A 00005D50 KsOpenFile 12 B 00005F86 KsSetParamI32 13 C 00006036 KsSetParamI64 14 D 000067E7 KsTest ... 可以看到，在函数名称上是没有问题的了。 四、Cygwin 下的32/64位工具链切换首先必须要有一个64位的操作系统，才能用64位的 Cygwin，才能使用64位的工具链。 我的操作系统是64位的，我自然就选择了64位的 Cygwin。一切都配置好，输出 Built target kawashima 之后，我就用最简单的 KsTest() 函数做了一个 P/Invoke 实验——我还没试过调用 Cygwin 环境下编译的动态库，先要确保能正常调用，尽管只是一个无参数、无返回值的测试函数。结果第一次运行的时候就抛出了一个 BadImageException。 看到 dumpbin 有正常输出，说明这是一个正常的 PE 文件。然后我排除了可能的依赖库问题（编译后的64位执行文件导入了 cygwin1.dll、cygstdc++-6.dll 和 cyggcc_s-seh-1.dll 的符号），异常依旧出现。我突然想到，这难道就是传说中的 PE32 和 PE64 的加载问题？PE64 虽然在指令集和内存布局上都兼容 PE32，但是虚拟内存空间就成了一个问题。杨彦君曾经吐槽说 Linux 下64位和32位根本就不兼容（64位系统无法运行32位应用程序），我反吐槽说微软准备了两条依赖链。各位看到的“64位 Windows 兼容32位 Windows 程序”的现象，实际上是由于同一台机子上既有32位的环境，也有64位的环境——也就是所谓的 WOW（Windows-on-Windows）。WOW 最初的应用是32位的 Windows 95 支持运行16位的应用程序。扯远了，总而言之就是我的主程序和动态库的目标平台不同，导致了这个异常。 所以，在涉及 P/Invoke 的时候，要注意原库的目标平台。那么问题来了：挖掘机技术哪家强如何在64位的 Cygwin 下编译一个32位的动态库呢？ 有同学可能会说：这还不简单，给编译器加上 -m32 选项呗。就像这样： # Force 32-bit set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -m32&quot;) set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -m32&quot;) 但是这在 Cygwin 下不行，链接时是找不到合适的静态库的。我尝试过 link_directories()，然而还是找不到。由于链接直接失败了，所以我只能凭输出说，指定 -m32 时编译出的中间文件处于未知的状态，从而无论32位还是64位的静态库都无法链接上。 好嘛，既然不能用64位的 Cygwin 编译32位的动态库，那我大不了就装一个32位的 Cygwin，用它的工具链不就好了吗？很可惜，由于我的操作系统是64位的，所以 CLion 直接就不支持32位的 Cygwin，只支持64位的。所以只好继续用64位的工具链。 那么是如何解决的呢？首先，Cygwin 自带一个简易的包管理，安装32位的工具链。但是有了工具链还不行，要让 CMake 使用32位的工具链： if (${TARGET_ARCH} STREQUAL &quot;x86&quot;) set(CMAKE_C_COMPILER &quot;/usr/bin/i686-pc-cygwin-gcc&quot;) set(CMAKE_CXX_COMPILER &quot;/usr/bin/i686-pc-cygwin-g++&quot;) elseif (${TARGET_ARCH} STREQUAL &quot;x64&quot;) set(CMAKE_C_COMPILER &quot;/usr/bin/x86_64-pc-cygwin-gcc&quot;) set(CMAKE_CXX_COMPILER &quot;/usr/bin/x86_64-pc-cygwin-g++&quot;) else () # ... endif () 是的，这是一个很不优雅的方案。特别是硬编码了编译器路径，虽然是 Cygwin 能识别并正确映射的，但这个 CMake 配置不能直接拿去给 Linux 用户用。而且工具链上没有 ARM 目标，也是一个败笔。 很神奇地，在采用了32位的编译器和链接器后，它们终于会选择正确平台的静态库了。明明64位+-m32 的配置都无法正确选择。 五、Cygwin 自己的问题通过了 KsTest() 的测试后，在实际使用这个库的时候，我又发现了一个坑爹的问题：Cygwin 的一些函数对 P/Invoke 很不友好。 我目前碰到了 fopen() 和 malloc()，没试过它们对应的释放函数，或者其他的标准库函数。调用时现象如下（“随机”选一种出现）： 程序无响应； .NET 抛出 AccessViolationException。 第一条我是在调用前后加了 MessageBox() 测试过的，确认是这些函数的调用造成的无响应。 由于这些标准函数都是从 cygwin1.dll 直接导出的，所以我原来猜测也许是 Cygwin 的旧版本实现上出问题了。于是我从 2.4.1 切换到 2.5.0-0.7，但是这个问题还是发生了。而原来的 HCA 解码器程序是同样环境编译的，也用到了标准库函数，但是能正常运行，所以我只能推断异常和 P/Invoke 有关。具体怎么个关系，我就真不知道了。 解决方案是条件编译，在 Cygwin 下使用 Windows API 替换标准库函数。malloc() 和 free() 就用 new 和 delete 来代替了，毕竟里面用到的主要是（存储数据用的）结构体，构造函数为默认就行。 六、编译器优化的坑今天（3月21日）在代码排版的时候，手贱改了一个地方，差点就找不到错误了。 原来的代码是这样的： void clHCA::clCipher::Init0(void) { for (int i = 0; i &lt; 0x100; i++) _table[i] = (unsigned char) i; } 我一看，这大小不是刚好能用一个 uint8 装下嘛，为何不用呢。于是就改成了这样： void CHcaCipher::Init0() { for (uint8 i = 0; i &lt; 0x100; i++) { _table[i] = (uint8)i; } } 于是噩梦出现了，昨天通过的解码测试今天突然就通不过了。经过 C# 端的排查，发现问题出现在对 KsBeginDecode() 的调用上，调用后 CPU 满负荷运转——死循环的特征。为什么一个本来正常的函数出现了死循环呢？它做了什么呢？我挑了几个可疑的点设下断点（没法直接调试，就用 MessageBox() 告诉我），最后定位到 CHCA 的内部变量初始化。再查，就发现是上面这一段出现了错误。 问题出在哪呢？uint8 的最大值是256（0x100），而以上的代码会被编译成这样的汇编：（你懂计算机吗，还最大值256？你看你自己不就是脑残了么。下面的又有什么意义呢？） mov al, 0 ; ... cmp al, 100h ; &lt;- 这是不可能出现的 ; cmp al, 00h &lt;- 可能是这样 jl ... inc al 实际上，由于声明的 i 的类型是 uint8（unsinged char），所以条件 i &lt; 0x100 实际上恒为真，i &lt; 0x00 恒为假。不管是被编译为上面的代码，还是直接被优化，这个循环是跳不出去的了。 所以，改代码前请三思。难道 malloc() 也是如此吗？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"},{"name":"kawashima","slug":"kawashima","permalink":"https://blog.mottomo.moe/tags/kawashima/"}]},{"title":"博客更新","slug":"zh/2016-03-16-Blog-Update","date":"2016-03-16T10:19:00.000Z","updated":"2020-03-30T22:34:35.435Z","comments":true,"path":"categories/Misc/zh/2016-03-16-Blog-Update/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-03-16-Blog-Update/","excerpt":"","text":"春节开始，就没更新博客了。一方面……懒了点，另一方面……算了就是懒。分类有所更改，404 更智能了一点。 春节过后很高兴地，收到了首要目标的 conditional acceptance。这边算是解放了。 主要猛攻了 CGSS，取得了一定成果（咦这么论文式的措辞？），详见 CGSS 核心反向过程实录。 暂时挂起的几篇文章： 安利白箱及其后续 CGSS 和 LL 上手 翻译风波 WordPress 建站指南（写给小白级别的入门，从选择域名到全站 HTTPS 一条龙。写到一半发现安全配置那里就得扯一长串了，还要解释 vim，一团乱麻。后来村长又不想自己建了，就暂挂了。）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"AlphaGo 与对机器智能的担忧","slug":"zh/2016-03-15-Pessimism-to-Machine-Intelligence","date":"2016-03-15T14:20:00.000Z","updated":"2020-03-30T22:34:35.435Z","comments":true,"path":"categories/Misc/Thoughts/zh/2016-03-15-Pessimism-to-Machine-Intelligence/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2016-03-15-Pessimism-to-Machine-Intelligence/","excerpt":"","text":"前记：3月8日的 Steam 更新添加了对 Vulkan 的 overlay 支持；3月12日 NVidia 驱动更新添加了 Vulkan API 支持。 举世瞩目的李世乭对阵 AlphaGo 的围棋之战在今天落下帷幕，最终李世乭以1:4落败。然后我在博客园新闻区看到了这样一篇：《为什么李世石的胜利让我喜极而泣》。下面的评论说“这事让好多文学分子高潮了”，认为这只是算法的胜利，计算机终究会为人类服务，那些担心都是无稽之谈。在这里讲一下我的看法。 如果机器具有了智能，判断对物种的好恶的能力，会展开对人类的“清洗”吗？从逻辑上来说，清洗是更好的选择。有文章提到过，光看人类自己，看看印第安人在美洲的经历，就知道黑暗森林法则实践起来是什么样子。如果它们还懂得沟通，获取它们群体内的最大利益，甚至会重演八国联军的事件。AlphaGo 是设计用来博弈的，正处于“不成熟的理性”的阶段，如果无法判断“整体”的概念，无法理解第零定律的话，就会出现曲别针的例子——所有人都做成曲别针，尝试劝阻的人也被做成曲别针。 等等，刚才不是假定了机器有了智能吗？但是退一步说，即使机器没有智能、只是按部就班行事，也会出现曲别针事故呢。看官知道第一个蠕虫病毒是怎么产生的吗？足够的功能，加上错误的参数。就执行的命令而言，并没有错误，只不过出现了人类不希望的结果。人并不希望比自己先进的生命体出现（同样，黑暗森林）。前面印第安人的例子已经是很仁慈了，因为还没产生生殖隔离，所以还有种群内的“怜悯”。 所以，认为不需要担心的，和担心的，两类人的出发点是不同的。前者从逻辑的角度看问题，而且很乐观地假设了机器总会在人类的控制之下；后者从人性（人类“生存”利益）的角度看问题，而且悲观地认为自律（有足够能力离开人自行活动）地机器有着胜于人类的能力。各位，不妨找一个平衡点吧。这就和养狼一样，给了机器强大的计算能力和与物质互动的工具，相当于给了它们獠牙。这方便了人们的生存，但是就是不知道什么时候会反咬一口——想避免这不幸的情况发生，请拔掉它们的牙，将它们限制在虚拟空间之内吧。 说得容易做起来难，好多人都已经半数字化了呢。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"修正提交给 SharpDX 的 pull request","slug":"zh/2016-03-14-Correcting-The-PR","date":"2016-03-14T10:28:00.000Z","updated":"2020-03-30T22:34:35.435Z","comments":true,"path":"categories/Tech/zh/2016-03-14-Correcting-The-PR/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-03-14-Correcting-The-PR/","excerpt":"上次我说，解决了 Matrix.PerspectiveFovLH() 的问题，然后提交了 pull request。","text":"上次我说，解决了 Matrix.PerspectiveFovLH() 的问题，然后提交了 pull request。 后来这个PR被merge了，我很兴奋。直到三天前，我突然收到了来自 GitHub 的自动邮件： I had to revert this code. As it was breaking all implementations (all MultiCube samples were not correctly rendering) Could you take some time to check why please? 哇，真是了不得了，初次的PR被revert了！而且说所有的 MultiCube 示例都无法正常渲染了（SharpDX 带两个测试，一个三角形测试一个立方体测试），我这不是捅大篓子了吗？ 前两天在研究将反向的结果包装回去，检查两种无法自动对比的代码真心头疼，又想起了这码事，不能让人家等久了，于是开始审查代码。 我想，为什么这代码用了这么久我都没发现问题呢？一看各处应用点，N 为0的地方我都用的是修改的函数，其他地方用的原来的函数。这说明根本没好好测试过嘛！没验证过修改的函数在 N 不等于0时的表现。 然后就发现了，M34 写成了 M44，而这个矩阵在 N 为0时最后一行刚好全零，完美地规避了元素顺序。这样，上面说的博文中的代码就是错的了。 具体的请查看#725，和对原PR的回复。同时可以注意一下 MSDN 上的补充。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"DirectX","slug":"DirectX","permalink":"https://blog.mottomo.moe/tags/DirectX/"},{"name":"SharpDX","slug":"SharpDX","permalink":"https://blog.mottomo.moe/tags/SharpDX/"}]},{"title":"CGSS 核心反向过程实录 | 三、解密方法确认","slug":"zh/2016-03-10-Reversing-CGSS-3","date":"2016-03-10T14:12:00.000Z","updated":"2020-03-30T22:34:35.434Z","comments":true,"path":"categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-3/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-3/","excerpt":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 （3月3日8时-12时） 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 我相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、转折：密钥，目标锁定找到了 HCA 之后怎么办呢？我知道这个文件很可能是加密过的，但是加密方法未知，所需的解密参数未知。这样一个东西，怎么撬开呢？想起上次说过，ADX 文件是支持简单的 XOR 加密的。但是，即使如此，那3×16字节的密钥也无法暴力破解啊。 这里来一个小插曲。在3月8日晚间有了初步结果之后，对村长吐槽说暴力破解应该是不行的。 村长：“你应该用Q-Learning……今天刚学……trial&amp;error……试错和暴力破解是两个概念啊” 我：“但是你反馈没用啊，密钥是在一个空间内随机分布的，没有收敛性” 村长：“如果无反馈怎么破解” 所以，想尝试用优化算法来干这事的就别想了。 又是 vgmstream 的周边给予了一个转折。在它的一个 feature request 中，有用户提到了加入 HCA 解码器的请求，并附上了一个 MEGA 链接，说是在日本某个公告板找到的。 还好，这个 MEGA 链接还没挂，我就赶快来了一份。其中有 Google 翻译翻译过的 readme，关于参数设置部分是这样的： Decode The default option Volume = 1 (times) Bit mode = 16 (bit) Loop count = 0 (times) Keys that are used in the decryption key = 30DBE1ABCC554639 ※ PSO2 Is. 虽然有着浓厚的机翻味道，但是懂还是能懂的。数一数，唔，这个密钥是64位的。可信度如何呢？按照附带的调用示例，我试着输出了一下这个文件的信息： C:\\Users\\MIC\\Desktop\\cgss-crack\\_vgmt_acb_ext_8a79c100465ec1c6ffbfdb45cf86af36bf6425cf\\acb\\awb&gt;hca -i song_1004.hca song_1004.hca 偺僿僢僟忣曬 僐乕僨僢僋: HCA 僶乕僕儑儞: 2.0 僠儍儞僱儖悢: 僗僥儗僆 (2僠儍儞僱儖) 僒儞僾儕儞僌儗乕僩: 44100Hz 僽儘僢僋悢: 5260 愭摢柍壒僽儘僢僋悢: 0 枛旜柍壒僒儞僾儖悢丠: 727 價僢僩儗乕僩: CBR (屌掕價僢僩儗乕僩) 僽儘僢僋僒僀僘: 0x02AA comp1: 1 comp2: 15 comp3: 1 comp4: 0 comp5: 128 comp6: 128 comp7: 0 comp8: 0 埫崋壔僞僀僾: 尞桳傝埫崋壔 仸惓偟偄尞傪巊傢側偄偲弌椡攇宍偑偍偐偟偔側傝傑偡丅 关注的重点是，这些输出看上去是合理的！这时候千万不要因为乱码而笑话，有点常识的人都知道，前文提到这个程序是来自日本公告板的，常量字符串就很可能是用 Shift-JIS（CP932）编码的，这样在一个 CP936（GBK）编码的控制台中输出，乱码并不奇怪。后来我重新编译了一下，有了可读的输出： D:\\Source\\C\\hca\\bin\\Debug&gt;hca -i C:\\Users\\MIC\\Desktop\\cgss-crack\\_vgmt_acb_ext_8a79c100465ec1c6ffbfdb45cf86af36bf6425cf\\acb\\awb\\song_1004.hca C:\\Users\\MIC\\Desktop\\cgss-crack\\_vgmt_acb_ext_8a79c100465ec1c6ffbfdb45cf86af36bf6425cf\\acb\\awb\\song_1004.hca のヘッダ情報 コーデック: HCA バージョン: 2.0 チャンネル数: ステレオ (2チャンネル) サンプリングレート: 44100Hz ブロック数: 5260 先頭無音ブロック数: 0 末尾無音サンプル数？: 727 ビットレート: CBR (固定ビットレート) ブロックサイズ: 0x02AA comp1: 1 comp2: 15 comp3: 1 comp4: 0 comp5: 128 comp6: 128 comp7: 0 comp8: 0 暗号化タイプ: 鍵有り暗号化 ※正しい鍵を使わないと出力波形がおかしくなります。 翻译过来是这个样子的： D:\\Source\\C\\hca\\bin\\Debug&gt;hca -i C:\\Users\\MIC\\Desktop\\cgss-crack\\_vgmt_acb_ext_8a79c100465ec1c6ffbfdb45cf86af36bf6425cf\\acb\\awb\\song_1004.hca C:\\Users\\MIC\\Desktop\\cgss-crack\\_vgmt_acb_ext_8a79c100465ec1c6ffbfdb45cf86af36bf6425cf\\acb\\awb\\song_1004.hca 的标头信息 编解码器: HCA 版本: 2.0 声道数: 双声道 (2声道) 采样频率: 44100Hz 区块数: 5260 开头静音区块数: 0 末尾静音区块数？: 727 码率: CBR (固定码率) 区块大小: 0x02AA comp1: 1 comp2: 15 comp3: 1 comp4: 0 comp5: 128 comp6: 128 comp7: 0 comp8: 0 加密类型: 带密钥的加密 ※若使用的（解密）密钥不正确，则输出的波形是不正常的。 说一下这个“静音区块”是怎么回事。在 ADX 的说明中也说过，为了对抗已知明文攻击（known-plaintext attack），ADX 的一些静音区块（半字节全零的区块）可能是不加密的。可以猜想 HCA 在头尾也嵌入了一些，如果加密方法“继承”了一点的话。 总之，虽然没仔细看这个解码器的源代码，但是就看着它的输出，可以假定这个解码器对当前版本的 HCA 是有用的。在这个假设的基础上，继续假设它的输入也是合理的、必需的、形式正确的。也就是说，我要寻找的东西，是且只是一个64位的密钥，而且可能会被拆分成两半。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"CGSS 核心反向过程实录 | 二、内容提取初试","slug":"zh/2016-03-10-Reversing-CGSS-2","date":"2016-03-10T08:58:00.000Z","updated":"2020-03-30T22:34:35.434Z","comments":true,"path":"categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-2/","excerpt":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 （3月2日23时-3月3日2时） 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 我相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、文件结构猜测上次我们讲过，歌曲文件的大小在 2M 以上。根据这个准则大致浏览一下各目录，就能发现目录 l 下聚集着一些 3.5M 左右的文件，数量不算多也不算少。推测这些是音频文件，而且是打歌用的音乐。我随机选择了一个 8a79c100465ec1c6ffbfdb45cf86af36bf6425cf，开始查看。 首先我以为是简单的音乐，就试着用 foobar2000 配合各种解码器来播放，都失败了。文件识别如何呢？TrIDNet 败下阵来，直接就报无法识别了，连推荐选项都没有。于是只好手工分析了。 由于几乎不可能是文本文件，所以最好的工具无非就是16进制查看器啦。这里我选用的是 Hex Editor Neo。 这个文件头就很有意思： 然后往下看，能看到一些可读的东西，例如 Cue、Wafeform、SamplingRate 等等。不过还有一个很有意思的现象，这个 @UTF 总是在4字节对齐（或者更高，例如16，我没仔细算）开头的地方出现。这就说明，@UTF 很可能是一个节（section）的开始标志。考虑到现在很多文件格式是针对32位机器的，对齐和数据首选32位（4字节）是很正常的。在@UTF 之前的那些字节，很多都是 0x00，说明这个文件结构是固定填充，带 padding 的。 考虑到一般分节的文件结构会记录数据偏移，而且很可能出现在头部，我们就来试试。第二个 DWORD 是 0x0036caf8（Big Endian，大端序），等于十进制的 3590904，而该文件的大小是 3590912 字节，跳转到偏移 0x0036caf8，果然接下来8个字节都是 0x00，说明 @UTF 后紧跟着的4字节存放的是文件有效大小。 按照这样的思路抓几个节来分析，能得出下面一个简陋的结构： struct { int32 magic; // &quot;@UTF&quot; int32 length; // 不包含&quot;@UTF&quot;头和4字节的长度 int32 ???; int32 desc_offset; // 文字描述段（含段flag）距离本节的偏移 int32 unknown_payload_length; // ??? ???; char field_desc[N]; // 文字描述段，C样式字符串，NULL结尾 int32 end_signature = 0x00000000; // 固定的全零结尾 } 没错，对实际解析没什么用。然后注意到一个段（segment）SamplingRate，这个值应该不是随便取的。一般的设备也就是 11025 Hz、22050 Hz、44100 Hz、48000 Hz 这几种规格，如果播放时还要进行转换，就可能满足不了音游的实时性要求了。我们来看看： 从后往前推，SamplingRate 是倒数第三个段，如果前面是数据，那么应该接近数据的末尾。慢慢推就发现，ac 44（十进制 44100）应该就是了。至于前后的字节，猜测是类型说明。 但是分析也就到此为止了，简单的挖掘挖不出新东西。 三、曙光：AFS2继续看文件有没有什么有意思的。我发现，在最大段的数据（猜测是音频本体）前的节并不是 @UTF，而是 AFS2。为什么我这么肯定呢？因为 AFS2 和 @UTF 一样，享受4字节对齐的“特殊待遇”。 这个 AFS2 并不像 @UTF 所指的那么泛，很可能是这个文件类型的指示。于是 Google 一下“AFS2 Format”，去掉那些明显是水军的链接，又有一个东西进入了视野：AWB。更多的时候，是这么写的：“AWB AFS2”——几乎是不可分割的。 首先我点入了这个链接，然后是这个。然后我知道了解包工具 QuickBMS 的存在，和对应的 AWB 解包脚本。 我把 AFS2 节提取出来进行解包，但是什么都没出来。本来想结合推导出的结构手写 QuickBMS 脚本的，还找了一下使用方法，但是结构不完整也没法写了。 附：这个时期找到的 AFS 格式描述，不过和我观察到的不一致。 这条线暂时搁到一旁。 四、vgmtoolbox 的拯救我继续阅读搜索结果。又一个东西吸引了我的注意：vgmtoolbox，有人说这个可以解 ACB/AWB 包。 什么是 ACB/AWB？仔细看索引数据库就会发现一些 .acb 文件，以及刚才抓的文件的文件头中的 ACB Format/PC Ver.1.23.01 Build:，都在提示我们这是个 ACB 包。 于是我下载了 vgmtoolbox，在 Extraction Tools\\Common Archives 下找到了解包的界面。尝试后我发现，整个文件就是一个 ACB 包，AFS2 节只是其中的一部分。 然而，解包之后发现，解出来的是一个后缀名为 .hca 的文件。Google 之后，一团线出现在我眼前。 处在核心的，是一家名为 CRI Middleware 的日本软件公司。这家公司出品过游戏，不过在现在，其主业是提供音频解决方案。它开发了一款音频格式 ADX，也提供了相应的封包方案 ACB/AWB。 ADX 支持加密，维基百科上是这么说的： A.D.X. supports a simple encryption scheme which XORs values from a linear congruential pseudorandom number generator with the block scale values. This method is computationally inexpensive to decrypt (in keeping with A.D.X.’s real-time decoding) yet renders the encrypted files unusable. The encryption is active when the “Flags” value in the header is 0x08. As XOR is symmetric the same method is used to decrypt as to encrypt. The encryption key is a set of three 16-bit values: the multiplier, increment, and start values for the linear congruential generator (the modulus is 0x8000 to keep the values in the 15-bit range of valid block scales). Typically all A.D.X. files from a single game will use the same key. 也就是说，解出来的是音频文件应该是 ADX 一类的。考虑到 BNEI 是日本企业，涉足游戏，和 CRI 是可能合作的，这进一步增加了可信度。 如何证明呢？CGSS 的启动画面就有 CRI 的logo（右上角）： 以前我还不知道，现在我知道了。 然后我搜索 ADX 的播放器，找到一个 CriAtomPlayer（从名字就可以看出来源）。虽说是在国内网站上找到的，不过根据后来看到的资料，应该来自于限定日本国内使用的免费 ADX LE 开发套件。正当我满心欢喜地敲下回车的时候，一播放，完全是噪音。加密？你要我去试3×16位的密钥？这条线在这里断了。 五、谱面的出现百无聊赖之中，我随意翻找 a 目录下的文件，拖到 vgmtoolbox 的窗口中看能不能解压，从最大的文件开始尝试。 第一个，不行。用 Notepad++ 一看就是编译后的 Unity3D shader。 第二个，不行。用 Notepad++ 一看……等等，这也是一个 SQLite 数据库！ 话不多说，再次查看里面的内容。哇，这次挖到了东西，所有的对话文字、卡片说明、特技说明、载入画面的“八卦”（ウワサ）等等，都展现在了眼前。 于是我意识到，在 a 目录的 Unity3D shader 之海中，一定还存在其他的数据库。于是又写了一个小程序，在所有文件中搜索 SQLite 数据库。果不其然，我所保存的数据中，除了索引数据库，还有另外44个文件是 SQLite 数据库，打开看看是什么吧。有房间物品说明、PLv（Producer Level）说明等等，不过最有价值的，还是很容易解析的谱面（你看到了第一眼也会懂的，开发人员太贴心了www），和额外的谱面说明。 这一趟下来，音频这一关还没法过，但是谱面拿到了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"CGSS 核心反向过程实录 | 一、摸清目录结构","slug":"zh/2016-03-10-Reversing-CGSS-1","date":"2016-03-10T05:27:00.000Z","updated":"2020-03-30T22:34:35.434Z","comments":true,"path":"categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-1/","excerpt":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。","text":"索引 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 （2月21日） 一、声明The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 我相信大牛即使是没有看过我写的这些玩意儿也能上的。 二、一切的起因我2月15日时开始玩了CGSS，由于加入的第一天正好是一个送 star jewel 的活动的第一天，所以记得比较清楚。 然而，在音游上，我是个手残，至少初始状态下是个手残。开始的一周，在队伍的life值（可以认为是HP）还不高、没“奶妈”（恢复life）卡等因素的共同作用下，打 Regular 难度，终盘都半死不活。你或许会问，多练习不就好了？的确如此，不过运营商怎么赚钱呢？很简单，限制你的练习次数。游戏中有一个叫做体力槽（スタミナゲージ，stamina gauge）的东西，每玩一首歌（“打歌”）就要消耗一定的体力。这个体力是会慢慢涨回去的，5分钟一点；然而一首歌的消耗随难度不同在11点到20点之间。体力槽上限我现在见过的是81点。所以各位可以计算一下，平均多久才能打一首歌。体力可以氪金，或者通过掉落频率较少的物品来补充。——看到这里，想必之前不知道的同学也理解了收钱的方法了吧，和普通网游是差不多的。 但是！我等是有技术的，而不是萌豚，能用技术轰下的阵地就不会用钱砸。于是问题就很明显了，我们要根据已有的数据模拟出一个练手的东西出来。（不要想去伪造 HTTP 请求，破解是有底线的，不说错误的数据肯定会被检测到，就是刷出个全SSR又有什么意思呢？卖？那就和苟活的人没区别了。） Q: 有没有会嗤笑这个的成品呢？ A: 当然，这些人会：1、对 CGSS 无感的；2、有时间肝（花大量时间打游戏）的；3、有钱氪（课金，中文叫充值）的；4、手巧的。以上几项我一个都不符合，也没什么“本命”（非常喜欢某个角色）一说，所以，既然是数据，我们就用数据的手段来一决雌雄吧！ （注：在修订此文章的3月16日，经过一个月的练习，我的技术已经达到了能几乎FC17星的曲目、23星存活没问题、24-25星试一次的水平。除去队伍强化（从最初一张R其他N，到现在全队至少是R）的因素，技术确实是提高了。离大触还很远，不过比自己进步了许多。看来这和练钢琴是差不多的。） 三、目标分析CGSS 的玩法属于音游，大致由这些元素构成： 歌曲播放； 跟着节奏点击操作的质量判断； 评分； 显示； 社交（好友、任务）； 扭蛋（抽卡）； 卡片管理； Communication（类似 gal game 的东西）。 CGSS 有点特殊的地方是有一个 3D Live 的选项，这是通过 Unity 实现的，我们没必要还原这个，按下不表。另外，显示部分可以做得简单一些，因为我们做的是一个模拟程序，而不是对游戏的精确还原。再说了，完全反向所需的精力十分巨大，产出远不如投入（还会被告），根本没必要。除去其他和我们的目的不相关的元素，我们需要实现的有： 歌曲播放； 点击判断； 分数计算； 综合显示。 有了明确的目标之后，就开始逐个击破。 判断和显示是要自己写的，而文件是要读取的。在玩的时候，已经下载的歌曲是不会再下载的；因此，先解决歌曲文件和 beatmap（谱面）的位置和读取问题。 四、文件粗略分析首先将 Android 上的数据拷贝一份。数据在哪里呢？熟悉 Android 开发的同学们应该熟悉 Environment.getExternalFilesDir() 这个 API，映射到的是 /mnt/sdcard/Android/data/{app_id}/files，是各种外部数据的存放位置。我是在浏览文件管理器的时候偶然发现的。看总大小（500M，CGSS 的安装包&lt;50M），应该就是外部数据了。 复制之后结构应该是这样的： F:\\TEMP\\root&gt;tree 卷 Software 的文件夹 PATH 列表 卷序列号为 XXXX-XXXX F:. └─Android └─data └─jp.co.bandainamcoent.BNEI0242 ├─cache │ ├─tmp │ └─UnityShaderCache └─files ├─a ├─b ├─c ├─l ├─manifest ├─r ├─s └─v 注意到一个很特殊的目录 manifest，其他的目录名字都是不明所以的单字母，只有这个非常显眼。打开之后可以发现，目录内有且只有一个文件： F:\\TEMP\\root\\Android\\data\\jp.co.bandainamcoent.BNEI0242\\files&gt;dir manifest 驱动器 F 中的卷是 Software 卷的序列号是 XXXX-XXXX F:\\TEMP\\root\\Android\\data\\jp.co.bandainamcoent.BNEI0242\\files\\manifest 的目录 2016/02/21 08:42 &lt;DIR&gt; . 2016/02/21 08:42 &lt;DIR&gt; .. 2016/02/16 17:17 1,269,760 cceff7e658530cf7c8bf96901ef77d7e85dd436b 这个文件是一个什么东西？试试用 Notepad++ 打开： 有点经验的同学应该立刻能反应过来：这是 SQLite 3 的数据库格式！而且，从常识上来说，SQLite 是嵌入式数据库的首选，在移动平台上有着广泛的应用，所以出现在这里是可信的。 于是我们就找一个 SQLite 数据库的浏览工具吧。这里我用的是 SQLiteStudio。 翻阅记录，加上一点直觉和对数据的敏感性，能大致判断记录项的意义。然而，最有趣的地方还是在这里： 这说明： 这个数据库很可能是货真价实的索引（因为仍在假设阶段）； 程序中用的很可能是明文，经过加工后成了现在看到的东西。 五、初步验证猜想在玩的时候，有些歌曲是第一次运行时就下载了的。在玩的时候注意到这些情况： 歌曲的“开始”变成了“下载”，同时试听也没有了。点击“下载”则需要在“数据下载中界面”等待大概半分钟，然后试听就有了，歌曲也能正常玩了。 在开始一首歌的时候，有时候会有数据下载，但是一般都是十秒内结束。 有少见的情况，有试听，但是开始打歌的时候要等待比较长的时间；不过这都发生在上次歌曲下载没有完成我就强制退出（有时界面会无响应）的时候。 一般的打歌过程中，如果不换卡或者显示模式（3D/2D）是不会出现额外的下载过程的；而且明显这些文件是有缓存的。 CGSS 的“通信中”和“数据下载中”是两个不同的状态。 因此可以判断，在点击“下载”的时候，是下载音频文件，而且包含试听和本体。第一次打歌的时候下载数据的包含谱面和一些其他素材。然后从时间上加以印证：贴吧上有人说过设置中切换音频质量，低质量一首大概 2M，高质量一首大概 3.5M，“不要问是怎么知道的”（其实就是因为ta用了流量，然后看到了账单嘛）。地址我没记下来，不过我记得应该是在偶像大师灰姑娘女孩星光舞台吧里的。这个数据很关键，综合 MP3 的一般大小，假设歌曲采用 MP3 CBR，那么低质量码率大概是 96~128 Kbps，高质量大概是 192~224 Kbps，歌曲时间在2~2.5分钟——这和我的耳朵&amp;手机时间告诉我的相吻合。因此也可以判断，不管对方采用什么样的音频编码，其压缩率应该和 MP3 接近。 虽然歌曲的标题不知道，但是可以注意到歌曲的数量。这个数量怎么得到呢？上图中有一个 song_*，数据库中还有一些 name 值为 musicscores_* 的记录。不过由于这个“score”在当前语境中有多种可能意思：曲谱（即使不太可能）、分数、谱面（我一开始假设谱面是分开存放的，这个文件和音乐强相关，有可能是谱面），暂时还不知道设计者采用这个词的时候是想着哪一种。这里又遇到了一个挫折：（2月16日版的）数据库中的这两条记录数量都超过了发行的歌曲数量，剔除了明显重复的之后也是。（现在再想一想，有可能是预告呢，呵呵。） 但是，峰回路转，不在这么明显的地方验证数量，我们换一个地方。经过一番过滤，我发现了一个突破口： 上面的文件，直接出现了歌名！对灰姑娘曲目有点了解的人，应该能一眼发现熟悉的歌曲。例如，3d_cutt_apple 明显是《アップルパイ・プリンセス》（Applepie Princess，十时爱梨角色CD曲），3d_cutt_twilight 明显是《Twilight Sky》（多田李衣菜角色CD曲）。另外，我们还知道，solo 卡（带有“ソロ”标记的卡）是可以打《お願い！シンデレラ》的 solo 版的——所以 3d_cutt_oneshin 还带一个 solo 的“姐妹”。同时文件名还显示，这些文件用于 Unity3D，很可能是显示的资源包。因此可以做出一个合理假设，这些记录和歌曲相关，而且和歌曲版本也有关系（估计是动作？好像某地提到了“cutter”，但是不知道意思），而且看起来一个文件对应一首（分版本的）歌。我查了一下 CGSS 的歌曲列表（2月21日快照），一共54首（《お願い！シンデレラ》不算 solo 版），刚好和相应记录数量吻合。因此可以判断，不管歌曲有没有下载下来，这个数据库存储的都是完整的、最新的资源列表。 有了以上的关键提示，我们能确定要解析的目标的大概质量和体量（文件大小、内容量）了。但是现在遇到一个问题：文件名全都是莫名其妙的随机串，并不是直白的文件名。 看看，数据库中不是有一个 hash 列吗？有没有可能代码中有个函数用的是这个散列值呢？于是我写了一个小程序，进行了散列值-文件名的交叉比对，结果是我猜错了。（当然，BNEI 的程序员应该不会弄一个这么明显的东西出来。）不过为什么找不到呢？我突然发现，二者长度不相等，数据库中的值是128位的（32×4），文件名是160位的（40×4）。熟悉的同学也应该一眼就看出来了——这不就是 MD5 和 SHA-1 吗？但是知道了又能怎么样，这只是信息摘要，还不知道原始信息是什么呢。（读者可以看着这些值试试，很可能在这里就得出了我后来才得出的结论。）那么二者的功能就很明显了——MD5 用来校验文件完整性，SHA-1 来散列文件名。 走到这一步，对 CGSS 的数据目录结构有了个大体的认知，不过还是没有实际的用处。接下来，就应该推进到文件内容了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"CGSS 核心反向过程实录","slug":"zh/2016-03-10-Reversing-CGSS","date":"2016-03-10T05:00:00.000Z","updated":"2020-03-30T22:34:35.435Z","comments":true,"path":"categories/Tech/RE/zh/2016-03-10-Reversing-CGSS/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS/","excerpt":"","text":"本系列的索引。 声明 The Idolmaster Cinderella Girls Starlight Stage 软件和相关媒体的著作权为 Bandai Namco Entertainment Inc. 所有。本系列文章仅从兴趣出发，研究数据反向过程。在此不会给出完整的反向过程、反向结果和源代码，只给出思路和部分非关键数据。 2017年5月追记： 我探索这些的目的，是以一个玩家的身份，让 CGSS 变得更好玩。私下里我类比过普罗米修斯，将天火——谱面的制作和玩的能力从“天上”分一点出来。其实，修改 CGSS 去作弊是很简单的，无论是客户端还是 MITM。但是我不会去作弊，也不希望这系列文章的读者们将文章内容用在歪门邪道上，不希望去作弊、破坏平衡性。玩过 LLSIF、SB69、GF(note)、Arcaea 之后，我仍然认为 CGSS 的综合指标（游戏性、操作体验、曲目等等）是行业内翘楚，Cy这次比较用心。那么作弊还有什么意思嘛！对了，我不氪金，不冲分，只是闲暇时间来两局，玩得舒心。 当然，まゆさまが見ています。 从2月21日初试，到3月10日，反向结束。提取了谱面信息并成功解码了一首歌曲——song_1004，能听出是《メッセージ》。在将来的一段时间内，我将把部分的反向过程写出来。由于同时在做着毕设，写得会有点慢，但是一定会写完的。（天国的 Bulletproof……写完这个系列……也许就好。） 风格和展现尺度就致敬大神的了。 一、摸清目录结构 二、内容提取初试 三、解密方法确认 四、Java 代码反向 五、C# 代码反向 六、获取密钥 七、重新打包 八、成果应用","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"CGSS","slug":"CGSS","permalink":"https://blog.mottomo.moe/tags/CGSS/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"DereTore","slug":"DereTore","permalink":"https://blog.mottomo.moe/tags/DereTore/"}]},{"title":"两个奇梦","slug":"zh/2016-02-07-Two-Strange-Dreams","date":"2016-02-06T17:54:00.000Z","updated":"2020-03-30T22:34:35.434Z","comments":true,"path":"categories/Misc/zh/2016-02-07-Two-Strange-Dreams/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-02-07-Two-Strange-Dreams/","excerpt":"两个奇梦。","text":"两个奇梦。 昨晚（2月5日晚上-2月6日下午）做了几个梦，还记得两个。 其一 能记得的最后是，我站在一张长方形的、高度大概到腰间的浅棕色木桌子前，对着桌子。 桌上散着一些像是CD的东西，四方的、装着光盘的盒子。其中一张，这个我记得很清楚，封面是如月千早，左手持话筒，右手向着右下方作展开状，双眼凝望前上方。那张明显是千早的专辑。是的，我知道千早并不是实体，但是那一瞬间我产生了一种“她就是实实在在的人并出了专辑”的感觉。难道是我（6日）凌晨看爱马仕和《迷你偶像》（「ぷちます!」）太多了（那个凌晨又刷完了《迷你偶像》第一季）？不对啊，那个凌晨还看了三话的《神薙》呢，为什么我没在脑海中重演精美、活灵活现的OP？（所以说难道……歌神又一次碾压全场？） 我记得爸妈也在，老爸拿起其中一张问这是什么。我暗暗想道，纸包不住火，于是开始解释，同时将自己关注动漫和略知日语等等情况和盘托出了。（现实中，连关于动漫的部分我都没有说过一丝，也没敢旁敲侧击，更别提日语部分了。） 其二 做第二个梦的时候，已经是回笼觉了。我已经起来，主动预掐了九点闹钟。 第二个梦的对象是一个轮椅上的女孩，极度消沉（梦中推测，受到了很大打击），头低着，显得很悲伤。这个梦里好像经历了很艰苦的过程，为了结局做了哪些准备我也忘了。反正能记得结局的舞台是在一个堡垒（不是城堡哦，你们想多了，是那种在上面架着弓弩的防御工事）的高墙上，我说了一通话，最后大声喊道： I will let you feel! I will let you hear! I will let you see! （为什么用的是英语呢？我很好奇。） 而且是那种用尽全力的呼喊，一句和一句之间是有停顿的，每个结尾词都被强调了。随着每一次呼喊，女孩都似乎是颤抖了一下，就像童话故事（雪之女王）里心里的镜子裂痕一次一次扩大的样子，我能感觉到。此时的视角也很奇怪，我是在用第三人称近景看着我自己，左边有一块区域放着女孩的特写，如同一个电影镜头，由此才能看到颤一下的画面。更神奇的是，背景奏响的是某种交响乐，而且是我作的。我不是开玩笑，观看全局的我心里真的就在想着配乐，每个和弦、每个小节、节拍和乐器我想得一清二楚，也在我眼前具现化了（看到了一张不断添加音符的五线谱），每个小节由四个和弦组成。而背景音乐随着我想的而变，用术语来讲就是有一个相位差。仿佛就是我现场作曲，而配乐的乐队在幕外即时演奏一样。随着每一次的呼喊，乐曲一次次地强调，掀起小高潮。 到最后即将到高潮（我心里想着的，同时也是背景演奏着的）、整个故事要大结局、女主角要哭或者站起来什么（因为我最后没看见啊）的时候，突然被弄醒了。此时我闹钟还残留着下一个小节的四个和弦，乐队的演奏越来越远了。不到几秒我就恢复了神智，一听声音，是老妈抱着我小侄女（2岁？）玩，而且是知道我还在睡，拿她小手放我脸上玩。 我此时正准备看着大结局呢——毕竟好像是我终于感化了女主角什么的这种故事里的情节（gal？），我还想知道接下来会发生什么呢，结果就被这一个毫无意义的举动给毁了！而且顺带着，“动态作曲”和“意识乐曲合成”也被终止了。（平日我也许能想到一点旋律，但是编曲就十分苍白，毕竟乐理不精；而这次梦境是我第一次“全合成”，即使是在潜意识中。我在梦中意识到背景音乐是我想出来，并推断出也是我脑中演奏的时候我自己也有点吃惊，想更多地回味这个经历。）所以我重重地、不耐烦地叫了一声“哼，别搞”，然后继续睡。虽然没睁开眼，不过从传来的哭声听，小侄女被吓哭了。 此时我推测是下午两三点，因为我上一次清醒的时候是12:46，我看了手机。再睡了那一觉起来，刚刚下午六点；可是最后这一次倒没有做梦。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"个人","slug":"个人","permalink":"https://blog.mottomo.moe/tags/%E4%B8%AA%E4%BA%BA/"}]},{"title":"准备回老家了","slug":"zh/2016-02-05-Ready-for-the-Trip-to-Hometown","date":"2016-02-04T20:10:00.000Z","updated":"2020-03-30T22:34:35.433Z","comments":true,"path":"categories/Misc/zh/2016-02-05-Ready-for-the-Trip-to-Hometown/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-02-05-Ready-for-the-Trip-to-Hometown/","excerpt":"","text":"博主今天早上八点左右就要出发回老家了，到那边很可能就没有网用了。所以晚上连夜奋战，将堆积的博文速速码完，发布。 不过在没有网络的情况下，WebStorm（11.0 之后强制通过服务器获得临时授权，序列号破解是不可能的啦，当然还有其他的如 CLion 和 PhpStorm，不提供社区版/教育版的那些）就没辙了，到时如果能躲过走亲戚的话看看能不能反向出什么东西。 在此向我可能没有机会道春节的各位提前说一声：祝各位春节吉祥如意！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof 和 GLantern 更新：抗锯齿与非正常变换","slug":"zh/2016-02-01-Bulletproof-Update","date":"2016-01-31T18:00:00.000Z","updated":"2020-03-30T22:34:35.433Z","comments":true,"path":"categories/Tech/Coding/zh/2016-02-01-Bulletproof-Update/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2016-02-01-Bulletproof-Update/","excerpt":"GLantern 的绘制方式更新了！获得了技能：抗锯齿（一般绘制）、绘制效率提高、抗溢出变换。Bulletproof 作为直接继承项目，也得到了特性的更新。 另外，GLantern 的 live preview 也上线了（呃，之前忘了）。请戳：Bulletproof/GLantern。","text":"GLantern 的绘制方式更新了！获得了技能：抗锯齿（一般绘制）、绘制效率提高、抗溢出变换。Bulletproof 作为直接继承项目，也得到了特性的更新。 另外，GLantern 的 live preview 也上线了（呃，之前忘了）。请戳：Bulletproof/GLantern。 首先说一下原来是怎么画的： DisplayObject.prototype.render = function (renderer, output) { this.__render(renderer, this._rawTarget); this.__processFilters(renderer, this._rawTarget, this._bufferedTarget); RenderHelper.copyTargetContent(renderer, this._bufferedTarget, output); }; DisplayObjectContainer.prototype.render = function (renderer, output) { super.render(renderer, this._containerTarget); for (var i = 0; i &lt; this._children.length; ++i) { this._children[i].render(renderer, this._containerTarget); } RenderHelper.copyTargetContent(renderer, this._containerTarget, output); }; 这导致了什么问题呢？ 大量借助 WebGLFramebuffer 的拷贝（通过 shader 拷贝），每个元素绘制都会有1到2次拷贝操作。 WebGLFramebuffer 是没有抗锯齿的，所以所有的图元绘制都带有锯齿。 一个潜在的问题：假设舞台大小为 100×100，元素A大小为 50×50，位于位置 (-200, -200) 处，其逻辑父B位于位置 (200, 200) 处，则A就画不出来了。 对于问题3的稍详细的解释：因为第一次变换的时候边界 (-200,-200,-150,-150) 就已经超出了视场 (0,0,100,100) 的范围，所以做 visiblility test 的时候会失败而不会绘制；但是，稍微计算一下的话就会发现A的实际位置在 (0,0,50,50)，应该被画出来。这是一个刁钻的情况，但是可以发生。 现在的绘制流程就简单多了，直接向屏幕（相当于 gl.bindBuffer(gl.FRAMEBUFFER, null)）绘制。对原先的 render() 方法，干脆去掉了 outputTarget 这个冗余的参数，因为 WebGLRenderer 已经有了一个公开属性 currentTarget，同时出现两套同样意义的字段是不合适的。抽象调用： render(renderer:WebGLRenderer):void { if (this.visible &amp;&amp; this.alpha &gt; 0) { this.__preprocess(renderer); this.__render(renderer); this.__postprocess(renderer); } } 具体实现（这里取进行了最底层绘制操作的 SolidStrokeRenderer 为例子）： render(renderer:WebGLRenderer):void { if (this._vertices.length &gt; 0) { var target = renderer.currentRenderTarget; RenderHelper.renderPrimitives2(renderer, target, this._vertexBuffer, this._colorBuffer, this._indexBuffer, false, target.isRoot, false); } } 虽然在 WebGL 1.0 中，FBO（frame buffer object）不支持抗锯齿，但是屏幕渲染器是支持的。对于直接绘制到屏幕上的元素（例如不带滤镜的 Shape）就可以用上抗锯齿功能了。同时，拷贝操作的大量减少提高了绘制效率，现在小圆脸即使不缓存 Graphics 结果也可以稳定在60帧了（测试基准：NW.js v0.12.3 stable）。 请注意，这里为了能直接将最终位置反映到屏幕上，新建了一个 shader：Primitive2Shader。在片元部分和 PrimitiveShader 是一样的，简单颜色赋值而已。但是在顶点处理上就复杂一点了： precision mediump float; attribute vec3 aVertexPosition; attribute vec4 aVertexColor; uniform mat4 uProjectionMatrix; uniform mat4 uTransformMatrix; uniform vec2 uOriginalSize; uniform vec2 uFitSize; uniform bool uFlipX; uniform bool uFlipY; varying vec4 vVertexColor; void main() { vec3 newVertexPostion = aVertexPosition; if (uFlipX) { newVertexPostion.x = uOriginalSize.x - newVertexPostion.x; } if (uFlipY) { newVertexPostion.y = uOriginalSize.y - newVertexPostion.y; } gl_Position = uProjectionMatrix * uTransformMatrix * vec4(newVertexPostion.xyz, 1.0); vVertexColor = aVertexColor; } 第一步是要支持 uTransformMatrix 的计算，这个计算由 DisplayObject.__updateTransform() 完成，在必要的时候触发计算。最终的值会被传入 shader。 第二步就是其他处理。有没有想过，为什么会出现 X 轴和 Y 轴的翻转？答案是，OpenGL（数学）坐标系和 Flash（GDI）坐标系关于 Y 轴是相反的。为了正确地一次画出图形，需要在 shader 中立即执行 Y 轴翻转。而翻转的轴是 (0,H)（H 是图元高度），因此还需要一个额外参数，图元大小（uOriginalSize），指示翻转轴位置。 解决了这些之后，就是代码兼容性调整了，耐心+细心将编译错误和运行错误解决了，三个测试样例通过，收工。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"杂事","slug":"zh/2016-01-30-Misc","date":"2016-01-30T15:45:00.000Z","updated":"2020-03-30T22:34:35.433Z","comments":true,"path":"categories/Misc/zh/2016-01-30-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-01-30-Misc/","excerpt":"“破事水”","text":"“破事水” 其一 晚上买完衣服往家里走的时候，路上和一对女子擦肩而过。我闻到了离我近的那位的发香。然而父母就在身后呢，我也不能回头、侧脸看——就算是自己一人，我也不会那么做，太失礼了。 这味道我说不上是什么，但是我很确定我小时候在这么一间房间里呆过，而且我也挺喜欢这个味道的。不是香味，只能被描述为一种合成的气味。 生命中又多了一个过客。 其二 老妈买了一个新相机，附送了相机带。关于穿的方法，不知道的同学可以看看这里。 我以前没穿过，弄了半天，试验了数种组合都没达到“顺畅地”穿过（不打结、不扭曲）的水平。于是我就开始分析： 带子有正反两面，整体有内外两面，分为状态A（正）和状态B（反）、状态1（内）和状态2（外）； 由于挂住所必需的铁环的结构限制，带子必须是从外部往内部，斜向上穿过； 在我之前的试验中，是从外侧穿入固定扣的； 综上，目标是从状态B1开始，经过若干翻转位置，到达状态A2。 然后我就抓狂了：这个铁环进行了一次B→A的翻转，但是状态一直是A1，没有1→2的翻转装置。在顺畅的情况下，达不到状态A2；为了达到A2，必须要经过一次扭曲。 我打算将这个作为最终答案，老妈看不下去了，抓起相机带，从固定扣内侧穿了过去！于是问题变成了B1→A1，这是一个相当容易的问题。 这不是开玩笑吗！假设就错了！这相当于三门问题中，你选了三扇门都是山羊，而主持人突然打开了第四扇门一样。 在深刻反思的同时，我暗暗道：如果是我，我就取消这么反人类的设计…… 其三 生产力发展，导致礼仪的形式与实质进一步分开，不必太抱团维持关系了。这是老爸提的一个自称“了解九零后社会行为”一直说的九零后员工“难管”（不和上级搞好关系、喜欢到处跳），不过管理一个“大咖”就可以治住他们，他们自己靠过去的原因。有时间再展开说。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"SharpDX 的 Matrix.PerspectiveFov* 问题","slug":"zh/2016-01-24-About-MatrixPerspectiveFov","date":"2016-01-24T14:43:00.000Z","updated":"2020-03-30T22:34:35.433Z","comments":true,"path":"categories/Tech/Coding/zh/2016-01-24-About-MatrixPerspectiveFov/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2016-01-24-About-MatrixPerspectiveFov/","excerpt":"我之前曾经暗笑过，毕设我的题目是一个 Direct3D 的东西，我觉得一个多月就可以搞定。然而，实际上手之后，世界又欺骗了我。今天我讲一下我是如何被几个连锁的问题坑，最终发现并解决了的。","text":"我之前曾经暗笑过，毕设我的题目是一个 Direct3D 的东西，我觉得一个多月就可以搞定。然而，实际上手之后，世界又欺骗了我。今天我讲一下我是如何被几个连锁的问题坑，最终发现并解决了的。 首先，按照项目要求、我的喜好和能力范围，我选择的是 C#/SharpDX 的组合，没有选择 C++ 也没有选择 XNA。不过原理是相通的，所以 DirectX 的教程在大致了解了 SharpDX 的封装风格后还是能用的。我采用的是这个教程的逐步深入方式（学习嘛），而不是 MiniCube 示例的直接上顶点数组+shader的方式。 我跳过了 Lesson 4 ，虽然知道这方式很蛋疼（用多了 WebGL 习惯了 OpenGL 的思路），特别是顶点格式（SetFVF()）。不过看起来后期会用到 VertexDeclaration，好理解多了，一步一步来吧。然而转到 Lesson 5 的时候就出问题了，我的屏幕上什么都没出现。 我是进行了初步的代码理解后就开始设计以后的渲染流程了（分别用 C++ 和 C# 写了简单的架构），所以逻辑并没有教程里的渲染单一三角形那么直观。我想，设备创建之后，也就是初始化顶点数据-写入-绘制而已啊，不到20行的代码怎么就出问题了呢？此时我是比较整体逻辑的，而不是一句句照搬；逻辑上等价就是正确。折腾了一晚上没发现是什么导致的。于是决定返回尝试和教程亲和度最高的 C++。可是，C++ 这边也是什么都出不来。是我的 DirectX 问题吗？新建一个代码文件，粘贴教程内容，编译（CLion 使用 CMake，对构建选项的控制比 Visual Studio 方便得多，增加一个 target，只编译这个就行），运行，嘿，不是 DX 的问题。那么是什么呢？抓狂后迫不得已，一行行对比和教程中的区别。明明消隐（culling）都是关了的。最后发现，我启用了模板缓冲： presentationParameters.EnableAutoDepthStencil = TRUE; 注释掉（默认 ZeroMemory() 了所以是 FALSE）就好了。然而并不知道为什么会出错……或者我是没有去看模板函数和模板判定…… C++ 那边搞定，终于回到 C# 这边了。按照 C++ 那边调好，还是没有绘制。 偶然之间，发现如果注释掉设置变换矩阵（视图、投影、世界）的语句，依稀能看到点三角形的样子——绘制的范围在 XOY 平面 [-3, 3] 范围，所以能看部分并分辨出来。 最终，将问题发生点锁定在数行代码之内： Matrix matrix; matrix = Matrix.LookAtLH(new Vector3(0, 0, 10), new Vector3(0, 0, 0), new Vector3(0, 1, 0)); target.Device.SetTransform(TransformState.View, matrix); var size = _manager.Control.Size; // matrix = Matrix.OrthoLH(size.Width, size.Height, -100, 100); matrix = Matrix.PerspectiveFovLH(MathUtil.DegreesToRadians(45), (float)size.Width / size.Height, 0f, 100f); target.Device.SetTransform(TransformState.Projection, matrix); target.Device.SetTransform(TransformState.World, Matrix.Identity); 看到这里，由于 Control.Size 是不会出错的，所以不得不怀疑是 Matrix 的问题，怀疑一个流行库的底层函数的实现有问题！ 然后发现，视图和投影共同起作用，无法分离。如果使用正交投影（如注释了的代码）而不是透视投影，能正常显示。 设断点单步调试，发现投影矩阵居然是这样的（宽度 800px，高度 600px）： [NaN 0 0 0 0 NaN 0 0 NaN NaN 1 1 0 0 0 0] 这个矩阵在同样的条件下，C++ 那边的值是正常的： [1.72751749 0 0 0 0 2.41421342 0 0 0 0 1 1 0 0 -0 1] 其他两个矩阵第一眼看上去正常。嗯，如果给投影设置一个无效的矩阵，自然就画不出东西了。那么为什么会出错呢？ 首先来看看透视投影矩阵。以下的矩阵以 Direct3D、左手系的为准，OpenGL 的和/或右手系会有所不同。 第一种形式是这样的： 关键参数是视场（field of view，FOV，FOV=2θ）、宽高比（aspect ratio）、近剪裁面和远剪裁面距离4个参数。 第二种形式是这样的： 关键参数是矩形的左右上下（LRTB）和远近剪裁面距离6个参数。不过一般投影面是居中的（原点在正中），所以一般会取 L=-R=0.5W、T=-B=0.5H 的值。 然后我们看看 SharpDX 对 Matrix.PerspectiveFovLH() 的实现。我将关键代码列出来。 public static void PerspectiveFovLH(float fov, float aspect, float znear, float zfar, out Matrix result) { float yScale = (float)(1.0 / Math.Tan(fov * 0.5f)); float xScale = yScale / aspect; float halfWidth = znear / xScale; float halfHeight = znear / yScale; PerspectiveOffCenterLH(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out result); } public static void PerspectiveOffCenterLH(float left, float right, float bottom, float top, float znear, float zfar, out Matrix result) { float zRange = zfar / (zfar - znear); result = new Matrix(); result.M11 = 2.0f * znear / (right - left); result.M22 = 2.0f * znear / (top - bottom); result.M31 = (left + right) / (left - right); result.M32 = (top + bottom) / (bottom - top); result.M33 = zRange; result.M34 = 1.0f; result.M43 = -znear * zRange; } 可以看到，Matrix.PerspectiveFovLH() 用 FOV、宽高比和近剪裁面距离确定了一个四棱锥的底面（矩形），以此作为目标投影矩形的大小，然后传给 Matrix.PerspectiveOffCenterLH() 计算矩阵。然后注意到我传的参数，近剪裁面距离为零——意味着直接计算的话，目标投影矩形是一个零宽度零高度的矩形！然后接下来就是被零除的问题，返回的自然是 NaN。 看来我怀疑对了。 那么近剪裁面距离为0是否是一个可取的值呢？有意义，可以取到。考虑到我们绘制的实际上是一个平截头体（frustum）所交的内容，其极限是一个四棱锥，意义就是从观察点到远剪裁面中由 FOV 和宽高比确定的矩形所形成的四棱锥中的所有内容都会被考虑。谁说“眼前”一定要大于某个值呢？更重要的是，Direct3D 对应的函数（D3DXMatrixPerspectiveFovLH()）很好地处理了0值——同样的参数，在 C++/DirectX 中能正确渲染。寻找一下理论基础，那就是——在矩阵计算形式一中，根本不需要计算宽高。形式一在给定了 FOV 和宽高比时，比形式二更通用；形式二向形式一的转换必须在近剪裁面距离不为零时才能以成立。也就是说，SharpDX 的开发者可能并没有测试这种特殊情况，其他用 SharpDX 写各种 DirectX 程序的人也至少是规避了这个问题（可能是效率影响？），而不巧我撞上了。 所以最后，提出了一个 issue，紧接着提了一个 pull request。PR 的提交自动构建失败是强签名的问题——不过代码本身没错，更改也不影响其他文件——人工查看日志的话应该会明白的。 有一个很有意思的现象，C++ 的 IDE 我选择的是 CLion，编译基于 Cygwin。Direct3D 应用程序的绘制逻辑一般是空闲时渲染的： MSG msg; while (TRUE) { if (PeekMessage(&amp;msg, hWnd, 0, 0, PM_REMOVE)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } else { // Idle Render(); } } 在这种逻辑下，测试空白的渲染（只有 Clear()），在我的显卡上如果不进行垂直同步（也就是立即渲染），那么原生 D3D 的帧率在2800左右，而 SharpDX 的“改良版”循环（RenderLoop）帧率在6200左右。这刷新了我的认知——而且是在图形渲染上。 我以为是 Cygwin 的 API 包装层引起的效率损失，然后费了好大劲换到 MinGW 上（主要是 CLion 对 MinGW 版本和环境要求很严格），还是差不多的数值。 难道是 SharpDX 的黑科技？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"DirectX","slug":"DirectX","permalink":"https://blog.mottomo.moe/tags/DirectX/"},{"name":"SharpDX","slug":"SharpDX","permalink":"https://blog.mottomo.moe/tags/SharpDX/"}]},{"title":"翻译歌词的四个月","slug":"zh/2016-01-16-Four-Months-on-Translating","date":"2016-01-16T07:40:00.000Z","updated":"2020-03-30T22:34:35.432Z","comments":true,"path":"categories/Misc/Records/zh/2016-01-16-Four-Months-on-Translating/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2016-01-16-Four-Months-on-Translating/","excerpt":"本来题目是“翻译歌词的三个半月”的，结果因为本文内容实在是长而且杂，所以拖来拖去半个多月才完稿，从1月16日到2月5日，所以标题就成了“四个月”了。在这半个月内，又有四篇翻译和一个时间轴过审，于是并入原来的表中。 从去年9月开始尝试翻译云音乐的歌词，到现在，已经过去了三个半月。在这段时间，感谢云音乐任劳任怨地做我的试验场，以及碰到的各位。翻译从开始时的生硬、错漏百出，到现在的用词和阅读理解都有了质和速的提高，众位的支持是不可或缺的。","text":"本来题目是“翻译歌词的三个半月”的，结果因为本文内容实在是长而且杂，所以拖来拖去半个多月才完稿，从1月16日到2月5日，所以标题就成了“四个月”了。在这半个月内，又有四篇翻译和一个时间轴过审，于是并入原来的表中。 从去年9月开始尝试翻译云音乐的歌词，到现在，已经过去了三个半月。在这段时间，感谢云音乐任劳任怨地做我的试验场，以及碰到的各位。翻译从开始时的生硬、错漏百出，到现在的用词和阅读理解都有了质和速的提高，众位的支持是不可或缺的。 一、翻译列表和时间轴列表链接：翻译歌单和时间轴歌单。 首先先上到此博文开始写的时候的翻译过审列表（按照审核通过时间顺序，从先到后）： # 歌曲 我的译名 备注 01 Truly 动画《绝对防卫利维坦》ED 02 a little love song 游戏《恋爱选举巧克力》住吉千里线ED 03 Girls, Be Ambitious. 动画《空之音》OP 04 伤つけられるより伤つける方が痛いよ、なんて… 伤害比被伤害更痛苦，为什么呢…… 游戏《恋爱选举巧克力》木场美冬线ED 05 Love you… 游戏《Lovely Quest》ED 06 Witeria 游戏《紫影的索纳尼尔：美丽回忆》ED 07 Shape My Story 动画《特例措置团体斯特拉女学院中等部C3社》OP 08 三つ叶のクローバー 三片叶子的幸运草 游戏《恋爱选举巧克力》青海衣更线ED 09 星待ちテアトル 有星星等待的剧场 游戏《恋爱中的她的笨拙舞台》千代田百花线ED 10 Touch my heart! 游戏《恋爱中的她的笨拙舞台》十川真优线ED 11 いちゃいちゃプリンセス! 粘人小公主！ 游戏《粘人公主！ -和大小姐打情骂俏H的日常-》（自译名）OP 12 RED love(我妻由乃のテーマ～抹殺愛～) 动画《未来日记》我妻由乃角色歌2 13 ドララドラ~畑の唄~ 呼拉呼拉 -耕田歌- 企划“音乐少女”竜王更纱主打歌 14 駆逐くちくクチクくちククチくくチク駆逐艦 kuchiku×6驱逐舰 舰娘鬼畜曲另外，“鬼畜”一词是「きちく」（kichiku） 15 女の子って 关于女孩子 动画《只有神知道的世界》角色歌——桂木桂马自黑曲 16 Chocolate Tiara 游戏《偶像大师 灰姑娘女孩》三村加奈子主打歌 17 カラフル Diary 缤纷的日记 游戏《your diary》ED 18 MeltyMoment 游戏《Melty Moment》OP 19 キスキラリ 闪亮之吻 游戏《向日葵的教会与长夏假期》胧白金刚石线ED 20 ウサテイ 兔子帝 东方鬼畜曲，因幡帝 21 みんなのきもち 大家的心情 游戏《偶像大师 灰姑娘女孩》市原仁奈主打歌 22 さくらいろチェリッシュ 樱花色的珍藏 动画《黄金拼图》07 IN 23 月光Love sick 动画《笨蛋、测验、召唤兽》角色歌——吉井明久&amp;姬路瑞希对唱曲 24 Hotel Moonside 游戏《偶像大师 灰姑娘女孩》饭田友子主打歌 25 オオカミとピアノ 大灰狼与钢琴 动画《Wake Up, Girls!》七海菜菜美角色歌 26 2nd SIDE 游戏《偶像大师 灰姑娘女孩》神谷奈绪主打歌 27 コトバラ 言语蔷薇 游戏《向日葵的教会与长夏假期》鹭月月华线ED 28 North method 动画《天体的方式》OP专辑C/W曲 29 ゆーけーるよーふーたりでー 两个人一起走下去 游戏《永不落幕的前奏诗》OP 30 Twilight Sky 游戏《偶像大师 灰姑娘女孩》多田李衣菜主打歌 31 アップルパイ・プリンセス 苹果派·公主 游戏《偶像大师 灰姑娘女孩》十时爱梨主打歌 32 青空StartingLine 游戏《恋爱选举巧克力》东云皐月线ED 33 きみのいろ おしえて 请将你的颜色告诉我 游戏《恋爱选举巧克力》森下未散线ED 34 お散歩カメラ 散步与照相机 游戏《偶像大师 灰姑娘女孩》高森蓝子主打歌 35 シンクロマニカ (Synchro Manica) 动画《伽利略少女》OP 36 希望の前で待ち合わせ 在希望的前方再会吧 游戏《向日葵的教会与长夏假期》夏咲咏线ED 37 Romantic Now ~For Uzuki rearranged MIX~ 曲目38的岛村卯月翻唱版 38 Romantic Now 游戏《偶像大师 灰姑娘女孩》赤城米莉亚主打歌 39 Angel Breeze 游戏《偶像大师 灰姑娘女孩》川岛瑞树主打歌 40 せいぎのキョッピー!! 正义的 cupie! 动画《摇曳百合》第三季岁纳京子角色歌(c/w) 41 PEACE &amp; LUCK 动画《武装神姬》Lene 角色歌 42 シュバッとNo.1 “嘿哈”和 No.1 动画《干物妹！小埋》希尔芬角色歌(c/w) 43 クローバー (Clover) 游戏《your diary》OP 上面的歌词有一部分是我提供了时间轴的，其他是由其他人提供歌词的。 提供时间轴而没去翻译的（按照审核通过时间顺序，从先到后）： # 歌曲 我的译名 备注 01 I’m in love 游戏《恋爱中的她的笨拙舞台》爱丽丝线ED 02 恋はインスピ 恋爱是灵感之源 游戏《恋爱中的她的笨拙舞台》七濑千奈线ED 03 私だけの空 只属于我的天空 游戏《天色Islenauts》天雾夕音线ED 04 Age of Aggression 游戏《上古卷轴5：天际》可选曲 二、翻译工作2.1 原定的主要内容一切的开始，是《绝对防卫利维坦》。当时为了填补看番的空白，在B站正版完结动画中找到了这个——而且制作公司还是 GONZO！看了之后，正片（作画、剧本）没发现有什么闪光点，倒是被ED洗脑了。然后我想起了云音乐，上面的这首《Truly》居然没有翻译！这番很冷我知道，但是作为一个刚看完的番的洗脑ED，还是想着给它加上翻译。于是注册了云音乐的账号（之前都是不注册，仅利用cookie保存播放列表，听LL歌单），用看番许久的听力语感+在线翻译+在线语法书，硬是将翻译弄出来，提交了。时至今日，看到这个翻译的生硬用词和混乱的句子，我还是浑身发冷，现已加入黑历史。 经过这一次翻译练习，我发现，哎，我居然能做简单的翻译工作了！这燃起了我的激情，社区化的激情。于是下一首选定的就是《空之音》的ED《Girls, Be Ambitious.》。为什么不是OP呢？因为OP人气较高（Kalafina 组合演唱，自然受到很大的关注），翻译早有了。这次的翻译比上一次轻松一些，第一是因为通过初次阅读我越级接触了一些日语语法，二是《空之音》的澄空&amp;华盟版在ED处是附有字幕的，虽然只是 short version 的字幕（只有第一个韵节的翻译），但也帮大忙了。于是我以澄空&amp;华盟的版本为基础开始啃，又查了许多东西，觉得理解了之后写出来。这也是我第一次采用自校对的方式提高质量的翻译，初稿后多次润色和订正，最终形成了现在的版本。这个翻译总体来说我是满意的，只不过操作失误有一个句子上传时覆盖了之后的，以及「新しくて懐かしい世界の音」我一直没想明白怎么准确表达…… 接下来的三首就是兴趣的结果了。我刚刚通了中文版《恋爱选举巧克力》的千里线，觉得线路ED还是相当不错的，于是来找，顺带也听听其他的角色线ED，最终就选择了在游戏中比较喜欢的两个角色（而且ED也比较好听的）千里和美冬的歌开始翻译。这次的翻译素材和前两次不同，是个人歌曲，和角色个人的经历密切相关。可以说，这些歌曲就是角色内心的反映，在看着歌词听歌的时候也在走着角色的心路历程。为了准确翻译，就要求对角色和其经历有较深的了解和理解。于是在翻译之前我找了美冬的资料（当时还没玩美冬线），毕竟连题目的「伤つけられるより伤つける方が痛いよ」都乍一看让人摸不着头脑，里面的那些直接和线路剧情相关的句子，例如「『伤つけるより、伤つきたい』そんなの最低の言い訳、裏切ったのは私の心との誓い」，我根本不知道想表达什么，直译或许就表达不出角色的心境了。千里就好办一点了，因为这是强制线路，我已经通了，也从千里的视角看到了整个游戏中的事件过程，因此心情拿捏起来准确一些。（嗯，但是由于望文生义，千里的第一句就翻译错了。）同时这也是我第一次做日文的时间轴——对于一个只有五十音和简单词汇的程度的知识的人，就算是一次听力练习吧。后面那首《Lovely Quest》的ED则是我非常喜欢的曲子，HOOKSOFT 的这一纯爱作在去年几乎就是俘获了我的心，特别是这首每条线结局的高潮部分必不可少的暖心歌。这段时间我看到了许多丘比QB的翻译，其中给我触动较大的就是某首（忘了）的形式严整性。所以在这一首的翻译文字中，可以看到我是费了很多时间去对文字进行“修剪”，以保持工整的。 接下来的几首的来源，都是我在私人FM中听到后觉得不错，放到备用歌单中，然后某天再选一些想翻译的做翻译。在《Witeria》中，我对虚词、语气词还是没有准确区分，所以许多句子还是莫名其妙的。 《Shape My Story》是我碰到的第一个觉得十分困难的翻译。因为全曲的语法（如「上げるんだ」）和我之前见过的很不同（而且我没有系统地学语法），同时歌词的逻辑也很模糊。不过经过连续几天的攻关，有几次都想放弃，最后暗示自己“开始写翻译稿就要负责认真地做完”，所以还是啃下来了。 被整得着实累了，休息几天之后想着其实衣更这妹子也是不错的，把她的线路ED也做了吧。正好，在千里线中其实也展现了不少她的个性和生活，做起来还是轻松一些的。 然后开始推《恋爱中的她的笨拙舞台》的生肉（第二次尝试推生肉，第一次是《Melty Moment》，只不过 HOOKSOFT 全篇懒得用汉字让我崩溃了，弃坑），乘兴将四位主角的线路ED歌词搜索补上了，同时选了幼驯染和编曲好一点的两位的歌做了翻译。我的风格就是翻译一定要体现角色个性，所以在百花的歌中，中间一段接近独白的歌词的切分，在翻译中也有着同样的形式。同时，照顾到游戏的“话剧表演”这个主题，两人的歌中如果有这方面的意思就迎合主题，例如真优的「始まるのかな」被翻译成“好戏能开场吗”而不是普通的“（关系）能开始吗”。 《いちゃいちゃプリンセス!》只是作为备用翻译项，后来觉得既然都“立项”了就做翻译吧。在为了这篇文章查找其出处时才知道背后是多么邪恶的游戏（非主流会社，纯拔作）。 种田歌也是一个难点，因为我在翻译的时候并不确定这首歌要表达什么，“种田”主题和歌词、编曲的差异很大，我一直怀疑自己的理解够不够准确。（后来的后来我查了更纱的设定，总算解开了这个结，不过那是后话。）而且在这一时期，我还在用着尽量相近的汉语拟声词来还原歌曲中日语的拟声词。 《RED love》的难点在还原由乃的病娇语气和果敢（甚至是冷酷）的心理，这首歌的用语的冲击性比之前都强，要将冲击性表现出来。 舰娘的鬼畜曲主要就是角色实在很多，而且每个角色的用语都要符合其性格和语气，还要遵循原有歌词。例如「白雪です」和「綾波と申します」，都是自我介绍，但是前者是普通的语气，后者则十分正式、彬彬有礼，所以也采取了不同的翻译方式“这里是白雪”（嗯，舰娘的通信是通过无线电不是吗）和“本舰是綾波”（本人，人→舰）。「できれば全員出撃ですね」中没有采用“全员”，而是将“所有人”→“所有舰”。 抽时间翻译的《女の子って》则注重还原神大人的睿智卖萌，还有两段歌词的工整对仗。歌曲中唱的明显是口嫌体正直，所以高潮部分本来的中性词都被翻译成了意义不那么好的词（「かかっちゃった」“迷了心窍”，「染まっちゃった」“浇了一身”），表现的就是赌气。 到了一个很大的转折点，《Chocolate Tiara》。这首歌也是私人FM偶然推荐，然后我偶然地选中做了翻译的。这首歌的翻译并不难，主要就是这位吃货三句不离美食，要将这些食物的名字完美地嵌在句子里。不过对于这首歌，评论给我造成的影响远大于给这首歌做翻译的，这留到评论部分讲。之后所有的爱马仕歌曲，都是这首歌挖下的坑。做它们的翻译原因很简单，一是爱马仕的，二曲子好听，就这么简单。开始的时候还专挑灰姑娘女孩的角色主打歌分支，现在资源快枯竭了准备要拓展领域了。这部分将会在这一节最后单列出来讲。 《カラフル Diary》的翻译开工原因是我开始推《your diary》，而这个gal的甜度实在是要让人脱水了。因此当私人FM一推荐的时候，我就立即将其加入翻译列表。 《MeltyMoment》的选择原因也很简单，毕竟是我刷（对，刷，不光是文字，人设都看不下去了）过的gal，而且歌词的上传者就是QB大神。算是一点点虚荣心吧。 《キスキラリ》的出现也是一记惊雷。较早的时候我因为觉得好听，就收藏了同专辑的《コトバラ》。但是当私人FM中响起了《キスキラリ》的高潮的时候，我瞬间就记起我似乎在哪里听到过这十分特殊的四度音阶的编曲，我的确是听过而且那给我留下了深刻的印象，就像是直接印在了脑海中。当这个奇迹出现的时候，怎么能不将其收藏呢？于是这首歌被给予了特殊的位置——进入了“我喜爱的歌曲”列表，而且第一时间准备翻译。不过，这首歌的歌词应该是为了方便人唱，全写成了平假名，所以一向凭借着汉字，而且词汇量不够的我就抓瞎了。不过经过努力，从分词到查询对应的汉字写法和意思，歌词像拼图一样被拼了起来，由此才能正常地翻译。而这首歌的旋律、编曲和用词本来就有浓重的雍容华贵之感（查了资料，金刚石的设定就是大小姐），因此在翻译中也注重句子工整、堆砌辞藻和段落间的对称。总之，这个全平假名的歌词着实带来了不小的麻烦。另外，两首歌的歌名都是合成的——「キス」（亲吻）+「キラリ」（亮闪闪的样子），以及「言葉」（ことば，言语）+「バラ」（蔷薇），不知道取名的人是卖了什么萌。 接下来的是《ウサテイ》，难度在叙述时语速较快，做时间轴时的分割调了几次。还有这一身市井气的文本，要恰当地翻译。初稿还是比较粗野的，结果就被驳回了： 分享单曲：你上传的《ウサテイ》的翻译由于歌词翻译有错误未通过审核，很遗憾不能获得积分。 其实没有错误，我估计可能是类似“你妹的”这样的字眼导致的吧。在二稿中设了一个很高的用语文明线，就顺利通过了。 然后是我个人认为的翻译水平巅峰，《さくらいろのチェリッシュ》。这首歌是《黄金拼图》的IN，就是爱丽丝学唱歌那一话班级合唱的歌曲。说起来有趣，在确认具体的话数时，我立即就想到了第7话——一点进去，bingo。呀，难道这给我印象这么深吗？这首歌本身带有浓浓的骊歌味，这让我想起了《送别》这个明珠般的作品。这大大地增加了这首歌的分量，或曰难驾驭程度。如果翻译上佳，那是正常事；但稍有差池，就会落入万丈深渊。这次的翻译初稿翻译了意思，然后据此整理出了润色稿v1，接着继续润色了几次，每次随着歌琢磨词语和节奏对不对。成品就是现在大家看到的这个版本。（小声说一句：昨天发现居然还有一个错误……啊！） 《月光Love sick》是一首优美的高灵压曲子，相信知道动画的人懂瑞希无辜的声调背后隐藏着什么吧。曲子自身难度不大。 《オオカミとピアノ》是 WUG 中久海菜菜美的角色歌。这首歌我做的时候感觉难度很大，在单子里晾了两个星期。难度主要出现在三个地方：首尾音节配合的意大利语+日语、全曲中“伴唱”的歌词与主唱歌词的衔接，以及这首歌的特色——中二宣言。由于我还没看过宽叔的这一遗作，在没见过菜菜美的表现时必须要查资料弄清楚她的经历和特征（时间有限，不可能将TV+剧场版全刷完对不），才能理解歌曲中相关的信息，例如曲名（菜菜美代表动物为狼，担任键盘手）。最后看着翻到一半的稿子，抱着“啃也要啃完”的决心磨完了初稿。之后就是调整和润色，精心选词、剪裁句子，形成了终稿。 金刚石的ED翻译被语句变换（「わたしへのあなたからの」→「あなたへのわたしからの」）坑了，《コトバラ》作为消遣和对前者失误的补救，做了翻译。这首歌的歌词也是极为工整（而且通篇平假名），不过我并没有像前面那样也配上完全工整的汉语。质量还算可以，唯一的遗憾是翻译的时候脑洞大开，突然想到“覆水难收”于是就有了一句“说出去的话就像泼出去的水”这样不符合整体气氛的翻译，而且直到上传的时候也没觉得有什么问题…… 同一个时间抽到的《North method》，刚好《天体的方式》OP专辑当年我整个听过，一看这首还没翻译（尽管由于其c/w曲的地位，比起OP人气冷了许多），就有了翻译的念头。其实这首歌翻译还是挺快的，一边听着一边看着（动画留下的毛病，对声音刺激依赖很大）很自然地就写好的大部分初稿。学了几个新词汇之后补全，整体润色，上传。 接下来是minori社的新作OP。这个会社倒是没什么好感（因为作品特征为巨乳，而我是坚定的贫乳捍卫者），歌还不错。也是抱着“刷小怪”的心理就做了翻译。 之后《青空StartingLine》和《きみのいろ おしえて》的翻译居然是来自衣更ED中的评论（笑）。我会不定期浏览自己翻译的歌的评论，12月的时候发现了新评论，回复了一下，结果就被@遠野冬子拜托翻译了另外两首。具体的对话还被保留着，去衣更那儿看就可以。Yeah!第一次有一种“接到活了”的感觉。我前面好像说过，恋选中五个主角，皐月和未散我是无感的，所以当时没有做。这两首，扪心自问是属于做得比较草率的，也没有很好地检查和润色，总觉得没有动力而干巴巴的。 我现在常用的头像（如果你阅读时我的博客头像也没变的话，参见博客的头像）——星月——的出处，《伽利略少女》，其OP为《シンクロマニカ》。这是一首我从来没能弄懂在讲什么的歌，歌名不明所以，配合的OP动画也很意识流。我是抱着崇敬的心情来做翻译的，只不过，这歌词连理解起来都困难（老美看道德经的感觉），更别提翻译得顺畅了。啃！最可惜的是，上传翻译后，翻译错位了，一整段往前移了一句，不知是哪个环节造成的。在这个节骨眼上犯错令人悔恨终身。 然后挑了向日葵教会ED集中最后一首我觉得好听的，也是作为主线（咏线）的ED《希望の前で待ち合わせ》。查阅资料得知，这首曲子和另外两首我翻的在感情基调上迥异，是因为这条线是一条催泪线。这首歌是读着歌词翻的，然后听几遍校对，算是语言能力有了一点点的提高（或者……这首歌用词和语法太简单）。 2.2 Round 2接下来讲的是在本文决定要写（1月16日）之后的翻译歌曲。 《摇曳百合》真·主角，京子的喧闹角色歌《せいぎのキョッピー!!》的翻译是在写申请材料时为了减压而做的。当时整个人为了申请都要崩溃了。京子的思维是很跳跃的，歌词内容也是很跳跃的，典型的前一句和后一句连起来但是很容易脑补中间部分的感觉。于是为了翻译成正常的叙述语言，翻译的内容长度比歌词长……（别看字符数，去理解两种语言字面上的内容。） 和《PEACE &amp; LUCK》的相识是一次偶然，又是私人FM推荐的歌曲。前奏响起来的时候我就被惊艳到了，然后一看这不就是神姬么。对，我看过动画，也知道本质上就是塑料小人（和高达一个性质，对不起揭露了赤裸裸的现实）。这么好的歌曲没人调轴也没人翻译，那自然就我上啦！后来我看了一下四位的角色歌，也只有这一首是我喜欢的。毫不掩饰地说，这首歌除了甜就是甜，让人都要融化了，这就是那种我会大喊“萌え”的歌啊！ 希尔芬的自夸曲《シュバッとNo.1》，我的翻译风格就和@-南大鸟-对《T・S・F in にっぽん!》的翻译的很不一样。这位仁兄应该也是懂的（毕竟做了很多新番OP/ED翻译，而且是准确的），但是在那首歌里用大量的卖萌模糊了歌词本来的意思，即使本意也不难懂。但是遵照原文的翻译有一个很大的劣势：希尔芬的语气词（口癖，口头禅）太！多！啦！多到有些句子都仅由口癖组成，让人大伤脑筋。翻译成中文，实词对应不上，语气词也对应不上（「ですわ」本身是没有语法意义的，但是是贵族女性身份的象征；现代汉语淘汰了这种复杂的语气词）。最终各位见到的翻译是一个糅合的版本。为什么翻译这首歌？因为私人FM推荐的时候，我恰巧看到下面的评论，说翻译君不知道去哪儿了…… 发文时最后做的歌词是《クローバー》，这首不算有特色也不算难，只是一个对《your diary》的收官。 2.3 IM@S重头戏：偶像大师（IDOL M@STER）的专门列表。 严格来说，是偶像大师灰姑娘女孩的列表——我不敢动雪步的神曲《Kosmos,Cosmos》，因为自己没有详细了解过雪步CV更换始末，也没玩过 XBOX 上的正作游戏、体验众人所说这首歌代表的的雪步的成长，所以没有正式进军正作。（最后被爱心人士捷足先登了，囧。） 我有一条工作线是从私人FM中来的，听到什么有潜在翻译价值的（或单纯好听的）就放到备用歌单，然后不定期从里面选一些来翻译。直到我开翻《Chocolate Tiara》，评论里有一个请求“把爱马仕的歌曲都翻译了”，让我打开了新世界的大门——由此增加了专门的爱马仕任务支线。 第一阶段是翻灰姑娘女孩的角色专辑，不过现在由于资源也逐渐枯竭了所以准备进入下一个阶段，翻各种爱马仕曲（合唱、翻唱、原创）。其实大多是公式化的，觉得歌不错&amp;妹子（的封面图）不错的话就翻译。 这里记录翻译角色专辑时几个印象深刻一些的曲子。角色专辑，主角自然是单个角色，那么翻译的风格就要贴合这位角色以及歌曲内容。例如下面四位分别是幼女、摇滚少女、合法萝莉和小学生；在我翻译过的歌曲中，还有吃货、御姐、蹭得累、摄影少女和年上系偶像，卵用翻唱那个不算。里面每一位的语言风格和设定是要对应上的。（其实我觉得像歌神72那样上场立即实力碾压的多好……然后对着瑞树刷一发“太太我喜欢你呀”……抗议我把千早说老了？不不不，她只是躺枪了，因为黑幕放段落中间影响阅读；而且正作13人中千早的能力也是极为强悍的啊。） 《みんなのきもち》在一开始是连歌词都没有的。我搜索了歌词，发现所有网上的歌词都没有记录说出来（不是唱出来）的话。于是在翻译了歌词之后就开始不断地听，想凭借入门级的水平还原所有句子。这么过了两天，再播放的时候，有人已经上传了歌词！点开一看是@星野总攻，自称中有“爱马仕歌词专业户”，想到我毕竟刚刚踏入未知领域，以及云音乐的歌词是不会被覆盖的，所以最现实的做法就是赶快将完成的翻译上传（此时已经校对过一次）。这就给我敲了一记警钟：一定一定要注意时间轴和翻译的时效性。 《Twilight Sky》的翻译是受到了评论里的一条的鼓动。评论里如是说： 听这首曲越久，就越感动。整个作品下来，李依菜对rock的了解比我这个外行还少，让人觉得她是搞笑役。甚至这首曲子相当一部分就像是小女孩描绘自己想象的世界那样，跟rock搭不上。“巧く歌うんじゃなくて 心を込めて歌うよ 世界でたった一人の 君に伝わりますように”自己觉得rock，那就是rock。 我主要兴趣并不是 rock，但是这歌词实在是击中了心里的什么东西，立刻就觉得这首歌“不一般”。回味了几遍这首歌，在叙述逻辑的跳跃上和前面也有得一拼。这首歌最大的特点就是大量运用成语（定型文），我很庆幸我在用汉语来翻译（找汉语中对应的成语还是挺简单的），要是用英语那真难倒我了。 《アップルパイ・プリンセス》是我在半夜写代码，开私人FM的时候偶然听到的。第一感觉是，咦，这编曲挺活泼的。然后就是：“哇，我是不是又听到了一堆食物？”在这样的好奇心驱使下我切换到云音乐看，一首歌下来把我乐的。叙事连贯，和里面传达出的可爱语气活灵活现地讲了一个故事（甚至是感想）。尽管是在大半夜（一两点），我还是决定立即翻译。翻译不难，就是食物我还知道得少了点。╮(╯﹏╰)╭ 《Romantic Now》曾经被机翻污染过。我在十二月中旬的时候将这个加入翻译列表，但是由于心情不稳定，做了第一段初翻之后整个列表两周都没动。等到第一封推荐信搞定之后兴高采烈，回来一看，估计是哪个以为翻译就是找乐子的家伙将原文放到在线翻译里就丢回来了——而且还居然过审了！这首歌并不是非常吸引评论（尽管看起来小学生很受到青睐，这首歌人气不错），但是不到两周的时间里，最热的抨击机翻的评论就已经被顶了7次了。机翻这事，以前见过，在我的一个歌单里收集了一些我见过的机翻，不过随着时间流逝有些被慢慢取缔了。我提交了词曲报错、一位爱马仕翻译常客@星空社首席酔歌P也帮忙at了曲库。最后在三天内机翻就被撤掉了；这段时间我也赶紧完成了剩下部分的翻译。幸好卯月的翻唱没有被那位仁兄辣手摧花，翻译完后我先传的是卯月那边的，米莉亚这边确认撤下了之后再传了上去。 2.4 冷知识比较上心的几个gal的制作情况： 《恋爱选举巧克力》角色歌：时间轴5/5，翻译5/5 《your diary》OP/ED：翻译2/2 《向日葵教会与长夏假期》角色歌：翻译3/4（没玩过游戏，但是这三首歌实在太好听了） 《恋爱中的她的笨拙舞台》角色歌：时间轴4/4，翻译2/4（有两个无感） 《Lovely Quest》ED(IN)：翻译1/1 《Melty Moment》OP：翻译1/1 翻译失败会怎么样？除了上文提到的“有错误”的理由，还会有这种： 分享单曲：你上传的《Age of Aggression》的翻译由于其他用户的翻译较为贴切，因此没有被选用。 也就是我最近传了时间轴的那首。这首歌的歌词有着明显的韵律，原作（上古卷轴5：天际）中是作为点唱的曲子，由游吟诗人演唱的。所以我在做翻译的时候，也用诗的方式翻译了——追求韵脚也相似，而且是一句对一句——只不过这就涉及了大量的倒装、生僻字词。估计如果真的审核通过，其他人也不好唱的吧。最后被选上的歌词用词简单点的，也不凝练；但是考虑到平民化立场，白话方式反而是最适合的。 三、评论、点赞和校正其实做翻译，当收获了赞美的时候是最幸福的。我第一个点赞应该是……对不起我忘了，好像是接下来说的这里。第一个评论回复是在《Chocolate Tiara》中，我传完翻译之后按照歌词的提供者@supve-sonico的语气，表明自己上传了翻译，并小小地卖了个萌。然后我收到了这位的感谢回复和一个关注。这毕竟是第一个语言互动。私信上，我目前只收过来自三个人类用户（非系统用户）的私信。有史以来第一封用户私信是@小柯酱发来的，在里面说感谢提供歌词（翻译）。到现在我也没问具体是哪首歌的翻译，因为当时已经上传了十几首的了。第二封来自@2B丶小艾琪，说道： 谢谢大侠完成了Twilight Sky的滚动歌词！ 这位，看头像是李依菜的忠实粉丝啊。第三位等会会说到。 到目前为止，我还没有收到at。 我很高兴我的翻译能改变一些事情。舰娘的那首曲子的评论中，我看到过两个“歌词辛苦”或“翻译辛苦”的，此时心中会感觉暖暖的。在传种田歌的歌词和翻译之前，没有一条评论是针对歌曲内容的。而在我提供了歌词和翻译（11月中旬）之后，评论内容发生了明显的改变，有了较多的对歌曲内容的评论。这是我第一次切实地感到自己做出的贡献。 歌词和翻译少不了会出错。我在翻译《a little love song》的时候就出现了严重的错误，后来意识到的时候发表了一条评论，附上正确的翻译，并表示自己“恨不得找个地洞钻进去”。这条回复居然还被点了一次赞！现在已经查不到是谁了，如果我找到，这位，我们放学后在小树林好好谈♂一♂谈。后来在翻译皐月的角色ED时，又出现了严重低级错误——“青い”被翻译成了“绿色”（应该是“蓝色”）。这个错误我立即意识到了，因为我一眼就发现最终的翻译和我的稿子不太一样，自查后发现我错了，而网易审查员帮修改了一下。于是我又想了，这群人又是什么来头，这么敬业呢？ 在最近的米莉亚单曲上也出现了问题。在翻译完之后我有点觉得怪怪的，不过赶时间没有逐句校对。不久就被@廃物指出了： 寝ぐせの向き次第 跟 ウインク３つ错啦 我回复： 谢谢！可以指正吗？ 于是得到了指正： 寝ぐせの向き就是睡醒之后乱糟糟的头发的方向 大概就是说占卜的未来竟然是靠头发的方向决定的 ウインク是wink 哇，不说前面那个原本为“如我所梦”的模糊翻译，我居然眼花了连清浊音都没看清楚……真是不校对就出事故。 犯错的不只是我，老马也有马失前蹄的时候。前奏诗的翻译传完后过了一个月，我突然接到了歌词提供者@十六夜桜的私信： 前奏诗的ED的歌词是我上传的，但是那个时候没有官方的歌词本是我耳扒的… 有几处错误的地方，害得你翻译也跟着翻错不好意思_(:з」∠)_ 第一段，是「手を離さないで」，而不是「でも離さないで」 第二段，不是「誓うは抱かれて」，而是「時間は流れて」 然后后面那句「友とに歩き出そう」也不正确，应该是「手を取り歩き出そう」。 就是以上几处错误了，然而我再上传不知咋地根本过不了审核，所以麻烦你帮修改过来吧，3Q~ 时间轴在这个地方http://tieba.baidu.com/p/4225479464 首先说一句，这位在上传歌词的时候（估计在三月？），云音乐的歌词/翻译记录格式可能不是现在这样子。我看到的时候，是没有歌词提供者链接，也没有“上传歌词”选项的，而滚动歌词最后有一句“by 十六夜桜”。我曾经在云音乐上搜索了这个名称的用户，找到的用户的活动情况很冷清，而且只创建了两个歌单。不过，其中一个就是前奏诗的OST。这次发私信，证明了这位就是歌词提供者（而且是听写！）。 这位做事有头有尾，而且待人诚恳，实为楷模。只不过可惜我点击“上传歌词”后收到的系统回复是： “你上传的《ゆーけーるよーふーたりでー》的歌词由于已有正确的LRC歌词未通过审核” 我将这个回复转发给了他。只可惜这事最后就不了了之了。 四、结束语在这四个月间，经由翻译的机会，我看到了、学到了、体会到了许多。悲喜之情都来源自对翻译的投入，以及，那份爱。 之前微信上，有个叫“赤潮Akashio”的独立评论员说过，二次元的“爱”是很虚的一样东西，是不存在的——在商业利益面前，其意义就是被利用、被拿来赚钱（如B站的“情怀”手游、周边），甚至你连版权都不想买。现在这篇文章已经被投诉而被删掉了。而我很感谢云音乐提供的机会，让理想主义有一个小小的避风港；我们不追求成为带星星的达人，只是想随着喜欢的歌一起共享情感而已。 这之后我还会继续“工作”——纯天然，零报酬，就是愉悦（不，麻婆，不是你的愉♂悦）。这已经成了我生活的一部分。每当文字在指尖飞舞，分分合合，从一种优美的形态转变成另一种的时候，愉悦就会油然而生。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"两个吐槽和反思：教务网、云音乐","slug":"zh/2016-01-15-Two-Complaints","date":"2016-01-13T17:18:00.000Z","updated":"2020-03-30T22:34:35.432Z","comments":true,"path":"categories/Misc/zh/2016-01-15-Two-Complaints/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-01-15-Two-Complaints/","excerpt":"吐槽昨天两个弄得我哭笑不得的东西，一个是教务处的开题基本信息提交页面，一个是网易云音乐。或许不仅仅是吐槽，而已经加强成评论了。","text":"吐槽昨天两个弄得我哭笑不得的东西，一个是教务处的开题基本信息提交页面，一个是网易云音乐。或许不仅仅是吐槽，而已经加强成评论了。 首先来看看教务网的那个页面长什么样： 这里为了说明接下来的一个问题，我动了一下 DOM，将那个“提交”加在了原来的位置上。因为我已经提交了，所以服务器动态生成的页面（这个服务器有一个错误页面，会报告详细的调试信息，从中得到一个显然的结论是运行在 Django 上，所以说是“动态生成”而不是用样式隐藏）里没有那个“提交”链接。其余的，除了现在所有字段都无法编辑外，其他和第一次访问时没什么区别。 然后请注意两个问题，凭直觉给一个答案： 那个“是否非涉密可公开”是什么东西？ 如果你想打印评审表，你在不清楚其他功能的情况下，看到这些提示会怎么做？ 是，我承认我在这个“是否非涉密可公开”处栽跟头了，填了“否”——然后生成的 PDF 表单中就成了这个样子： 如果没有看到这个“不可公开”，我还不会意识到我选错了。更大的问题是，不只我一个人选错了，在晚上七点多的时候有人提醒说要提交打印这表，然后在我们6个已经提交的人中4个填错了。我们这些前辈的鲜血就算是警醒了后人吧。 所以，教务处设计这提示的兄台，您知道 UX 吗？您用过这页面吗？知道用户心理诱导吗？为什么不用好端端的“是否涉密”而用一个考逻辑的“是否非涉密可公开”呢？您是想在问涉密的同时还提醒涉密和公开之间的关系吗？从常识想一想，涉密的题目居然能公开答辩？ 然后我们来看看这货的 HTML 源代码： &lt;td&gt; &lt;p&gt;是否非涉密可公开: &lt;/p&gt; &lt;div class=&quot;td_inta&quot;&gt; &lt;select class=&quot;tb_tx&quot; disabled=&quot;disabled&quot; id=&quot;id_1_45-answer&quot; name=&quot;1_45-answer&quot;&gt; &lt;option value=&quot;&quot;&gt;---------&lt;/option&gt; &lt;option value=&quot;99&quot;&gt;是&lt;/option&gt; &lt;option value=&quot;105&quot; selected=&quot;selected&quot;&gt;否&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;td_htxt&quot;&gt; &lt;/div&gt; &lt;/td&gt; 嗯，还好，看来是一个独立 ID 硬编码的选项——哎重点不是这个！这个是否你居然使用 ID 作为选项值？既然名称都给了（1_45-answer），为什么不用一个简单的 0/1 呢？如果想在这之前插入选项怎么办，这么高的耦合度，表变一点点后端也得跟着改分支逻辑。 不过幸好设计兄没有犯这种错误，我在看代码之前以为就凭这蹩脚的说明也该犯的： &lt;label for=&quot;sel1&quot;&gt;是否非涉密可公开：&lt;/label&gt; &lt;select id=&quot;sel1&quot; name=&quot;sel1&quot;&gt; &lt;option value=&quot;是&quot;&gt;是&lt;/option&gt; &lt;option value=&quot;否&quot;&gt;否&lt;/option&gt; &lt;/select&gt; 上面演示的另一个典型的硬编码问题在哪里呢？就出在这次的描述修改上。如果描述为了简明而修改成“题目是否涉密”的话，原来选项的“是”“否”角色就要倒过来了——如果要保持原有的逻辑不变（例如使用元素索引来赋 selected 属性），就会变成下面这个样子： &lt;label for=&quot;sel1&quot;&gt;是否涉密：&lt;/label&gt; &lt;select id=&quot;sel1&quot; name=&quot;sel1&quot;&gt; &lt;option value=&quot;是&quot;&gt;否&lt;/option&gt; &lt;option value=&quot;否&quot;&gt;是&lt;/option&gt; &lt;/select&gt; 看到上面这个抽风的代码，想必后面的维护者会气得跳起来。不过幸好现在这位前端还没沦落到这样的地步，基本规则还是……呃，知道的。 哦对差点忘了上面问的另一个问题了。公布正确答案：只需要保存一下，就可以导出，并不用像高考报名表和考研报名表那样先提交（这个提示倒说得很清楚，提交之后不可再修改）后才能导出打印。出乎意料吗？ 所以您老，就不能将“提交”新起一行吗？如果设计成这样，是不是更好地体现出了先后顺序了： 今天经过一点偶然，我写了一点评论准备发到云音乐上，对应的歌是《Sister,Friend,Lover》： 首先纪念一下回到克图格亚的克子。这首是奈亚子W四个ED中我最喜欢的一首，刚私人FM推了珠绪的「嫌いなワケLychee」，刚好那首没有翻译，我就想着这首如果没有的话我一定要补上。一看已经有翻译了，瞬间也不想做那个了……哎这就是角色与角色的差距啊。 （不知道第一句表达的意思的同学，可以去 81 Produce 的官网，看2015年7月14日的消息。如果首页没有了的话，可以去新闻存档看。） 然而，按下“评论”按钮，却提示“无法评论”。为什么呢？看这里： 注意那个小小的云朵图标，那个的意思是这首歌符合两个条件： 我播放过，所以自动存在了我的“音乐云盘”里，播放时是从这里拉的源； 这首歌已经无法公开播放了，多半是由于版权问题。 什么时候丢掉公开播放权的呢？可以从线索中估计一下： 按照这首歌的人气，大概就是在12月11日到12月13日之间了。如果没有播放过会是什么样子呢？像下面这样： 注意这个 instrumental 版本，完全是灰色的，说明我之前没缓存过（基本上就是没播放过），同时我现在也不能播放了（“因合作方要求暂时下架”）。 一瞬间就心累了许多。不过一个例子让我看到了不同的东西，在《Girls, Be Ambitious.》： 这首歌的翻译是我做的（唉，年少无知），由于其中出现了一个错位的错误（将翻译从 Notepad++ 复制到网页时有一句复制到了下一句的位置，直接覆盖了）而成为了我的黑历史，所以我一直关注着。（题外话：另一首《シンクロマニカ》出现了严重的歌词错位，中间缺了一句所以后面的都往前移了。同样加入黑历史——而且是星月的cover啊——但是我确定复制的时候没有错误，是一一对应的，不知道是什么不可控因素起作用了……╮(╯▽╰)╭）这首歌我以前提到过，10月25日的时候就被禁止公开播放了。 但是12月中旬我看的时候，惊喜地发现在长期冷寂的评论区多了一条评论（天天看评论的，肯定之前的最新评论都烂熟于心了）。看到这条12月8日的评论我一激动，就想回复“终于见到一个新评论了”，可是按下“评论”按钮的时候，又是“无法评论”。 那么问题来了：那位仁兄是怎么能评论的呢？我觉得解释几乎只有一个：这位不在受限制区域中，但是具体在哪里我就不知道了。据此可以得出另一个有趣的结论：如果我一个在帝都的人看到的是“无法评论”，网页上尝试播放是“暂时下架”，那么这位创造了奇迹的仁兄的存在说明，云音乐的限制操作并不是仅针对某些版权资源的地图炮，而是将用户分成了两类，A类能播放，B类不能，就这么简单。分类标准？也许只是根据 IP 段。也就是说，即使明写着“暂时下架”，但是只要你处于正确的一类，它就没下架。或者换一个更直接的说法：云音乐的“暂时下架”是一个幌子，并没有切切实实地落实嘴上说的话，还是留了一个小后门的。这个后门未来是否会方便用户，这就不得而知了。 不过我并不是说那位是特权用户，只是ta在正确的时间出现在了正确的地点。我只是想感叹，版权帮助资本家筑起了高墙，占地为王了。更概括地说，是“连接权”： 归根结底，由于缺乏一个市场广泛接受的、有法律约束力的连接权开放和公平使用规则，任何公司(包括 BAT)要想做通连接的生意，要么自己控制这些能力和资源，要么加入某一阵营以享受不完全的连接权。虽然这样做可能会导致全社会的重复投资，但对于三家公司的战略安全却是必需的。 你喜欢在天天孤岛之间划上几小时的船吗？如果是为了必需品，如柴米油盐，这还好，但是为了一点糖果，一两次还行，并不会每天划的。这就相当于碎片化环境下的用户选择：歌手A和歌手B的版权分别由公司X和公司Y买下，如果是一个同时喜欢A和B的用户，要不就只能在X和Y的播放器之间切换（如果不允许下载的话），要不只能在其中取舍一番，选一个，要不就太麻烦了。幸好标准是统一的，大不了抓 PCM 数据包。多样性促进进化，碎片化促进灭绝，除非还有一根根丝线作为维系。 反例来了。早前，因为没有达成共同协议，日本的不同通信运营商之间的号码之间短信是不互通的，不知道现在是否还是这样。（题外话：这就是为什么在动漫作品里，学生之间交换的总是说“メールを送り”也就是“发邮件”，而不是“发短信”。）但是，通信受损了吗？只不过和我国的体系不一样而已，并没有有大损害。这是由于电信属于国民命脉，是必需品，所以中间的“丝线”不管是从道德角度还是利益角度，都是断不了的。美国的唱片业也很复杂，对受众造成了什么影响吗？ 最后，《Sister,Friend,Lover》现在的播放权在谁手里呢？并不在虾米手里（同样说“下架”），也不在QQ音乐手里（标注“资源来自网络”）。那么我也不知道会在哪里，反正这个音乐的天下已经支离破碎了，一介草民能动什么。如果你卖草鞋还好说。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof 的 GitHub Pages 项目页面","slug":"zh/2016-01-08-Bulletproof-Live-Pages","date":"2016-01-08T08:48:00.000Z","updated":"2020-03-30T22:34:35.432Z","comments":true,"path":"categories/Misc/zh/2016-01-08-Bulletproof-Live-Pages/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-01-08-Bulletproof-Live-Pages/","excerpt":"","text":"今天试用了一下针对项目的 GitHub Pages（本博客是针对用户的），于是 Bulletproof 有了自己的项目展示页面！试试点击“Have a try”吧。 我是从一个传统程序开发者起家的，到今天能在网页上能展示轻量级项目的预览而不再需要经过传统的编译-发布-安装部署，多亏了新的 Web 技术。 TypeScript：用传统的面向对象思想（其实算是语法糖吧）写 JavaScript Gulp：自动化构建，生成各种需要的东西 Browserify：将用 Node 的方式（CommonJS 模块化规范）写出的 JavaScript 尽可能地放到浏览器里引用，配合 Gulp 食用风味更佳 Canvas：没有 &lt;canvas&gt;，就没有便捷统一的2D绘图 API 和 WebGL 这些，还有众多的基础技术…… 其实如果学的是 OpenGL，还会有 Emscripten（啊主页应该是这里）这条路，也是很方便的。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof 重获新生","slug":"zh/2016-01-07-Bulletproof-Remastered","date":"2016-01-07T11:59:00.000Z","updated":"2020-03-30T22:34:35.432Z","comments":true,"path":"categories/Misc/zh/2016-01-07-Bulletproof-Remastered/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2016-01-07-Bulletproof-Remastered/","excerpt":"","text":"见 GitHub repo。测试示例已经通过，所以检查了一下就推上去了。在运行示例的时候，请将它们运行于一个服务器上，然后用支持 WebGL 的浏览器浏览；或者使用 NW.js 等 Node+v8 的环境。 这是继去年9月突然无声息之后，试验新路而走出的路。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"翻过了两座网站维护小山","slug":"zh/2016-01-03-Overcame-Two-Obstacles-in-Website-Maintenance","date":"2016-01-03T06:02:00.000Z","updated":"2020-03-30T22:34:35.431Z","comments":true,"path":"categories/Tech/zh/2016-01-03-Overcame-Two-Obstacles-in-Website-Maintenance/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2016-01-03-Overcame-Two-Obstacles-in-Website-Maintenance/","excerpt":"昨天登录 SSH 去看服务器状态的时候，磁盘占用就已经100%了（实际上算了一下，97%差不多），不过基本操作还是没表现出问题，心里就合计着等到某天真出了问题再修吧。结果一觉起来，就有人报告网站又崩溃了。没办法，要做到快速响应，赶快修吧。 这篇文章记录了今日维护碰到的两个问题： 磁盘占用100%，而且找不到可以删除的文件； Discuz X3.2 的 forum_threaddisablepos 表“损坏”。","text":"昨天登录 SSH 去看服务器状态的时候，磁盘占用就已经100%了（实际上算了一下，97%差不多），不过基本操作还是没表现出问题，心里就合计着等到某天真出了问题再修吧。结果一觉起来，就有人报告网站又崩溃了。没办法，要做到快速响应，赶快修吧。 这篇文章记录了今日维护碰到的两个问题： 磁盘占用100%，而且找不到可以删除的文件； Discuz X3.2 的 forum_threaddisablepos 表“损坏”。 一、磁盘占用100%很久之前，就已经出现了匪夷所思的现象： $ df $ du / -sh 我们配的是 50G 的硬盘，实际文件占用不到 10G，磁盘占用却每天都在往上涨。 开始（9月初）的时候利用命令找了一下大文件删除： $ find / -type f -print0 | xargs -0 du -h | sort -hr | head -20 看到是 php-fpm 和 nginx 的日志最大，删。到去年十一月的时候，占用率已经到80%，需要每几天就删除日志（对，没弄 cron 脚本）。占用率到100%的时候页面载入就会出错，数据库读写异常，所以每次一看100%了赶快删日志。 和lan姐讨论了一下，他（嗯，没打错）认为是 inode 的问题，小文件占用了太多空间。我想了一下，很可能，毕竟我们的 info 节数据被分开来按照单个文件的方式存了，而这不是小数量。我还想着在闲时改代码，放数据库里。 科普：小文件也能占用大空间？ 在 Windows 上，磁盘分配的空间单元是簇（cluster），文件占用大小（在未设置压缩属性时）是簇大小的整数倍，与文件的对应关系由分区表（partition table）记录。例如，NTFS 的默认格式化选项上，簇大小是 4K（4 KiB），也就是说即使你的文件内容只有 1.5 KiB，资源管理器显示大小为 1.5 KB，也会占用 4 KiB 的磁盘空间。在 Linux 上，对应的概念是块（block）和 inode。 平均一个文件会浪费 0.5 个存储单元的空间，文件一多就体现出来了。文件越小，浪费空间所占比重越大，就出现了许多小文件浪费了大空间的情况。 不过即使是勤劳地删除日志，最后也到了即使删除所有能删的东西磁盘占用率也上了93%的尴尬境地。就到了现在。 今天我找了一下维护的资料，查了一下 inode 的实际占用率： $ df -i /home 实际才用了6%，说明小文件浪费的空间没达到阈值。那么是什么问题呢？于是我谷歌了一下：“linux df 100% usage, du shows less”。 谷歌同志实在是太强大了，理解了我想找什么。结果的第一条就是我所需要的。 三楼的回答中提到： This was caused by apache (httpd) keeping large log files in memory which had been deleted from disk. 我不熟悉 Linux 的磁盘分配策略。Windows 下，打开一个文件会自动锁定句柄，在不关闭之前文件是无法删除的。而根据lan姐（解决后问的）所说，Linux 的文件可以随意删除，但是空间释放要到关闭时才进行。（这也就是最大化利用内存映射的体现吧！） 于是按照所提示的运行命令（我们的服务器日志保存在 /var/log）： $ lsof | grep &quot;/var&quot; | grep deleted 然后就可以看出，是 php-fpm 和 nginx 的日志占用着： 于是重新启动服务来关闭文件并释放（因为已经删除，所以停止服务时会自动释放）： $ service nginx restart $ service php-fpm restart 于是磁盘占用就恢复正常了： 至此这个问题告一段落。 二、Discuz X3.2 forum_threaddisablepos 表损坏（注：pre_ 是 Discuz X 中的待替换表前缀，在安装的时候可以配置。例如配置为 aaa，则会创建名为 aaa_forum_threaddisablepos 的表。） 打开任何一个版块，都会报错： Table ‘database.pre_forum_threaddisablepos’ does not exist. 由于之前也出现过类似帖子表的损坏，我就尝试了一下以前的修复命令。保持 MySQL 运行，使用 mysqlcheck： $ ./mysqlcheck --all-databases --auto-repair -u root -p 但是却报告这张表并不存在： 使用 REPAIR TABLE 命令也失败了（REPAIR TABLE 是 MySQL 的方言）： 于是我到了表的存储目录下去找了一下这张表： 只存在 .frm 保存的架构数据，不存在表的内容。这更蛋疼了。只好求助于百度（毕竟 Discuz 主要在国内用），搜索表名“forum_threaddisablepos”。还好，前几个回答就有靠谱的。这些问题发表在 Discuz 的官方站点上，但是不知道为什么我访问不了，说是域名解析失败，明明可以 ping 的。幸好可以借助百度快照查看文本内容。 首先找到的线索是，有人说（“有用户说‘有人说’”）是这是一张内存表。 在另一篇帖子中，20楼提供的方案解决了我的问题。 执行语句（注意替换 pre_）： CREATE TABLE IF NOT EXISTS `pre_forum_threaddisablepos` ( `tid` mediumint(8) unsigned NOT NULL default &#39;0&#39;, PRIMARY KEY (`tid`) ) ENGINE=MEMORY DEFAULT CHARSET=gbk; 最后能用了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"网站维护","slug":"网站维护","permalink":"https://blog.mottomo.moe/tags/%E7%BD%91%E7%AB%99%E7%BB%B4%E6%8A%A4/"}]},{"title":"GLantern 绘制效率问题及其解决","slug":"zh/2016-01-02-GLantern-Rendering-Efficiency-Problem","date":"2016-01-01T19:03:00.000Z","updated":"2020-03-30T22:34:35.431Z","comments":true,"path":"categories/Tech/Coding/zh/2016-01-02-GLantern-Rendering-Efficiency-Problem/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2016-01-02-GLantern-Rendering-Efficiency-Problem/","excerpt":"在写着架构博文的时候，突然想测试一下动画效果。于是直接就上了 bp.startAnimation()，突然发现帧率才25左右。哦天哪，这效率可比 Pixi 差了不是一点半点。于是返回 GLantern 查看，果然是 GLantern 的问题。大致定位之后就得修补啊……","text":"在写着架构博文的时候，突然想测试一下动画效果。于是直接就上了 bp.startAnimation()，突然发现帧率才25左右。哦天哪，这效率可比 Pixi 差了不是一点半点。于是返回 GLantern 查看，果然是 GLantern 的问题。大致定位之后就得修补啊…… 一开始，我还以为是数组的太大导致的效率低下。此时帧率大概25。 于是我做了一下 CPU 探查，并查看时间线。（抱歉这二者没截图。） 结果是脚本执行时间占大头，在70%左右，同时 CPU 总计占用排名第一的用户函数是 bufferData()（也就是 WebGLRenderingContext.bufferData()）。凭这个，我认为是数据量太大导致每次绘制时传输数据缓慢。于是我粗略估算了一下，第一大 PackedArrayBuffer（属于一个颜色数组）的项数量在14万多一点点。才14万，这个数据量还是挺小的。 我做了一个实验，注释或短路掉特定的操作，查看此时的绘制情况。让我惊奇的是，问题源头明显是 RenderHelper.renderPrimitives() 和 RenderHelper.renderBuffered()（因为只有它们调用了 PackedArrayBuffer.syncBuffer()，内部调用 WebGLRenderingContext.bufferData()），但是在将它们的绘制调用（glc.drawElements()）注释掉之后，即使保留其他语句，帧率都能达到60。 此时的时间线是这样的： 这直接推翻了我“大数据量”的假设，让我更迷惑了：看似完美的绘制逻辑中，哪里出了问题呢？ 我想着，先把能优化的优化一下吧。所以我写了一个小小的优化，默认缓存了 Graphics 的内容（原先每一帧都要所有的 IGraphisDataRenderer 重新绘制）。优化前后有什么不同呢？优化前，每一帧都有几次 RenderHelper.renderPrimitives() 调用和几次 RenderHelper.renderBuffered() 调用，优化后只剩下了后者。 这次的绘制帧率不到30，比之前略强了一点： 但是时间线的数据和做这个优化之前（注意不是上面第二张图，而是忘记截了的原状态下的时间线）的大相径庭： 查看其时间线可以发现，在后面花了很多时间在非用户脚本优化上，而脚本比例小了很多。也就是说，虽然 drawElements() 调用时间不长，但是 执行处理时间长。这和很久之前的症状是一样的，让我开始怀疑是否是绘制步骤错误或者参数错误。而且，问题一定是出在 RenderHelper.renderBuffered() 中的某个地方。 CPU 探查和堆快照结果如下： 可以看到，最大的数组就是 1 MB 多一点。还是一头雾水。我将目标大致放在了 bufferData() 前后。这样的话真凶是使用模式吗？（使用模式影响 OpenGL 对数据的缓存策略。） 一般的例子中用的都是 gl.STATIC_DRAW，意义为写一次频繁用，我蛋疼地试着将它改成了 gl.DYNAMIC_DRAW，意义为频繁写频繁用。令我吃惊的是，帧率马上就上去了： CPU 探查结果虽然不是很令人满意，却有了不少的提升： 其他倒是没怎么变化： 这么说真凶就是使用模式啦。（其实我并不是很明白为什么——因为实际上传过去的数据是几乎不变的。） 堆内存分配那边我看过，并没有内存泄露。 再做一个实验，在改为 gl.DYNAMIC_DRAW 的情况下，如果 Graphics 不默认缓存为位图（贴图）的话，帧率从48下降到42左右。 47 FPS，这个值还是低于 Pixi 的稳定60，而且处理时间还是很长，有没有其他的问题呢？我想到了循环——手工循环（JavaScript）和自动循环（shader），因此转而怀疑起滤镜的应用来。 我目前没有实现自动调整大小的 RenderTarget2D，所以滤镜 shader 每次都应用（对于目前帧大小）1024×512、(5+5)×2+3次，加上其他开销（每个 DisplayObject 有至少两次，一次原始绘制加上至少一次作为孩子被拷贝，一共至少7×2次），量很大。 于是，在 gl.DYNAMIC_DRAW 条件下，将 BlurShader 和 Blur2Shader 的循环次数改成3+3，在 Graphics 不缓存时平均帧率能达到54，不过边线就更明显了： 缓存时能维持在60： 如果设置为2+2，能轻松达到平均帧率60，不过线条更明显了；设置为1+1就没法看了。 在 gl.STATIC_DRAW 条件下，缓存时设置为3+3帧率稳定在38左右。可以看到，使用模式不同对效率造成了很大的影响。 关于效果，即使是3+3有边线，窃以为效果还是比 Pixi 的极速shader好的。 综合所有的因素，最后就选择了 gl.DYNAMIC_DRAW、3+3并缓存 Graphics 内容。 X+X 的意义见这里。 今天解决了 Visual Studio 2015 的 Web 项目相关的缺失、损坏等问题（就是造成之前 TypeScript 项目属性无法查看的那个）。这个问题还导致我在安装 Web Essentials 时报错说缺少依赖项 Web Developer Tools，在 VS 的安装程序中修改（添加、删除）“Web 开发人员工具”项（也就是 Web Developer Tools）时显示安装成功却实际上没变化（错误依旧）。 StackOverflow 的问题描述 一楼的方案是可用的，修复 Microsoft ASP.NET 5 RC1 即可。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"Bulletproof 的新弹幕对象架构设计","slug":"zh/2015-12-29-Bulletproof-Danmaku-Architecture-Design","date":"2015-12-29T13:14:00.000Z","updated":"2020-03-30T22:34:35.431Z","comments":true,"path":"categories/Tech/zh/2015-12-29-Bulletproof-Danmaku-Architecture-Design/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-12-29-Bulletproof-Danmaku-Architecture-Design/","excerpt":"Bulletproof 重构的工作进展不错，主要是花了时间基于 WebGL 写了 GLantern，将基础的绘制剥离了，以此为基础写弹幕相关的就轻松了。 九月份的测试是概念的验证，架构极其混乱。当时 TypeScript 版本还在 1.4，import 语法限制很多（只有 import x = require(&quot;file&quot;);），而且 TS 和 C# 那一点点微妙的差距我还没很好地体会出来，最后就变大文件乱引用加一堆hack的混合物了。当时也没什么大的目标，能做出一个能执行代码的高级弹幕的原型就可以了，因为自己都不知道能不能做成。——是，有先例，但是看着这么多已有的代码就开始仰望巨大的工程了。 既然验证通过了，就要开始做架构了。（地基打好了，就开始规划柱梁，再装修。）考虑到应用场合，姑且做了一个。 新的源码在通过一些测试用例后会推上来。莽然融合 WebGL 的测试的各种东西放在了 native-webgl-obsolete 分支（看名字就知道是废弃了）。 详情请展开。","text":"Bulletproof 重构的工作进展不错，主要是花了时间基于 WebGL 写了 GLantern，将基础的绘制剥离了，以此为基础写弹幕相关的就轻松了。 九月份的测试是概念的验证，架构极其混乱。当时 TypeScript 版本还在 1.4，import 语法限制很多（只有 import x = require(&quot;file&quot;);），而且 TS 和 C# 那一点点微妙的差距我还没很好地体会出来，最后就变大文件乱引用加一堆hack的混合物了。当时也没什么大的目标，能做出一个能执行代码的高级弹幕的原型就可以了，因为自己都不知道能不能做成。——是，有先例，但是看着这么多已有的代码就开始仰望巨大的工程了。 既然验证通过了，就要开始做架构了。（地基打好了，就开始规划柱梁，再装修。）考虑到应用场合，姑且做了一个。 新的源码在通过一些测试用例后会推上来。莽然融合 WebGL 的测试的各种东西放在了 native-webgl-obsolete 分支（看名字就知道是废弃了）。 详情请展开。 先扯一点远的。我觉得 Win32 啊 COM 啊 COFF 啊这些架构/格式都是神级的设计，经历了多少的时间和实践检验哪……完毕。 第一次运行测试的测试，直接读入之前的 kanpai-madoka.js。MotionGroup 之类的就省了，按照所有值默认显示出来，第一个静帧。 设计还算合理。怎么说呢？在规划之后（停留在想法上，没写下来——这是个缺陷，因为我经常忘东西 = =），动手实施，很快就写出来了。运行测试，改了几个 NotImplementedError（我会在所有未实现的函数里引发 NotImplementedError 而不是指定默认值，这是学习 C# 的抽象函数实现模板中引发 System.NotImplementedException 的方式）之后就能正常工作了。（这种方式只能证明，当前的设计是一个有效解，而不能证明是最优解……） 然后我开始讲目前用到的 Bulletproof 新架构。（以下是 SVG 图形，如果你看得别扭的话……其实 Chrome 一旦对于没指定字体的文字应用系统默认字体，也就是宋体，就开始乱套了。） 首先是整体（包视角）的设计。 对应的文件结构是这样的： D:\\SOURCE\\JAVASCRIPT\\BULLETPROOF\\SRC │ Bulletproof.ts │ ├─bilibili │ │ BiliBiliDanmakuApiContainer.ts │ │ IBiliBiliDanmakuApiContract.ts │ │ │ └─danmaku_api │ │ BiliBiliDamakuApiObject.ts │ │ Display.ts │ │ Global.ts │ │ │ └─data_types │ ICommentBitmapCreateParams.ts │ ICommentButtonCreateParams.ts │ IGeneralCreateParams.ts │ IMotion.ts │ IMotionPropertyAnimation.ts │ └─danmaku │ DanmakuBase.ts │ DanmakuCoordinator.ts │ DanmakuKind.ts │ DanmakuLayoutManagerBase.ts │ DanmakuProviderBase.ts │ ├─code │ │ CodeDanmaku.ts │ │ CodeDanmakuLayoutManager.ts │ │ CodeDanmakuProvider.ts │ │ │ └─dco │ DCOHelper.ts │ DCShape.ts │ IDanmakuCreatedObject.ts │ IDCExtraCreateParams.ts │ ├─mode7 └─simple 首先，在一个全局包 Bulletproof 中有一个全局（对于每个实例而言）类 Bulletproof。每个 Bulletproof 对象会创建一个弹幕的综合管理类 DanmakuCoordinator，用于控制弹幕的产生（兼顾视觉效果与渲染效率）。每个 DanmakuCoordinator 会创建 *DanmakuProvider 对象，提供不同类型的弹幕控制（管理）服务。理论上，可以通过反向注入的方式添加遵循新逻辑的弹幕类型，不过目前还是使用着固定索引的方式，和 BiliBili 的当前值对应（准备先实现普通弹幕、定位弹幕、代码弹幕）。一个 *DanmakuProvider 拥有一个 *DanmakuLayoutManager 实例，该实例负责根据情况计算所属弹幕种类中的某个弹幕的应在位置。每个弹幕种类有自己的实现类 *Danmaku，负责更新与绘制所属的弹幕内容。 接下来是显示核心 *Danmaku 的设计。我目前实现了大部分的 CodeDanmaku，就以此为例子。 CodeDanmaku 继承自 DisplayObjectContainer，为其创建的代码弹幕提供一个统一的视觉元素根节点。同时，每个 CodeDanmaku 有独立的 BiliBiliDanmakuApiContainer 实例，作为高级弹幕代码与 Bulletproof（以及底层的 GLantern）的通信接口。例如，以下的代码会被分配到一个具体的 CodeDanmaku（假设名字为 cd1）中执行： var s = $.createShape(); 执行后，s 的逻辑和视觉父亲自动是 cd1。这段代码是代入了 cd1.apiContainer 的各个对象（对 BiliBili 高级弹幕 API 的模拟），因此保证不同的代码弹幕的创建能自动与对应的 CodeDanmaku 挂钩，执行是分离的。但是目前的实现问题（用 Function），如果突破了简易沙箱，还是会相互影响的。例如，在另一个高级弹幕中输入内容： s.alpha = 0.4; 就会发现，前面创建的图形透明度发生了变化——此时 s 是一个全局变量。这一点以后考虑采用jabbany的 WebWorker 方案，更安全而且不会造成污染——毕竟浏览器的沙箱帮挡着，除了伪造通讯之外是没有能破坏主线程的方法的。 这些弹幕都被作为 DisplayObject（之后的普通弹幕和定位弹幕也会采用此策略）加入到了根 Stage 的孩子集合中，因而更新和绘制是随着元素树进行的。 最后再回顾一下 DanmakuCoordinator-*CodeDanmakuProvider 的设计。这种预先创建并索引的关系和 ShaderManager-ShaderBase 是一样的。这一点模仿了 Pixi。当初 GLantern 起稿的时候，shader管理是按照最后一个 WebGL 测试的形式写的，每个 WebGLRenderTarget 带着专属的 ShaderBase，如果要实现不同功能，还得实时销毁并创建绑定新的 ShaderBase。后来咬着牙动了大手术，将整个蹩脚的设计改成了现在的 ShaderManager。感谢这个 ShaderManager，后来就一直没有担心过shader资源分配的问题，而且添加新shader非常方便。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"},{"name":"架构","slug":"架构","permalink":"https://blog.mottomo.moe/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"GLantern 更新：文字和 Tween","slug":"zh/2015-12-27-GLantern-Update","date":"2015-12-27T08:08:00.000Z","updated":"2020-03-30T22:34:35.431Z","comments":true,"path":"categories/Tech/zh/2015-12-27-GLantern-Update/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-12-27-GLantern-Update/","excerpt":"GLantern 更新到 0.3.0-alpha，提供了初步的文本和缓动（tween）支持。","text":"GLantern 更新到 0.3.0-alpha，提供了初步的文本和缓动（tween）支持。 一、文本绘制由于我使用的是原生的 WebGL，所以文字绘制并不像高级的库那么方便。 怎么绘制文字呢？有请 &lt;canvas&gt;。注意初始化 WebGLTexture 的时候，是可以导入如下内容的： 空（null），代表创建一个空白的贴图，大小用户指定； ArrayBufferView，代表在用户指定的大小范围内填充这些像素内容； HTMLCanvasElement； HTMLVideoElement； HTMLImageElement； ImageData。 后四个选项是会拷贝对应元素的当前帧到贴图中。按照我的试验，是按照1:1比例复制，例如缓冲区为 100×100，图像为 50×50，则复制后图像内容会处于 (0,0,50,50) 区域。更多信息请查看规范。（虽然里面标的是 TexImageSource，但是实际上 TypeScript 的 lib.d.ts 并不支持此定义，所以得写成联合类型的形式。） 于是问题就简单了，将文本绘制到一个缓冲 &lt;canvas&gt; 上，然后将其内容拷贝过来。Pixi.js 和 THREE.js 采用的都是此方式。 具体实现其实挺简单的，在已有基础上改造出一对拷贝网页元素的顶点/片元 shader 就好。注意的是拷贝的是当前内容，所以要记得更新。 二、TweenTween 么……沿用的是上个版本遗留下来的函数啦……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"在冰冷的圣诞夜写下对未来的分享的思考","slug":"zh/2015-12-24-Cold-Christmas-Eve-And-the-Future-of-Sharing","date":"2015-12-24T11:02:00.000Z","updated":"2020-03-30T22:34:35.431Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-12-24-Cold-Christmas-Eve-And-the-Future-of-Sharing/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-12-24-Cold-Christmas-Eve-And-the-Future-of-Sharing/","excerpt":"12月24日本是各大字幕组狂欢、在出片时附一句“圣诞快乐”、“新年快乐”的日子，但是今年的这一天，国内的 ACG 资源界遭遇了双重打击。","text":"12月24日本是各大字幕组狂欢、在出片时附一句“圣诞快乐”、“新年快乐”的日子，但是今年的这一天，国内的 ACG 资源界遭遇了双重打击。 极影在去年就被清理了。中午11:56，pz菊苣贴图，漫游的BT宣布关闭，还说着有DMHY；当时我刷了一下DMHY，熙熙攘攘依旧，可是在16:13，又有人发了截图，DMHY跪了。 现在连遗言都没了，干干净净的空页面框架。 昨天中午，轻之国度被查封。时间往前推五个月，七月份的时候腾讯与天闻角川宣布合作。群里有菊苣评论道： 娇喘（注：应该是拼音输入“角川”之误）发现天角这弱逼搞不懂（注：应该是拼音输入“动”之误）轻国，所以直接卖版权给了企鹅。 所以没错，上面的新闻链接我都是故意从疼逊新闻引的。 其实新闻说“告破”，那真的是糊弄一般民众了。明摆着是养肥了要开始收网了。 用这么一个比喻吧： 有一片荒地，种子随风落到这里，长成了野生树林。树林更新换代留下的养分使得这片土地肥沃起来。十五年过去，现在地主要园丁往里面种桉树（桉树的特性自行补知识）卖木材了，于是长出的东西就要除掉。觉得还能用的，拔根移到花盆里，其他的一把火烧了。 上面那位菊苣评论道： 一方面国内acg传播全靠字幕组汉化组打开局面，另一方面财团们很不开心这样，所以等打开市场之后就可以把小作坊踢开了。 另一位菊苣说： 挺好的。关键是字幕组上不得台面，没有把自己做大，光是停留在自high。……现在开放市场，就是做大的机会啊；但是字幕组也不愿走市场化利益化的道路，跟视频网站合作，还是喜欢走作坊式的、自由式的道路。……想着小国寡民的日子，时代总会变化的。 从理性角度，我在此提出一个假设：发展下一个形态的文化所需的物质基础已经庞大到必须聚合才能继续的地步了。（这个命题就和我以前想的另一个命题差不多，在科技树的某个高度，会出现所有人按照最合理的社会位置排列，也无法达到这个高度的情况——环境无法承受。所以人类在和自己的命运斗争，是先攀上科技树，还是先被资源短缺限制死。）并不是说创作者无法创作艺术作品，例如你看 DeviantArt、pixiv、Free Music Archive，不是不行，但是就大众化、养家糊口来说还是很困难的。毕竟，我们还不在各取所需、各尽所能的共产主义社会中——而且我也怀疑就从人性来看，达到这个程度的可能性——能力适合、自身喜好和社会结构稳定三者微妙统一是很困难的。想想卢德运动，就个体而言手工业者们是很悲惨的，但是他们的遭遇却让生产力提高了——选一个人还是五个人？现在的文化产品生产力的变革，很像是从井田制向土地私有制的变革。（这个比喻不是太恰当，毕竟所有制和现在完全吻合，体会一个意思就好。）或者圈地运动？（也不是很恰当。） 每次想到07年左右，我刚上中学的时候，我都会叹一口气，属于自由分享的黄金时代已经过去了。拥抱变革，或者被碾在轮下。即使有 GNU 这个开源标杆在，软件业也从不缺乏吸血鬼（leecher），而为了抵抗吸血鬼，又需要商业抗衡。这和劣币何其相像。 OK，现在改看看能否解决这个问题。 做字幕组不是为了钱（至少有口碑的字幕组不是，谁都知道卖钱或者变相卖钱都在作死），而是兴趣、人脉和学习。——谁没事大半夜地赶制造字幕发布呢，劳神费力？完全商业化就将不可量化的利益扼杀了。有人提到“字幕组团队也有望借此机遇转型，结束只干活不挣钱的尴尬境遇；用户虽然付了费，但最终获得了更多的优秀动漫作品”（微信转载，针对 BiliBili；结果被举报侵犯权益给删掉了，根据作者后来发布的消息看来是被B站要求的），这种问题，拜托您考虑一下拿到钱怎么分好吗？不管怎么分，如果不是按照正式工资来算的话，都会因此利益纷争的。 我的建议：采用类似 Steam Workshop 的社区方式，但是只适用于本体+附加产品的方式（例如视频+外挂字幕、游戏+翻译），实体小说就麻烦了。暂且留下一个改进目标吧。 怎么实行呢？ 首先，和手游/网游差不多的，赚的钱来自5%的羊身上（中国人免费惯了，视频付费率更低——之前微信文章那位给出过数据和获取方法，低于1%）。所以，这部分有“爱”有金拿来课的死宅是投入回收的重点，而不是全部的死宅。这和收税是一样的，“拔最多的鹅毛，听最少的鹅叫”，那就拔那些毛多而且拔了也不叫的，少拔毛少还吵的。 其次，降低画面质量、免费N分钟、试玩等是过滤出核心用户的有效手段。本来整个群体的用户粘性并不是很大，大多数人有着“看一看，觉得不错买手办”的心理，有肉就来，没肉就走，吸引他们的是一时刺激。那么可以考虑针对这一点，提供部分免费的服务 第三，社区的细节。在这个社区中，每一个文化产品资源有对应的条目，而每个用户可以申请协助创建某个条目的附加资源。购买基本物品（例如 BD 的数字版），然后在附加资源中选择喜欢的。对于做出了贡献的用户，可以生成一份履历表——证明自己对于某某资源的贡献如何，受到了怎么样的评价，毕竟这本来就是一份半公益的事业。GitHub、志愿北京就是采用了这种方式。如何取得创建的权限呢？版权方发行了正片之后，或者版权方认为可以开始加工的时候，向申请者提供短时间（例如3天，过期无效）的部分资源接触权限。在这段时间内，申请者必须按时报工，以获取接触下一段资源的权限。（例如，台本。当然，这很极端了，毕竟台本哪里这么容易给外人看的呢。）泄露怎么办？申请者信誉降级，或者直接无法申请新的协作工作。成果可以由版权方考虑是否上架，或者上架后听群众意见。 第四，版权在谁手里？原材料在制作方手里，附加资源由原制作方和附加制作者共有。ACI 字幕组目前走的是这条路，通过接洽 ACI 的节目制作方，拿到了中文字幕的制作权，然后由组内的爱好者制作。这是要双方协调的。（是否发放工资我真不知道。） 最后，还是BD的问题。有人会问，你这样做会不会影响作为收入贡献的主力，BD的销量啊？答：你觉得买BD的人的心态和一个看低画质的人的心态能一样吗？Steam 和 Origin 出来了，实体游戏的销量受到影响，但如果加上数字版本销量，总量还是增大了呢。 按照如上的方案，对三方都有好处：对于协作方（从字幕组转化），可以累积社区贡献（类似志愿服务），新成员可以增长见识；对于受众，继续保持选择高质量附加材料的权利——字幕组对作品的热情驱使着他们更用心地做（某组的《女子落语》的词句注释量和详细程度可不是一朝一夕就能写出的）；仍然保持的受众吸引力继续维持版权方的收益。只不过，实行这个方案要强有力的技术或其他监管，除了做出公信力（芝麻信用的后台是谁？是阿里，但是其给出的数据居然能从法律和社会意义上影响公民），还要防止在预获取的过程中就发生资源的流出事件（想想2003年的 HL2 源代码泄密）。 文章的最后我想寄希望于合作的力量。各个字幕组也好，各个片子也好，都像是漂浮在茫茫大海中孤岛。后来出现了字幕组的人的联合、组的联合，在工作成果和人际交往上都更深了一层。遭受打压的BT其实有一个意料之外的功能：保存稀有资源，因为其后背不只是几个大公司的存储，而是所有爱好者的硬盘之和。 要是走向统一的话，社区化的统一比起巨头的冲撞（clash）来说或许是更好的选择。 2016年1月24日注： 嘿，我发现设想的方式的确已经有人在做了，这就是 Duolingo（中文版）！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"对模糊问题的调整尝试","slug":"zh/2015-12-23-Try-Fixing-Blurring-Problem","date":"2015-12-23T06:13:00.000Z","updated":"2020-03-30T22:34:35.430Z","comments":true,"path":"categories/Tech/zh/2015-12-23-Try-Fixing-Blurring-Problem/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-12-23-Try-Fixing-Blurring-Problem/","excerpt":"在上次讲模糊的时候总是过于暗淡之后，tt补充道： 你应该注意到了pixi的strength在传给shader之前进行了/4？在对两者进行比较之前或许应该先考虑这个区别。 哦，我承认，我没注意到。 以 X 方向的模糊为例，Pixi 的 strength 计算是这样的： this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width); 于是在我的代码中就得这样： shader.setStrength(this.strengthX / 4 / this.pass / (t1.fitWidth / t1.originalWidth)); 而原来只是简单的设置为 strengthX： shader.setStrength(this.strengthX); 难怪了。以下是对比图。","text":"在上次讲模糊的时候总是过于暗淡之后，tt补充道： 你应该注意到了pixi的strength在传给shader之前进行了/4？在对两者进行比较之前或许应该先考虑这个区别。 哦，我承认，我没注意到。 以 X 方向的模糊为例，Pixi 的 strength 计算是这样的： this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width); 于是在我的代码中就得这样： shader.setStrength(this.strengthX / 4 / this.pass / (t1.fitWidth / t1.originalWidth)); 而原来只是简单的设置为 strengthX： shader.setStrength(this.strengthX); 难怪了。以下是对比图。 对比图中，从左到右、从上到下分别是： Pixi 的渲染结果； &lt;canvas&gt; 2D + Box Blur（对 Gaussian Blur 的一种快速近似）的渲染结果，以此为标准； 修正后的 GLantern 渲染结果，循环次数为 5+5（X 方向5次，Y 方向5次）； 修正后的 GLantern 渲染结果，循环次数为 9+9。 可以见到，5+5的方案的模糊程度与标准最为接近（可以取色验证一下），有效地保留了对比度，效果较9+9也不逊色。所以要改用新公式&amp;5+5了。 5+5、9+9 是什么意思呢？是这一段代码： var passCoeff = 3; var t1 = input, t2 = this._tempTarget; t2.clear(); var t:RenderTarget2D; for (var i = 0; i &lt; this.pass * passCoeff; ++i) { // Blur in X direction } for (var i = 0; i &lt; this.pass * passCoeff; ++i) { // Blur in Y direction. } renderer.copyRenderTargetContent(t1, output, clearOutput); 分别对 X 和 Y 方向应用 passCoeff * pass 次快速高斯模糊。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"GLantern 加入滤镜，并发布到了 NPM","slug":"zh/2015-12-22-GLantern-Supports-Filters-and-Is-Published-on-NPM","date":"2015-12-22T15:50:00.000Z","updated":"2020-03-30T22:34:35.430Z","comments":true,"path":"categories/Tech/zh/2015-12-22-GLantern-Supports-Filters-and-Is-Published-on-NPM/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-12-22-GLantern-Supports-Filters-and-Is-Published-on-NPM/","excerpt":"GLantern 于今天调试加入了基本的滤镜支持。同时，0.1.0 版也作为第一个 release 发布到了 NPM 上。","text":"GLantern 于今天调试加入了基本的滤镜支持。同时，0.1.0 版也作为第一个 release 发布到了 NPM 上。 滤镜是高级弹幕很可能会用到的东西，毕竟 BiliBili 的高级弹幕 API 都给出了两个可用滤镜：模糊（blur）和发光（glow）。所以在完成了初步的绘图功能后，首要任务就是加入滤镜。这工作其实在 GLantern 推到 GitHub 之前就开始在做了（所以在第一个 commit 中可以发现完成了一半的滤镜功能），但是一直有很头痛的地方，就是这个： 可以看到，在对一个简单的椭圆进行模糊的时候却出现了许多的“波纹”。基本 shader 我是遵循 Pixi 的结构，但是 Pixi 的表现正常，而我的就不正常。这么明显的事故肯定是不能推的。于是我找了一下高斯模糊的 shader。许多线索都将我引向了这篇文章。于是我就按照文章中所讲述的原理写了一个 shader 测试，结果照样是有波纹。这下子就能确定不是算法上的问题了——从结构上看，二者采用的都是快速的两遍（2-pass）模糊，先 X 方向或 Y 方向，然后是另一个。这是基于统计学的一个常用定理，二维正态分布函数可以分解成两个一维正态分布函数的乘积： A Gaussian function with a distribution of 2σ is equivalent with the product of two Gaussian functions with a distribution of σ. 然而，仔细读了文章之后发现，作者提到，他的图片结果都是连续模糊了9次的： 9-tap Gaussian blur applied nine times with discrete sampling (left) and linear sampling (right). Click for the full resolution of the image. Note that there is no visible difference between the two techniques even after several passes. 也就是说，不是一次成型，而是九次成型。作者专门提到了使用的是 linear sampling 而不是 discrete sampling，设置 r 为模糊半径的话，从算法上来看也只是取了 9 个点（而不是 r*r 个点），想想看，在靠近椭圆边界的地方必然会造成距离边界 kr（k 是整数）的像素处形成一个“峰”或“谷”，也就形成了“波纹”。 发现了这一点之后，将循环上了9次，果然： 浏览了另外的一些资料，认为 Pixi 的 shader 思想应该是来自这里，不仅是预先计算了系数，还利用小的数值几乎解除了模糊操作对图像尺寸这个信息的依赖（采用 0.004 作为一个基础倍数）。这样做减少了一些除法，不过也降低了质量。以下是同样条件下的超级快速 shader 的应用结果： 解决了模糊的问题之后，发光也就顺理成章地出来了（调整了发光颜色，提高区分度）： 写这篇文章之前不久发现了一个问题，模糊半径越大，亮度就越低，超过 60 就很弱了——这是线性采样+循环带来的恶果吗？似乎 Pixi 在模糊半径 160 时都挺正常的，这个原因还有待探究。不过都已经 publish 出去了…… 也有狂人做了真正的高质量模糊 shader（不缩水的正态分布）：这里。各位可以试试调整一下其模糊半径（mSize），值高一点渲染速度马上就下去了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"杂记","slug":"zh/2015-12-19-Misc","date":"2015-12-19T11:04:00.000Z","updated":"2020-03-30T22:34:35.430Z","comments":true,"path":"categories/Misc/zh/2015-12-19-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-19-Misc/","excerpt":"12-17 上传《青空StartingLine》的歌词翻译之后，今天早上收到了审核通过的通知。我照例播放试了试，然后发现，诶，好像有两个翻译的“绿色”被改为“蓝色”了。是上传的时候错了？我查了一下翻译稿，我打的是“绿色”……看来是云音乐的小编改的了。我正想着要发一个评论，又仔细看了看：原文是“青く”，也就是我脑抽望文生义翻成了“绿色”（正确的是“蓝色”）……感谢细心的小编，审核翻译的时候还对着原文看了看（也许只从“为天空涂上绿色”就能看出错误了吧 = =）。对了，三处相同结构，最后一处小编没看到，于是我的黑历史又多了一条。 不管怎么说，云音乐上，恋爱选举巧克力的5首ED，时间轴×5+翻译×5，10/10 全部拿下！","text":"12-17 上传《青空StartingLine》的歌词翻译之后，今天早上收到了审核通过的通知。我照例播放试了试，然后发现，诶，好像有两个翻译的“绿色”被改为“蓝色”了。是上传的时候错了？我查了一下翻译稿，我打的是“绿色”……看来是云音乐的小编改的了。我正想着要发一个评论，又仔细看了看：原文是“青く”，也就是我脑抽望文生义翻成了“绿色”（正确的是“蓝色”）……感谢细心的小编，审核翻译的时候还对着原文看了看（也许只从“为天空涂上绿色”就能看出错误了吧 = =）。对了，三处相同结构，最后一处小编没看到，于是我的黑历史又多了一条。 不管怎么说，云音乐上，恋爱选举巧克力的5首ED，时间轴×5+翻译×5，10/10 全部拿下！ 12-19 黑道圣徒4（Saints Row 4）的一些 neta： Independence Day：你看看开场…… The Matrix：这是最明显的了，贯穿全篇的恶搞对象。例如，意识逃出虚拟世界到了一个布满人类胶囊的机器房间、四周是屏幕的房间（Neo 会见 The Architect 的房间）、红蓝门（the red/blue pill）、超能力训练、警察会（数据化地）变为 Zin（对应 Agents）。 Harry Potter：Kinzie 提示说如果要立即降低通缉度，要抓住那个“golden orb”。考虑到这个金球的行为方式，明显是在说金色飞贼（Golden Snitch）。 Game of Thrones：有一个关卡的名称是 A Game of Clones，就是要解决那些分身为旧敌对帮派成员的那些数据。标题我认为是对 Game of Thrones 的恶搞，毕竟专门弄一个结构和读音相似的标题，加上这游戏连自己都不放过（参见 DLC 支线 Enter the Dominatrix 中的对话——当然，这标题是对 The Matrix 衍生的游戏 Enter the Matrix 的模仿），很容易让人联想到 GoT。 Doctor Who：在 DLC 支线 How the Saints Saved Chirstmas 中，第二关 Fight before Chirstmas 出了山洞往右边拐，本来是想完成找雪人成就的，结果在第一个岔路通往的山洞就发现了标着“Turdis”的单人公厕类似物，有人在里面呕吐。TARDIS 君，走好。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"第一个 pull request 被 merge 纪念","slug":"zh/2015-12-15-First-Pull-Request-Merged","date":"2015-12-15T15:12:00.000Z","updated":"2020-03-30T22:34:35.430Z","comments":true,"path":"categories/Misc/zh/2015-12-15-First-Pull-Request-Merged/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-15-First-Pull-Request-Merged/","excerpt":"","text":"第一次提出 PR，被 merge！走出了第一步。鉴于 Notepad++ 那个只是一个普通的 issue……这次算是真的为社区做了点贡献吧？ 推 PR 的时候，真的就像是这篇文章中说的： 「我可没有说大话，」Garland 想起自己第一次把代码添加到团队正在建设的网页中那段经历还是心有戚戚焉，「我呆坐在电脑前长达 15 分钟，才有勇气按下提交的按钮。」 列出指定目录下的前20大文件： $ find / -type f -print0 | xargs -0 du -h | sort -hr | head -20","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"代码","slug":"代码","permalink":"https://blog.mottomo.moe/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"杂记","slug":"zh/2015-12-13-Misc","date":"2015-12-13T15:06:00.000Z","updated":"2020-03-30T22:34:35.430Z","comments":true,"path":"categories/Misc/zh/2015-12-13-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-13-Misc/","excerpt":"摘要： 瑞福问我“洞洞，你看上去没有以前那么快乐了”； 劣币驱逐良币。","text":"摘要： 瑞福问我“洞洞，你看上去没有以前那么快乐了”； 劣币驱逐良币。 参加上面那会之前，收到了瑞福的微信，问晚上要不要去五道口吃一顿。晚上吃完之后，推着自行车（嗯，我还是问同学借的）一路从展春园西路和成府路相交处的粤味餐厅走到清华瑞福的宿舍下。在路过大概在人文图书馆的时候，瑞福说了一句让我内心一震的话： 洞洞，我感觉你看上去没有以前那么快乐了。 噫！在不知不觉间，将自己“镇静”过去了，还是逃不过旁人的目光呢。 和瑞福认识有快10年了，从初中到现在。在高三那最后的日子里，我的压力比同班同学要大很多——因为虽然理综在中位，英语在前几，但是语文和数学简直是要命。当然，对于我来说高考失利基本上就会被甩出主流，即使后续转好也会不自觉地纠结这事情，因为履历并没有其他人那么完美。 在这段时间，我只记得自己每天就是练习册、卷子，社交的活动只是在宿舍里的那些交流。啊呀，可惜我的大脑被“优化”到忘记了许许多多的细节，只记得下午有机会就会找人玩三国杀到剩十分钟到晚自习，而其他的对话（如洗饭盒、洗收衣服时的）都忘了，空余一个“这是一个事件发生时间段”的壳。我本来就没有多少社交性的对话，多为功能性的对话。 在这段最艰苦的时间，如果按照瑞福的标准，我还是很快乐的——即使未来十分令人担忧。现在又到了一个岔路口，现在的我，没有从前那么快乐了。 我回答： 高中的时候就像是围了一堵墙，它将你和社会隔开了。虽然是封闭的，但是在里面是一个理想中的环境，你不用关心其他什么事。到了大学就不同了，你看到的东西更多了，你可以接触更广泛的世界，而更广泛的世界也可以接触你，不光是好的一面，还有那些阴暗面。 大二上学期末入了坑，然后以此为跳板了解音乐和游戏，所以今年的封禁和版权组合拳极大地触动了我的神经，而且渲染了悲观的情绪。当开始想国家想人类始源的时候，经过推演，理想规划是不可能达到的——如果人不遵从理性的话——而观察到的事例已经让我不相信人类能作为一个整体进入这个阶段（一部分必将会被“吐”出去，剩下的随着演化也会不断重复这个过程），摆在眼前的就是明显的结论——人类只有死路一条，而且人不够格作为理性的种族。在现世没有一个拯救人的方案，原因竟然是人就是如此。多么灰暗！在其中只能看到眼前的一点残明，而远一点就是无尽的黑暗。 看到了墙外的真实，单纯造就的快乐早就被一点一点地磨去了。 格雷欣法则（Gresham’s Law），也称为劣币驱逐良币现象。这个现象和人心息息相关。 这是发生在澳大利亚的一次利用维基百科的事件。维基百科提供的是自由状态下的公信力，而当出现被利用的情况，势必会造成其公信力的丧失。货币是以国家信用为担保的等价物，当出现了可以通过此等价物进行信用损耗或信用本身被损耗的时候，到了一个极端水平，就会发生“除旧迎新”的事，参考津巴布韦元。另外，你看看知乎是怎么一步步地陷入民粹的泥沼的。 推理（又跳步了……），这还是源自祖宗留给我们的保命用的保守策略——简单说，就是尽量别吃眼前亏，谁知道你活不活得到美好的“将来”呢？ 由此产生的循环也是我上面做出“演化重复”结论的根据。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"工程伦理","slug":"zh/2015-12-13-Engineering-Ethics","date":"2015-12-13T13:33:00.000Z","updated":"2020-03-30T22:34:35.429Z","comments":true,"path":"categories/Misc/zh/2015-12-13-Engineering-Ethics/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-13-Engineering-Ethics/","excerpt":"关于下午的座谈会中一个外国大学教授问到的工程伦理（engineering ethics）。","text":"关于下午的座谈会中一个外国大学教授问到的工程伦理（engineering ethics）。 今天下午开了学院的一个教学评估（academic program assessment），最后专门设了一场座谈，问一些问题，让学生（国内和国际的）来说说当前的学习环境以及希望需要有什么改变。 前面的我觉得问的都是普通的问题，比如“你们有什么语言和协作课程”“学校开的课程给你们什么提高”“如果你能改变教育系统你希望做什么”、问国际学生“你为什么来”“是否推荐家乡的其他人来就读，为什么”。最后的最后，差不多到预定的结束时间，坐在7个人正中的，主导发言的，估计是此团的团长，问了一个问题：“OK, this is really the FINAL question. Is there any course that teaches engineering ethics?” 听到的时候，我都懵了。ethics？我没听错吧？为什么突然讲到 ethics？在场的各位也表现出惊异的样子，所以团长慢慢重复了一遍：“Ethics, yes, ethics. Ethics, E-T-H-I-C-S.”这时我才确定没听错。然后大家开始问 ethics 什么意思（不是我吐槽，我是在怀疑在场各位的英语水平）——难道你们熟悉 morality 就不熟悉 ethics 了么？然后有个女生就说：“啊，是思想品德之类的啊。”OK，话题被成功误导到了“是否开设了类似思品课的课程”这个方向上。然后他们就说，我们大学没有思品，学的都是政治…… 在他们说的时候我回想了一下，虽然前面声音比较弱，但是我确实听到的是“engineering ethics”而不只是“ethics”。 什么是 engineering ethics（工程伦理）呢？是一种从章程和既有案例衍生出的某个行业的行为约束。 我大二的时候读过一部分 Thinking Like an Engineer: Studies in the Ethics of a Profession 的译文版（感谢老爸在我高三结束后某天买回来，当时想的也只是我的专业是工科，归为 engineer 一类，让我看点这方面的哲学书）。这本书就是讲工程伦理的起源、实践案例和讨论，可惜我当时还是太年轻，没有静下心去啃里面艰深而精彩的论述。其中就讲了海丘勒吾（Hydrolevel）公司的案例：McDonnell and Miller 公司质询 ASME，认为一个其采纳的标准规范本来可以用简单方式而非规定的方式解决，这个小题大做的规定可能是受到 Hydrolevel 公司的“影响”导致给了 Hydrolevel 公司巨大的竞争优势，破坏了市场的公平。大家都知道标准和推荐性的标准（例如 GB 和 GB/T）必须是公正的、客观的，若其中出现了不公正内容，就可能失去作为标准的公信力。接下来就是查证，确认这个规定在通过（以及被申诉）的时候有没有受到某个利益方的影响，以及规定本身是否是真正服务于用户的。（这让人想起来维基百科上也在发生着中立性争议(EN)，这是学术上的操守事项。） 好，回到现场。当时我恢复了一点点记忆，想起来我确实看过工程伦理的东西，但是内涵和鲜活的例子想不起来了（叫你不认真看书！）。于是在伤停补时（OwO）的时候补充了一个事（对，现在看起来这个行为挺羞耻的，情急之下语言也是混乱的，暴露了半桶水的本质）： But some professors do well in this. For example, Professor Liu1, in his last class, he cross-checked all the papers that we handed in in some classes before, and listed all the cheaters. (Visiting group members laugh out loud.) I think he did well in this case. 1 刘继红老师，教我们机械设计这门课的，推荐上几次课感受一下，别忘了发表一下感想。我保持中立。 在合影的时候，我听着前面几个女生还在讨论为什么问思品，我直接上去给她们灌输了不准确的工程伦理解释（“国外工程师这个行业是有专门的道德规范的，例如保留数据、不要弄虚作假什么的”）……再往前一排的对应位置是一个香港（港中文还是港理工还是港科技忘了忘了）的教授，普通话肯定是听得懂的，不知道他听到这个二十多岁的人说出这种不准确的话的时候对这个说话者是怎么看的，同时通过这个说话者对学校又是怎么看的。也许只是没注意。 又多了黑历史……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"VS2015U1 的使用问题基本上解决了","slug":"zh/2015-12-12-VS-Problem-Almost-Solved","date":"2015-12-12T11:52:00.000Z","updated":"2020-03-30T22:34:35.429Z","comments":true,"path":"categories/Misc/zh/2015-12-12-VS-Problem-Almost-Solved/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-12-VS-Problem-Almost-Solved/","excerpt":"从上次的尝试结果继续。这都是昨天到今天的事了。","text":"从上次的尝试结果继续。这都是昨天到今天的事了。 打开错误日志，经过一番过滤，大概找到了关键问题的发生处。 [2EC0:1C2C][2015-12-11T02:27:39]i000: SI: Processing product entry: &#39;PowerShellToolsV1&#39;. [2EC0:1C2C][2015-12-11T02:27:39]i000: SI: Downloading file: &#39;http://go.microsoft.com/fwlink/?LinkID=616995&#39; [2EC0:1C2C][2015-12-11T02:27:55]i000: SI: Downloaded file: &#39;http://go.microsoft.com/fwlink/?LinkID=616995&#39; to location &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\PowerShellToolsV1\\en\\1\\PowerShellTools.14.0.vsix&#39; [2EC0:1C2C][2015-12-11T02:28:10]i000: SI: Certificate not valid for file:D:\\Downloads\\VS2015\\OfflineCache\\installers\\PowerShellToolsV1\\en\\1\\PowerShellTools.14.0.vsix [2EC0:1C2C][2015-12-11T02:28:10]e000: SI: System.ApplicationException: Downloaded file failed signature verification and may have been tampered with 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.ThrowOnDownloadFailedTrustVerification(String downloadedPath) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.Execute(OfflineCacheSnapshot snapshot, String offlineFeedPath, ProductEntry entry, XmlNamespaceManager namespaceManager, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.Tasks.OfflineTaskManager.AddProduct(OfflineCacheSnapshot snapshot, String onlineFeedPath, String offlineFeedPath, String productId, ILogger logger, Func`1 checkIfUserCanceled) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.OfflineCacheManager.SyncProducts(UpdateMode updateMode, ICollection`1 productIds, String parent, String callerBaseDirectory, Func`1 checkIfUserCanceled) [2EC0:1C2C][2015-12-11T02:28:10]i000: SI: Processing product entry: &#39;Win10_VSTools_14.0.24720&#39;. [2EC0:1C2C][2015-12-11T02:28:10]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_VSTools_14.0.24720\\en\\0\\Windows_VSTools.exe&#39; [2EC0:1C2C][2015-12-11T02:28:10]i000: SI: Starting burn layout for product &#39;Win10_VSTools_14.0.24720&#39;. Command line: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_VSTools_14.0.24720\\en\\0\\Windows_VSTools.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_VSTools_14.0.24720\\en\\0&quot;&#39; [2EC0:1C2C][2015-12-11T02:30:42]i000: SI: Burn layout exit code for product &#39;Win10_VSTools_14.0.24720&#39; is &#39;0&#39; [2EC0:1C2C][2015-12-11T02:30:42]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_VSTools_14.0.24720\\zh-CHS\\0\\Windows_VSTools.exe&#39; [2EC0:1C2C][2015-12-11T02:30:42]i000: SI: Starting burn layout for product &#39;Win10_VSTools_14.0.24720&#39;. Command line: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_VSTools_14.0.24720\\zh-CHS\\0\\Windows_VSTools.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_VSTools_14.0.24720\\zh-CHS\\0&quot;&#39; [2EC0:1C2C][2015-12-11T02:34:17]i000: SI: Burn layout exit code for product &#39;Win10_VSTools_14.0.24720&#39; is &#39;0&#39; [2EC0:1C2C][2015-12-11T02:34:17]i000: SI: Processing product entry: &#39;Win10SDK_10.0.10586.15&#39;. [2EC0:1C2C][2015-12-11T02:34:17]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_10.0.10586.15\\en\\0\\sdksetup.exe&#39; [2EC0:1C2C][2015-12-11T02:34:17]i000: SI: Starting burn layout for product &#39;Win10SDK_10.0.10586.15&#39;. Command line: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_10.0.10586.15\\en\\0\\sdksetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_10.0.10586.15\\en\\0&quot;&#39; [2EC0:1C2C][2015-12-11T02:34:20]i000: SI: Burn layout exit code for product &#39;Win10SDK_10.0.10586.15&#39; is &#39;-2146889721&#39; [2EC0:1C2C][2015-12-11T02:34:20]e000: SI: System.ApplicationException: Burn layout for &#39;Win10SDK_10.0.10586.15&#39; failed with exit code &#39;-2146889721&#39;. 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.ExecuteBurnLayout(String productId, String installer, String layoutDirectory, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.Execute(OfflineCacheSnapshot snapshot, String offlineFeedPath, ProductEntry entry, XmlNamespaceManager namespaceManager, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.Tasks.OfflineTaskManager.AddProduct(OfflineCacheSnapshot snapshot, String onlineFeedPath, String offlineFeedPath, String productId, ILogger logger, Func`1 checkIfUserCanceled) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.OfflineCacheManager.SyncProducts(UpdateMode updateMode, ICollection`1 productIds, String parent, String callerBaseDirectory, Func`1 checkIfUserCanceled) [2EC0:1C2C][2015-12-11T02:34:20]i000: SI: Processing product entry: &#39;AppInsightsToolsVisualStudio_HiddenV2_4.0.51117.1&#39;. [2EC0:1C2C][2015-12-11T02:34:20]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\AppInsightsToolsVisualStudio_HiddenV2_4.0.51117.1\\en\\0\\AppInsights_VisualStudio.msi&#39; [2EC0:1C2C][2015-12-11T02:34:20]i000: SI: Processing product entry: &#39;Win10_Emulator_10.0.10240&#39;. [2EC0:1C2C][2015-12-11T02:34:20]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10240\\en\\0\\EmulatorSetup.exe&#39; [2EC0:1C2C][2015-12-11T02:34:20]i000: SI: Starting burn layout for product &#39;Win10_Emulator_10.0.10240&#39;. Command line: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10240\\en\\0\\EmulatorSetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10240\\en\\0&quot;&#39; [2EC0:1C2C][2015-12-11T02:35:07]i000: SI: Burn layout exit code for product &#39;Win10_Emulator_10.0.10240&#39; is &#39;-2146889721&#39; [2EC0:1C2C][2015-12-11T02:35:07]e000: SI: System.ApplicationException: Burn layout for &#39;Win10_Emulator_10.0.10240&#39; failed with exit code &#39;-2146889721&#39;. 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.ExecuteBurnLayout(String productId, String installer, String layoutDirectory, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.Execute(OfflineCacheSnapshot snapshot, String offlineFeedPath, ProductEntry entry, XmlNamespaceManager namespaceManager, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.Tasks.OfflineTaskManager.AddProduct(OfflineCacheSnapshot snapshot, String onlineFeedPath, String offlineFeedPath, String productId, ILogger logger, Func`1 checkIfUserCanceled) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.OfflineCacheManager.SyncProducts(UpdateMode updateMode, ICollection`1 productIds, String parent, String callerBaseDirectory, Func`1 checkIfUserCanceled) [2EC0:1C2C][2015-12-11T02:35:07]i000: SI: Processing product entry: &#39;Win10_Emulator_10.0.10586.11&#39;. [2EC0:1C2C][2015-12-11T02:35:07]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10586.11\\en\\0\\EmulatorSetup.exe&#39; [2EC0:1C2C][2015-12-11T02:35:07]i000: SI: Starting burn layout for product &#39;Win10_Emulator_10.0.10586.11&#39;. Command line: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10586.11\\en\\0\\EmulatorSetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10586.11\\en\\0&quot;&#39; [2EC0:1C2C][2015-12-11T02:35:10]i000: SI: Burn layout exit code for product &#39;Win10_Emulator_10.0.10586.11&#39; is &#39;-2146889721&#39; [2EC0:1C2C][2015-12-11T02:35:10]e000: SI: System.ApplicationException: Burn layout for &#39;Win10_Emulator_10.0.10586.11&#39; failed with exit code &#39;-2146889721&#39;. 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.ExecuteBurnLayout(String productId, String installer, String layoutDirectory, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.Execute(OfflineCacheSnapshot snapshot, String offlineFeedPath, ProductEntry entry, XmlNamespaceManager namespaceManager, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.Tasks.OfflineTaskManager.AddProduct(OfflineCacheSnapshot snapshot, String onlineFeedPath, String offlineFeedPath, String productId, ILogger logger, Func`1 checkIfUserCanceled) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.OfflineCacheManager.SyncProducts(UpdateMode updateMode, ICollection`1 productIds, String parent, String callerBaseDirectory, Func`1 checkIfUserCanceled) [2EC0:1C2C][2015-12-11T02:35:10]i000: SI: Processing product entry: &#39;Win10SDK_Hidden_10.0.10240&#39;. [2EC0:1C2C][2015-12-11T02:35:10]i000: SI: Using existing file: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_Hidden_10.0.10240\\en\\0\\sdksetup.exe&#39; [2EC0:1C2C][2015-12-11T02:35:10]i000: SI: Starting burn layout for product &#39;Win10SDK_Hidden_10.0.10240&#39;. Command line: &#39;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_Hidden_10.0.10240\\en\\0\\sdksetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_Hidden_10.0.10240\\en\\0&quot;&#39; [2EC0:1C2C][2015-12-11T02:35:13]i000: SI: Burn layout exit code for product &#39;Win10SDK_Hidden_10.0.10240&#39; is &#39;-2146889721&#39; [2EC0:1C2C][2015-12-11T02:35:13]e000: SI: System.ApplicationException: Burn layout for &#39;Win10SDK_Hidden_10.0.10240&#39; failed with exit code &#39;-2146889721&#39;. 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.ExecuteBurnLayout(String productId, String installer, String layoutDirectory, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.InstallerProductTask.Execute(OfflineCacheSnapshot snapshot, String offlineFeedPath, ProductEntry entry, XmlNamespaceManager namespaceManager, ILogger logger) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.Tasks.OfflineTaskManager.AddProduct(OfflineCacheSnapshot snapshot, String onlineFeedPath, String offlineFeedPath, String productId, ILogger logger, Func`1 checkIfUserCanceled) 在 Microsoft.Web.PlatformInstaller.CommandLine.Offline.OfflineCacheManager.SyncProducts(UpdateMode updateMode, ICollection`1 productIds, String parent, String callerBaseDirectory, Func`1 checkIfUserCanceled) 所以什么东西缺失了就很清楚了。简单写了一个小程序。 private static void work(String listFileName) throws IOException { ArrayList&lt;String&gt; commands = new ArrayList&lt;&gt;(); BufferedReader reader = new BufferedReader(new FileReader(listFileName)); String command = null; int currentIndex = 0; int commandCount; while ((command = reader.readLine()) != null) { if (command.length() &gt; 0) { commands.add(command); } } reader.close(); if (commands.isEmpty()) { return; } commandCount = commands.size(); @NotNull Process process; while (currentIndex &lt; commandCount) { try { command = commands.get(currentIndex); log(command, currentIndex + 1, commandCount); process = Runtime.getRuntime().exec(command); process.waitFor(); log(process.exitValue()); process.destroy(); if (process.exitValue() == 0) { currentIndex++; } } catch (IOException | InterruptedException ex) { ex.printStackTrace(); } } out.println(&quot;Completed: &quot; + Integer.toString(commandCount) + &quot; tasks.&quot;); } 轰炸式运行下面的命令行： D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_10.0.10586.15\\en\\0\\sdksetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_10.0.10586.15\\en\\0&quot; D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10240\\en\\0\\EmulatorSetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10240\\en\\0&quot; D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10586.11\\en\\0\\EmulatorSetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10_Emulator_10.0.10586.11\\en\\0&quot; D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_Hidden_10.0.10240\\en\\0\\sdksetup.exe /quiet /layout &quot;D:\\Downloads\\VS2015\\OfflineCache\\installers\\Win10SDK_Hidden_10.0.10240\\en\\0&quot; 经过8个小时（凌晨四点到中午十二点），花费了大量的流量，终于搞定了。Python 那个，没有一个校验的命令行，所以无法自动做。 关于为什么这么频繁地失败，我做了一下抓包。发起请求（向 download.microsoft.com）下载一个包的时候，URI 是正常的，同时我 nslookup 了一下，解析也是正常的，但是最后总会302跳转到一个 10.254.*.*（内网）的地址上，发回无效的内容，于是校验就失败了。不知道是什么人污染了。 可以注意到，这是 offline cache，在VS的ISO中是不带的。（也就是说，自身不带 Windows SDK！） 看到4个任务都完成，运行 vs_community.exe，可视化安装。但是还是和以前一样，报告 UWP CRT 安装失败，像这种。回到 OfflineCache 一看，经过installer对可选项的burn操作，内容又缺失了。无奈只好重新来，这次主攻两个10586。 傍晚完成，手工切到SDK目录，用自带的 sdksetup.exe 可视化安装，正常。再次打开 vs_community，安装好的东西被识别为 UWP 和工具版本1.2。 运行VS，还是报 ResourceManagerPackage 包加载错误。按照网上的一些解决方案（123）全都失败了。同时还搭上了 Azure，和方案1中的报错差不多。 卸载，从零开始。碰上了 LocalESPCui 卡死，幸好有前人将解决过程放在了网上。 按照上面的修复后继续运行默认安装器，安装自动继续。完成后我再让其进行完整修复重启，终于能运行了。然后导入原有的设置。有小小的问题，虽然版本号对了，但是有界面元素还是RTM而不是U1的，看得出。 然后试验了一下工程模板，UWP处于需要安装状态，就让它自动安装，去睡觉了（三点）。 现在正常了，图标（笑脸-&gt;用户图标）也正常了。 不过 TypeScript 支持损坏了，原因是无法加载 Microsoft.Web.Editor 程序集。安装了一个Java 语言支持插件也有程序集的问题。不过幸好语言选择除了 C# 和 VB.NET 之外的我都是用着 JetBrains 的产品，不怎么受影响（也许如果写 ASP.NET 可能会有？）。 还没有试验 C# 的工程；不过下午受人所托编译了一下原来的一个mod，C++用的是12.0(2013)的工具链，工作正常。 先到这里吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.mottomo.moe/tags/Visual-Studio/"}]},{"title":"只是稍稍冒泡而已","slug":"zh/2015-12-10-Resume","date":"2015-12-10T09:45:00.000Z","updated":"2020-03-30T22:34:35.429Z","comments":true,"path":"categories/Misc/zh/2015-12-10-Resume/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-10-Resume/","excerpt":"","text":"GitHub 推了两个repo，一个 TbKickstartExtract 一个 GLantern。前者是给同学做的一个简单的抓淘宝众筹数据的东西；后者是 Bulletproof 分离出来的图形上的代码，Bulletproof 重新组织之后引用的就会是这个，它还是我自动化构建的入门。 推了两个repo之后觉得，如果有谁关注了博客和 GitHub 动态（自作多情啦捂脸）的话就会发现“咦，这小子怎么言行不一致啊”，所以就推了博客的更新。 嘛，生存的东西还没搞定，在去向落实之前还是要分精力出去。 PS. 毕设的题目被分配（对，你没看错，是直接分到人头上，然后给你发通知说你就做这个）到了一个 DirectX 渲染的东西，这不是给我助攻么？顺便，这就是为什么我这么着急要将 VS 修好；修不好只好放大招重装系统了。 PPS. 翻译量过25纪念","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"升级到 Visual Studio 2015 Update 1 之后遇到的一个问题","slug":"zh/2015-12-08-A-VS-2015-Update-1-Problem","date":"2015-12-08T01:46:00.000Z","updated":"2020-03-30T22:34:35.428Z","comments":true,"path":"categories/Misc/zh/2015-12-08-A-VS-2015-Update-1-Problem/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-12-08-A-VS-2015-Update-1-Problem/","excerpt":"升级到 Visual Studio 2015 Update 1 后遇到的一个（可能是由 API 变更导致的）问题及诊断过程。（未完成，仅记录）","text":"升级到 Visual Studio 2015 Update 1 后遇到的一个（可能是由 API 变更导致的）问题及诊断过程。（未完成，仅记录） 自从大三课程设计做的那个蛋疼的 ERP 之后（选用了 VB .NET，开发效率以一敌十），就没用过 Visual Studio 了。最近 Update 1 发布了，本着尝一下那些标称的改进的心态更新了。但是在安装时，手抽打了一个 Simplified Chinese language pack（BCL 自带的那些文档都是英文的了，不像以前有本地化的版本，看着怪不舒服的），然后在“正在更新 CHS 资源”那僵持了半个多小时。我看着任务管理器，CPU 和磁盘都没有活动，但是无法判断其在采取什么行动，脑抽虽然看着小圆点在动但是还是判断流程卡死，将安装任务强行结束了。在结束的瞬间，安装状态发生了变化…… 这就是麻烦的开始。 昨天想玩一下 C# Interactive（C# REPL），打开视图-其他窗口-C# Interactive。瞬间跳出一个错误，说是 Roslyn 包加载失败，然后又跳了一次。Roslyn 包加载失败？这不就意味着几乎所有的代码分析要废了么？赶紧打开一个 C# 工程，报 CSharp 包加载失败。明显这是不修不行了。 于是在程序与功能中选择 VS 2015 的修复选项，进度条走到最后状态栏变黄（出现警告）了： 10586 SDK 哈希错误；VCRT因有其他版本而无法安装×2；VSIX找不到条目； 卸载：VSIX 安装：10586； 手工卸载（含VCRT）—— SQL Server Compact Edition 找不到路径 再安装，除去 Emulator for Android、10586 报VSIX，无其他错误 每次启动都在加载项目时崩溃 https://www.devexpress.com/Support/Center/Question/Details/T269599 然后禁用几乎所有扩展，重装还是崩溃 一个提示引起了注意 WebEssentials: Applied global settings. 然后禁用了 WebEssentials，正常了，能用 C# 了。 注意 ISO SHA-1 校验通过 UWP C++ 不能用，因为 UWP &amp; C++ 安装失败，从这里 https://social.msdn.microsoft.com/Forums/vstudio/en-US/643464f5-5b41-4d98-8d60-3216ee09c1f5/visual-studio-2015-rtm-windows-10-sdk-10010240-the-installer-failed-the-hash-value-is-not?forum=vssetup 到这里 https://social.msdn.microsoft.com/Forums/vstudio/en-US/bfc4c36d-88d3-4b65-9208-580ee1c1d19d/windows-10-sdk-10010240-the-installer-failed-fatal-error-during-installation-error-code?forum=vssetup&amp;prof=required 有点眉目，解决中 原生 C++ 也不能用（IntelliSense 需要 SSCE）：http://stackoverflow.com/questions/10739845/how-to-deploy-sql-server-compact-edition-4-0 找到文件夹，删除干净，C:\\Program Files\\Microsoft SQL Server Compact Edition 只有一个空的 INSTALLER 文件，导致被认为安装了。再来，选择x64，安装。 回到UWP，删除了 Program Cache 下所有的 Win10 SDK 相关条目，但是居然能正常安装，说明识别位置不在这里 手工到Win10_UniversalCRTSDK包安装，拒绝（Gathering required information 之后就直接跳出，和SSCE表现一样） 找到 Program Files (x86)\\Windows Kits\\10，删除 Include 和 Lib，安装时说要 insert disk 删除整个 10，还说要disk 这时从光盘添加功能，失败。 查阅记录， [19C8:257C][2015-12-08T12:24:48]i000: Setting numeric variable ‘Win10_Universal_CRT_SDK_Redistributable_KeyExists’ to value 1[19C8:257C][2015-12-08T12:24:48]i000: Setting string variable ‘Win10_Universal_CRT_SDK_Redistributable_KeyVersion’ to value ‘10.0.26624’[19C8:257C][2015-12-08T12:24:48]i000: Setting numeric variable ‘Win10_Universal_CRT_SDK_Tools_x64_KeyExists’ to value 1[19C8:257C][2015-12-08T12:24:48]i000: Setting string variable ‘Win10_Universal_CRT_SDK_Tools_x64_KeyVersion’ to value ‘10.0.26624’[19C8:257C][2015-12-08T12:24:48]i000: Setting numeric variable ‘Win10_Universal_CRT_SDK_Tools_x86_KeyExists’ to value 1[19C8:257C][2015-12-08T12:24:48]i000: Setting string variable ‘Win10_Universal_CRT_SDK_Tools_x86_KeyVersion’ to value ‘10.0.26624’[19C8:257C][2015-12-08T12:24:48]i000: Setting numeric variable ‘Win10_UniversalCRTSDK_KitsRootKeyExists’ to value 1[19C8:257C][2015-12-08T12:24:48]i052: Condition ‘Win10_UniversalCRTSDK_KitsRootKeyExists’ evaluates to true.[19C8:257C][2015-12-08T12:24:48]i000: Setting string variable ‘Win10_UniversalCRTSDK_KitsRootKeyPath’ to value ‘C:\\Program Files (x86)\\Windows Kits\\10\\’ 这不是开玩笑么 注册表找不到条目 尝试用 vs_community /layout 重来，但是要多次下载失败才成功一次手都酸了，到现在都没好","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.mottomo.moe/tags/Visual-Studio/"}]},{"title":"GLantern 的 RenderTarget alpha 问题解决","slug":"zh/2015-11-29-GLantern-RenderTarget-Alpha-Problem-Solved","date":"2015-11-29T08:02:00.000Z","updated":"2020-03-30T22:34:35.428Z","comments":true,"path":"categories/Tech/Coding/zh/2015-11-29-GLantern-RenderTarget-Alpha-Problem-Solved/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-11-29-GLantern-RenderTarget-Alpha-Problem-Solved/","excerpt":"困扰许久的 alpha 问题终于解决了。这个问题在上个 Bulletproof 的进度报告中也提到，不知道是哪里的问题：图层alpha、上下文设置、shader 计算、给的原始点颜色数据。这次将 Flash 的部分抽出来，在未计算图层 alpha 的时候就测试，间接排除了第一种情况；直觉上第四个概率很小。接下来的就是二选一，今天突然想到 Pixi 的颜色结果是正常的，clone 了下来直奔主题。 详述在下文。","text":"困扰许久的 alpha 问题终于解决了。这个问题在上个 Bulletproof 的进度报告中也提到，不知道是哪里的问题：图层alpha、上下文设置、shader 计算、给的原始点颜色数据。这次将 Flash 的部分抽出来，在未计算图层 alpha 的时候就测试，间接排除了第一种情况；直觉上第四个概率很小。接下来的就是二选一，今天突然想到 Pixi 的颜色结果是正常的，clone 了下来直奔主题。 详述在下文。 我以前的初始化代码是这样的： var glc = this._context; glc.disable(gl.DEPTH_TEST); glc.disable(gl.CULL_FACE); glc.enable(gl.BLEND); glc.blendEquation(gl.FUNC_ADD); glc.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); Pixi 里的是这样的（src/core/renderers/webgl/WebGLRenderer.js）： var gl = this.gl; // set up the default pixi settings.. gl.disable(gl.DEPTH_TEST); gl.disable(gl.CULL_FACE); gl.enable(gl.BLEND); 很可能是 glBlendFunc() 的设置问题？由于 WebGL 书上的例子采用的都是 alpha/1-alpha 的设置，我用惯了 GDI+ 而 GDI+ 中核心的 AlphaBlend() 在混合时采用的也是 alpha/1-alpha 方式，我就很自然地将这一行放了上去。然后就出现了如二次函数般的颜色衰减。我想是不是混合模式的问题，将最后一行注释掉，结果就正常了。 var glc = this._context; glc.disable(gl.DEPTH_TEST); glc.disable(gl.CULL_FACE); glc.enable(gl.BLEND); glc.blendEquation(gl.FUNC_ADD); //glc.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); 照这么看，默认采用的混合模式应该是 alpha/1（正确结果是线性衰减而不是二次衰减）。（测试，结果为 1/0。）杨彦君说的是按照自发光且带alpha来理解，但是……由于在 GDI+ 经历的都只是实色混合模型而不是颜色光照模型，不太能理解这种想法…… 再次订正于12月3日： 12月1日，上面这个 1/0 的配置，上了图层测试之后就原形毕露了：先画的图层全部消失，因为未使用目标像素（DST = 0）。又蛋疼了两天。 继续读 Pixi 的源代码，在 GraphicsRenderer.render() 方法中发现了一个对 setBlendMode() 的调用，而且是每次元素绘制之前都会调用。混合模式在 GDI+ 和 Photoshop 里都见过，控制通道的混合输出。顺藤摸瓜在 WebGLRenderer 中找到了 BLEND_MODE 和 blendFunc() 参数的映射。搜索 BLEND_MODE 发现默认的混合模式（最常见的是在滤镜应用前重设）是 BLEND_MODE.NORMAL，对应的参数配置是 1/1-alpha。考虑到 GLantern 采用的是与 Pixi 类似的缓冲格式（Pixi 是 XYRGBA，放在一个缓冲区，GLantern 是 XYZ + RGBA，放在两个缓冲区；颜色都预乘，GL 环境预乘开），其中颜色是相同的，那么应用同样的配置就应该能得到相同的结果。 于是加入混合模式机制，采用相同的映射，尝试绘制。此时才真正成功了。 细想一下，1/1-alpha 的配置也应该是很好理解的……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"降世神通：科拉传奇 游戏简单记录","slug":"zh/2015-11-28-The-Legend-of-Korra-Game","date":"2015-11-28T15:21:00.000Z","updated":"2020-03-30T22:34:35.428Z","comments":true,"path":"categories/Misc/zh/2015-11-28-The-Legend-of-Korra-Game/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-11-28-The-Legend-of-Korra-Game/","excerpt":"这一周趁着 Steam 特卖，入手了 The Legend of Korra，一个晚上的时间就通关了。 本文是其的简单记录，有轻微剧透。","text":"这一周趁着 Steam 特卖，入手了 The Legend of Korra，一个晚上的时间就通关了。 本文是其的简单记录，有轻微剧透。 游戏和剧集的故事基本上是独立的，看时间是发生在 Season 2 之后不久。（废话，看游戏的推出时间和剧集的播出时间。） 一开始我是很不熟悉的，Chapter 3 打第一个大萝卜头和之后广场对战三基佬，都用了我接近40分钟。大萝卜头最终还是靠慢慢闪避+耗解决的，三基佬在轻松用反击解决 firebender 后熬 waterbender 却经常被 earthbender 单虐。到了 Chapter 5 结束开了 airbending 之后，就能试验四种能力的特性了。 我摸索出的特征是：waterbending 适合于远程，而且空中打击可以躲避大部分伤害，但是重击只能对于前方一定距离处到一定距离处的敌人（不是贴身）；earthbending 威力大，但是出招慢，而且在空中或者太小的地面上就无法出招（被狠揍）；firebending 在连续普通攻击时有自动跟踪效果（人会自动“瞬移”到下一个目标处），速度奇快，而且对萝卜头的出招是在空中的（几乎可以避开萝卜头的所有物理攻击），缺点是只能近身攻击；airbending 适合于清扫身边大范围的敌人，而且起跳后可以在空中维持一个旋风进行隔空移动（越过深沟时很好用），但威力较弱。综合使用四种方式的优势，可以应对不同的环境。 游戏内商店的东西不多，而且物品描述是一直显示出来的，所以我仔细读了一下所有的。然后我发现了三个神器，推多了几次，买了下来，之后各种数据就开始轻松刷了。 首先入手的是自动恢复生命值的东西，接下来入手HP上限减半换永远满气的东西（这个很贵，多刷一些经验），最后是一个加速的东西（能一定程度提高评分以换取更高经验）。有一个HP上限减半换经验加倍的东西，在我的方案中是不需要的，而且一旦装上反而是很危险的。多刷经验，买各种招式，大概三四十次就能将所有的御术升到满级10级，这样HP上限也会升到最大值（弥补减半带来的不足），对付各种敌人简直是不能再轻松了。其他的物品就慢慢刷，反正是没有多大必要的。反正我们技术是够，HP条基本上是不会掉光的，更何况还有一个回血的装备在呢。 一些小技巧： 锁定目标后可以不用 waterbending 的远程而直接用 firebending 快速普通攻击，就不用费力地将敌人打下高台后再跳上去了。这个技巧适用于 Chapter 3。 所有的单一招式中，属 earthbending 的重击最强力，适合开各种箱子和大件物品（如车、石墙什么的），不过用它打人很容易挨揍，因为准备时间很长。 刷经验最好的章节是 Chapter 6，地形开阔，有三个送经验的大怪，没有阶段（stage，例如 Chapter 5 中被三个萝卜头在飞驰中堵截）的干扰。 气宗的“御风而行”是一个很好用的技能，特别是到了 Chapter 6 遇到毒池的时候往风球上一坐直接就无视了。 路边瓶瓶罐罐装着的那些气（经验）比给敌人造成连击伤害得到的要少很多，不过推荐去打一打，因为可能会触发战斗，又是送经验的。 通关之后觉得，这游戏和 The Matrix: Path of Neo 相似性极高。 二者都是以武术为主的题材。（TMPoN 有枪械，不过我是武术流，不必须用的时候就不用。） TMPoN 对 Neo vs. Agent Smith 群一战的还原，和 TLoK 中 Korra 在 Avatar 状态下将满地的敌人全面压制的关卡内容接近。 TMPoN 中有一关 The Witch，boss的攻击方式是瞬移+念力投掷（柱子、钢琴etc)，反击方式是 Neo 用念力在物体飞来时夺取控制权并扔回去；TLoK 的最终boss的其中一个阶段也是如此，扔的都是大石块。 TMPoN 的最后一关第一阶段 Neo 和 Agent Smith 的空中决战，在这个阶段结束之后某一方会将另一方压在身下撞到地面上（谁压谁依动画前最后一击的结果而定）；TLoK 的boss被终结方式就是被 Korra 用念力将一个飞起来的大石头压在其身上撞击。 TMPoN 的最后一关第三阶段是 Neo 对巨大化的 Agent Smith，TLoK 则是 Korra 对巨大化的老头。 科拉传奇中还有一个有意思的模式，Pro Bending，这是对动画中出现的御术竞技的还原。这个技巧就请各位好好领会吧，很简单的。记住要多支援 NPC 队友，因为他们不会根据形势选择正确的目标。 那个收集10个白菜的成就简直是制作方的恶意……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://blog.mottomo.moe/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"GLantern 的第一次 Alpha 测试","slug":"zh/2015-11-28-GLantern-First-Alpha-Test","date":"2015-11-28T09:17:00.000Z","updated":"2020-03-30T22:34:35.427Z","comments":true,"path":"categories/Tech/zh/2015-11-28-GLantern-First-Alpha-Test/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-11-28-GLantern-First-Alpha-Test/","excerpt":"GLantern 是一个 TypeScript 项目，希望基于 WebGL 提供一个 Flash 接口。我已经将其放到了 GitHub。详细阅读请展开。","text":"GLantern 是一个 TypeScript 项目，希望基于 WebGL 提供一个 Flash 接口。我已经将其放到了 GitHub。详细阅读请展开。 GLantern 是从 Bulletproof 的 WebGL 实现（对，还没推送到 GitHub 上，因为不稳定）中分离出来的。看 Bulletproof，很大一部分都是 Flash 和 WebGL 的代码，而这些和弹幕的实现并没有多大关系，还造成了调试困难，所以将它们分离出来……一句话，就是系统解耦，好处什么的就不分条列举了。 为什么要继续造轮子？TWO.js 为了追求速度，采用了 THREE.js 样式的接口和“节点”思想；Pixi.js 的 WebGL 渲染方式对多段线的处理不正确（见以前的示例）；Egret 和 lufylegend。主要针对的是 Canvas2D，而且需要进行转换（Egret 提供了转换工具）。 此次进行的是简单绘制测试，没有图层 alpha，没有滤镜。 /** * test/visual/index.ts */ import {GLantern} from &quot;../../src/GLantern&quot;; import {Shape} from &quot;../../src/flash/display/Shape&quot;; import {Graphics} from &quot;../../src/flash/display/Graphics&quot;; var lantern:GLantern = new GLantern(); lantern.initialize(682, 438); document.body.appendChild(lantern.view); window.addEventListener(&quot;unload&quot;, (ev:Event):void =&gt; { lantern.uninitialize(); }); var s:Shape = new Shape(lantern.stage, lantern.stage); lantern.stage.addChild(s); var g:Graphics = s.graphics; g.lineStyle(6, 0xff0000); g.drawRect(100, 100, 200, 200); lantern.runOneFrame(); document.body.addEventListener(&quot;mousedown&quot;, (ev:MouseEvent):void =&gt; { s.x += (ev.button === 0 ? 1 : -1) * 10; console.log(s.x); lantern.runOneFrame(); }); 我习惯用自动完成，所以用的是 TypeScript 编译到 JavaScript，所以引用的是 src 中的文件。如果作为 JavaScript 模块引用，写成的是这个样子： // 在 index.js 中也可以 require(&quot;../../build/index&quot;) var GLantern = require(&quot;glantern&quot;); GLantern.injectToGlobal(this); var lantern = new GLantern.GLantern(); var stage = lantern.stage; // ... var s = new flash.display.Shape(stage, stage); stage.addChild(s); var g = s.graphics; // ... 是不是和 ActionScript 的版本比较相似了？ 以前jabbany向我解释过，他不用完整的模型，是为了减小生成大小，提高运行速度。我觉得……先让他们写得舒服（几乎在运行时不用作转换，例如 flash.display.DisplayObject → DisplayObject），就牺牲了一些速度和大小，换来接口的一致性。 这次尝试用了一下 Gulp，而不是 WebStorm 内的 TypeScript 编译。这样下一次各位安装、生成的时候就没这么麻烦了。虽然不再用 WebStorm 内置的编译协助，还是先赞一下 JetBrains，WebStorm 11 中的 TypeScript 支持（捆绑的到 1.6.2）不错了，支持了 1.6 的新 import 解析，还有 tsconfig.json，比 WebStorm 10 那蛋疼的 1.4 好多了，现在能享受到 1.6 的自动完成和实时查错，顺手很多。 试验的还有 TypeScript 的类按文件组织。这样有好处有蛋疼的地方，在项目 readme 里写得很清楚了。话说如果某天 tsc 能跟上 csc（csc /optimize /target:library /out:lib.dll *.cs）那就更方便了。（你说 --outFile 参数？我好像是试一次失败一次。） 在从 Bulletproof 抽出 Flash 结构和 WebGL 绘制代码的时候，没有遇到太大阻力。——要是大了，那就说明我原来的模块分离做得太差了！现在的评价是“差”（看看 bulletproof-bilidanmaku.ts 那组织混乱的代码），还没下滑到“太差”的程度。不过幸好在迁移之前，Flash 和 WebGL 的这两块我是专门调整梳理了依赖关系的。所以最后，许多代码没怎么变（功能组织上有变化），组合了一下启动就跑起来了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"GLantern","slug":"GLantern","permalink":"https://blog.mottomo.moe/tags/GLantern/"}]},{"title":"TypeScript 的一个语义问题，或者是一个需要注意的语法细节","slug":"zh/2015-11-15-A-Flaw-In-TypeScript","date":"2015-11-14T17:27:00.000Z","updated":"2020-03-30T22:34:35.427Z","comments":true,"path":"categories/Tech/zh/2015-11-15-A-Flaw-In-TypeScript/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-11-15-A-Flaw-In-TypeScript/","excerpt":"这篇文章记录了在做 JavaScript 继承的时候突然发现的一个 TypeScript 的坑：继承（extends）对于静态字段/函数的语义和主流 OOPL 不同。 TypeScript 目前（1.6.2）没有解决，于是就记录下来了。最后提出了一种兼容方案。","text":"这篇文章记录了在做 JavaScript 继承的时候突然发现的一个 TypeScript 的坑：继承（extends）对于静态字段/函数的语义和主流 OOPL 不同。 TypeScript 目前（1.6.2）没有解决，于是就记录下来了。最后提出了一种兼容方案。 在对 Bulletproof 重构的时候发现了一个问题。在 WebGL 的实现中，我用了一个 RenderTarget 类。这个类的渲染目标是一个纹理缓冲区（就像 XNA/MonoGame 中的 RenderTarget2D 类那样），在 WebGL 绘制的时候需要提供顶点数据。而这个纹理的顶点是固定的（永远保持原始大小），底层绑定到一个 WebGLBuffer，最好的方案就是用一个静态字段保存。如果你做过 WebGL 编程，你可能知道，任何一个 WebGLBuffer 的创建都是需要通过一个 WebGLRenderingContext 来完成的，而这个上下文是对于一个 &lt;canvas&gt; 而言的，所以这个“静态字段”并不是严格的静态（与实例无关性）。 但是，JavaScript 不支持静态初始化，所以我只好写出了这种代码： class RenderTarget { constructor() { if (!RenderTarget._isInitializedStatically) { RenderTarget.__staticInit(); } // ... } static __staticInit(): void { // 各种静态字段的初始化 // ... RenderTarget._isInitializedStatically = true; } static _isInitializedStatically: boolean = false; static _textureCoords: WebGLArrayBuffer = null; // WebGLArrayBuffer 是我编写的类 static _textureIndicies: WebGLArrayBuffer = null; } 确实，这样在我的程序里是没问题的，一切工作都如预期，RenderTarget 及其子类的静态字段整个程序生命周期内只被初始化了一次。 然后现在，由于我实在不想忍受 TypeScript 的模块行为（这个行为导致我将所有强相关模块放到了一个超大的 .ts 文件里，这就是为什么 Bulletproof 的每个文件大而臃肿），决定这次用 JavaScript 重写，自己控制导出。 简单说，TypeScript 中有一个 export 关键字，控制着类（和其他）的编译结果。如果不带 export，则这个类/模块会被声明为全局下的一个闭包；如果带，会用 exports.ModuleOrClassName = ModuleOrClassName 或者 ModuleName.ClassName = ClassName 这样导出，其中 ModuleOrClassName 和 ClassName 是对应的闭包。 我希望的调用方式是这样的： import Class1 = require(&quot;moduleFile.classFile&quot;); // 导入 Module1.Class1 module Module1 { export class Class2 extends Class1 { // ... } } 但是 TypeScript 狠狠地嘲笑了我一番。如果在 moduleFile.classFile 中的模块 module1 不使用 export 修饰符的话，import 语句会报错说找不到那个文件导出的对象；如果用则必须用这样的语法导入： import module1External = require(&quot;moduleFile.classFile&quot;); import Class1 = module1External.module1.Class1; // 这一步其实是创建别名（alias），不是文件导入 // ... 你看，那个 .module1.Class1 是一个非常烦人的东西。这里是一个很好的例子，里面的各种引用因共用 bulletproof 命名空间，还得分多个变量来做别名，十分混乱。 还是继续说正题吧。这次做继承，我立刻想到的是 Function.call()。但是转念一想，静态字段怎么办？想到有 TypeScript 的先例，我就翻出了其编译的结果： // d: ChildFunction, b: ParentFunction var __extends = (this &amp;&amp; this.__extends) || function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() { this.constructor = d; } d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); }; 在继承链上，除了在构造函数中调用了 Function.call()（这里没展示）之外，在此之前调用的就是这个 __extends()。慢着！除了对 prototype 和 constructor 的处理，对静态字段/函数怎么会只有一个简单的键值对遍历-复制过程？稍微有点了解的人应该会意识到，如果被复制的对象是一个基元类型，在父子类之间是无法保持值的关联的。也即，修改了其中一个的值，另一个不会改变。 这可能会导致意外的结果。例如，如果这个静态字段不是在初始化时发生变化的，而是懒惰求值的（例子见下文的 TypeScript 示例），那么就会造成父子类中此字段的值不一致。如果此时需要访问此字段，则会发生问题：如果你是父类，你怎么知道子类的此字段的值呢？再举个栗子，如果上文中 _isInitializedStatically 字段是延迟更新的，那么实际上就会在创造每个类的时候都将字段初始化一次，总次数是 1+N 次，其中 N 为子类数量。这不是我们所希望的。 为了验证这一点，我们先要知道传统的面向对象的语言是怎么处理这种情况的。一般来说，静态变量会被放到一个全局内存区域，保持其全局的唯一性。在这里我用 C# 来演示这个 static 对于成员变量的语义： using System; static class Program { class ParentClass { // 值类型（value type）测试 public static int StaticInt = 0; // 引用类型（reference type）测试 public static Uri StaticUri = null; } class ChildClass : ParentClass { public static void ChangeInt() { StaticInt = 1; } public static void ChangeUri() { StaticUri = new Uri(@&quot;http://www.baidu.com/?pn=foo&quot;); } } static void Main(string[] args) { Console.WriteLine($&quot;Original StaticInt: {ParentClass.StaticInt}&quot;); ChildClass.ChangeInt(); Console.WriteLine($&quot;New StaticInt: {ParentClass.StaticInt}&quot;); Console.Write(&quot;Original StaticUri: &quot;); Console.WriteLine(ParentClass.StaticUri == null ? &quot;null&quot; : ParentClass.StaticUri.AbsoluteUri); ChildClass.ChangeUri(); Console.Write(&quot;New StaticUri: &quot;); Console.WriteLine(ParentClass.StaticUri == null ? &quot;null&quot; : ParentClass.StaticUri.AbsoluteUri); Console.ReadKey(); } } 输出： Original StaticInt: 0 New StaticInt: 1 Original StaticUri: null New StaticUri: http://www.baidu.com/?pn=foo 可以见到，在声明为 static 的时候，ParentClass.StaticInt 和 ParentClass.StaticUri 被放到了一个全局区域，ChildClass 在继承的时候没有进行隐藏（shadow），所以引用的是父类的这两个静态字段。根据结果我们可以看出，它们确实是全局唯一的，对于 ParentClass 和 ChildClass，指向的是同一个位置。所以，即使是修改了 ChildClass 中的值，其修改对象其实为静态对象的定义位置——即是 ParentClass.StaticInt 和 ParentClass.StaticUri，这个修改在所有引用了这两个字段的类中都得到了反映。（我没有输出 ChildClass.StaticInt 和 ChildClass.StaticUri 的值，因为要验证的是全局的同步，输出这两个不能证明要证明的东西。） 然后看一下在弄清楚了继承机制下的 TypeScript： class ParentClass { // 基元类型（primitive type）测试 static StaticInt = 0; // 引用类型（reference type）测试 static StaticObject = Object.create(null); } class ChildClass extends ParentClass { static changeInt(): void { ChildClass.StaticInt = 1; } static changeObject(): void { ChildClass.StaticObject[&quot;key&quot;] = &quot;value&quot;; } } console.log(&quot;Original StaticInt: &quot;, ParentClass.StaticInt); ChildClass.changeInt(); console.log(&quot;New StaticInt (Parent): &quot;, ParentClass.StaticInt); console.log(&quot;New StaticInt (Child): &quot;, ChildClass.StaticInt); console.log(&quot;Original StaticObject: &quot;, ParentClass.StaticObject[&quot;key&quot;]); ChildClass.changeObject(); console.log(&quot;New StaticObject (Parent): &quot;, ParentClass.StaticObject[&quot;key&quot;]); console.log(&quot;New StaticObject (Child): &quot;, ChildClass.StaticObject[&quot;key&quot;]); 输出： Original StaticInt: 0 New StaticInt (Parent): 0 New StaticInt (Child): 1 Original StaticObject: undefined New StaticObject (Parent): value New StaticObject (Child): value 我们同样仅改变 ChildClass 的静态字段，输出 ChildClass 和 ParentClass 的静态字段的值。可以看到，输出是意料之中的（如果事先了解 TypeScript 对 extends 的编译结果的话），基元类型没有发生改变，而引用类型由于在继承时复制了字段引用所以会发生改变。 可以看到，在值类型/基元类型静态字段的继承行为上，C#（其实也可以把 Java 揪来）和 TypeScript 虽然有着相近的语法，但是有着不同的行为。换一个角度，也可以说，对于熟悉传统面向对象编程语言的人来说，TypeScript 的 extends 语义是有问题的，很容易让人被坑。 插一句，静态函数是没有这个问题的，因为新声明的函数对原函数的行为是隐藏，在 C# 和 JavaScript 中是一致的，只不过 JavaScript 没有一个明确表明此意图（而不是不小心写了一个同名函数）的注释或关键字，而 C# 有 new（VB .NET 有 Shadows）。 当然这可能是有意为之的。毕竟考虑到与 JavaScript 的兼容性（TypeScript 是 JavaScript 的超集），连访问成员字段/函数都必须每个加 this、访问静态字段/函数必须加类名呢。例如，我如果指定的是 ParentClass.StaticInt，和指定 ChildClass.StaticInt 相比，输出的结果就不一样了。因此，在使用静态字段/函数之前，必须好好考虑使用的是谁的字段——不方便（例如在不知道完整继承树、不知道谁声明了这个字段的情况下），但是绝对严谨。所以，将其判定为语义错误的结论是有待商榷的。 反过来看原来的代码为什么工作似乎正常，不过也只是看上去正常。这是因为这些字段在第一个 RenderTarget 的子类（RenderTarget 不是直接使用的）初始化时被初始化。初始化的时候做了什么呢？ 检查 RenderTarget._isInitializedStatically，如果为 true 则不初始化静态字段。（当然，如果一个类在其任何子类实例化之前初始化了自己的静态字段，则其子类必然不会重复初始化，因为复制的这个字段值为 true。） 初始化各个静态字段。除了 _isInitializedStatically，其他都是引用类型。 将 RenderTarget._isInitializedStatically 设为 true。 通过将这个行为包装在 RenderTarget.constructor 中，确保子类同样在构造函数中执行此行为。 可以看到，由于所有类访问的都是 RenderTarget._isInitializedStatically 而不是各个类的 _isInitializedStatically，加上所有要访问的字段都是引用类型，歪打正着：由于所有 RenderTarget 及其派生类的第一个实例创建时设置了全局唯一的标志（RenderTarget._isInitializedStatically）所以这个字段只在此时被修改，其他所有的初始化过程访问的都是这个标志所以会跳过静态初始化，同时由于它们的其他静态字段都是引用类型所以指向了同一个位置，访问时就是同一个引用。 如果要和主流 OOPL 的静态字段继承语义保持一致（其实 JavaScript 并不是 OOPL），可以利用引用的不变性来解决这个问题。简单说就是将这些字段保存到一个自动生成的对象中。编译的结果可能会像这个样子： var ParentClass = (function () { function ParentClass() { } ParentClass.$someStrangeLongStaticMemberName.StaticInt = 0; ParentClass.$someStrangeLongStaticMemberName.StaticObject = Object.create(null); return ParentClass; })(); var ChildClass = (function (__super) { __extends(ChildClass, __super); function ChildClass() { __super.call(this, arguments); } return ChildClass; })(ParentClass); 此时对 StaticInt 和 StaticObject 的引用自动识别（在符号表里有记录的吧），分别编译为访问 $someLongStaticMemberName.StaticInt 和 $someLongStaticMemberName.StaticObject，这样由于共享了 $someLongStaticMemberName 的引用，因此更改能同步，也就符合了常见的语义。 问1：如果子类声明了新的静态字段怎么办？ 答1：在符号表里加入一个 ChildClass.$someLongStaticMemberNameForChild 呗。 问2：为什么不改 tsc 呢？ 答2：因为……代码集中到了一个文件里，太大……如果只是提一个 issue 的话倒是可以吧…… 用上文的 RenderTarget 初始化举一个栗子。为了避免初始化不确定性，如果使用原生 JavaScript，配合 Node.js require() 的缓存特性，可以实现静态初始化并避免暴露无关的静态字段。 var WebGLArrayBuffer = require(&quot;./WebGLArrayBuffer&quot;); // 父类静态初始化标志不暴露 var isStaticallyInitialized = false; function RenderTarget(glc) { if (!isStaticallyInitialized) { staticInit(glc); } } module.exports = ParentClass; RenderTarget._textureCoords = null; RenderTarget._textureIndicies = null; // 父类的静态初始化函数不暴露 function staticInit(glc) { RenderTarget._textureCoords = WebGLArrayBuffer.create(glc, ...); RenderTarget._textureIndicies = WebGLArrayBuffer.create(glc, ...); isStaticallyInitialized = true; } var __extends = require(&quot;./__extends&quot;); var RenderTarget = require(&quot;./RenderTarget&quot;); var __super = RenderTarget; function PrimitiveRenderTarget(glc) { __super.call(this, glc); } __extends(PrimitiveRenderTarget, __super); module.exports = PrimitiveRenderTarget; 当然，如果使用情景没有这么复杂（需要延迟初始化）的话，将静态字段的初始化代码放在 staticInit() 中并直接调用，就实现了类静态构造函数的语义： function ParentClass() { } module.exports = ParentClass; ParentClass.StaticObject = null; (function staticInit() { ParentClass.StaticObject = Object.create(null); ParentClass.StaticObject.foo = &quot;bar&quot;; })();","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"音乐的正版化随着政策开始了","slug":"zh/2015-11-09-Copyright-Protection-Officially-Starts","date":"2015-11-09T09:21:00.000Z","updated":"2020-03-30T22:34:35.427Z","comments":true,"path":"categories/Misc/zh/2015-11-09-Copyright-Protection-Officially-Starts/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-11-09-Copyright-Protection-Officially-Starts/","excerpt":"","text":"10月25日的时候，我曾经说过云音乐的听歌保护改变。当时还以为，这像之前遇到的播放失常一样是临时的。可是，今天的博客园新闻告诉我，形势非常严峻，我没认清此次刮的是什么风，低估了它的强度。 12月4日补充： 睡前看科技新闻，在一个不太起眼的角落发现了一条足够震撼的消息：“音乐产业发展意见”于12月1日公布了，从电影电视剧开始的行动“开始”（11月17日定的条文，肯定更早之前就已经向业内打了招呼了，所以实际开展和技术准备时间早于此节点，只不过各大提供商此时才公开表示支持而已）向音乐延伸。 中国的文化业（含文化产业和引入资源）割据后被巨头掌控的时代来了。这次国家出面要求统一，一方面保护了大公司下站队的艺人的权利（这也是此次通知的主要意义），另一方面也在将渠道完整地纳入监管。从此，创作成果的发布和传播受到保护，质量有大公司担保——同时也收到监察，一枚硬币的两面。对于终端用户，也就是产业链的末端，我说得严重一些，如果企业不支持社区或实行特定营销策略（如 Visual Studio 和 IntelliJ 的 community edition，还有 Steam Discount 和 Origin 的 Humble Bundle），那么人们就不得不挤破头——面包吃不到，给你点面包屑让你饿着但不饿死的感觉毕竟不好受。对于内容的创作者则是福音，因为这得以保护非实体的创作成果，只要跟好队，有产出，就有饭吃。 我认为，这次整风相当于文化业的“国企改革”。九十年代的国企改革牺牲（这个字眼值得斟酌）了许多人，促成了社会的进步，虽不见血，但是和见血没什么两样，触动的既得利益者是处于系统末梢的根须的职工们。这次触动的是终端用户，保护的是“社会的利益”，也是大提供商的利益。真有一种“人类进步的引擎得由大企业来做，草民一边去”的气势。对此思想我持保留态度。反正我是很喜欢云音乐曾经提供的相对自由的环境，能上传一些鬼畜草根音乐（有专门类别，用户能看出这不是发行的东西），能上传和翻译歌词（社区的力量）。这和 Mozilla 那样是让各位看到了自己可能提供的帮助，获得成就感。但是如果一切资源都只能按照权利方提供的那个“规定版本”来的话，会不会也出现现在译制片的那些笑话呢？听说因为《银河护卫队》的挑刺，网友称谷大白话应该进译制厂去给他们整整。随便啦，我可是不想掺什么事，在社区是最开心的。 照这么看，“国家资本主义”是没错了。政府掌控财团（或者我等平民不知晓的……）而不是财团手握政府。亲爱的社会主义和万恶的资本主义核心的不同点只在政治形式上了。融入国际市场的一个缺陷就是，总会被资本牵着走，谁有资本谁就能说话；总设计师同志想到了这一天吗？总觉得，ZF好厉害，在一如既往的恶劣环境下能坚决抗老美，保持独立自主之国格，实为可贵。 嘛，人类就是这样子，抱团相信低熵能促进系统优化的。也许将来有一天我会尝试模拟这个过程，看看在生灭之间会如何。 真·学神：http://www.cnblogs.com/icedream61/p/4959411.html 已经不在一个高度上了……所以要说膜拜的话对方也只会以为这是平平常常的事情而已。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"杂谈","slug":"zh/2015-10-29-Misc","date":"2015-10-29T05:00:00.000Z","updated":"2020-03-30T22:34:35.427Z","comments":true,"path":"categories/Misc/zh/2015-10-29-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-29-Misc/","excerpt":"个人事务原因，GitHub 上的活动要先暂停一下。","text":"个人事务原因，GitHub 上的活动要先暂停一下。 今天食物群里糖王菊苣发了一个 AniTama 的链接，我看到下面索尔菊苣大声惊呼，就点进去看了看。由此，掉入了 AniTama 的大坑。 （AniTama 本身不提供 PC 版网页，只提供移动版网页，和基于移动网页打包的客户端。） 这些人的实力，远远超出了我的储备。 像这个、这个，都是基础中的基础、但我没有底力写出来的内容。 对不起，我不敢再说看过动画了。根本就没看懂，也没有数据，然后就瞎写一通（以前的某文）。 现在的感觉，就像头上的苹果，即使尽力伸出手，跳起来，也够不着，这深深的失落。 又如燕雀较于鸿鹄，既知其志，必自惭形秽。 现实又一次将我摁在了地上。 有一天，一个猎人捕获了一匹绝世宝马，于是他前去将这匹马献给国王。 虽然宝马一事的流言蜚语传遍了大街小巷，大家都想先睹为快，但是国王正陶醉于人民的热情中，哪里会轻易展示出来。 但是，皇家马厩的马夫很好心，说要不就寄放在这里吧，圣上也许哪一天就会用到了呢。 一年过去，十年过去，三十年过去。国王终于想起来当初还有那么一个宝物，正赶上信任危机，要牵出来在国民展示权威。 但是，看到的，却是瘦骨嶙峋、气喘吁吁、弥留之际的老马。它终究没能在其壮年献出一份力，而是在人们快要抛弃它的时候，被拎出来以衰老的姿态示人。 再受欢迎的马，也会被时间冲刷掉。最后所有人都被时间所遗忘。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"如果将画家送上战场","slug":"zh/2015-10-27-What-If-Sending-A-Painter-to-the-Battlefield","date":"2015-10-26T16:56:00.000Z","updated":"2020-03-30T22:34:35.426Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-10-27-What-If-Sending-A-Painter-to-the-Battlefield/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-10-27-What-If-Sending-A-Painter-to-the-Battlefield/","excerpt":"如果将画家送上战场……","text":"如果将画家送上战场…… 今天走在路上突然想到的，然后就记起了 The Pianist，初中的几次音乐课上老师给我们放的电影。（不过主角之一不是士兵，是难民。） 艺术家们在和平年代是宝贵的财富，但是如果最坏的情况都发生了，不得不将画家装上枪送上前线，怎么想这事？ 简单来说，我认为人的本性是自私的，这自私来自于资源的有限性。而人的能力是有限的，因此先人发现如果各方势力都划定界限，自己能保有资源量的期望要比大混战时的要高，因此会产生“协约”这一做法。但是这本性在战争中显露无遗，社会是具有分形性的（村长：一直没讨论这个），一个国家和一个人类个体在相应的规模上看是没有什么区别的。 问题来了。画家在战争中的价值（物质价值，战斗力）明显不如普通小兵仔，但是在和平时的价值（精神价值，创造力）远高于小兵仔。派出他们，在弹尽粮绝的时候，或者不是弹尽粮绝的时候，是合理的吗？对未来估值，估计发展潜力，是人“进化”后得到的呢，还是本能推断的结果呢？ 考虑一下一个超级超级工程，例如光速飞船。显然目前的科技水平是不可能造出来的，但是或许某天三体人来了我们也得造。很明显，这样的工程的依赖关系是一个树状结构，从实际操作者，到设计者，到制造者，到保障者，数量几乎是几何增长的。那么，如果某种科技，假设所有的人都被安排到了这个结构中，但结构还是有空缺呢？那么这个工程就不能完成了——这就是人类科技的极限之一。或者你可以说有一个缓和方案，假设一代人做一部分，下一代更新了整个社会分布后继续，那么这个时间跨度就要以十年百年计，要看在目标时间跨度的范围内是否合理了吧。另一个潜在的缺陷是，如果所有的人的知识体系都为了其所在的位置而特化，从而与其他位置的人产生永久的知识隔离呢？（挺恐怖的，这样真成螺丝钉了。）那么这个社会整体也就无法承载所需的知识了。这是人类科技的极限之二。为了养活这么多人，如果地球的资源循环（一般一年一循环，例如粮食；也有长时间的，例如铁元素）跟不上所需的生产速度呢？不光工程可能无法实现，人类这个物种自身的存在都可能会被威胁到。这是人类科技的极限之三。人如果信息化、能量化，倒是可能以一种联合态存在。不过如果想以此来减少上面这工程的资源耗费的话（例如不用物质循环、时间可以忽略），还要考虑对物质的干涉问题，和维持工程的资源耗费问题，恒星级能源？ 做出以上推理的前提是人类必须完全协调地工作。一旦这个脆弱的状态被打破，那么就又成了高熵态了。别说大工程，恐怕又是恢复到对资源的赤裸裸掠夺上。 但是考虑到人类整体作为“实验对象”的可能性，要对生物共同的“为了自己的生存”进行质疑。为什么所有生物的目标是一致的、单纯的？是被刻印（到现在，遗传也是方法之一）到每个个体之中了吗？还是说，只是生物对“变化”（时间）这个概念有所觉察，进而“自然而然”地去试探、去触碰，然后被其所推动？但是时间只是我们所能觉察的四个维度中的一个，更高维度的状态我们恐怕是无法体验的，也就无法对应到直觉中。虽说数学家们做出过“四维正多面体经过我们空间时的投影”，那终究不过是将更高的一个维度特化成了几何维度展示出来了。所以在更高的维度上观看我们所谓的时间维度是什么样的？我们的“理”，与更高的“理”应该就存在着差别了，因此我们所谓的“时间”，可能只是一个“事实”，就如我们观看去掉了时间轴后的立方体，它已经坍缩到了“事实”上了。一种问法是：西方极乐世界有时间轴吗？ 我为我感到悲哀，想不出这些的答案，因为思维还是太狭隘，或许把我放到更高的一个维度上我也理解不了，放回来也说不出吧。存在状态作为生物，除了这所知的宇宙还有比其更无尽的存在或虚无，而这是我无法达到的领域，嗟乎！ 好像乱了……哎能读就好。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"杂谈","slug":"zh/2015-10-25-Misc","date":"2015-10-25T15:32:00.000Z","updated":"2020-03-30T22:34:35.426Z","comments":true,"path":"categories/Misc/zh/2015-10-25-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-25-Misc/","excerpt":"本篇日志对于一篇杂谈来说太长了，因为讲了几个方面的东西。为了减小首页规模所以请展开查看吧。","text":"本篇日志对于一篇杂谈来说太长了，因为讲了几个方面的东西。为了减小首页规模所以请展开查看吧。 tt发来了邮件，引用标准草案说明各个自增的顺序是没有规定的。按照他的用语， ……因此，无论编译器返回什么值，或是让一匹独角兽从窗外出现给所有人分发冰淇淋，都不算作对标准的违反。…… 为什么这说法这么像读过的那些技术入门书的句子；题材倒是会很丰富，不论是讲编译的、讲语言的、讲架构的，老外的书里总是能跳出一两个好玩的东西。顺带一提，如果真有独角兽在窗外分发冰淇淋，我很乐意来一份。 不过既然微软在将 clang 整合到 Visual Studio 中，这些问题应该会逐渐减少。舍友倒是没多么纠结啦，他不是做这个的，可能只是在专业课（要用到一点基础编程）上被老师坑了一下。 tt也说了，我的博客没有评论机制。是的。开始的时候我用了多说，但是后来撤掉了。因为多说通过对其脚本的引用（referer 头），会利用服务器会抓取我的博客内容。虽说直接用 URL 作为存储索引也足够区分，但是内容似乎都流过去了。刚刚建立博客时我就说过这个问题，但是随着博客内容的积累，我并不希望通过这种方式流失内容，所以就将脚本引用删掉了。（即使不这么做，以后也可能会有一些乱七八糟的网站或人通过自动或人肉爬虫进行转载的吧。隐藏 &lt;span&gt; 方法到时就能发挥一定的效力了。 这是没有自己的博客数据库的大劣势。因此我在考虑这一波过去后有时间了，开一个 VPS，将博客转移到 WordPress 上。不过先要等到安顿了再说。 其实如果有任何想法，可以直接给我发邮件的。嘛，“向社会妥协了”（杨彦君语）之后我入手了一个智能手机，配置了一下常用邮箱的 SMTP 和 POP3 服务，所以基本上睡前就会检查一下邮件的啦。 Bulletproof 修正了 Graphics 的绘制逻辑，现在应该和 Flash 是一样的了。不过颜色的问题还没解决，就是上次提到的似乎跟 alpha 扯上关系的问题。 不过进一步观察发现，premultipliedAlpha（该翻译成什么呢？预乘的 alpha？）也脱不了干系。上次的小圆脸的结果，背景颜色根本不对，因为源图像的背景是棕黄的，而上次显示的是惨白。这还没开滤镜呢，只有 alpha，怎么就这样了？想想一个合理的解释是由于当前的上下文将颜色模式的预乘开了，公式成了这个样子： R&#39; = R * A G&#39; = G * A B&#39; = B * A A&#39; = A 但实际上，应该按照这样解读： R&#39; = R G&#39; = G B&#39; = B A&#39; = A 模式错了，将颜色送进去之后，在 shader 处理（之前？之后？有哪位能帮忙解答一下）时被自动“纠正”： R* = R&#39; / A&#39; G* = G&#39; / A&#39; B* = B&#39; / A&#39; A* = A&#39; 你看，那个椭圆 alpha 大概在0.6，所以最终的 RGB 分量是原始值（原始值也是预期的最终值）的 1.67 倍；WebGL 保证颜色不越界，那么一般就能取到最大值1.0，导致颜色基本上是黑白的（黑色 RGB 都是0，不变）。另一个证据是，如果 alpha = 1，则画出来的图元颜色没有问题，毕竟此时即使是除了一个 A&#39; 还是原来的值，撞大运刚好等于预期的值。 但是，在创建 WebGLRenderingContext 的时候不管是否设置 premultipliedAlpha，设置为 true 或 false 都没有影响渲染结果，这比较头疼。 24日早上跑了12分钟跑。黄导（嗯，黄导）也是厉害，和监考老师一直聊天所以最后4个组（8个班）全都过了。虽说一般都是能过的，不过老师总是“啊跟你说话都忘记掐表了，现在都20分钟了”甚至“哎呀这个班跑之前忘记重设了，现在都40多分钟了”也该被吐槽了吧。 晚上还跑到沙河校区去答辩去了，下午晚上走了不少距离，晚上腿确实疲劳。但是睡一觉之后都没事了……反倒是一个舍友还在嚷嚷“昨天跑步今天腿还酸”的。 今天开云音乐，在我翻译的歌单中突然发现了一些有小小云朵图标的项目。后来发现其他一些歌单上的一些曲子也有同样的图标： 恐怕又是 IP 段判断失误了。云音乐一直就有 IP 可能处理不好的问题（百度一下“因合作方的要求，此资源暂时被下架”就能看到）。像上面肉松（户松遥）的歌（《Girls, Be Ambitious》），之前就遇到过弹出“暂时下架”拒绝播放的情况。我还以为是合约到期了还是什么的（百度音乐就是这么衰落的），但后来发现只是软件方式的播放者位置限制而已。 以前直接禁止播放的行为让我很不开心。这次云音乐就做得不错，体验有很大改善。将播放过的歌曲缓存在音乐云盘里，这样只要云盘没满，就能播放以前听过的歌曲——毕竟没有理由给你直接禁了啊，而且看着自己歌单突然就废了一部分谁也不会开心的吧。 我航21系宣传部还原 Fate/UBW OP。我估摸这事也只有相对比较开放的21系的学生会支持花时间构思创作了。其他大部分系（我们呵呵）缺少技术宅的碰撞（就和一滴水和一片海洋一个道理），我们系导员直接就会问：“你做这个能给学院拿什么奖啊？” 最开始是周防天音的线路ED《HOME》，然后到《纯白交响曲》的特典单曲《シンフォニック・ラブ》（嗯受到工口之主的签名影响我知道了濑名爱理的存在），再到《幻想嘉年华》OP（还有《寻找失去的未来》的游戏OPED，不过我没怎么听），我发现我挺吃橋本みゆき的诶…… 嗯，游戏上 CUBE 和 HOOKSOFT 两家，确认。在《恋する彼女の不器用な舞台》中的森谷実園（配アリス会长），在《your diary》的游戏OP中发现这位配的是かなで，形象很不同诶（话多/话少）。另外居然还配了《Lovely Quest》里的水穂！查了一下百科，看来吉田真弓在白糖系上参加了不少作品嘛。 升级到 Hexo 3.1.1 之后的坑爹事： https://github.com/hexojs/hexo/issues/1565#issuecomment-151027460 这个异常在 node_modules/hexo/node_modules/nunjucks/src/parser.js 的第1158行被抛出。我加上了两行代码查看情况： console.log(tok); console.log(this.tokens.str); 然后就在控制台抓输出，看看是哪个文件。 （上面的问题涉及的我的博客上传的代码就两行，所以我暂时将那两行改了一下，不过还是希望能用到正常的 skip-render 功能。） 还有，原来的 _config.yml 直接在 3.1.1 中 hexo g，出现了3个问题： 生成速度非常慢，目前规模是600多个文件，2.8.3 生成时间大概是20秒，而 3.1.1 一顿一顿地在40到60秒之间。 不断报警告（WARN），说在对应的 _widgets 目录中未找到 EJS 文件。 无法识别 permalink: categories/:category/:title/ 这样的配置。具体表现为生成成功，但是在页面中的链接（包括日志、分类、标签、时间）都无效了，指向了其原本应该指向的地址的上一级的 index.html，如 /categories/Misc/2015-10-10-Something/ 变成了 /categories/Misc/index.html，archives/2015/10/ 变成了 /archives/2015/index.html，等等，全乱套了。 我怀疑是模板的兼容性出了问题（毕竟在一个新文件夹里 hexo init 后 hexo g &amp;&amp; hexo s 的结果一切正常），临时换上了 hueman 主题，但是问题依旧。后来尝试了多种配置，每次都执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s，没有一个解决了问题的。又受不了了，干脆用上原始的 _config.yml，直接 hexo g &amp;&amp; hexo s，工作正常；然后往上面一点点加上原来的配置——最后配置文件都等价了，居然又可以了。这是诈和么？ 现在除了 skip-render，其他能正常用了。感觉上 Hexo 3.1.1 比 2.8.3 快了不少，能充分利用缓存了。 这篇日志发布的时候，永久链接格式发生了变化。考虑到国际化（好好利用 Hexo 的新功能），和减少潜在的 URL 冲突（项目的 GitHub Pages 一般会在 domain.com/project-name，这里 domain.com 是博客所用域名，所以在主博客中要将 uiharu.moe/ 后面跟着的入口缩减一下），原来的格式是 :category/:year/:month/:day/:title/ 新格式是 categories/:category/:year-:month-:day-:title/ 我现在将文章按照语言组织起来了，所以现在的文章都在 source/_post/zh/ 目录下，:title 都含有“zh”，所以就会出现 http://uiharu.moe/categories/Misc/zh/2015-10-25-Misc/ 这样的地址了。 Pencil+ 3 对于机甲和道具的处理已经接近去年的那个思想上的项目了…… 现在押上未来，就算是双线也好，我也会发出呐喊。就算众人只是模糊的灰色影子匆匆略过也好，如果没人去做，大家都只会接受煎熬。有不能做的，有不愿做的。有可能我只是想表达一个“呵呵，我就是能做得到”这种拯救苍生于水火的意思吧。——切，也许还不成呢，做好一百二十分的准备吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"北航北航！你的开源协作精神去哪里了！","slug":"zh/2015-10-23-Where-Is-Collaboration-in-BHU","date":"2015-10-23T08:30:00.000Z","updated":"2020-03-30T22:34:35.426Z","comments":true,"path":"categories/Misc/zh/2015-10-23-Where-Is-Collaboration-in-BHU/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-23-Where-Is-Collaboration-in-BHU/","excerpt":"","text":"想写一个 Android app 替换掉学校的那个超不好用的东西。不过用 SDK Manager，Android Source 总是没法更新成功。找除了FQ之外的方法时，找到了一个帖子，设置 SDK Manager 的代理为 http://mirrors.neusoft.edu.cn:80。明显这是一个镜像源，不过那 .edu 的域名还是吸引了我，上去看了一下。原来是东软信息学院的镜像站。 翻到页面最下方，是清华的镜像站。这个名称（二级域名）居然是“tuna”，有点意外。点开，继续翻到页面最下方，是其 GitHub 组织账户。看了看，那些项目都活得很健康！ 在其中一个 gdanmaku 项目中，发现了测试地址 http://dm.tuna.moe/。MOE 域名！然后一看，又指向一个二级域名，那么主站呢？点开一看，十分精彩，甚至还有一个 IRC 频道，而且现在（16:48）还在不断刷新（多人参与）！ 反观北航。自从年初未来花园关闭了之后，镜像站也一起被关闭（由同一个学长维护的）。社团成什么样子了？MSTC 成了内部组织，Google Camp 和百度那啥（还有一个莫名其妙的 CSDN）不知道具体活动如何，但是主要也是学习使用这些公司的技术，获得更好的实习机会什么的。计算机协会？呵呵，那群只会给人笔记本清灰的家伙能做什么！开源协会，在我前年还在 MSTC 的时候，那次百团大战，微软、谷歌、百度都出了五六个人，而开源协会整个下午只有孤零零一人守在一张小桌子后。我看了一下本学习的社团状况，开源协会已经被下调为1星了（MSTC 是5星），岌岌可危。 跟你们讲个笑话，我们学校自己的软件在自己手里的情况。我现在的专业是机械，我们有一门专业课叫“专业综合实验”，主要就是进行数字化加工实验的。开始是手工编G代码，然后是生成模型用软件导出G代码加工。就在昨天，这课开始讲自动G代码生成软件。一上课，老师拿出一个U盘，说：“同学们用过 CAXA 制造工程师没有？”（“金工实习的时候用过。”）“这次我们还是用 CAXA，你们把这软件装到电脑里去。这里面有32位的有64位的，如果你的系统是64位就选那个2013的，不用解密（他把‘破解’都说成了‘解密’）直接用；如果是32位的就安装那个2010的，只能用30天，到时间重装。需要序列号的话，下面文档里有。……64位这个是‘大赛专用版’，是数码大方他们专门给院校用的，就不用解密了。”看看看看，滥用都成这样子了。CAXA 起源于北航，而现在就如同廉价的奴隶一般被使唤。如果每个软件副本都有自己的感觉的话，它们会不会心塞呢？ 虽然领导们嘴上说着建设先进、一流，却没人在这里发力。21系确实有大神将项目玩得溜溜的，但是没有一个联合的组织，没有一个共同的目标、一个兴趣。反观身边的人，想的都是怎么考上本校研究生（对，甚至都不想往外试试，只因为本校考本校，特别是本系，有面试优势），怎么找到最轻松薪酬最高的工作。——这样每个人之间都是敌人，资源有限，你争我夺。我承认我胆小，人脉没学生会、团委的人多，因此也就没法仅凭一人的力量将局势扭转。没有干草，风中的小小火柴怎么能有燎原之势？若有星星点点的汇聚，或许能指出一方光明，但究竟是什么让火种支离破碎呢？ 班里一群人每天组团上自习复习考研，其中绝大多数都是考本校本系的。他们应该觉察到，你看现在大家其乐融融、相互鼓励，但是到了考试的战场上，指不定就是谁把谁给刷下去了，所以本质上每个人都是孤立的。认命也罢，不服也罢，没有共同创造的价值，只会剩下残酷斗争的遗骸，咒骂也罢，淡然也罢，事实是板上钉钉的，即使无人知晓。 胡乱写了一通，满纸荒唐言。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"微软的 C++ 编译器将自增自减炖成了一锅汤","slug":"zh/2015-10-22-Increment-Decrement-Bug-in-CL-Goes-Wild","date":"2015-10-22T05:36:00.000Z","updated":"2020-07-26T13:48:19.784Z","comments":true,"path":"categories/Tech/Coding/zh/2015-10-22-Increment-Decrement-Bug-in-CL-Goes-Wild/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-10-22-Increment-Decrement-Bug-in-CL-Goes-Wild/","excerpt":"《由一个自增引发的问题》的后续，用实验和文档证明微软挖大坑。 附赠：瞥一眼，瞧一瞧给微软报告bug特别是技术bug会有多麻烦。","text":"《由一个自增引发的问题》的后续，用实验和文档证明微软挖大坑。 附赠：瞥一眼，瞧一瞧给微软报告bug特别是技术bug会有多麻烦。 今天凌晨我写了《由一个自增引发的问题》，然后将链接发给了杨彦君。此时已快两点半，想不到他居然还没睡，说是战M（战女神 Memoria）出了汉化要使劲推…… 上午我有课，中午回到宿舍的时候看到了反馈。 跟你说的一样，++慎重 我甚至有点理解为什么Python和Ruby要删去++了 然后我提出了一个假设：其实如果不计编译效率的话，全部用栈来实现一个虚拟机语言，其 INC 指令就不会出错。他回复：“Java 吗？”我构造了一个例子： PUSH 3 // stack[0] PUSH 0 // stack[1] INC stack[0] // stack[0] += 1 ST stack[2] INC stack[0] ST stack[3] INC stack[0] ST stack[4] ADD stack[1], stack[2] // 第一次 pre-increment 的结果 ADD stack[2], stack[3] // 第二次 pre-increment 的结果 ADD stack[3], stack[4] // 第三次 pre-increment 的结果 POP POP POP POP result 对于此例子，他的评论： clang和llvm组合应该是这种结果 然后我用 Java 做了个实验，证明了 Java 的执行结果是符合预期的（在自增自减上二者语义是相同的）： 都做到这份上了，不妨将前置后置、自增自减都来试一遍。有兴趣的同学可以编译一下。最终确认了，无论是前置还是后置，无论是自增还是自减，微软出品的 C++ 编译器都能做出一锅大杂烩。 // 环境：MSC (Microsoft C++ Compiler) 19.0, target 10.0.10240, x64 / Win32 int main() { int i; int j; // 预期：12 (=3+4+5) // 实际：9 i = 3; j = (i++) + (i++) + (i++); // 预期：15 (=4+5+6) // 实际：18 i = 3; j = (++i) + (++i) + (++i); // 预期：3 (=2+1+0) // 实际：0 i = 3; j = (--i) + (--i) + (--i); // 预期：6 (=3+2+1) // 实际：9 i = 3; j = (i--) + (i--) + (i--); return 0; } 所以微软的 C++ 编译器在自增自减上病的不轻啊。 从中抽个例子，和昨天的不同的例子，用后置自增吧： mov dword ptr [ebp-8],3 mov eax,dword ptr [ebp-8] add eax,1 mov dword ptr [ebp-8],eax mov ecx,dword ptr [ebp-8] add ecx,1 mov dword ptr [ebp-8],ecx mov edx,dword ptr [ebp-8] add edx,1 mov dword ptr [ebp-8],edx mov eax,dword ptr [ebp-8] add eax,dword ptr [ebp-8] add eax,dword ptr [ebp-8] mov dword ptr [ebp-14h],eax 该怎么吐槽呢，和表兄如出一辙？ 让我们看看 C++ 规范里是怎么写的吧。由于为了此事专门去花212美刀买一份生效了的标准（“US$212, working on getting this down to $60”）而非草案实在是不划算，我只好下载了2014年11月的工作草案。 其中，第106页，5.2.6节规范了后置自增自减（我进行了必要的加粗）： 5.2.6 Increment and decrement [expr.post.incr] The value of a postﬁx ++ expression is the value of its operand. [ Note: the value obtained is a copy of the original value — end note ] The operand shall be a modiﬁable lvalue. The type of the operand shall be an arithmetic type or a pointer to a complete object type. The value of the operand object is modiﬁed by adding 1 to it, unless the object is of type bool, in which case it is set to true. [ Note: this use is deprecated, see Annex D. — end note ] The value computation of the ++ expression is sequenced before the modiﬁcation of the operand object. With respect to an indeterminately-sequenced function call, the operation of postﬁx ++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side effect associated with any single postﬁx ++ operator. — end note ] The result is a prvalue. The type of the result is the cv-unqualiﬁed version of the type of the operand. See also 5.7 and 5.17. The operand of postﬁx — is decremented analogously to the postﬁx ++ operator, except that the operand shall not be of type bool. [ Note: For preﬁx increment and decrement, see 5.3.2. — end note ] 第115页，5.3.2节规范了前置自增自减（我进行了必要的加粗）： 5.3.2 Increment and decrement [expr.pre.incr] The operand of preﬁx ++ is modiﬁed by adding 1, or set to true if it is bool (this use is deprecated). The operand shall be a modiﬁable lvalue. The type of the operand shall be an arithmetic type or a pointer to a completely-deﬁned object type. The result is the updated operand; it is an lvalue, and it is a bit-ﬁeld if the operand is a bit-ﬁeld. If x is not of type bool, the expression ++x is equivalent to x+=1 [ Note: See the discussions of addition (5.7) and assignment operators (5.17) for information on conversions. — end note ] The operand of preﬁx — is modiﬁed by subtracting 1. The operand shall not be of type bool. The requirements on the operand of preﬁx — and the properties of its result are otherwise the same as those of preﬁx ++. [ Note: For postﬁx increment and decrement, see 5.2.6. — end note ] 最后的加粗意思就是说，y = ++x 和 y = x += 1（由于运算优先级有保证，括号省略了）是等价的。（再展开，就是和 y = x = x + 1 等价了，再结合赋值表达式的值规则可以得到结果。） 结论就是：微软你挖了一个至少17年的大坑（时间肯定更长），编译器版本从 12.0（对应 Visual C++ 6.0）到 19.0（对应 Visual Studio 2015），现在还没填上。再往前的编译器我没试过，就当“可能有”吧（这种bug一般就是之前没解决的遗留，较少是新繁殖的虫子）。这个坑一些“思想奇异”的开发者说不定什么时候就往里面跳了，而且如果没有反汇编还爬不出来；复杂的程序你还想慢慢反汇编找？ 我认定这是一个bug，想报告给微软，不过想不起来怎么报告。于是我 Google 了一下“microsoft bug report”。 排名在第一的，微软的帮助论坛上的帖子和吐槽大家就自己看吧。 第二项是 Microsoft Connect。可是点击进去后，页面非常吓人： 我就是想报告一个编译器bug而已啊！您老即使产品线那么大，一眼看上去也没有一个专门给技术人员报bug的地方啊！（这一点从 Visual Studio Code 终于用了自己的公开bug反馈系统开始得到了改善，虽然在 0.9.1 之前隐藏很深……） 在这方面，你看看隔壁 Apache，看看 Mozilla…… 我认了。就选 Visual Studio and .NET Framework 吧。 你要我选哪个？我期望的是一个“CL”或者是一个“Visual Studio Internal Fault”这样的分类啊！ 好吧，我选择 Visual Studio 2015。那么你告诉我，我希望上传示例和截图来帮助提高反馈质量，你们也说了可以上传附件，但是这些是怎么回事： 一堆的脚本加载失败 由此带来的不可上传附件和区域空缺 “&amp;#169;”这样的 HTML 5 常用符号（&#169;）怎么就没有解析了？ 我认为 Chrome 可能不适应微软自家的菜肴，于是我换上了微软的亲女儿 Edge： 你是在逗我吗？ MSDN 上的 C++ 版块充斥着语言应用的帖子，不是提交错误的地方。 这位老兄（年份很早了）想给微软提交一个崩溃报告，但是石沉大海。 以下两位是我搜索“report a compiler bug to visual studio”看到的。 这位老兄实在是幸运，在 Microsoft Connect 提交的编译器错误最终被修复了。 这位老兄的运气就很差，提交了一串bug都没有得到好的反馈，一位善良的客服陪着磨嘴皮子。 看到这里我心都凉了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"CPlusPlus","slug":"CPlusPlus","permalink":"https://blog.mottomo.moe/tags/CPlusPlus/"}]},{"title":"由一个自增引发的问题","slug":"zh/2015-10-22-An-Increment-Problem","date":"2015-10-21T17:42:00.000Z","updated":"2020-07-26T13:48:12.899Z","comments":true,"path":"categories/Tech/Coding/zh/2015-10-22-An-Increment-Problem/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-10-22-An-Increment-Problem/","excerpt":"今天晚上，舍友把我叫过去（他用的是 VC++ 6）问：“这里为什么输出的是16？” 程序非常简单： #include &lt;stdio.h&gt; int main() { int i, j; i = 3; j = (++i) + (++i) + (++i); printf(&quot;%d\\n&quot;, j); return 0; } 我看了一下，回答说：“我觉得是15吧。” 然而，运行输出的不是预计的15（=4+5+6），而是16。我尝试去查找原因，却发现这似乎是编译器挖的一个大大的坑。","text":"今天晚上，舍友把我叫过去（他用的是 VC++ 6）问：“这里为什么输出的是16？” 程序非常简单： #include &lt;stdio.h&gt; int main() { int i, j; i = 3; j = (++i) + (++i) + (++i); printf(&quot;%d\\n&quot;, j); return 0; } 我看了一下，回答说：“我觉得是15吧。” 然而，运行输出的不是预计的15（=4+5+6），而是16。我尝试去查找原因，却发现这似乎是编译器挖的一个大大的坑。 我先开始做实验，尝试捕捉中间结果。 #include &lt;stdio.h&gt; int main() { int i, j, a, b, c; i = 3; j = (a = (++i)) + (b = (++i)) + (c = (++i)); printf(&quot;%d\\na=%d,b=%d,c=%d&quot;, j, a, b, c); return 0; } 然而，这次的输出又是预料中的： 15 a=4,b=5,c=6 也就是说，这几个理论上不会改变代码执行流程的赋值影响了执行结果。后来发现是第一个赋值引起的，后面两个不影响，所以 a 的值不好捕获（不信可以尝试一下）。 然而，如果是两个自增，结果会为10，其中第二个自增（b）的值为5。 我在出去买夜宵的路上在想，也许是编译器的问题？两次访问 i，实际上只是通过地址？（如下面的伪代码） add ptr[i], 1 add ptr[i], 1 stack = ptr[i] + ptr[i] 但是优先级被忽略了？第三个自增为什么没有发生这种情况？我认为解释不通。 再一想，不管怎么样，这是编译器说了算，还是直接看编译的结果吧。回来后我就在他的 VC++ 6 中设了一个断点，看看三个自增的情况下会被编译成什么样子，然后就出现了意料之外的结果： 前两个自增虽然用寄存器进行了缓存，却真的出现了 temp = ptr[i] + ptr[i] 的情况（和语义预期不同）；第三个自增的结果也用寄存器缓存，不过独立地和前面的结果相加，相当于 temp = temp + exx（和语义预期相同）。也就是说，这三个自增，出现了两种执行方式！ 我有时间补上 VC++ 6 的三自增反汇编结果，毕竟我这里已经不再用 VC++ 6 了；舍友都睡觉了。 然后，我在 Visual Studio 2015 上尝试同样的测试（两个自增、三个自增），结果更让我吃惊。 首先是两个自增，结果是10而不是预计的9： int main() { int i, j i = 3; j = (++i) + (++i); return 0; } 反汇编后是这样的： mov dword ptr [ebp-8],3 ; ebp-8 是 i 的地址 mov eax,dword ptr [ebp-8] add eax,1 mov dword ptr [ebp-8],eax mov ecx,dword ptr [ebp-8] add ecx,1 mov dword ptr [ebp-8],ecx mov edx,dword ptr [ebp-8] add edx,dword ptr [ebp-8] ; 注意上面这两行，是谁和谁在相加 mov dword ptr [ebp-14h],edx ; ebp-14h 是 j 的地址 不难看出10是怎么得到的，上面的核心代码和以下的等价： i = 3; ++i; ++i; j = i + i; 当然如果开了反汇编窗口中的“显示符号”选项的话，ebp+* 会被换为更清晰易读的形式（i、j），不过我这里就用最原始的方式来展现了。 然后是三个自增的情况。代码只是一句略有变化： j = (++i) + (++i) + (++i); 猜猜这次的结果是多少？是18，不是预期的15，也不是 VC++ 6 中得到的16。看看反汇编之后的代码吧： mov dword ptr [ebp-8],3 mov eax,dword ptr [ebp-8] add eax,1 mov dword ptr [ebp-8],eax mov ecx,dword ptr [ebp-8] add ecx,1 mov dword ptr [ebp-8],ecx mov edx,dword ptr [ebp-8] add edx,1 mov dword ptr [ebp-8],edx mov eax,dword ptr [ebp-8] add eax,dword ptr [ebp-8] add eax,dword ptr [ebp-8] mov dword ptr [ebp-14h],eax 可以看到，这次的代码和下面一段等价： i = 3; ++i; ++i; ++i; j = i + i + i; 这真是超出预料的。在行为上，不仅是各个版本的编译器行为不同，还都和从语法角度推断的结果不一样。真是不知道这是一个 bug，还是我应该再去读一下 C++ 语言规范了。 总之在有定论之前，不要作大死地使用 (++i) + (++i) 这种人机共愤的语句！ 另外，我并没有在 Visual Studio 2015 中发现明显的控制“反汇编”窗口显隐的菜单项，或许只是因为我的默认界面设置是以 VB 为标准的。在“监视”窗口和“变量”窗口，右键单击都有“转至反汇编”的菜单项，但是按下去没有反应；在“命令”窗口执行 disasm 命令提示无法执行。查阅 MSDN 后发现，要先在[选项]-[调试]-[常规]中打开“地址级调试”选项。选中后就可以正常查看反汇编结果了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"CPlusPlus","slug":"CPlusPlus","permalink":"https://blog.mottomo.moe/tags/CPlusPlus/"}]},{"title":"Bulletproof 的当前状态","slug":"zh/2015-10-20-Current-Status-of-Bulletproof","date":"2015-10-19T16:54:00.000Z","updated":"2020-03-30T22:34:35.425Z","comments":true,"path":"categories/Misc/zh/2015-10-20-Current-Status-of-Bulletproof/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-20-Current-Status-of-Bulletproof/","excerpt":"一直都没回复tt和jabbany，对不起了。 距离上一次 Bulletproof 的代码推送已经超过了一个月。不知star了的各位大神还有多少仍然在关注。这半个月来无声息也是我的问题，不过最近是艰难的一段时间，接下来两个多月也会是。趁着今天还有点时间简要说一下 Bulletproof 的 WebGL 化进度。一些示例截图&amp;目前的问题。","text":"一直都没回复tt和jabbany，对不起了。 距离上一次 Bulletproof 的代码推送已经超过了一个月。不知star了的各位大神还有多少仍然在关注。这半个月来无声息也是我的问题，不过最近是艰难的一段时间，接下来两个多月也会是。趁着今天还有点时间简要说一下 Bulletproof 的 WebGL 化进度。一些示例截图&amp;目前的问题。 填充选用的是 libtess。虽说正如tt提到的，Pixi 采用 earcut 而我们用 libtess，后者能处理更多东西（例如相交处理）不过效率降低，但是目前还没观察到足够复杂的填充环境（虽说以后可能会有）。 现在已经能运行三个基础示例： 可以见到，目前还有如下缺陷： 锯齿！锯齿！锯齿！默认的抗锯齿不能用，而且可能是我没调好 WebGLRenderingContext 的设置，透明度有问题（下面还会提到），导致 FXAA 滤镜效果很差。 DisplayObject 的滤镜没开。按照目前的试验，BlurFilter 似乎是可以用的，GlowFilter 还待调试。开了滤镜后帧率有较大幅度下降。 绿坝娘的裙子缺了一块。估计不是脚本的问题，而是我的代码里漏了什么吧。 外表之下的问题： 所有的临时 WebGLRenderTarget 都是频繁创建、销毁的，造成较大的开销。 ShaderBase 与 WebGLRenderTarget 绑定，这影响了 WebGLRenderTarget 的分配策略，和滤镜的多次处理策略，要学习 Pixi 的方法。 填充和画线逻辑还有点问题（下面会详细讲）。 下面是测试 libtess 计算结果的代码。（默认 winding rule 为 ODD） var s = $.createShape({ lifeTime: 7 }); var g = s.graphics; g.lineStyle(2, 0x00ff00); g.beginFill(0xff0000, 1); g.moveTo(100, 100); g.lineTo(200, 100); g.lineTo(200, 400); g.curveTo(350, 125, 300, 400); g.endFill(); import flash.display.Shape; import flash.display.Graphics; import flash.events.Event; function drawShape (ev) { var s:Shape = new Shape(); this.stage.addChild(s); var g:Graphics = s.graphics; g.beginFill(0, 1.0); g.drawRect(0, 0, s.width, s.height); g.endFill(); g.lineStyle(2, 0x00ff00); g.beginFill(0xff0000, 1); g.moveTo(100, 100); g.lineTo(200, 100); g.lineTo(200, 400); g.curveTo(350, 125, 300, 400); g.endFill(); } this.stage.addEventListener(Event.ENTER_FRAME, drawShape); 你可能要奇怪了，为什么填充的 alpha 选择的是 1.0 呢？因为在 0.4 的时候，二者是这个样子的： 根本看不出来对么？不过确实填充了，切换到 alpha 为 0.8 时： 如果靠近屏幕，勉强能看到一点。0.9 时再明显一点，1.0 就直接变成纯色了。所以目前我还不清楚是什么导致了这个 alpha 变化与预期不符的问题。标准输出应该如下： alpha 直接影响了 FXAA 的结果。我们这里弄得源图像（有大量透明空白区域）的 alpha 全是 1.0 一样，计算半透明时透明的点都当成纯黑点了。要不你看人家示例多正常…… 更复杂的示例也有准备，不过也只是部分正确，moveTo() 的处理和 closePath() 的处理要改。 var s = $.createShape({ lifeTime: 7 }); var g = s.graphics; g.lineStyle(2, 0x00ff00); g.beginFill(0xff0000, 1.0); g.moveTo(100, 100); g.lineTo(200, 200); g.lineTo(150, 200); g.lineTo(150, 120); g.moveTo(100, 150); g.lineTo(200, 150); g.lineTo(200, 170); g.lineTo(100, 170); g.lineTo(100, 150); g.drawCircle(20, 20, 10); g.lineTo(0, 0); g.endFill(); import flash.display.Shape; import flash.display.Graphics; import flash.events.Event; function drawShape (ev) { var s:Shape = new Shape(); this.stage.addChild(s); var g:Graphics = s.graphics; g.lineStyle(2, 0x00ff00); g.beginFill(0xff0000, 1.0); g.moveTo(100, 100); g.lineTo(200, 200); g.lineTo(150, 200); g.lineTo(150, 120); g.moveTo(100, 150); g.lineTo(200, 150); g.lineTo(200, 170); g.lineTo(100, 170); g.lineTo(100, 150); g.drawCircle(20, 20, 10); g.lineTo(0, 0); g.endFill(); } this.stage.addEventListener(Event.ENTER_FRAME, drawShape); 可能先得保证活命了，课内自己开一个组单挑别的组（5~7人×6），真是作死。不过他们的思想和经验都远远没那么先进，你能想象他们看着10年前的教学示例，由于不知道什么开发技术，就要沿着10年前的老路用 Access + VBA 来开发一个 ERP 系统么？（他们 VBA 也应该会是从视频课程里学的，到最后也只是应用上略知皮毛而已。针对我设计时的方案文本，老师曰：“我们不是做软件工程的，是做应用软件的。”我倒不认为这是采用落后的工具和符合行业风气的丑陋美工的借口。）不过“中国人的集体智慧”可是不可以轻视的…… 可能要断断续续拖到第一场之后了…… 给了我最大震撼的软件产品有两个，第一个是 Windows XP（尤其是桌上弹球），第二个是 Grand Theft Auto 3。之后就没有能如此将我 shock 到的软件了。我还是很怀念原来的感觉，所以我想做一些自己能认同的东西（村长语：你不要总是批评别人啊，你见到哪个批评家被历史记住的），仅此而已。所以为了摆脱目前的环境，我需要做出合理的牺牲。 关于惊叹的历史，有时间再说。（好像以前几个说“有时间再说”的文章都没写下去了……）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"杂记","slug":"zh/2015-10-18-Misc","date":"2015-10-17T17:10:00.000Z","updated":"2020-03-30T22:34:35.425Z","comments":true,"path":"categories/Misc/zh/2015-10-18-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-18-Misc/","excerpt":"","text":"在B站看到了一个乐正绫发声的《Cras numquam scire》，不管是拉丁语部分还是日语部分都调教得很棒。 于是回到云音乐去找完整版（之前在工作用歌单里放的是 TV size），找到了：http://music.163.com/#/m/song?id=26083399。一看，歌词和翻译提供是木耳也要听歌，就是几个月前漫版群里提到的做了按会社分类的歌单的那位，对 ACG 颇有研究。 想想现在在云音乐上提供的歌词8份，翻译9份（分别还有4/3份现在还在审核中，还有一些待上传。范围……gal 和看过的一些冷番，碰巧听到旋律还行而没有歌词、翻译的就顺手做一份，这样随性的。和那位比高下立判。又是巨大的挫折感，恐怕我永远无法追及…… 继前几次的 WebGL 实验，大前天开始整合进来，昨天下午终于能勉强显示一个线框球（示例1）了。但是多个 buffer 还是失败。18日22点成功，发现这次也是漏了投影矩阵，或者设为了单位阵。 在博客园的一篇博文里看到一段话，大意是这样的： 函数式是函数包装数据（引用数据），面向对象是对象包装方法，这是数据和函数结合的两种方式。 于是茅塞顿开，这就是为什么 JavaScript 的函数+原型链能模拟面向对象的编程风格。一直隐隐觉得两个思想指的不是一个方向，但居然能兼容（OOPL 也可以通过引入 lambda 表达式来提供函数式的支持）。或曰，闭包和类在表现上是等价的。 后来突然意识到这个观点给我很深的影响，但是出处找不到了…… http://www.cnblogs.com/suimeng/p/4886561.html Source 里很多这种例子。 WebGL（遵循 OpenGL ES 2.0）不支持 Framebuffer 抗锯齿（anti-aliased Render-To-Texture），只好自己来了。抗锯齿本来想用这个的，不过这是 Unity 下的啊…… 暂时用了 FXAA，效果不是很理想，可能还要改。具体技术，下次正式的记录里再说吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"TD线上的“缓冲区溢出攻击”","slug":"zh/2015-10-12-Buffer-Overflow-on-TD-Line","date":"2015-10-12T13:23:00.000Z","updated":"2020-03-30T22:34:35.425Z","comments":true,"path":"categories/Misc/zh/2015-10-12-Buffer-Overflow-on-TD-Line/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-12-Buffer-Overflow-on-TD-Line/","excerpt":"（本文写作时间跨度为12、13日） 对TD线本学期新政策的批评，附照片。照片未压缩，谨慎浏览。","text":"（本文写作时间跨度为12、13日） 对TD线本学期新政策的批评，附照片。照片未压缩，谨慎浏览。 新学期的TD政策：大一到大三有一门0.1学分的体育必修课，内容为本学期刷48次TD。大四原有12分钟跑，所以可以在二者中选择一个，无论是刷满了还是跑过了都算过。TD线路的具体路线，沙河那边是游泳馆一个点（A），操场两个点（A-B），原有TD线两个点（A-B），本部这边是原有TD线两个点（A-B），操场两个点（A-B-A）。有早中晚三个时段，分别是06:40-07:40，12:30-14:30，17:10-18:30。 由于原本刷TD只是体育加分政策的一环（刷满40次总分加10分），而这个学期突然就变成了必修，许多人措手不及。从试运行的两天（8日、9日）来看，操场人还是比较少的，每个刷卡点排上两三分钟的队就可以了。传统TD线人倒是很多，TD最后要从一个台子上滑杆下来或者爬梯子下来，下面是一个4×4左右的缓冲区，刷卡的B点就在这里——靠墙放置的刷卡机已经被淹没，缓冲区里几乎都是人（实际上人只占了70%的可用空间，居然不会去优化），甚至一些人还不能从高台上下来。 但是随着正式计算时间的开始，操场的人数呈现指数增长的态势。 今天下午五点十分开始的时候过去刷，大概30米长（×2，两个点），后来是35米（×2），走的时候（33分）时40米。还好去得早，晚一点又碰上高峰；六点半前据同学报告“别想刷卡了”。 通知上结尾处是这么说的： 一天三次的锻炼开放时间，每次锻炼时间刷卡有且只能有一次，这就意味着你连续16个工作日，3周+1天就可以获得学分，这不比考试容易得多吗？不要因为排队就不开心，在中国哪有不等待的事情，但是请同学们放心，我们会尽快地减少排队等待时间。 另机器少的原因，主要是供应商的供货价格偏高。所以希望我们北航的有志青年……一是提出宝贵改革建议，二是创造我们自主研发的产品，降低成本…… （注：对原文虚词、标点误用和语法错误做了修正） 好了，“不要因为排队就不开心”，可是我每次排队都不开心。13日的时候我算了一下，排一个队的大概有110-120人。现在那个机器是什么情况呢？上一个同学刷卡成功后，它发出声音“刷卡成功”并停留显示两秒；上一个此时走开，下一个过来，卡放在感应区、面部对着摄像头（理论上要记录打卡时的照片）也要等两秒多才能识别并切换到报告；如果校园卡信息读取失败则需要手工输入学号。 刷卡的问题找到了~旧卡读出的数据是十进制，新卡读出的数据是疑似十六进制~完成之前的算法不可用！如果办卡那里给不出好的解决方法，持新卡的人不太多，考虑到经济问题，可能就不会改算法了！所以叫同学们暂且输学号，哪天发现能刷卡就刷卡~ 我们就少吐槽学校的任务交付出了多少问题了。在此之前发消息的人你确定不是 BCD 编码和 HEX 编码的问题么，说什么十进制十六进制…… 好了上面有点偏题。这里我们来看一下这个“排队”会排多久吧。按照120人计算，假设一人刷一次（没有代刷），每个人是完全理性的，所用时间4.5秒（几乎是极限），那么站在120人的队伍最后的我排这个队需要 120 ÷ (60 ÷ 4.5) = 9 (分钟) 当然，我在这三天遇到了超过5个代刷的，而且人的移动并不是很理性。再加上跑/走800米所需的时间，在操场每次刷TD需要超过30分钟。（至于原TD线的数据如何，本学期没去过原TD线路所以不清楚，不过机器的速度是差不多的。）对比一下之前提到的开放时间数据，你就知道有多少人能幸运地刷上了。另外，谁不想一天刷至少两次呢？于是平均一天就花了超过一个小时在这TD上。 另外，每个时间段按照开放一个半小时计算，假设TD终点、操场两个点一共3个点都最大化效率地利用了，理论上最多能容纳多少人呢？ 3 × 1.5 × 3600 ÷ 4.5 = 3600 (人) 3600人什么概念？略多于北航一届本科生人数。自己想一想，大三100%需要刷TD，大四由于有第二选项12分钟跑，假设有10%的人因不想忍受12分钟跑而来刷。那么这个容纳量刚刚好，在理论条件下。当然，由于一共就4台机器，每台机器每个时间段都要受到1200人的蹂躏，看这质量能撑多久。 13日中午，我12:30到操场A点，第二次刷A点的时候已经过了13:00，于是13:07得以才出操场。午睡就泡汤了。同时，A点机器在第二次刷的时候已经通信失败了，说是先刷卡将数据存在机器里，修复后上传。 看着旁边TD线B点，高台上还站着人，我的第一感觉就是：缓冲区溢出啦！输入超过处理能力啦！ 所以，学校那些批下这个强制刷TD政策的人，你也许用心是好的，但是能不要拍脑袋吗？或许，做出这个决定的人根本不用来刷呢。 13日下午，17:30左右的补充照片，让你们见识一下TD长龙。 这个生物日（起床-睡觉，和自然日不太一样……）报告了两个bug： https://code.visualstudio.com/issues/detail/19984（由于傲游 UA 错误，系统版本不太对，应该是 10.0.10240 的。傲游可能是没写好 manifest，就像是这里所说的一样。） https://bugs.mysql.com/78807","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"WebGL 测试4 - Framebuffer 和滤镜","slug":"zh/2015-10-11-WebGL-Test-4","date":"2015-10-11T12:20:00.000Z","updated":"2020-03-30T22:34:35.422Z","comments":true,"path":"categories/Tech/Coding/zh/2015-10-11-WebGL-Test-4/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-10-11-WebGL-Test-4/","excerpt":"示例可以在这里查看。此次的示例挺有意思的（个人觉得），推荐看看。效果的图片预览请展开。 我似乎有几篇博文都说“预览请展开”的，那是因为不想浪费大家流量，如果有图片，或者文章过长的话就把一两句描述放前面，感兴趣的同学可以花一点流量阅读细节。 题外话： 前天晚上和村长对话了。村长得知我要考研之后很惊讶：“你居然去考研？堕落了！”然后推荐我去申国外。其他保守看应该没问题，不过先把外语水平考试（I/T）考了，才能投申请啊（所以不趁有时间考 I/T 的我是不是很愚蠢）。 所以之后会很忙（其实已经比正常的准备时间都推后了），不管是哪条线都会很忙。所以尽快将 Bulletproof 写到能运行示例的程度就暂时放在一边，火力全开为生存而斗争吧。jabanny 的邮件还没回复，和 tt 在 xross 上的试验讨论也暂缓（suspended）了。先说声对不起了。 这次我们来反向的是 Pixi 的滤镜，采用帧缓冲（Framebuffer）作为绘制缓冲区。想当初 Bulletproof 底层换到 Pixi 上就是因为有一个高速滤镜的硬需求。 此次的着色器和 JavaScript 代码都是几乎推倒重来的，因为要考虑迁移到 TypeScript 上时的 OO 特性。 （文中的代码和示例的代码可能有少许不同，以示例为准，因为是之后又经过调试的。） 通过的测试环境：Windows 10, Chrome 45 / Firefox 41 / IE 11 / Edge。 未通过的测试环境（由尝鲜的杨同学提供）：OSX El Capitan, Chrome 47-dev / Safari 9。","text":"示例可以在这里查看。此次的示例挺有意思的（个人觉得），推荐看看。效果的图片预览请展开。 我似乎有几篇博文都说“预览请展开”的，那是因为不想浪费大家流量，如果有图片，或者文章过长的话就把一两句描述放前面，感兴趣的同学可以花一点流量阅读细节。 题外话： 前天晚上和村长对话了。村长得知我要考研之后很惊讶：“你居然去考研？堕落了！”然后推荐我去申国外。其他保守看应该没问题，不过先把外语水平考试（I/T）考了，才能投申请啊（所以不趁有时间考 I/T 的我是不是很愚蠢）。 所以之后会很忙（其实已经比正常的准备时间都推后了），不管是哪条线都会很忙。所以尽快将 Bulletproof 写到能运行示例的程度就暂时放在一边，火力全开为生存而斗争吧。jabanny 的邮件还没回复，和 tt 在 xross 上的试验讨论也暂缓（suspended）了。先说声对不起了。 这次我们来反向的是 Pixi 的滤镜，采用帧缓冲（Framebuffer）作为绘制缓冲区。想当初 Bulletproof 底层换到 Pixi 上就是因为有一个高速滤镜的硬需求。 此次的着色器和 JavaScript 代码都是几乎推倒重来的，因为要考虑迁移到 TypeScript 上时的 OO 特性。 （文中的代码和示例的代码可能有少许不同，以示例为准，因为是之后又经过调试的。） 通过的测试环境：Windows 10, Chrome 45 / Firefox 41 / IE 11 / Edge。 未通过的测试环境（由尝鲜的杨同学提供）：OSX El Capitan, Chrome 47-dev / Safari 9。 图片预览： 可以看到，应用了滤镜的矩形被像素化了，而没应用滤镜的三角形前后无变化。 话说玩过 XNA/MonoGame 的同学应该知道，其中有一个继承自 Texture2D 的类 RenderTarget2D，使用方式大概是这样的（参数什么的从简了）： RenderTarget2D target = new RenderTarget2D(); game.SetRenderTarget(target); // 切换到缓冲区输出 SomeDrawableComponents.draw(gameTime); game.SetRenderTarget(null); // 切换回屏幕输出 DrawTheTextureToASurface(target, someSurface); 这样实现的是一个类似游戏内屏幕的效果（例如 Half Life 2 的 Breencast 在各种屏幕上的投影）。很“碰巧”地，这种方式在 Pixi 中也见到了（详情请见 Pixi 的多重滤镜机制的代码）。 来分析一下。滤镜的基本操作流程是： 绘制原始图形； 处理此图形； 拷贝到输出（可选，如果前两步直接在屏幕缓冲区完成的话）。 WebGL 中的绘图完全是由着色器根据给定的顶点、颜色、索引数据画的。像 BitBlt() 这样的缓冲区数据复制函数是不能用的。那么有没有一种方法，叫做 copyBetweenRenderTargets(from, to) 呢？没有。 这里从 WebGL 的一个着色器类型 sampler2D，Framebuffer 的一个操作 gl.framebufferTexture2D() 和 XNA/MonoGame 的 API 可以猜想（还用得着猜吗），既然我们看的屏幕是二维的，Texture2D 是二维的，那么就利用 Texture2D 作为真正的缓冲区。（附：GDI+ 中，WinForms 封装了一个 Graphics.FromBitmap() 方法，理由类似。）其实也可以想一下，如果屏幕进入到三维（立体投影），这种绘图习惯应该会改变吧？ 首先我们来看一下这次用到的三组着色器。 原始绘图着色器（顶点、片元）： attribute vec3 aVertexPosition; attribute vec4 aColor; uniform mat4 uProjMatrix; varying vec4 vColor; void main() { gl_Position = uProjMatrix * vec4(aVertexPosition.xyz, 1.0); vColor = aColor; } precision mediump float; varying vec4 vColor; void main() { gl_FragColor = vColor; } 像素化着色器（顶点、片元）： // Borrowed from pixi.js - default vertex shader precision lowp float; attribute vec3 aVertexPosition; attribute vec2 aTextureCoord; attribute vec4 aColor; uniform mat4 uProjMatrix; varying vec2 vTextureCoord; varying vec4 vColor; void main() { gl_Position = uProjMatrix * vec4(aVertexPosition.xyz, 1.0); vTextureCoord = aTextureCoord; vColor = vec4(aColor.rgb * aColor.a, aColor.a); } // Borrowed from pixi.js - pixelate filter - fragment shader precision mediump float; varying vec2 vTextureCoord; uniform vec4 dimensions; uniform vec2 pixelSize; uniform sampler2D uSampler; void main() { vec2 coord = vTextureCoord; vec2 size = dimensions.xy / pixelSize; vec2 color = floor((vTextureCoord * size)) / size + pixelSize / dimensions.xy * 0.5; gl_FragColor = texture2D(uSampler, color); } 输出至屏幕时的着色器（顶点、片元）： attribute vec3 aVertexPosition; attribute vec2 aTextureCoord; uniform mat4 uProjMatrix; varying vec2 vTextureCoord; void main() { gl_Position = uProjMatrix * vec4(aVertexPosition.xyz, 1.0); vTextureCoord = aTextureCoord; } precision mediump float; uniform sampler2D uSampler; varying vec2 vTextureCoord; void main() { gl_FragColor = texture2D(uSampler, vTextureCoord); } 可以看到，变量名统一了（aVertexPosition、aColor、aTextureCoord、uSampler），因为要在多个处理过程中用到。 其中，原始着色器的作用是按照指定的颜色和位置进行输出；像素化着色器处理；屏幕输出着色器则是做了类似拷贝的操作（直接绘制贴图），稍后在代码里可以看到是怎么结合使用的。 接下来从总绘制逻辑开始分解说明。 /** * @param {Boolean} [pixelate] */ function render(pixelate) { if (pixelate === undefined) { pixelate = true; } if (pixelate) { rawTarget.use(); rawTarget.renderElements($_rect_vertices, $_rect_colors, $_rect_indices); pixelateTarget.use(); pixelateTarget.renderRenderTarget(rawTarget); screenTarget.use(); screenTarget.renderRenderTarget(pixelateTarget); } else { rawScreenTarget.use(); rawScreenTarget.renderElements($_rect_vertices, $_rect_colors, $_rect_indices); } rawScreenTarget.use(); rawScreenTarget.renderElements($_tri_vertices, $_tri_colors, $_tri_indices, false); } 先进行最初的绘制，画出一个矩形（renderElements()），然后由像素化滤镜在自己的缓冲区内处理（renderRenderTarget()），最后绘制到屏幕上（renderRenderTarget()）。 在创建上，四个 RenderTarget 指定了不同的着色器和输出方式。 function initRenderTargets() { glc.disable(gl.DEPTH_TEST); glc.enable(gl.BLEND); glc.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); var mat4 = new Matrix4(); mat4.setOrtho(0, canvas.width, 0, canvas.height, -1000, 0); /** * @type {Shader} */ var rawShader = new Shader(glc, Shader.getShaderSourceFromElement(document.getElementById(&quot;vshader-raw&quot;)), Shader.getShaderSourceFromElement(document.getElementById(&quot;fshader-raw&quot;)), { &quot;uProjMatrix&quot;: {type: UniformType.MAT4, value: mat4.elements} }, [&quot;aVertexPosition&quot;, &quot;aColor&quot;] ); /** * @type {Shader} */ var screenShader = new Shader(glc, Shader.getShaderSourceFromElement(document.getElementById(&quot;vshader-screen&quot;)), Shader.getShaderSourceFromElement(document.getElementById(&quot;fshader-screen&quot;)), { &quot;uProjMatrix&quot;: {type: UniformType.MAT4, value: mat4.elements}, &quot;uSampler&quot;: {type: UniformType.SAMPLER2D, value: 0} }, [&quot;aVertexPosition&quot;, &quot;aTextureCoord&quot;] ); /** * @type {Shader} */ var pixelateShader = new Shader(glc, Shader.getShaderSourceFromElement(document.getElementById(&quot;vshader-pixelate&quot;)), Shader.getShaderSourceFromElement(document.getElementById(&quot;fshader-pixelate&quot;)), { &quot;uProjMatrix&quot;: {type: UniformType.MAT4, value: mat4.elements}, &quot;dimensions&quot;: {type: UniformType.VEC4, value: [canvas.width, canvas.height, 0, 1]}, &quot;pixelSize&quot;: {type: UniformType.VEC2, value: [50, 50]}, &quot;uSampler&quot;: {type: UniformType.SAMPLER2D, value: 0} }, [&quot;aVertexPosition&quot;, &quot;aTextureCoord&quot;, &quot;aColor&quot;] ); rawTarget = new RenderTarget(glc, canvas.width, canvas.height, rawShader); pixelateTarget = new RenderTarget(glc, canvas.width, canvas.height, pixelateShader); screenTarget = new RenderTarget(glc, canvas.width, canvas.height, screenShader, true); rawScreenTarget = new RenderTarget(glc, canvas.width, canvas.height, rawShader, true); g_pixelateShader = pixelateShader; } Shader 的构造函数如下： /** * @param {WebGLRenderingContext} glc * @param {String} vshader 顶点着色器源代码 * @param {String} fshader 片元着色器源代码 * @param {Object} uniforms 存储键值对，键为 uniform 变量名称，值为对应的 WebGLUniform 类实例 * @param {String[]} attributeNames attribute 变量的名称（注意只需要名称，因为对一般是手工操作） * @constructor */ function Shader(glc, vshader, fshader, uniforms, attributeNames) { } Shader 类负责管理一个着色器实例（关联至 WebGLProgram），以及提供对应变量的自动更新操作。这种做法学习自 Pixi。 RenderTarget 的构造函数如下： /*** * @param {WebGLRenderingContext} glc * @param {Number} width * @param {Number} height * @param {Shader} shader * @param {Boolean} [isRoot] * @constructor */ function RenderTarget(glc, width, height, shader, isRoot) { } isRoot 参数控制着 RenderTarget 的行为。为 true 时表示将要直接绘制到屏幕上（缓冲区为 null），为 false 时表示这个 RenderTarget 是一个缓冲用的 RenderTarget，绘制操作发生在帧缓冲区（Framebuffer）内。 其实整个绘制的过程几乎是一致的，除了： 直接绘制到屏幕上的 RenderTarget 中，frameBuffer 为 null，texture 为 null； 作为缓冲区的 RenderTarget 中，frameBuffer 和 texture 都不为 null。 二者的区别在初始化时就已经决定，在绘制时两种 RenderTarget 共享绘制代码。大致如下： // renderElements() 中 glc.viewport(0, 0, this._width, this._height); this.use(); shader.use(); shader.updateUniforms(); var FSIZE = Float32Array.BYTES_PER_ELEMENT; glc.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer); glc.bufferData(gl.ARRAY_BUFFER, verticesTyped, gl.STATIC_DRAW); glc.vertexAttribPointer(shader.getAttributeLocation(&quot;aVertexPosition&quot;), 3, gl.FLOAT, false, FSIZE * 3, 0); glc.enableVertexAttribArray(shader.getAttributeLocation(&quot;aVertexPosition&quot;)); glc.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer); glc.bufferData(gl.ARRAY_BUFFER, colorsTyped, gl.STATIC_DRAW); glc.vertexAttribPointer(shader.getAttributeLocation(&quot;aColor&quot;), 4, gl.FLOAT, false, FSIZE * 4, 0); glc.enableVertexAttribArray(shader.getAttributeLocation(&quot;aColor&quot;)); glc.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer); glc.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesTyped, gl.STATIC_DRAW); if (clear) { glc.clearColor(0, 0, 0, 0); glc.clearDepth(0); glc.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } glc.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0); // renderRenderTarget() 中 this.use(); shader.use(); shader.updateUniforms(); var FSIZE = Float32Array.BYTES_PER_ELEMENT; // Bind target texture to current content glc.activeTexture(gl.TEXTURE0); glc.bindTexture(gl.TEXTURE_2D, renderTarget.texture); glc.bindBuffer(gl.ARRAY_BUFFER, glVertexPositionBuffer.buffer); glc.bufferData(gl.ARRAY_BUFFER, vertexPositionsTyped, gl.STATIC_DRAW); glc.vertexAttribPointer(shader.getAttributeLocation(&quot;aVertexPosition&quot;), 3, gl.FLOAT, false, FSIZE * 3, 0); glc.enableVertexAttribArray(shader.getAttributeLocation(&quot;aVertexPosition&quot;)); glc.bindBuffer(gl.ARRAY_BUFFER, glTextureCoordBuffer.buffer); glc.bufferData(gl.ARRAY_BUFFER, textureCoordsTyped, gl.STATIC_DRAW); glc.vertexAttribPointer(shader.getAttributeLocation(&quot;aTextureCoord&quot;), 2, gl.FLOAT, false, FSIZE * 2, 0); glc.enableVertexAttribArray(shader.getAttributeLocation(&quot;aTextureCoord&quot;)); glc.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glTextureIndexBuffer.buffer); glc.bufferData(gl.ELEMENT_ARRAY_BUFFER, textureIndicesTyped, gl.STATIC_DRAW); if (clear) { glc.clearColor(1, 0, 0, 0); glc.clearDepth(0); glc.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } glc.drawElements(gl.TRIANGLES, textureIndices.length, gl.UNSIGNED_SHORT, 0); RenderTarget.use() 方法很简单： RenderTarget.prototype.use = function () { var glc = this._glc; // We did not provide a image as the input, so there is no need to flip vertically. glc.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0); glc.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer); }; 核心就在一个 gl.bindFramebuffer() 上。之前说过直接输出时 frameBuffer 为 null，否则不为 null。而将渲染目标切回屏幕时 bindFramebuffer() 的参数正好为 null，于是二者在形式上就统一了。 其他的代码大多数是做绘制数据管理（创建、保存、回收）的，按照规范来就可以了。 最后提醒一下，在创建贴图的时候，要创建一个长宽都为2的整数次方的贴图，否则 WebGL 会报错说无法创建。因此在创建缓冲区（基于贴图）之前要手工调整宽高，使之都为2的整数次方。 Enjoy.","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"},{"name":"WebGL","slug":"WebGL","permalink":"https://blog.mottomo.moe/tags/WebGL/"}]},{"title":"WebGL 测试3 - 移动元素","slug":"zh/2015-10-09-WebGL-Test-3","date":"2015-10-09T06:18:00.000Z","updated":"2020-03-30T22:34:35.421Z","comments":true,"path":"categories/Tech/Coding/zh/2015-10-09-WebGL-Test-3/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-10-09-WebGL-Test-3/","excerpt":"示例可以在这里查看。 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 这次的试验项目是图形的变换，简单平移一下，按上下左右就可以玩了。","text":"示例可以在这里查看。 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 这次的试验项目是图形的变换，简单平移一下，按上下左右就可以玩了。 片元着色器不用改。改动顶点着色器： attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; // 新加入的矩阵：模型状态矩阵 uniform mat4 u_ModelMatrix; uniform mat4 u_ProjMatrix; void main() { gl_Position = u_ProjMatrix * u_ModelMatrix * a_Position; v_Color = a_Color; } 这里就有点线性代数的知识了。对于一个点（相对于原点的向量 &lt;x, y, z&gt;，齐次化后为 &lt;x, y, z, 1&gt;），要计算其在经过三维变换（平移、缩放、旋转、扭曲）和投影（正交投影/透视投影）后的新坐标，可以根据以下公式计算得到： &lt;x&#39;, y&#39;, z&#39;, 1&gt; = M(proj) * M(view) * &lt;x, y, z, 1&gt; 其中 M(proj) 是投影矩阵，M(view) 是模型的变换矩阵。两种矩阵的生成和原理到处都是，自行学习。 为了迎接新成员，要声明新的变量： /** * @type {Matrix4} */ var modelMatrix; /** * @type {WebGLUniformLocation} */ var u_ModelMatrix; /** * @type {Number} */ var locX = 0; /** * @type {Number} */ var locY = 0; modelMatrix = new Matrix4(); modelMatrix.setIdentity(); updateModelMatrix(glc, modelMatrix, u_ModelMatrix); Matrix4 使用的是原书附的代码，作者是 Takafumi Kanda 和 Kouichi Matsuda。 对于这个矩阵，数据要适时更新： /** * @param {WebGLRenderingContext} glc * @param {Matrix4} m * @param {WebGLUniformLocation} location */ function updateModelMatrix(glc, m, location) { glc.uniformMatrix4fv(location, false, m.elements); } 然后注册键盘事件，在响应函数中处理即可。 /** * @param {KeyboardEvent} ev */ function documentOnKeyDown(ev) { switch (ev.keyCode) { case 38: // u locY += 2; modelMatrix.setTranslate(locX, locY, 0); updateModelMatrix(glc, modelMatrix, u_ModelMatrix); break; case 40: // d locY -= 2; modelMatrix.setTranslate(locX, locY, 0); updateModelMatrix(glc, modelMatrix, u_ModelMatrix); break; case 37: // l locX -= 2; modelMatrix.setTranslate(locX, locY, 0); updateModelMatrix(glc, modelMatrix, u_ModelMatrix); break; case 39: // r locX += 2; modelMatrix.setTranslate(locX, locY, 0); updateModelMatrix(glc, modelMatrix, u_ModelMatrix); break; default: break; } } 基本的介绍就到这个地方。此次的示例还添加了一点新东西：Three.js 的性能监视器插件 Stats（压缩后）。 Stats 的基础使用可以见这篇文章。本例中的使用也很简单： function initStatElement(parentID) { var stats = new Stats(); var d = stats.domElement; d.style.position = &quot;absolute&quot;; d.style.right = &quot;0&quot;; d.style.top = &quot;0&quot;; document.getElementById(parentID).appendChild(d); return stats; } var stats = initStatElement(&quot;canvas-frame&quot;); function animate1() { stats.update(); requestAnimationFrame(animate1); } animate1(); 这里就出现了一个问题。可以看到，为了更新 stats 显示的内容，我们要用 requestAnimationFrame() 注册一个回调函数。同时，为了响应三角形的位置变化，我们还要另一个回调函数来绘制（而不像之前那样静态绘制）： function animate2() { drawLines(glc); requestAnimationFrame(animate2); } animate2(); 二者不会打架吗？更好的方法是统一到一个函数里，例如这样： function animateUltimate() { stats.update(); drawLines(glc); requestAnimationFrame(animateUltimate); } animateUltimate(); 考虑到要调用的函数一旦多起来，这样就难以管理，于是可以设计一个简单的调用队列： /** * @type {Function[]} */ var fs = []; var fthis = []; var fargs = []; /** * @param {Function} f * @param {any} _this * @param {any[]} args */ function addToAnimationLoop(f, _this, args) { fs.push(f); fthis.push(_this); fargs.push(args); } addToAnimationLoop(stats.update, stats); addToAnimationLoop(drawLines, this, [glc]); function animate() { for (var k = 0; k &lt; fs.length; k++) { // apply 展开参数数组，call 内联参数数组 fs[k].apply(fthis[k], fargs[k]); } requestAnimationFrame(animate); } animate(); 于是这样就差不多了。Have fun.","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"},{"name":"WebGL","slug":"WebGL","permalink":"https://blog.mottomo.moe/tags/WebGL/"}]},{"title":"WebGL 测试2 - 简单的有粗细的线条","slug":"zh/2015-10-08-WebGL-Test-2","date":"2015-10-07T17:47:00.000Z","updated":"2020-03-30T22:34:35.421Z","comments":true,"path":"categories/Tech/Coding/zh/2015-10-08-WebGL-Test-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-10-08-WebGL-Test-2/","excerpt":"示例可以在这里查看。 续上，这次我们添加一个小小的改进，给线条指定宽度。","text":"示例可以在这里查看。 续上，这次我们添加一个小小的改进，给线条指定宽度。 我们知道，由于 ANGLE 的限制，在 Windows 平台上 gl.lineWidth() 函数并不能用。那么要画宽度不是1的线条怎么办呢？按照上次我提出的“用矩形模拟”的方法是一种思路。 修改 main() 函数，这里我们动态加入线条。 function main() { if (!initShaders(glc, &quot;vshader-color&quot;, &quot;fshader-color&quot;)) { console.log(&quot;Failed to intialize shaders.&quot;); return; } // 这里添加三条线 verticesAndColorsArray = verticesAndColorsArray .concat(calculateLineVertices(0, 40, -40, 0, 5, 1, 0, 0)) .concat(calculateLineVertices(-40, 0, 40, 0, 3, 0, 1, 0)) .concat(calculateLineVertices(40, 0, 0, 40, 1, 0, 0, 1)); // 不使用 WebGL 的线宽设置（保持默认） //glc.lineWidth(5); var u_ProjMatrix = glc.getUniformLocation(glc.program, &quot;u_ProjMatrix&quot;); if (!u_ProjMatrix) { console.log(&quot;Failed to get the storage location of u_ProjMatrix.&quot;); return; } var projMatrix = new Matrix4(); projMatrix.setOrtho(-canvas.width / 2, canvas.width / 2, -canvas.height / 2, canvas.height / 2, 0, 1000); glc.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements); drawLines(glc); } 同时，由于我们使用矩形来模拟，也就是要画三角形，那么就要保证顶点数组的排列符合预期。这里我们选用 gl.TRIANGLES。 为什么不选用 gl.TRIANGLE_STRIP 或者 gl.TRIANGLE_FAN 加上索引-顶点呢？嘛，这是个简单的示例而已……索引+顶点到时候很可能要用的（将顶点 6N 的数据量压成了 2N+2 啊），不过考虑到画线时的相接情况，TRIANGLE_STRIP 和 TRIANGLE_FAN 在处理上会麻烦一些。 /** * @param {WebGLRenderingContext} glc */ function drawLines(glc) { /** * @type {Number} */ var n; if ((n = initVertexBuffers(glc)) &lt;= 0) { console.log(&quot;Failed to initialize vertex buffers.&quot;); return; } clearCanvas(glc); // 这次改用 gl.TRIANGLES 绘制 glc.drawArrays(gl.TRIANGLES, 0, n); } 顶点数组中每个顶点的格式不变，我们写一个函数生成需要的格式数组。其实就是一个简单的平面几何而已，最多不过 tan2(x) 的变换。 注意 WebGL 使用的坐标系（源自 OpenGL）和数学上的是一致的（正方向为右、上），和一般操作系统的坐标系（正方向为右、下）关系是相互为 Y 轴翻转。 /** * @param {Number} x1 * @param {Number} y1 * @param {Number} x2 * @param {Number} y2 * @param {Number} width * @param {Number} r * @param {Number} g * @param {Number} b * @returns {Number[]} */ function calculateLineVertices(x1, y1, x2, y2, width, r, g, b) { if (width &lt; 0) { return []; } var halfWidth = width / 2; var vert1 = [0, 0, r, g, b], vert2 = vert1.slice(), vert3 = vert2.slice(), vert4 = vert3.slice(); if (x1 == x2) { vert1[0] = x1 - halfWidth; vert1[1] = y1; vert2[0] = x1 + halfWidth; vert2[1] = y1; vert3[0] = x2 - halfWidth; vert3[1] = y2; vert4[0] = x2 + halfWidth; vert4[1] = y2; } else { // a little tricky /** * @type {Number} */ var slope = (y2 - y1) / (x2 - x1); /** * @type {Number} */ var ct = 1 / Math.sqrt(1 + slope * slope); /** * @type {Number} */ var st = Math.sqrt(1 - ct * ct); /** * @type {Number} */ var dx = halfWidth * st; /** * @type {Number} */ var dy = halfWidth * ct; if (slope &gt;= 0) { vert1[0] = x1 - dx; vert1[1] = y1 + dy; vert2[0] = x1 + dx; vert2[1] = y1 - dy; vert3[0] = x2 - dx; vert3[1] = y2 + dy; vert4[0] = x2 + dx; vert4[1] = y2 - dy; }else { vert1[0] = x1 - dx; vert1[1] = y1 - dy; vert2[0] = x1 + dx; vert2[1] = y1 + dy; vert3[0] = x2 - dx; vert3[1] = y2 - dy; vert4[0] = x2 + dx; vert4[1] = y2 + dy; } } return vert1.concat(vert2).concat(vert3).concat(vert2).concat(vert3).concat(vert4); } 看看示例，是三种不同粗细的线条吧？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"},{"name":"WebGL","slug":"WebGL","permalink":"https://blog.mottomo.moe/tags/WebGL/"}]},{"title":"WebGL 测试1 - 绘制纯色边三角形","slug":"zh/2015-10-07-WebGL-Test-1","date":"2015-10-07T10:48:00.000Z","updated":"2020-03-30T22:34:35.421Z","comments":true,"path":"categories/Tech/Coding/zh/2015-10-07-WebGL-Test-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-10-07-WebGL-Test-1/","excerpt":"示例可以到这里查看。 Pixi 的数据结构不符合 Bulletproof 的使用要求，要调整的话还要考虑与原架构的兼容性（提供了一个抽象的 Graphics），想想其实也没用到多少其功能，我们有自己的体系，就补充上 WebGL 的一块好了。 对 WebGL 不熟（以前就没写过底层一点的 OpenGL 程序），所以对绘制的基本过程也有点困难。因此就阅读了《WebGL 编程指南》，了解原理。","text":"示例可以到这里查看。 Pixi 的数据结构不符合 Bulletproof 的使用要求，要调整的话还要考虑与原架构的兼容性（提供了一个抽象的 Graphics），想想其实也没用到多少其功能，我们有自己的体系，就补充上 WebGL 的一块好了。 对 WebGL 不熟（以前就没写过底层一点的 OpenGL 程序），所以对绘制的基本过程也有点困难。因此就阅读了《WebGL 编程指南》，了解原理。 简单来说，启动后会绘制一个三角形，边分别是红、绿、蓝；按着 Ctrl 拖动有惊喜。 这个示例受限于 ANGLE，可以看到线宽在 Windows 平台上默认是不起作用的。为什么在 Pixi 中起作用似乎是因为它将边当成矩形来绘制（每一条边两个三角形），仔细看一下再说。 着色器这一块基本上可以用公用着色器，所以最终变成了操作顶点数据。 Matrix4 使用的是原书附的代码，作者是 Takafumi Kanda 和 Kouichi Matsuda。 顶点着色器（vertex shader）： attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; uniform mat4 u_ProjMatrix; void main() { gl_Position = u_ProjMatrix * a_Position; v_Color = a_Color; } 片元着色器（fragment shader）： #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() { gl_FragColor = v_Color; } 逻辑： /** * Created by MIC on 2015/10/6. */ &quot;use strict&quot;; /** * @type {HTMLCanvasElement} */ var canvas = document.getElementById(&quot;canvas&quot;); /** * @type {WebGLRenderingContext} */ var glc = canvas.getContext(&quot;webgl&quot;, {antialias: 1, alpha: 1, depth: 1}); var gl = WebGLRenderingContext; // X, Y, R, G, B /** * @type {Number[]} */ var verticesAndColorsArray = [ 0.0, 50.0, 1.0, 0.0, 0.0, -50.0, -50.0, 1.0, 0.0, 0.0, -50.0, -50.0, 0.0, 1.0, 0.0, 50.0, -50.0, 0.0, 1.0, 0.0, 50.0, -50.0, 0.0, 0.0, 1.0, 0.0, 50.0, 0.0, 0.0, 1.0 ]; /** * @param {WebGLRenderingContext} glc * @param {String} vsid * @param {String} fsid * @returns {Boolean} */ function initShaders(glc, vsid, fsid) { var vssource = getShaderSource(vsid); var fssource = getShaderSource(fsid); var program = createProgram(glc, vssource, fssource); if (!program) { console.log(&quot;Failed to create program.&quot;); return false; } glc.useProgram(program); glc.program = program; return true; /** * @param {WebGLRenderingContext} glc * @param {String} vshader * @param {String} fshader * @returns {WebGLProgram} */ function createProgram(glc, vshader, fshader) { var vertexShader = loadShader(glc, gl.VERTEX_SHADER, vshader); var fragmentShader = loadShader(glc, gl.FRAGMENT_SHADER, fshader); if (!vertexShader || !fragmentShader) { return null; } var program = glc.createProgram(); if (!program) { return null; } glc.attachShader(program, vertexShader); glc.attachShader(program, fragmentShader); glc.linkProgram(program); var linked = glc.getProgramParameter(program, gl.LINK_STATUS); if (!linked) { var errorLog = glc.getProgramInfoLog(program); console.log(&quot;Failed to link program: &quot; + errorLog); glc.deleteProgram(program); glc.deleteShader(vertexShader); glc.deleteShader(fragmentShader); return null; } return program; } /** * @param {String} id * @returns {String} */ function getShaderSource(id) { /** * @type {HTMLElement} */ var elem = document.getElementById(id); return elem.textContent; } /** * @param {WebGLRenderingContext} glc * @param {Number} type * @param {String} source * @returns {WebGLShader} */ function loadShader(glc, type, source) { var shader = glc.createShader(type); if (shader === null) { console.log(&quot;Unable to create shader.&quot;); return null; } glc.shaderSource(shader, source); glc.compileShader(shader); var isCompiled = glc.getShaderParameter(shader, gl.COMPILE_STATUS); if (!isCompiled) { var errorLog = glc.getShaderInfoLog(shader); console.log(&quot;Failed to compile shader: &quot; + errorLog); glc.deleteShader(shader); return null; } return shader; } } /** * @param {WebGLRenderingContext} glc * @returns {Number} */ function initVertexBuffers(glc) { /** * @type {Float32Array} */ var verticesAndColors = new Float32Array(verticesAndColorsArray); /** * @type {Number} */ var n = verticesAndColorsArray.length / 5; var vertexColorBuffer = glc.createBuffer(); if (!vertexColorBuffer) { console.log(&quot;Failed to create the buffer object.&quot;); return 0; } glc.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); glc.bufferData(gl.ARRAY_BUFFER, verticesAndColors, gl.STATIC_DRAW); /** * @type {Number} */ var FSIZE = Float32Array.BYTES_PER_ELEMENT; var a_Position = glc.getAttribLocation(glc.program, &quot;a_Position&quot;); if (a_Position &lt; 0) { console.log(&#39;Failed to get the storage location of a_Position&#39;); return -1; } glc.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 5, 0); glc.enableVertexAttribArray(a_Position); var a_Color = glc.getAttribLocation(glc.program, &quot;a_Color&quot;); if (a_Color &lt; 0) { console.log(&quot;Failed to get the storage location of a_Color&quot;); return -1; } glc.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 5, FSIZE * 2); glc.enableVertexAttribArray(a_Color); glc.bindBuffer(gl.ARRAY_BUFFER, null); return n; } /** * @param {WebGLRenderingContext} glc */ function clearCanvas(glc) { glc.clearColor(0, 0, 0, 0); glc.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } /** * @param {WebGLRenderingContext} glc */ function drawLines(glc) { /** * @type {Number} */ var n; if ((n = initVertexBuffers(glc)) &lt;= 0) { console.log(&quot;Failed to initialize vertex buffers.&quot;); return; } clearCanvas(glc); // 考虑到以后是按照不同的线条和填充来分组绘制的，这里用 gl.LINE_STRIP 来压缩数组也不错 glc.drawArrays(gl.LINES, 0, n); } function main() { if (!initShaders(glc, &quot;vshader-color&quot;, &quot;fshader-color&quot;)) { console.log(&quot;Failed to intialize shaders.&quot;); return; } glc.lineWidth(5); var u_ProjMatrix = glc.getUniformLocation(glc.program, &quot;u_ProjMatrix&quot;); if (!u_ProjMatrix) { console.log(&quot;Failed to get the storage location of u_ProjMatrix.&quot;); return; } var projMatrix = new Matrix4(); projMatrix.setOrtho(-canvas.width / 2, canvas.width / 2, -canvas.height / 2, canvas.height / 2, 0, 1000); glc.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements); drawLines(glc); canvas.addEventListener(&quot;mousemove&quot;, canvasOnMouseMove); } /** * @param {MouseEvent} ev */ function canvasOnMouseMove(ev) { if (ev.ctrlKey) { // x, y, r, g, b var arr = [0, 0, 0, 0, 0]; var lastArr = [0, 0, 0, 0, 0]; var len = verticesAndColorsArray.length; lastArr[0] = verticesAndColorsArray[len - 1 - 4]; lastArr[1] = verticesAndColorsArray[len - 1 - 3]; for (var i = 0; i &lt; 3; i++) { arr[i + 2] = Math.random(); lastArr[i + 2] = arr[i + 2]; } arr[0] = ev.offsetX - canvas.width / 2; arr[1] = -(ev.offsetY - canvas.height / 2); verticesAndColorsArray = verticesAndColorsArray.concat(lastArr).concat(arr); drawLines(glc); } } main();","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"},{"name":"WebGL","slug":"WebGL","permalink":"https://blog.mottomo.moe/tags/WebGL/"}]},{"title":"网上看到的","slug":"zh/2015-10-04-A-Glance-at-Wouters-Wiki","date":"2015-10-04T13:49:00.000Z","updated":"2020-03-30T22:34:35.420Z","comments":true,"path":"categories/Misc/zh/2015-10-04-A-Glance-at-Wouters-Wiki/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-04-A-Glance-at-Wouters-Wiki/","excerpt":"搜索“cube”，本来是找 CUBE 的官网，然而还发现了 Cube Engine。下面的链接指向了其创作者 Wouter van Oortmerssen 的网站。可以看到这位 Oortmerssen 兄涉猎广泛而且颇有经验。","text":"搜索“cube”，本来是找 CUBE 的官网，然而还发现了 Cube Engine。下面的链接指向了其创作者 Wouter van Oortmerssen 的网站。可以看到这位 Oortmerssen 兄涉猎广泛而且颇有经验。 他编写了两种语言。 Aardappel 没看到代码示例，倒是给了几个图形示例（快速排序、有序集合 lambda 和一个不知道什么东西）： （图片来自：Aardappel Language） 另一个是 Bla。说明文字太多了我没仔细看，但是代码示例看得我心里发毛： map(f,[]) = [] map(f,[h|t]) = [f(h)|map(f,t)] qsort([],_) = [] qsort([h|t],lt) = append(qsort(filter(lambda(x) = lt(x,h),t)), [h|qsort(filter(lambda(x) = not lt(x,h),t))]) stack()[T] = self where d = [] isempty() = d=[] push(x:T) do d:=[x|d] pop():T = d &lt;=&gt; [] -&gt; raise stack_empty | d &lt;=&gt; [h|t] -&gt; h do d:=t （代码来自：Bla Language） 我也说不清楚是什么，但看到的时候全身鸡皮疙瘩就起来了。再看看，却又也是十分精彩。Haskell 我是不怎么熟悉，不过 CoffeeScript 的入门示例就显得平易近人多了。再想想，里面的哪个语法现象都见过，那么给我这么惊诧的东西到底是什么？仅仅是函数式的简洁性吗？ 觉得 CUBE 社的立绘风格不错，再试一下这个会社的游戏。于是找到了 your diary。 贴吧的某汉化进度帖：http://tieba.baidu.com/p/3800491546?pn=1 所以说校对君的压力很大，很负责嘛。大多数都是明显的问题……（老实说，“また随分とのんびりした”这个我是看不懂，导致这一句不知道在说什么。其他四句能看懂……） 7楼（贴出图片的楼）一个回复： 把校对前的放出来真的好吗。真·初翻君会害羞的~(@^_^@)~(╯｀□′)╯（┻━┻ 汉化组也不容易啊。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"穿透幻影的太阳 OST","slug":"zh/2015-10-05-Misc","date":"2015-10-04T13:49:00.000Z","updated":"2020-03-30T22:34:35.421Z","comments":true,"path":"categories/Misc/zh/2015-10-05-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-10-05-Misc/","excerpt":"咳咳","text":"咳咳 B站买了这个冷番的版权，有幸能见到此正版。看了之后才知道为什么 lan 姐等幼女控第一眼就将这些角色认出来了。（如果你想看的话，请做好对剧情的心理准备。） 如你所见，加藤達也的作品。云音乐还没收，酷我上有一部分（我不喜欢酷我）。 「幻影ヲ駆ケル太陽」Vol.4【完全生産限定版】オリジナルサウンドトラック1 OST1／音楽：加藤達也 登録情報 出演: 門脇舞以, 喜多村英梨, 徳井青空, 巽悠衣子, 遠藤綾 監督: 草川啓造 形式: Color, Limited Edition リージョンコード: リージョンA (詳細についてはこちらをご覧ください DVD/Blu-rayの仕様。) ディスク枚数: 2 販売元: アニプレックス DVD発売日: 2013/12/25 時間: 50 分 ASIN: B00ELQXETS EAN: 4534530070067 内容紹介 ◆収録話(第7話、第14話) episodio VII「華麗なる休暇」 TV未放送エピソード episodio XIV「踏み込めない心」 【完全生産限定版特典】 ◆オリジナル・サウンドトラックCD1 ◆あかつきごもく 描き下ろしジャケット ◆友岡新平 描き下ろしケース ◆エレメンタル·タロット カード(愚者) ◆カラーブックレット 収録曲 1. 占いの館 2. 邂逅 3. 星に祈りを 4. セフィロ・フィオーレ 5. 秘めた想い 6. 永瀧さんぽ 7. 眠れない夜 8. 太陽の黒点 9. 静かな叫び 10. すれ違う二人 11. 潜む影 12. 侵蝕 13. 殲滅せよ 14. 覚醒 15. こぼれおちた記憶 16. 揺れる心 17. アストラルクス 18. 月の光、太陽の陰 19. 少女たちの闘い 20. 華麗なる休暇 21. 戦略会議 22. テネブライモード ★特典CD : オリジナル・サウンドトラックCD2 【收录曲目】 01 燃え尽きるような 2:06 02 少女たちの闘い (チェロ・ソロver.) 0:57 03 出撃 2:21 04 君のみち 2:32 05 不吉な暗示 2:03 06 迫りくる闇 1:41 07 ダエモニア 2:19 08 ディアボロス・タロット 1:55 09 重ねる罪を、はぎとる刃 2:09 10 それでは、また次回でしゅ! 2:15 11 使い魔 1:41 12 審判の時 1:54 13 インタールード ver.1 0:22 14 エレメンタル・タロット 2:33 15 幻影を駆ける 2:38 16 絆 1:48 17 歩こう歩こう 1:52 18 高鳴る鼓動 1:22 19 異質な抗戦 1:40 20 ケルブレム 2:03 21 インタールード ver.2 0:28 22 処刑人か、救世主か- 3:43 23 運命の選択 1:29 OST 分为两个部分，分别在 BD vol. 4 和 BD vol. 6。 OST 2 好找，百度一下就好。OST 1 上了谷歌才找到，红旅(?)的一个存档。轻国上原来有，但是链接失效了。想从 BD 入手，结果居然没组发 BD，华盟和雪飘只是做了高码率的内嵌版 HDTVRip。TSDM 上的帖子我目前积分不够（真糟糕）。Nyaa 上没有 OST，甚至除了英文字幕组外只有 ANK 的前两卷压制，和 U2 上提供的前两卷 BDMV。 在国内真的好冷。 趁着两个资源都还健在，赶快收藏。 附带今天的博客园新闻：http://news.cnblogs.com/n/530266/","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"「こいはる」の鸡肋","slug":"zh/2015-10-03-Koiharu-no-Chicken-Ribs","date":"2015-10-03T06:56:00.000Z","updated":"2020-03-30T22:34:35.419Z","comments":true,"path":"categories/ACGN/zh/2015-10-03-Koiharu-no-Chicken-Ribs/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-10-03-Koiharu-no-Chicken-Ribs/","excerpt":"刷过了恋春アドレセンス，真是大鸡肋。 多图杀猫，剧透注意。","text":"刷过了恋春アドレセンス，真是大鸡肋。 多图杀猫，剧透注意。 在讲之前，先说一下恋春的系统。摘抄自 HGCN： 本作最大的特点之一便是、既不需要你去可以提升女主角们的好感度、也不需要去选择进入个别路线的竖棋选项。 只是单纯的、自由的、享受着选择着各种你所喜欢的你所向往的你认为最开心最青春的选项活动。 不管是一心一意的喜欢着你所钟情的少女、亦或者博爱之下谁也舍不得伤害。 都！没！问！题！ 即使没法立即下定决心也没关系！尽情的去犹豫吧、去迷茫吧、去优柔寡断的徘徊在各个女主之间吧、最后的最终你一定能找到只属于自己的“正确的青春恋爱物语” 一句话，就是“普通 AVG 的支线系统我们看不上，把女主角当空气过你自己想过的生活吧”。就是这么一个反常的系统。 通了一周目之后就会出现提示，告诉玩家从二周目开始可以自由选择剧情（注：从主界面的“思い出”也就是“回忆”选项）。同时，6月的隐藏 H 事件解锁。注意哦，是全线路全剧情解锁，不管你选择过的还是没选择过的，你都可以跳跃到事件中体会一下。 这个日历系统，就是 KiriKiri2/KAG3 的地图系统的活用。 在交互上，刚刚玩过恋する彼女の不器用な舞台，感觉恋春的制作的精细程度上明显比不上前者。红色的校服和全粉红的对话框&amp;按钮闪瞎眼，大量使用片假名，还有文字的布局…… 人设上，画师是欧派魔人吗？看看数据，只有两个人是稍微正常的，其他的无一例外都承受着重担。游戏里的平板标准大概是 B 的样子。 另一个糟糕的特性是，不能在事件发生时保存！对于我这种在出选项时就要保存的人来说，简直要被逼疯了——你说我推了十分钟推到一段话结束，突然就出选项，在不能保存的情况下，肯定是要读档再快进到发生前（而且事件选项连 back log 都不能看，还不知道哪句话是最后一句）。这就破坏了推的节奏了，好在选项处理上和普通纯爱作是差不多的，简单选择就可以。 在我快刷（按 Enter，不是平常的 Ctrl）的时候居然听到“叮”一声，我知道是消息框的默认声音（不指定消息框样式时发出），然后就看到文字区一片空白，按鼠标按 Enter 都没用。正怀疑是不是因为 Windows 更新了所以触发了什么东西（中午尝试创建 VS 项目时 VS 也出现了长达三分多的无响应），结果发现系统各按钮还能用！点击返回主界面，然后读档——这时候报错，好像是图像加载错误什么的（忘记截屏了），依稀记得是 2100×1500 分辨率。 进入未优线之后，突然想再看看选项奇观（见下文），点击读档，却发现第一页的数据清空了（进入支线后的存档保存到了第二页）！ 吐槽了这么多系统和 bug 之后来看看宣称的“多图杀猫”吧。 首先就是选项奇观。男主姐姐说你告诉我你最在意的女孩子是谁吧。 然后就出现了恐怖的8个选项！ 普通的游戏哪里会来8个选项！不过这里的选择不是很重要——也说不定，反正攻略哪个选哪个就是了。 五个可攻略角色，从主界面会得出这个结论。但是，实际上还有一条线，以及两个 H scene。 多出来的这条线路是泉线，从9月7日开始进入分支。这个时间点在文化节之前；其他角色要到9月28日文化节最后一天才通过 H scene 确认分支。 这条线异常的短。9月28日，在文化节的闭幕式上，泉会作为乐队成员演出（哪条线都一样），而这就是泉线的结束点，过了就出现“一周目通关辛苦了”。其他角色线那要老老实实等到来年3月毕业…… 两次额外的 H scene 分别是泉和九的，在9月27日和6月14日（隐藏）。 叶衣线的结局在意料之中。 是不是想起了 Lovely Quest 里的八乙女？只不过这里已经生下来了，而且还嚷嚷着要馒头（遗传自母亲）。真令人毛骨悚然。 看到轻国上有讨论 H scene 的感想帖子，其实想想那些想认真玩的 gal 在这部分我都是快进跳过因为简直是玷污剧情……或者说作品都是纯爱系所以哪里有这么多的剧情成分，H 只是一种自然而然的行为，并不会承接剧情什么的……咳咳。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof 20151001 - 继续前行","slug":"zh/2015-10-01-Bulletproof-Back-on-Line","date":"2015-10-01T06:53:00.000Z","updated":"2020-03-30T22:34:35.419Z","comments":true,"path":"categories/Tech/zh/2015-10-01-Bulletproof-Back-on-Line/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-10-01-Bulletproof-Back-on-Line/","excerpt":"","text":"多次尝试，xross 异常的原因很可能是存在两条斜率很接近而又相交的线时 JavaScript 的 number 运算精度不够导致无法分辨，或者是散列函数区分度太小。散列上，我原来用的是 x * 2147483647 + y 的形式，足以区分了吧；后来直接用 toString() 之后求字符串散列值（BKDR hash），这样理论上 JavaScript 的数字精度有多高散列就能做到多好。但是还是失败了…… 感觉被朴素的二重循环方法狠狠地嘲笑了一把。 开始嵌入 libtess。在其示例页面嵌入的脚本中有这么一段： var startTime = window.nowish(); polyTriangles = triangulate(contours); initArrayBuffer(polyTriangles); var endTime = window.nowish(); 很好奇 window.nowish() 是个什么东西，于是我用 Chrome 尝试了一下： &gt; window.nowish function () { [native code] } 说明这是原生的代码而不是自定义的 JavaScript 函数。然而这个 API 并没有公开，谷歌了一下，即使限定了搜索词（javascript window &quot;nowish&quot;）都找不到。相比之下，Window.performance 要更为人所知一些。 还找到了一个对 Java 的 HashSet 进行散列攻击的例子：http://keary.cn/?p=845。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"xross 进度","slug":"zh/2015-09-29-Xross-Progress-And-Else","date":"2015-09-29T09:33:00.000Z","updated":"2020-03-30T22:34:35.419Z","comments":true,"path":"categories/Misc/zh/2015-09-29-Xross-Progress-And-Else/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-29-Xross-Progress-And-Else/","excerpt":"整个程序检查了一遍，修正了几个符号和顺序错误（眼花了）。现在能走原来附带的两个示例（test_1() 和 test_2()）了。但是 testRandom() 总是报空指针错误（FutureEvent.compareTo()，ipThis 经常为 null）。继续查找原因。 有一个坑是 EventQueue.poll() 使用的是 LinkedHashSet，这是一个有序的集合。开始的时候一切集合都用 XSet（用于自定义类型）和 PSet（用于基元类型）代替，测试1不通过，测试2报错。后来想起似乎见过原实现用了一些名字看上去和链表有关的集合类，搜索了一下，特性是遍历顺序和插入顺序相同。于是写了 LXSet 和 LPSet，这回对了。 调试的时候，debug 状态下的随机测试的朴素方法用时大约是 1400 ms，release 状态下大约是 70 ms。在代码中没有调用 console.*() 的情况下，这个差距略大……估计是预编译了吧。 VS Code 的两个小问题： 代码格式化（format code）之后，插入光标位置不变。我喜欢在编辑函数参数的时候格式化代码，特别是函数声明很长的时候。原本光标是位于某个参数标识符之后的，由于前面会添加或删除空格，格式化之后光标就不一定在原来语法上的位置上了。此时直接继续输入就不正确了，可能就跑到了某个参数的内部去了。 屏幕输出变化时，无法调试 Node(?)。课设的文档我是拿 Code 写的，同时还在编辑 xross 的代码。上去展示连接到投影仪，再撤回来，发现无法调试 Node 了，现象为无法启动任何脚本，调试工具栏闪现后闪退。直接执行 Node 表现正常，WebStorm 表现正常。 九月的日志总数达到了30篇，可能以后是无法超越的了。如果不是开学前开始的 Bulletproof 起了个头，就不会有这么多的日志了……","text":"整个程序检查了一遍，修正了几个符号和顺序错误（眼花了）。现在能走原来附带的两个示例（test_1() 和 test_2()）了。但是 testRandom() 总是报空指针错误（FutureEvent.compareTo()，ipThis 经常为 null）。继续查找原因。 有一个坑是 EventQueue.poll() 使用的是 LinkedHashSet，这是一个有序的集合。开始的时候一切集合都用 XSet（用于自定义类型）和 PSet（用于基元类型）代替，测试1不通过，测试2报错。后来想起似乎见过原实现用了一些名字看上去和链表有关的集合类，搜索了一下，特性是遍历顺序和插入顺序相同。于是写了 LXSet 和 LPSet，这回对了。 调试的时候，debug 状态下的随机测试的朴素方法用时大约是 1400 ms，release 状态下大约是 70 ms。在代码中没有调用 console.*() 的情况下，这个差距略大……估计是预编译了吧。 VS Code 的两个小问题： 代码格式化（format code）之后，插入光标位置不变。我喜欢在编辑函数参数的时候格式化代码，特别是函数声明很长的时候。原本光标是位于某个参数标识符之后的，由于前面会添加或删除空格，格式化之后光标就不一定在原来语法上的位置上了。此时直接继续输入就不正确了，可能就跑到了某个参数的内部去了。 屏幕输出变化时，无法调试 Node(?)。课设的文档我是拿 Code 写的，同时还在编辑 xross 的代码。上去展示连接到投影仪，再撤回来，发现无法调试 Node 了，现象为无法启动任何脚本，调试工具栏闪现后闪退。直接执行 Node 表现正常，WebStorm 表现正常。 九月的日志总数达到了30篇，可能以后是无法超越的了。如果不是开学前开始的 Bulletproof 起了个头，就不会有这么多的日志了…… 既然扯了这么多，就再多说一点。通了こいかの的真优线，然后其他线就当 CG 收集用了。 到最后还是一个不敢吃巧克力上台演出的幼驯染克服内心的坎儿的故事。全员登台演出《暴风雨》（Tempest）的部分是最精彩的。特别是如果你选择真优线的话，公演第二天就会收到舞台形式的告白。由于剧内人演的就是话剧，这里很看声优的功底——不过她们都是怪物啊。 接下来发生的事情就要让人大跌眼镜了。在观众退场之后，在后台突然间就开始了真优线的第一场H，猝不及防。你能想象吗，尚有余温——粗俗点就是“趁热来一发”。真是毁了意境。接下来就是揭伤疤然后多次啪啪啪之后心理治疗，从“不为男主我就不演”变成了“我很享受演出”，happy end。 如果没有特殊嗜好，不要去玩千奈线。如果没有特殊嗜好，不要去玩千奈线。（也有意外的收获，例如这里会告诉你真优是音痴……）然后最终千奈看着第二次艺术节真优大展歌喉非常惊讶，真优说“我相信我的未来，我相信明天”啊不不不，是“唯口熟尔”。千奈线，end。 爱丽丝线和百花线解决的的问题就更小了。 不管玩其他哪一条线，真优总是会作为幼驯染吃醋（和日常，毕竟走廊相连……），但会送上真心祝福。越玩越觉得对不起幼驯染啊！假如有的话只推幼驯染线就知足了……（在此之前你得有一个幼驯染。） 系统在鉴赏和跳过部分和平常的不一样。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"弹幕形式为什么会存在下去","slug":"zh/2015-09-28-Why-Live-Comments-Will-Live","date":"2015-09-28T10:04:00.000Z","updated":"2020-03-30T22:34:35.419Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-09-28-Why-Live-Comments-Will-Live/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-09-28-Why-Live-Comments-Will-Live/","excerpt":"无关的话放前面。 在编辑器上，Atom 确实比 MarkdownPlus 要好用。所以现在写博客，我改用 Atom 了。从 Notepad++ 到 MarkdownEdit 到 MarkdownPlus 再到 Atom，改用顺手的就好。（考虑到启动和编辑效率问题，一般编辑工作是用 Notepad++ 做。） 下面开始正文。 今天我要说的是，“弹幕”这种形式为什么会存在下去。这里的“弹幕”，并不是特指现在流行的弹幕评论方式，而是一种作品媒介和评论行为组成的有机整体。","text":"无关的话放前面。 在编辑器上，Atom 确实比 MarkdownPlus 要好用。所以现在写博客，我改用 Atom 了。从 Notepad++ 到 MarkdownEdit 到 MarkdownPlus 再到 Atom，改用顺手的就好。（考虑到启动和编辑效率问题，一般编辑工作是用 Notepad++ 做。） 下面开始正文。 今天我要说的是，“弹幕”这种形式为什么会存在下去。这里的“弹幕”，并不是特指现在流行的弹幕评论方式，而是一种作品媒介和评论行为组成的有机整体。 先从当前弹幕的背后内容载体——视频开始讲起。利用视觉暂留特性的艺术表现至少在走马灯上就已经出现了，出现类似现代“屏幕”、“演员”概念的至少有皮影戏。不过这只是前身，科学来讲应该从电影原理和器材的发现和发明开始。接下来的发展大概就是电影→电视→光盘介质视频→网络视频。从整个发展史可以看出： 内容表现的具体性在上升。例如，两个皮影小人代表了角色A、角色B，手中的刀枪翻来覆去代表舞刀弄枪。从现在的具体程度来看，那就是在人脑中建立了一个符号和一个实体的关联。现在的主流游戏提供的是真实感，从贴图到物理系统。超级玛丽角色进化的历史也是一个很好的例子。 媒介带来的互动性在下降。电影的群众性自然是不用说。电视至少也能作为一群、至少一家人的消遣（上世纪还有一院子的人围着看一台电视的情景）。光盘用光盘播放器放到电视机上的时候，还能容纳一群小伙伴在屏幕前。网络、流媒体的兴起和个人计算机的普及化让网络中的“人”更独立了。 请问，这一系列行为承载的内容是什么？是作者的想法通过工具的表达。以电影为例，每一个镜头都充满了语言，为何如此运动，为何如此打光；再加上语言或者意境（大战之后给一个长达十五秒的逆光的战场全景之类的），是作者与受众的交流。这个交流在媒介中是单向的，不过假如受众在同一个时间位于同一个地点那么他们也可以互相交流。若交流的内容是关于这个作品的，就可以视其为个体之间的价值观声明与协调过程。（关于“小团体”和信息价值的关系，我想以后写文章阐述。）用视频举个例子，假设A在看一个 DotA 的比赛视频，觉得这场比赛很精彩，有以下的表达方式： 心里默默称赞。（不对外表达） 大叫：“超神啦！”（在当前空间内表达） 去论坛发帖。（去往虚拟空间表达） 请问，哪一种方式收获的认同感最多呢？虽然2、3不好比较（要看具体情况），但是毫无疑问，如果A的性格不是太奇怪的话，后二者强于前者。不仅向他人宣称了自己的兴趣从而可能找到志同道合的朋友，而且基于这个关系拓展，预期能在该领域上获得更多有价值的信息。也就是说，关于作品的讨论行为是建立在“能获得更多有价值的信息”这个判断上的。（或者是心理安慰，如求赞同，这里不展开。） A: 这场比赛最后翻盘，XXX好厉害！ B: XXX还有许多精彩的后发制人的比赛，你可以去XX帖看一下。（介绍了一个对A有意义的信息源） C: XXX大神受我一拜！（观点被赞同） 不过网络视频在处理人与人之间的沟通时出现了问题，因为用户不一定是在同一个空间位置上的。由于之前所说的单向性的问题，早期的视频源并不提供受众与受众的交流渠道。因此如果要进行交流，需要到另一个网络位置，一般是论坛。这就是媒介与交流渠道的分离。 即使通过第三位置这种方式解决了交流的不便，还有一个问题：视频是具体的、是有时间信息的。想象一下这样的表述： XX作品7:20的人群后面的右手边第三个人的眼神好邪恶 看过的人，有些也不会留意，并不知道这个“七分二十秒处人群后面的右手边第三个人的眼神”是什么样子的；没看过的人，就更不知道了。原因是我们用了静态的语言去描述动态的事物的细节。我可以说“这匹马跑得飞快”，但是无法描述具体每个点是怎么动的，所以当有人听到这句话的时候，他的脑海里呈现的是抽象的马在抽象地跑，而能将其想象出来那是因为细节都是他脑补的。（想象一下，一匹马在跑，然后想象切换为骨骼结构视图，然后切换回来。“看到”的所有都是脑补的。） 弹幕就是应运而生的。在观看一个视频的时候，观众的时间轴被同步到了视频的时间轴上。因此，弹幕赋予文字的时间信息对于所有的观众而言，在时间上是相同的。而同一个视频意味着观众们所在的虚拟空间的位置相同。这就是为什么说观看带弹幕的视频时感觉是和其他观众在一起，有强烈的现场感。借由这种现场感，本来是简单的评论就被提升到了传统的人与人在介质周围讨论的使用体验。有所不同的是，由于这不是真实的“同时同地”，所以还是有些许的单向性，两个人是不能实时地以弹幕的形式来讨论的（因为不知道对方的回复时间），只能评论已有的评论。不过这是目前网络传媒中，对交流实时性的最好的模拟了。（虚拟空间和显示空间里的时间同步不妨去看看第二人生。） 和其他交流方式一样，弹幕这种交流方式也会衍生出艺术。说话可以说大白话，也可以舞文弄墨。弹幕艺术在面汤的博文中有所阐述，细节就不多说了。和语言交流不同，弹幕天生就在富媒体环境下长大。（有钱人家的孩子就是不一样。手动滑稽）对于人类来说，图形图像和音乐是超越了语言的表达形式。再想象一个例子：一群人在看电视，一个人说：“如果这里给这个内心复杂不说话的角色旁边加上一个白框，里面写上六个点（省略号）也许不错。”当然这个效果现在可以由 Mode 7 高级弹幕（定位弹幕）实现，这种图形化的方式让人人都可以理解。想想看，你能在电视上涂画吗？ 所以，从皮影戏到弹幕视频，基础的观念和职责都没改变。弹幕，在2006年是一个创新，而且它符合了人们延承下来的集体行为习惯，它是这习惯在现代的表现形式。 可以预测一下，同样是载体+讨论的形式，在未来是怎么发展的吧。随着 VR 和 AR 的引入（VR 快了，AR 还要等一段时间），参与评论的依然是虚拟的同时同地。不过可以选择是用户和用户同时还是和评论同时，前者可以与其他用户的虚拟实体交互（建立在统一的播放时间的基础上），而后者则沿用了现在的思路，不过可能会引入更丰富的评论元素（例如可交互的模型等其他信息，而不仅仅是遵循代码的图像/音频）。载体本身可能会演变成三维场景而不再是二维画面，用户间的讨论就会更多去考虑这个虚拟环境的每个元素的每个时刻的状态（从图像的线到场景的体）。伴随着这种交流形式的功能强大化，礼节和监管可能也会更麻烦呢。 若是问我：什么时候是弹幕会消亡？我回答：人类不再有团体性的时候。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"}]},{"title":"Java 你……","slug":"zh/2015-09-27-Oh-Java","date":"2015-09-27T13:42:00.000Z","updated":"2020-03-30T22:34:35.418Z","comments":true,"path":"categories/Tech/zh/2015-09-27-Oh-Java/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-27-Oh-Java/","excerpt":"","text":"xross 输入测试样例的时候抛出了异常，定位到似乎在红黑树的实现内部。在 Java 实现内插一些输出，在 TypeScript 实现内插一些输出，二者输出不一样。从第一个点的处理就出现问题了，二者生成并添加的新点不同。handleEvent() 里有什么呢？checkIntersections()，无非是求交、更新红黑树。求交的部分检查了一下，红黑树的部分犯错误的机会更大吧。 JDK 1.8 的 TreeMap 实现（java/util/TreeMap.java），第 2216 行、第 2235 行（其实还有更多）： /** From CLR */ private void rotateLeft(Entry&lt;K,V&gt; p) { // ... } /** From CLR */ private void rotateRight(Entry&lt;K,V&gt; p) { // ... } 看到这个真是乐了。想想 C# 和 Java 在 Hashtable 类上的名称“借鉴”的事，上文的几个“CLR”注释是不是又添了一些料呢？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof 20150926 - Bentley-Ottmann","slug":"zh/2015-09-26-Bulletproof-20150926","date":"2015-09-25T19:53:00.000Z","updated":"2020-03-30T22:34:35.418Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-26-Bulletproof-20150926/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-26-Bulletproof-20150926/","excerpt":"根据阿卡林/tt君的建议，移植了一下 Bentley-Ottmann 算法实现到 TypeScript 上了，准备去做性能分析。原来的是 Java 实现。 初版本发布在 https://github.com/Hozuki/xross。未测试。 关于坑、配置问题，请展开。","text":"根据阿卡林/tt君的建议，移植了一下 Bentley-Ottmann 算法实现到 TypeScript 上了，准备去做性能分析。原来的是 Java 实现。 初版本发布在 https://github.com/Hozuki/xross。未测试。 关于坑、配置问题，请展开。 代码里大量涉及了 Map 和 Set。我一想这不是 ECMAScript 6（已更名为 ECMAScript 2015）提供的新特性嘛，咱上 ES6 去。 于是打开 VS Code，设立工程。 首先这是个 TypeScript 工程，为了能正常编译到 ES6，需要进行如下设置。 更新 TypeScript 至 1.6（写本文时的最新版本）： # 如果未安装 npm install -g typescript # 如果已安装 npm upgrade -g typescript 一个比较坑爹的事情是，如果你安装了 Visual Studio 的 TypeScript 支持，则要好好检查一下 %PATH% 环境变量，一定要保证 tsc 命令调用的是 NPM 下载下来的 tsc.cmd。有时微软家的会往路径中写入类似 C:\\Program Files\\Microsoft SDKs\\TypeScript\\1.*\\ 这样的路径，编译器就可能跟不上时代了。 然后在工程目录下建立 tsconfig.json： { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es6&quot;, &quot;noImplicitAny&quot;: true, &quot;module&quot;: &quot;commonjs&quot;, &quot;removeComments&quot;: true, &quot;sourceMap&quot;: true } } 这样 VS Code 在智能感知的时候会去选择 lib.es6.d.ts 而不是 lib.d.ts，就能兼容 ES6 的声明了。而且，VS Code 默认生成的 tasks.json 中，命令行是带 -p 开关的，需要比较版本较高的 TypeScript 编译器才支持。 对了，如果目标是 ES6 的话，编译时不能指定 --module 参数（如果采用 -p . 加上工程目录的 tsconfig.json 这种参数指定方式，则会智能忽略），编译出来的 JavaScript 代码和 CommonJS、AMD 有很大的不同。此时如果直接在 VS Code 中浏览，可能会有大量的红线（媒婆？），因为编译结果中也存在用 ES6 语法的代码。所以要在工程目录下建立 jsconfig.json： { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es6&quot;, &quot;module&quot;: &quot;commonjs&quot; } } 再次浏览，就不会“满屏红”了。 如果编写正确的话，就应该能正常编译和检查了。接下来希望加入 Gulp 的支持。我的 gulpfile.js 是这么写的： var gulp = require(&quot;gulp&quot;); var concat = require(&quot;gulp-concat&quot;); var rename = require(&quot;gulp-rename&quot;); var uglify = require(&quot;gulp-uglify&quot;); var transpiler = require(&quot;gulp-es6-transpiler&quot;); var _build = function () { gulp.src(&quot;./build/*.js&quot;) .pipe(concat(&quot;xross-build.js&quot;)) .pipe(transpiler()) .pipe(gulp.dest(&quot;./build/&quot;)) .pipe(uglify()) .pipe(rename(&quot;xross-build.min.js&quot;)) .pipe(gulp.dest(&quot;./build/&quot;)); }; gulp.task(&quot;default&quot;, _build); gulp.task(&quot;build&quot;, _build); 里面的 gulp-es6-transpiler 是一个将 ES6 语法部分翻译成 ES5 语法的 Gulp 插件。不过运行结果总是出错——因为它不支持 import * from &quot;file&quot; 这个语法。 嘛，还有人说加上 babel（gulpfile.babel.js）给 Gulp 提供 ES6 支持。我傻乎乎就试了一下，发现这是给 gulpfile.js 提供 ES6 支持的，而不是给处理上（Esprima/Acorn）提供 ES6 支持的…… 算了，整个回退到 ES5 的状态。考虑到现代浏览器（至少 IE11）已经实现了 Map 和 Set，而且运行环境估计就在这里面，所以找一个即使是 ES5 语法也带了这两个的支持的工具吧。WebStorm 默认的环境就是这样，TypeScript 1.4 加上一些 ES6 特性（例如 Map 和 Set 部分的实现）。 写好之后准备调试。然而突然想到一个问题，JavaScript 的 Map 和 Java 的 Map&lt;T&gt; 语义相同吗？当初 KeiSystem 从 C# 转到 Java 的时候，Java 的类型擦除和没有自定义值类型这两个特点让我大伤脑筋。于是我做了一个实验： var a = {x:1}, b = {x:1}; debug.log(a == b); var s = new Set([a, b]); debug.log(s); 结果： false Set {Object {x: 1}, Object {x: 1}} 明显不是逐元素比较的，推测是比较对象引用。查阅文档可知，Map 使用的是 === 运算符，更不可能相等了。Java 里的 Map&lt;T&gt; 用的是 equals() 方法。这个方法是可以覆盖的，JavaScript 则没有运算符重载的机制。这就意味着，如果我直接写原文那样的代码，就会造成大量的意料之外的结果出现。好险！ 那么，如果我用一个模拟实现会怎么样？例如 ES6Shim？ 更不可能了吧。如果是按照标准来做的话，最后肯定也不可能判断那两个对象相等的。 所以只剩下一种方法，自己写，即使牺牲了大量的效率。整个项目已经回退到了 ES5 的状态，ES6 是暂时用不了的了。 要是 ES6 早日进入 Living Standard 状态就好了，少了很多麻烦事呢。（到时我也许已经换到 Go 上了，JavaScript 的异步真的好麻烦，语言本身的原因。） 又试用了一下 Atom，总体美观、可扩展性比 VS Code 好，但是响应效率和代码显示就差多了。默认行距那么大（12号字太小，空间空，14号字字体可以，行距大），自动完成列表那么大，我屏幕都快被占了1/16呢，这是推我去买巨大高分屏吗？！敲代码的时候也有很强烈的延迟感。Code 在代码显示上继承了微软家的传统，就是能在同样的空间里让工作空间安排最舒服。JetBrains 和 GitHub 要好好学习。（不仅如此，在在线文档显示上，微软做的也是巨头里很不错的一个。Mozilla 也很好。不服的话对比 MSDN 和 Java API Docs，还有审美狂 Adobe 自家的 ActionScript API Reference。）","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"路径","slug":"zh/2015-09-24-Path","date":"2015-09-23T21:07:00.000Z","updated":"2020-03-30T22:34:35.418Z","comments":true,"path":"categories/Tech/zh/2015-09-24-Path/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-24-Path/","excerpt":"以前看 Windows API，GDI 部分的时候就不知道，GDI Region 这一块是怎么实现的。 hRegion1 = CreatePolygonRgn(&amp;points[0], nPoints, ALTERNATE); hRegion2 = CreateRectRgn(0, 0, 100, 100); CombineRgn(hDestRgn, hRgn1, hRgn2, RGN_OR); FillRgn(hDC, hDestRgn, hBrush); DeleteObject(hRegion1); DeleteObject(hRegion2); 学了 CAD 后我知道，这是区域布尔操作。但是就是不知道如何在计算机中存储和表示这样的操作源和结果。区域里到底存着什么呢？点集？几何描述？二者各有缺陷。 到今天都不明白。所以现在碰到 Bulletproof 使用的 Pixi 的混乱填充结果就得开始恶补了。 此问题中的一些有意思的资源请展开。","text":"以前看 Windows API，GDI 部分的时候就不知道，GDI Region 这一块是怎么实现的。 hRegion1 = CreatePolygonRgn(&amp;points[0], nPoints, ALTERNATE); hRegion2 = CreateRectRgn(0, 0, 100, 100); CombineRgn(hDestRgn, hRgn1, hRgn2, RGN_OR); FillRgn(hDC, hDestRgn, hBrush); DeleteObject(hRegion1); DeleteObject(hRegion2); 学了 CAD 后我知道，这是区域布尔操作。但是就是不知道如何在计算机中存储和表示这样的操作源和结果。区域里到底存着什么呢？点集？几何描述？二者各有缺陷。 到今天都不明白。所以现在碰到 Bulletproof 使用的 Pixi 的混乱填充结果就得开始恶补了。 此问题中的一些有意思的资源请展开。 webgl-2d 它的使用方式是这样的： var cvs = document.getElementById(&quot;myCanvas&quot;); WebGL2D.enable(cvs); // adds &quot;webgl-2d&quot; context to cvs var ctx = cvs.getContext(&quot;webgl-2d&quot;); // easily switch between &quot;webgl-2d&quot; and &quot;2d&quot; contexts 对，会注册一个 webgl-2d 上下文！ GPU to the Web - Sep. 2012 第31页： “Stencil” the path object into the stencil buffer GPU provides fast stenciling of filled or stroked paths Calculate winding rule or containment at every sub-pixel sample in parallel 提出了以后 WebGL 可能自带 winding 计算的可能性。（虽然到现在都没有提供这个接口……） Clipper Delphi 实现的一个包含多边形计算的图形库。使用树状结构管理多边形，而且可以判断多边形开闭、采用不同的 winding。 Polyfill 呃，就看看。 Modernizr 居然能检测 canvas winding support……没用过，不知道怎么做的。 Revised Canvas Paths 提出了一些便于调用的接口。对比现在的浏览器支持，绘图部分，Chrome 和 Firefox 现在支持 Path2D。（好像有什么问题……对了这是给 Canvas2D 用的不是给 WebGL 用的。） 填充非凸多边形 提供了一个思路。 剪切参考： Vatti Clipping Algorithm（Clipper 就是用的此算法，同时这是这篇文章第二次提到 Clipper），论文(1992) Greiner-Hormann Clipping Algorithm Weiler-Atherton Clipping Algorithm Sutherland-Hodgman Algorithm","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"“热爱编程”是个什么鬼？","slug":"zh/2015-09-22-What-the-Heck-Is-I-Love-Programming","date":"2015-09-22T15:17:00.000Z","updated":"2020-03-30T22:34:35.418Z","comments":true,"path":"categories/Misc/zh/2015-09-22-What-the-Heck-Is-I-Love-Programming/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-22-What-the-Heck-Is-I-Love-Programming/","excerpt":"","text":"博客园新闻区的一篇文章。 我也私下和朋友说过几次，现在我的状态是“面太广，反而找不到着力点”。这个学期杨同学去找工作了，进行了几家公司的笔试。杨研究网页技术和 Docker 有一段时间了，找工作虽然未必说会进入公司立刻就到上好岗位，但是“有专攻”可以帮他活下去，而且他能力不错。我说，我估计就不行了，一个简单的问题“你会干什么”我就答不上来了，因为如果你随便找一个方向，我都是做不了什么的。申请前端？申请运维？申请某技术攻关？想得美，你只能去帮人家端茶倒水写文档（会议文件etc），要不你还是应着本科的专业去某个机械国企做活儿吧——不对，你手上技术没有工人师傅强，设计核算又不是顶尖，只好把你扔到某个未曾听闻的软件研发中心的小角落里去了。 所以我做了些什么？没做什么，纯粹是“热爱编程”了。近期，Source、SDL、MonoGame、编译器、逆向，做过。很久很久以前，还做过安装软件、玩过 OI、做过代码编辑器，还有更早的时候用着 Win32 API 就觉得很高级了。哪一样出了东西呢？没有。 静下来想想我到底要做什么呢？ 我觉得，自从入了动漫坑之后，所做的一切都是为了一个能让我表达自己的东西。最初想做一个视觉小说引擎这样“能讲故事的平台”，而后看到了 KiriKiri 及其优秀的脚本语言 TJS，和业界背后更大的宇宙。我希望通过能让我沉浸的方式，将我的故事说出来。（想象力随着年龄的增大而逐渐退化了吧；我要求自己要在任何时候保持理智状态。）更好的结果是，更多人有机会讲故事，而且是用更有感染力的方式呈现出来。为了达到此目的，我认为我要从底层开始学起，所以在绕了一大圈（看看我的工程文件夹，里面充满了早起废掉的做了一点点的编辑器和分析器）之后要从一个具备垃圾回收的语言（方便开发，如果有人希望的话）的代码是如何编译运行的开始学习。虽然乍一看 GC 和 gal game 相差甚远，但是这是计划的基础。可怕的是，如果在这条路上哪怕一个地方踏得过深了，就出不来了。 然后又开始关注画面，图像的信息。动画的一个特点就是大量运用图像和它们的连接关系（当然还有声音），这和其他基于文字（有可能伴随声音）影响人的方式是不同的。恕我绘画天赋也不太好（一直卡在阴影这里，只能用线条），有些菊苣们大叫“呀这个分镜作画很好/很差”的画面我实在看不出什么，而主要关注画面元素的移动和配合。于是又想为了创作更具有形神的画面的工作创造条件（所以有三维二维的尝试号召）。 表达的其中一个方式是语言。因此我还学/想学语言学和符号学，想研究人类表达的基础——在此之上去尝试找找人类的表达到现在是怎么形成和演变的，极限在哪里，或者是怎么能做到更好。 总结起来，目标是 way of expression of art。做不到先进厂家（Disney 啊 PIXAR 啊这些专门做三维技术突破的）的水平，也许这条路并不容易在社会上找到置身之地（如果资源紧缺，人类最终会放弃艺术，而选择物质以存活；对于企业而言也如此），但是这是我心里的方向，这条路能走多远就走多远吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"「こいかの」の逗X","slug":"zh/2015-09-20-KoiKano-no-Dou-X","date":"2015-09-20T14:04:00.000Z","updated":"2020-03-30T22:34:35.418Z","comments":true,"path":"categories/ACGN/zh/2015-09-20-KoiKano-no-Dou-X/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-09-20-KoiKano-no-Dou-X/","excerpt":"多图杀猫","text":"多图杀猫 官网 又是上来就全员好感度100%，各种倒贴……让人起鸡皮疙瘩。 本作系统在 KiriKiri2/KAG3 的基础上，加了一个可选的路线提示功能，和一个前进/后退到选项的功能。我很赞赏，毕竟这作不是靠曲折/烧脑的剧情取胜的，只是打打闹闹的日常罢了，所以给玩家提供一个将其完全变成拔作的选项方便了绅士们。 不过日常系的我照样慢慢推，谁总是X虫入脑啊。 下面一些有趣的截图。（到第七章中部） 首先是千奈。 千奈（昵称“娜塔莉”）说：好感度高的状态下合宿是很危险的，因为会有浴室 event、陪睡 event、卫生间三日月夜空 event 等等，然后以此为契机二人…… 男主说：你看我很纯洁很理性的，要不我和真优早就不只是幼驯染的关系了（注：因为她一直在主动进攻）。你信不过我吗？ 千奈真相帝啊！但是最后还是去了，这不是明知山有虎，偏向虎山行吗？（虽然最终合宿期间只是可以选择和百花发生一个小 event，量衣服尺寸的。） 但是大家都知道如果选千奈线的话，会发生什么样的事情，对吧。 然后是真优。 从这句话就可以看出真优的主动程度。公然开玩笑（后面说这是玩笑）说让男主开后宫…… 然后是百花。 和真优的组合技。“卿卿我我程度5？”“这才不到1哦，5会更激烈~” 一口老血。 百花你不要这么淡定地把真相说出来啊…… 看设定（我就直接引用 HGCN 的了，P1/P2）就知道百花不是无端端这么说的……但是请顾及在场的诸位啊。粉切黑又应验了么？ 10-03：翻到百科上的一段话 由来是真优以名字明明那么像回文诗词、可结尾却缺少了一个音而来。注：如会日文、应会发现那个音是な na 所以就会变成なが足りない→な足りない→ナタリー 当时我就没搞清楚 natari 是怎么来的，现在我知道了。 解释一下，“七瀬千奈”的发音是「ななせ せな」（Nanase Sena），真优说这近似回文（na-na-se-se-na-na），不过缺少了最后的“な（na）”。所以称其为“なが足りない”（“‘な’不够”），然后略去助动词“が”（在本句的汉语翻译中没有对应成分），就成了“な 足りない”（我给中间加了个空格，表停顿，这句和省略前意思一样），然后取省略后的句子（な たりない，na tarinai）的前三个音（なたり，natari），变长音就成了“娜塔莉”（ナタリー，natari-）了（这里注音用的是片假名，前面注音用的是平假名，发音相同；二者用法自行百科）。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Gal Game","slug":"Gal-Game","permalink":"https://blog.mottomo.moe/tags/Gal-Game/"}]},{"title":"M","slug":"zh/2015-09-18-M","date":"2015-09-18T12:28:00.000Z","updated":"2020-03-30T22:34:35.416Z","comments":true,"path":"categories/Misc/zh/2015-09-18-M/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-18-M/","excerpt":"","text":"完了，四个都成了黑历史。找出了明显的翻译错误……我说怎么读都读不通…… 09-19 学校网络最近总是时好时坏，坏的时候只能顺畅打开百度首页和博客园，其他的126啊Bangumi啊B站啊GH啊全都连接超时。 Python 对新手很不友好，这是它留给我的第一印象，虽然很多人说入门语言应该选 Python。隐式的类型推断（但是执行时是强类型）让智能感知很费劲。 我选用的 IDE 是 PyCharm。想从一个简单的示例入手： import urllib2 url = &quot;http://www.baidu.com/&quot; response = urllib2.urlopen(url) 到此为止，都是能从名称中看出来的。但是当我尝试使用 reponse 的时候，敲下“.”却没有任何提示——我根本就不知道它返回的类型是什么。是字符串吗？应该不是，至少要有一个网络错误时的 fallback 吧。如果是一个类，公开了哪些方法呢？看不出。 后来我从网上看到 urllib2 的使用，后面是 print response.read() 突然就冒出一个 read() 方法。由此又得想，如果我只需要读取一部分数据呢？如果网络状况不佳导致超时呢？Python 肯定提供了相关的机制，可是根本就看不到。 去看 Python 的 urllib2 文档，关于 urlopen() 方法是这样描述的： This function returns a file-like object with three additional methods: geturl() — return the URL of the resource retrieved, commonly used to determine if a redirect was followed info() — return the meta-information of the page, such as headers, in the form of an mimetools.Message instance (see Quick Reference to HTTP Headers) getcode() — return the HTTP status code of the response. 这才知道，原来返回的是一个和普通文件类似的 object。那么文件对象有什么成员呢？ f = open(&quot;&quot;) 然后查看 f 的成员，才能看到文件对象的成员。很不幸，如果我要使用的话，必须要记住每个常用类型的成员，如果是函数还加上签名，要不由 urlopen() 返回的东西在 PyCharm 眼中就是白板，根本就不知道怎么用。也就是说，如果我现在要去写 Python，要不智能感知就得做好一点，要不就得抱着整个文档去查。 VS + IronPython 还没有尝试，不过估计会好一些。 VB 和 VB .NET 有着强大的延迟绑定（late binding）能力，后来 C# 4.0 中引入了 dynamic。这功能我总觉得是烫手山芋，因为如果没有目标的文档根本就难以开发和维护。例如： Dim o As Object &#39; VB 语法 Set o = CreateObject(&quot;Excel.Application&quot;) &#39; VB .NET 语法 o = CreateObject(&quot;Excel.Application&quot;) 接下来知道怎么干些什么吗？不知道，因为此时 o 的类型还是普通的 Object，不带具体的成员信息。相比之下，如果引用了类库，强类型化后再操作就好多了： &#39; VB 在工程中添加对 Excel 的类型库引用即可 &#39; VB .NET 在工程中添加对 Excel 的互操作程序集引用之后，在使用其的文件内写上这一行 Imports Microsoft.Office.Interop.Excel &#39; 使用上是相同的 Dim o As New Excel.Application() o.Quit() 剩下就好办了。因为类型是契约（contract）的一种（我指的不只是接口意义上的契约），有了明确引导后沟通就方便多了。例如，PHP（PhpStorm 下）和 JavaScript（WebStorm 下）都可以在注释中指定类型来影响智能感知的行为： /** * @var string $host * @var string $username * @var string $password * @var string $database * @var int $port * @var mysqli $mysqli */ $mysqli = new mysqli($host, $username, $password, $database, $port); echo $mysqli-&gt;connect_error; 当你输入“$mysqli-&gt;”的时候，就会弹出合适的自动完成列表。这样很适合在类型不熟悉的时候帮助探索。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof 20150920 - Pixi.js 初次融合","slug":"zh/2015-09-20-Bulletproof-20150920","date":"2015-09-18T12:28:00.000Z","updated":"2020-03-30T22:34:35.416Z","comments":true,"path":"categories/Tech/zh/2015-09-20-Bulletproof-20150920/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-20-Bulletproof-20150920/","excerpt":"效率很高，但是部分效果很惊悚。 推送到了 pixi 分支：https://github.com/Hozuki/Bulletproof/tree/pixi。 效果请展开查看。 Visual Studio 2015（自带 IronPython 和 Python Tools for Visual Studio）在上一篇日志中的同一个测试下表现很好。 嗯，不过对于即时的键入，和内置方法的完成有点缺陷。例如同一个示例，如果我在后面新行输入“ur”，PyCharm 会提示输入“url”，但是 VS 没有反应；PyCharm 会内置一些方法数据，如 __INIT__、__ADD__，VS 没有提示。","text":"效率很高，但是部分效果很惊悚。 推送到了 pixi 分支：https://github.com/Hozuki/Bulletproof/tree/pixi。 效果请展开查看。 Visual Studio 2015（自带 IronPython 和 Python Tools for Visual Studio）在上一篇日志中的同一个测试下表现很好。 嗯，不过对于即时的键入，和内置方法的完成有点缺陷。例如同一个示例，如果我在后面新行输入“ur”，PyCharm 会提示输入“url”，但是 VS 没有反应；PyCharm 会内置一些方法数据，如 __INIT__、__ADD__，VS 没有提示。 默认是自动缩放，所以发光被截掉了一些。考虑这里做点修正。 另外，暂时还不知道杂线是怎么来的……Graphics 再检查一下……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof 20150917-0","slug":"zh/2015-09-17-Bulletproof-20150917-0","date":"2015-09-16T19:19:00.000Z","updated":"2020-03-30T22:34:35.416Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-17-Bulletproof-20150917-0/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-17-Bulletproof-20150917-0/","excerpt":"9月17日凌晨的脑洞，有可能能优化 Canvas2D 版的实现","text":"9月17日凌晨的脑洞，有可能能优化 Canvas2D 版的实现 又是脑洞时刻。查找“css filter canvas”之后发现了一个 StackOverflow 上的回答。 问题： I have applied some CSS3 filters to an image on a canvas like this: -webkit-filter brightness(0%) grayscale(100%) contrast(1000%) But when I save the image to my computer, the original image is being saved, not the one with applied filters. Is there a way to save the modified version of it? （很明显，&lt;canvas&gt; 要作为整个 DOM 元素参与样式计算，而不是其上的像素内容，相当于缓冲区内容。所以直接应用样式是不可以的，我以前试过。） 二楼的回答： Apply the filter in the canvas using a shader, rather than using a CSS style. Alternately, make a hidden canvas, draw your content to that, apply the CSS3 filter to it, and then use that canvas to output to the visible one. 二楼评论中一位ID为 katspaugh 的同志写道： Put the filtered canvas into SVG foreignObject, then insert the serialised SVG as a Base64-encoded image into the visible canvas. (Just kidding) 有趣的是，在回答评论中提到了 &lt;foreignObject&gt;。看 MDN 上的示例，能嵌入其他命名空间的元素。所以我做了一个实验： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://pic19.nipic.com/20120308/7491614_141057681000_2.png&quot; width=&quot;300&quot; height=&quot;300&quot; id=&quot;csimg&quot;&gt;&lt;/img&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;feglow0&quot;&gt; &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0 0 0 255 0 0 0 0 255 0 0 0 0 0 0 0 0 0 1 0&quot;&gt; &lt;/feColorMatrix&gt; &lt;feGaussianBlur stdDeviation=&quot;40 40&quot; result=&quot;coloredBlur&quot;&gt; &lt;/feGaussianBlur&gt; &lt;feMerge&gt; &lt;feMergeNode in=&quot;coloredBlur&quot;&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in=&quot;SourceGraphic&quot;&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;/svg&gt; &lt;svg width=&quot;500px&quot; height=&quot;500px&quot; viewBox=&quot;0 0 500 500&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;switch&gt; &lt;foreignObject width=&quot;500&quot; height=&quot;500&quot; requiredExtensions=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;!-- XHTML content goes here --&gt; &lt;body xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;canvas style=&quot;filter: url(#feglow0);&quot; id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;/foreignObject&gt; &lt;text font-size=&quot;10&quot; font-family=&quot;Verdana&quot;&gt; &lt;tspan x=&quot;10&quot; y=&quot;10&quot;&gt;You see no canvas.&lt;/tspan&gt; &lt;/text&gt; &lt;/switch&gt; &lt;/svg&gt; &lt;a href=&quot;javascript:;&quot; onclick=&quot;redraw()&quot;&gt;REDRAW&lt;/a&gt; &lt;script type=&quot;text/javascript&quot;&gt; function redraw() { var canvas = document.getElementById(&quot;canvas&quot;); var context = canvas.getContext(&quot;2d&quot;); context.drawImage(document.getElementById(&quot;csimg&quot;), 0, 0, 300, 300); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这次示例应该不存在安全性的问题，保存到本地直接就可以打开预览。注意我在 SVG 内部为 canvas 指定了样式。 但是这引发了浏览器兼容问题。对于 XML 命名空间的声明（见 &lt;foreignObject&gt; 元素和之后的 &lt;body&gt; 元素），Firefox 和 Edge 要求二者都指定命名空间 http://www.w3.org/1999/xhtml，Chrome 有时候要求二者都不指定命名空间（为空/无属性），IE11 不支持。而且，Chrome 45 和 Maxthon 4（内核为 Chrome 30）行为还不一样，前者要求不指定，后者不支持（Chrome 本来支持，不知道是不是傲游的bug）。 Video Destruction 的示例如果将定时函数换为 requestAnimationFrame()，会引发严重的效率问题。狂点一通，帧率就从60直降到不到10。相比之下，稳定调用帧率30效果好一些。——直觉上来讲，和 Bulletproof 最初的三维球示例是相反的。 继续。Firefox 和 Edge 支持如下的声明： &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;feglow0&quot;&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;g filter=&quot;url(#feglow0)&quot;&gt; &lt;foreignObject width=&quot;500&quot; height=&quot;500&quot; requiredExtensions=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;!-- XHTML content goes here --&gt; &lt;body xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;/foreignObject&gt; &lt;/g&gt; &lt;/svg&gt; 这么写的时候： &lt;g filter=&quot;url(#feglow0)&quot;&gt; &lt;foreignObject width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;!-- XHTML content goes here --&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;-webkit-filter: url(#feglow0); -moz-filter: url(#feglow0); -ms-filter: url(#feglow0); -o-filter: url(#feglow0); filter: url(#feglow0);&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;/foreignObject&gt; &lt;/g&gt; 在 Firefox、Edge、Chrome 45 上显示正常，Maxthon 4 上无法显示滤镜效果（显示为原图），IE11 不支持。（说明 Chrome 看 filter 属性。） 话说，9月15日（就在前天）的 W3C SVG 2 推荐标准中就明确指明： Additionally SVG allows embedded content using HTML5 ‘video’, ‘audio’, ‘iframe’ and ‘canvas’ elements. 要是标准早日实现就好了，我就不用那么头疼了…… Pixi？","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"再见，CSS Shader (CSS Custom Filter)","slug":"zh/2015-09-17-Goodbye-CSS-Shaders","date":"2015-09-16T17:31:00.000Z","updated":"2020-03-30T22:34:35.416Z","comments":true,"path":"categories/Tech/zh/2015-09-17-Goodbye-CSS-Shaders/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-17-Goodbye-CSS-Shaders/","excerpt":"","text":"按照杨彦君的提议，如果支持 CSS Shader（现名 CSS Custom Filter）的话，应该可以大大减轻绘制的工作强度。 但是实际应用中，上面的文章中的示例根本没有起到效果。查看元素发现，-webkit-filter: custom 被自动禁用了。 有人尝试用 WebGL 计算 CSS Shader，不过很不幸，其中需要用到 html2canvas，而且只能进行静态的渲染（也就是说，渲染是手工控制的，不是应用样式后自动进行的），改变一下 DOM 元素就知道，完全是图像平面的顶点/贴图变换。 话说 CSS Shader 是有安全问题的。一封 WebKit 开发组的邮件表明，Chrome 很久之前就已经不再支持相当部分的 CSS Shader 了。 本来这个草案是由 Adobe、Apple 等联合提议的。Adobe 还专门有介绍提议的文章和介绍 CSS FilterLab 的文章（CSS FilerLab 是 Adobe 用于测试开发 CSS Shader 的网页工具）。CSS FilterLab 里面的工具链接早已跳转到其 GitHub 页面。而这个项目的状态看起来不管是代码更新还是 issue 都停留在了两年前。 真是悲惨。想到还是得用 Three.js 我汗毛都立起来了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"新闻：MSBuild 要开始跨平台移植了（旧闻）","slug":"zh/2015-09-16-Heard-That-MSBuild-Is-Going-Cross-Platform","date":"2015-09-16T03:57:00.000Z","updated":"2020-03-30T22:34:35.415Z","comments":true,"path":"categories/Misc/zh/2015-09-16-Heard-That-MSBuild-Is-Going-Cross-Platform/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-16-Heard-That-MSBuild-Is-Going-Cross-Platform/","excerpt":"","text":"今天被学校的一个小工具折腾得不行，想自己写一个（毕竟都知道原理了）。打开 Visual Studio，映入眼帘的是刷新的新闻。9月3日发布，过了快两周我才看到…… MSBuild 三月开放了 GitHub repo，现在已经得到了大量的社区支持。下一步 MSBuild 就要开始跟着 .NET Core 跨平台了。由元数据（metadata）驱动（毕竟 CLR），MSBulid 本来就有良好的依赖管理能力（不用像 CMake 那样手工写一堆），而且充分利用多核处理器（这个或许 CMake 有，我没关注过）。微软计划将为其添加云构建的支持——很令人兴奋，如果和 .NET Native 技术结合的话对于应用而言编译就成了轻松快捷的事情——虽然我在想应用到大型软件上效果也会不错的。 很久以来微软都被开源社区（主要是某些 hardcore 的 geeks）称为 M$，博导也一直叫我“不要被M$控制，快跳到 Linux”。自从 .NET Core 和 BCL 宣布开源之后，微软给人的印象是越来越好了。 叫嚣“M$”的人，否定了他人的选择权利。你用 C++ 和 Python，我偏爱 C#；你喜欢命令行，我认为 GUI 比较便利（又不是不能用 CLI）。有错吗？为什么要歧视呢？就和几乎被所有人鄙视的 Visual Basic（我指的是 VB .NET 之前的 VB），都其实能做一些很漂亮的 hack，只不过异常晦涩难懂罢了。CLR 上的语言照样可以写操作系统。 Mono Project 的苦战也好，微软在趋势冲击下的拥抱开源策略也好，都是值得称赞的。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"POH","slug":"zh/2015-09-14-POH-06","date":"2015-09-14T07:49:00.000Z","updated":"2020-03-30T22:34:35.415Z","comments":true,"path":"categories/Tech/zh/2015-09-14-POH-06/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-14-POH-06/","excerpt":"Paiza 的第6期入门挑战和第6期+的题解 对 POH 的吐槽 对刷 Paiza 题库的惨痛记忆/OI etc","text":"Paiza 的第6期入门挑战和第6期+的题解 对 POH 的吐槽 对刷 Paiza 题库的惨痛记忆/OI etc Paiza 的新一期入门挑战（EN），现在是第6期了。代入情景的漫画一样充满槽点满满。（←请吐槽）OOPArt、COBOOL（日文版我没看出是什么，直到看了英文版），还有乱入的类型推导…… 我记得我做过第4期。印象中第4期的还是很简单的。（今天看了一下，确实。） 本期的三个问题还是很简单。大胃王（六村リオ）的题就是照着指令运算；大和抚子（緑川つばめ）的题也是……而且5行（3行）就可以了： void main() { char buffer[5]; gets(buffer); printf(&quot;%d&quot;, 11 * (buffer[0] - &#39;0&#39;) + 2 * (buffer[1] - &#39;0&#39;)); } 至于天才（霧島京子）的题，差点就过不去了。粗看题目还以为是求到达终点的最快走法，如果走不到输出“不可能”这样的东西。当时就在想：逆推？回溯搜索？循环判定？循环节引起超限怎么办？ 再看题，原来还是一个简单的题目，往下走就可以了……于是在 Notepad++ 中手写，提交，AC。 选用的还是 C#。感觉由于委托（delegate）被作为基础类型看待，CLR 上的语言都有函数式语言的潜质（或者已经是了，如 F#），这点我非常喜欢。就这一点就足以让我在能选 C# 的时候就不选 Java。（当然还有其他原因。） public class Hello { public static void Main() { bool[] history; int[] cells; int n; // Let&#39;s challenge in my favorite language!! string line; line = System.Console.ReadLine(); n = int.Parse(line); cells = new int[n]; line = System.Console.ReadLine(); var s = line.Split(&#39; &#39;); for (var i = 0; i &lt; n; i++) { cells[i] = int.Parse(s[i]); } var canGo = new System.Func&lt;int, bool&gt;(num =&gt; { if (num == n - 1) return true; if (num &gt; n - 1) return false; var current = num; history = new bool[100]; history[0] = true; while (current != n - 1) { history[current] = true; current = current + cells[current]; if (history[current] || current &lt; 0 || current &gt; n - 1) { return false; } } return true; }); line = System.Console.ReadLine(); var qcount = int.Parse(line); var results = new bool[qcount]; int k; for (var i = 0; i &lt; qcount; i++) { line = System.Console.ReadLine(); k = int.Parse(line); results[i] = canGo(k); } for (var i = 0; i &lt; qcount; i++) { System.Console.WriteLine(results[i] ? &quot;Yes&quot; : &quot;No&quot;); } } } 第5期一样简单。但是背后隐藏着的第5期+则开始玩 OI 了。五月份的时候lan发了链接，当时看到第一题想不出一个最快的解法（虽然题目没有要求最快；这种拼图在现实中也很令我头疼）就没做下去了，到现在都没做。后来lan说她刷完了，“挺简单的”。这印证了我的结论，不要和lan讨论题目，否则你会被虐的体无完肤。 当然，Paiza 本身是一个面向程序员的猎头公司，OI 是其附带的功能。这里可以选择题目做（需要登录）。我和lan曾经在发现这个网站后去刷S级的题目……结果我的解题速度被lan碾压，评价也被碾压（lan基本上是一次AC）。求我的心理阴影面积。 这里是第6期+。 今天看博客园文章的时候发现新东西“主席树”。百度了之后找到了一个 OIer 的博客。这位仁兄也是相当厉害，看他的回忆文章就能看得出。 第6期+也做了，只有一道题…… 标题也是十分恶搞。回文就回文吧，赶上了第7届松江 Ruby 大会，还专门构造了一个例子，就拿“松江”（まつえ）开涮： え、妻(つま)が松(まつ)江(え)？ 诶，爱人是松江？ 然后就出题了：找出给定输入能构造出的回文字符串中最长且字符序最小的。 其他的吐槽：看下面的“豪华礼物”（如果选用 Ruby 回答，速度最快的几段代码会在会议上展示，并且可以抽奖）部分。第一个就是限额三名的揖保の糸。（就是第6期漫画里出现的。安得一手好利啊。） 这道题也挺简单的……暴力法居然也AC…… using System; using System.Collections.Generic; using System.Linq; static class Program { static bool stringIsPalin(string s, int n) { for (var i = 0; i &lt; n / 2; i++) { if (s[i] != s[n - 1 - i]) { return false; } } return true; } static void Main(string[] args) { var line = Console.ReadLine(); var n = int.Parse(line); // 存放所有的非回文字符串 List&lt;string&gt; rolls = new List&lt;string&gt;(n); // 存放所有的回文字符串 List&lt;string&gt; palins = new List&lt;string&gt;(n); // 构造字符串时，对应索引的非回文字符串是否已经被使用过 bool[] used; string s; int stringLen = 0; for (var i = 0; i &lt; n; i++) { s = Console.ReadLine(); if (i == 0) { stringLen = s.Length; } if (stringIsPalin(s, stringLen)) { palins.Add(s); } else { rolls.Add(s); } } used = new bool[rolls.Count]; if (palins.Count &gt; 0) { palins.Sort(); } var result = &quot;&quot;; string r2 = null; int j; rolls.Sort(); var count = rolls.Count; if (count &gt; 0) { for (var i = 0; i &lt; count; i++) { if (!used[i] &amp;&amp; i &lt; count - 1) { j = rolls.IndexOf(new string(rolls[i].Reverse().ToArray()), i + 1); if (j &gt;= 0) { // used[i] = true; used[j] = true; result += rolls[i]; } } } } if (result.Length &gt; 0) { r2 = new string(result.Reverse().ToArray()); } if (result.Length &gt; 0) { if (palins.Count &gt; 0) { result += palins[0] + r2; } else { result += r2; } } else { if (palins.Count &gt; 0) { result = palins[0]; } } Console.WriteLine(result); } } 就是这样。居然暴力法都能过……原本还想着不行的话就加个索引的……如果字符串不等长的话就建二重索引……结果都是小题大做。看来第5期+耐心玩的话也可以用暴力法过……（题目提示移动一个方块到指定位置只要随机走很可能在一万步内完成。）","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Paiza","slug":"Paiza","permalink":"https://blog.mottomo.moe/tags/Paiza/"},{"name":"OI","slug":"OI","permalink":"https://blog.mottomo.moe/tags/OI/"}]},{"title":"Bulletproof 20150914 - SVG-Canvas 融合测试不那么尽如人意","slug":"zh/2015-09-14-Bulletproof-20150914-SVG-Canvas-Test-Not-Successful","date":"2015-09-14T07:49:00.000Z","updated":"2020-03-30T22:34:35.415Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-14-Bulletproof-20150914-SVG-Canvas-Test-Not-Successful/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-14-Bulletproof-20150914-SVG-Canvas-Test-Not-Successful/","excerpt":"Bulletproof 的 SVG-Canvas 融合测试不那么尽如人意，测试分支在 https://github.com/Hozuki/Bulletproof/tree/deprecated-svg-canvas。","text":"Bulletproof 的 SVG-Canvas 融合测试不那么尽如人意，测试分支在 https://github.com/Hozuki/Bulletproof/tree/deprecated-svg-canvas。 嗯，是的，deprecated-svg-canvas 分支。如名称所示的，应该不会再找个分支上继续工作了。 昨天的预告说发现了什么。是 SVG 支持的 &lt;image&gt; 标签。 就像这样： &lt;svg width=&quot;150&quot; height=&quot;150&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;feglow0&quot;&gt; &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0 0 0 255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0&quot;&gt; &lt;/feColorMatrix&gt; &lt;feGaussianBlur stdDeviation=&quot;40 40&quot; result=&quot;coloredBlur&quot;&gt; &lt;/feGaussianBlur&gt; &lt;feMerge&gt; &lt;feMergeNode in=&quot;coloredBlur&quot;&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in=&quot;SourceGraphic&quot;&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;g filter=&quot;url(#feglow0)&quot;&gt; &lt;image id=&quot;svgimg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;http://pic19.nipic.com/20120308/7491614_141057681000_2.png&quot; width=&quot;150&quot; height=&quot;150&quot;&gt; &lt;/image&gt; &lt;/g&gt; &lt;/svg&gt; 效果……GitHub 这里好像不能展示，或者 Hexo 的问题？（所以后面和 SVG 有关的所有展示都请大家自备服务器，放网页运行。） 可以看到，在渲染的时候，会计算透明通道，并得到正确的滤镜处理结果。能想到：如果将 canvas 的高效率绘图和 SVG 的原生滤镜结合起来会怎么样呢？ 这不是不可能的。我们可以见到，在 &lt;image&gt; 标签中有一个 href 属性（实际上可以不用带 xlink 命名空间），指向引用的图片源。所以我们如果要动态设置 &lt;image&gt; 的内容，就要动态设置其 href。问题是，href 的内容是 URL，而不是像素内容。因此我们需要一个动态更新的 URL，其永远指向最新的 canvas 内容。 从另一个方面考虑，canvas 有没有导出内容的方法呢？查阅 MDN（顺带吐槽 MDN 上中文翻译有很多小错误，不过还是要尊重志愿者的服务）我们可以知道，HTMLCanvasElement 有一个方法 toDataURL()，能将当前的内容编码为 data URL。（data URL 请见 RFC 2397。）而 &lt;image&gt; 的 href 是能正确解析 data URL 的，这就为我们搭建了一条从 canvas 到 SVG 的路。 题外话1：反向的路径有没有？有，可以看看 canvg 项目。 题外话2：我们其实还可以见到，在 MDN 中，HTMLCanvasElement 还有一个方法 toBlob()，能将 canvas 的内容存入一个 Blob 对象以供使用。不过至少在 Chrome 45 里，以及 nw.js 0.12 里都没有相应的实现。 题外话3：data URL 在 Chrome 中，在本地是不可使用的。如果你写了一段测试脚本给某个 &lt;img&gt; 的 src 或者 &lt;image&gt; 的 href 赋值为 data URL，并用浏览器直接从本地打开这个页面，则会引发一个 security exception。我还没在其他浏览器中试过。考虑到实际的页面并不是直接在本地打开的，无论是 nw.js 还是网站，总之有服务器撑腰，所以不会引发这个异常。 经过以上的预备，我们大概能想到一个流程： graphics.redrawObjects(); var canvas = graphics.canvas; var url = canvas.toDataURL(); // SVG 元素属性的赋值方法，与 HTML 元素不太一样 imageElement.href.baseVal = url; 于是我花了一个晚上将底层改造为 SVG+Canvas 的形式。但是接下来发生的事情出乎我的意料。 首先来看三维球示例的表现： 从结果中可以看出，每帧大多数的时间是花在绘制（painting）上的。想到在这个示例中我们启用了发光滤镜，每次更新 &lt;image&gt; 的 href 的时候，都要解码数据并更新缓存→计算颜色变换（color transform）→进行高斯模糊→合成与渲染，所需的时间不可小觑。 再看小圆脸示例的表现： 这次执行时间显著提升了。这是绘制的机制导致的。（与之前实现的一样，背景的椭圆只在开始的时候计算了一次效果，其余时间不会触发更新事件。所以更新来自于其他的几个 &lt;image&gt;。）小圆脸示例中有三层的内容是动态更新的：杏子+さやか+学姐、黑长直+小圆脸、黑长直和小圆脸的头发碎片。在高级弹幕代码中，有一个 Motion 随时间线性地改变着以上三个元素的 X 轴位置。canvas 只会画出存在于其范围内的东西，这意味着如下两段代码，虽然都是画一个圆，但是由于元素不同所以显示的完整性不同。 SVG 会显示完整的圆： &lt;svg width=&quot;120&quot; height=&quot;120&quot; viewBox=&quot;0 0 120 120&quot;&gt; &lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;40&quot; fill=&quot;none&quot; stroke=&quot;black&quot; transform=&quot;translate(40 40)&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; SVG+canvas 只能显示四分之一圆： &lt;svg width=&quot;120&quot; height=&quot;120&quot; viewBox=&quot;0 0 120 120&quot;&gt; &lt;image id=&quot;image&quot; width=&quot;120&quot; height=&quot;120&quot; transform=&quot;tranlate(40 40)&quot;&gt;&lt;/image&gt; &lt;svg&gt; &lt;canvas width=&quot;120&quot; height=&quot;120&quot; id=&quot;canvas&quot; style=&quot;display: none;&quot;&gt; &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var d = document.getElementById(&quot;canvas&quot;); var c = d.getContext(&quot;2d&quot;); c.moveTo(40, 0); c.arc(0, 0, 40, 0, Math.PI * 2); c.stroke(); var img = document.getElementById(&quot;image&quot;); img.href.baseVal = d.getDataURL(); &lt;/script&gt; 所以，必须要在 canvas 绘图之前，计算各种变换，应用到 canvas 上，绘图，再传到 &lt;image&gt; 上，对齐零点。这就导致图片更新频繁：每帧都要重新绘制到 canvas 上，然后通过 toDataURL() 进行图像的 Base64 编码，传递给 SVG，触发 SVG 更新，浏览器渲染。原来是绘制到 canvas 上后直接浏览器渲染。而将大数组编解码，还要附加多次渲染（因为有多个 &lt;image&gt;，每更新一次都要进行与脏区（dirty rectangle）有交集的所有元素的渲染），性能肯定要掉下去。这抵消了 &lt;image&gt; 的原生滤镜处理的优势，甚至比 canvas 的方案更糟糕。 让我们看看纯 canvas 的表现。 （解释一下，这次的三维球帧率比上次的有所降低。这是因为此次的绘制区域更大，所需的像素计算与拷贝时间增加了。） 这个对比简直是 canvas 虐 SVG+canvas，而且 Klingemann 的算法的执行效率几乎能赶上浏览器的原生模糊算法的执行效率了。 正因如此，使用 SVG 的滤镜辅助 canvas 绘制的方法被否决了。留下了一个存档放在新分支里。 搜索“JavaScript image processing”的时候，最先找到的是 caman.js，然后在其 GitHub 页面上见到了一段使用示例： Caman = require(&#39;caman&#39;).Caman; Caman(&quot;./path/to/file.jpg&quot;, function () { this.brightness(40); this.render(function () { this.save(&quot;./output.png&quot;); }); }); 注意里面有一个 save() 方法，意味着 canvas 的内容是可以导出的。 下一个页面是 Best JavaScript Image Manipulation Libraries，里面第14个是 svg.js。分析 svg.js 的滤镜示例可以看到以下的 SVG 源文件： &lt;svg id=&quot;SvgjsSvg1000&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;990&quot; height=&quot;1650&quot;&gt; &lt;defs id=&quot;SvgjsDefs1001&quot;&gt; &lt;rect id=&quot;SvgjsRect1007&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/rect&gt; &lt;filter id=&quot;SvgjsFilter1013&quot;&gt; &lt;feOffset id=&quot;SvgjsFeOffset1014&quot; in=&quot;SourceAlpha&quot; result=&quot;SvgjsFeOffset1014Out&quot; dx=&quot;0&quot; dy=&quot;1&quot;&gt; &lt;/feOffset&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;image id=&quot;SvgjsImage1008&quot; xlink:href=&quot;http://distilleryimage11.ak.instagram.com/89ac2e90d9b111e297bf22000a1f9263_7.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; x=&quot;15&quot; y=&quot;15&quot; opacity=&quot;0&quot;&gt; &lt;/image&gt; &lt;image id=&quot;SvgjsImage1010&quot; xlink:href=&quot;http://distilleryimage11.ak.instagram.com/89ac2e90d9b111e297bf22000a1f9263_7.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; x=&quot;15&quot; y=&quot;15&quot;&gt; &lt;/image&gt; &lt;text id=&quot;SvgjsText1011&quot; font-family=&quot;Helvetica Neue, Helvetica, sans-serif&quot; x=&quot;165&quot; y=&quot;259.203125&quot; font-size=&quot;24&quot; text-anchor=&quot;middle&quot; font-weight=&quot;100&quot; fill=&quot;#ffffff&quot;&gt; &lt;tspan id=&quot;SvgjsTspan1012&quot; dy=&quot;31.200000000000003&quot; x=&quot;165&quot;&gt; original &lt;/tspan&gt; &lt;/text&gt; &lt;/svg&gt; 从中可以看到 &lt;image&gt; 元素。至于 SVG 标准，是看到之后才查的。 然后问题来到 canvas 内容导出。StackOverflow 上有一篇回答中有一行代码： var data = canvas.toDataURL(&#39;image/jpeg&#39;); 所以才看到了 toDataURL() 方法。（之前在手册里见过，没用到所以印象不深……） 在进行 data URL 的赋值时在控制台中发现抛出了异常。有人给出答案说是防止本地文件被非法访问。（答案引文，答案引文的引文）说到最后还是同源的问题啦。（Netscape 的标准对后代产生了持续的影响ww） Information leakage can occur if scripts from one origin can access information (e.g. read pixels) from images from another origin (one that isn’t the same). To mitigate this, bitmaps used with canvas elements are defined to have a flag indicating whether they are origin-clean. All bitmaps start with their origin-clean set to true. The flag is set to false when cross-origin images or fonts are used. The toDataURL(), toBlob(), and getImageData() methods check the flag and will throw a SecurityError exception rather than leak cross-origin data. 附：另一种 SVG 绘制到静态图像上的方法","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof 20150913-1","slug":"zh/2015-09-13-Bulletproof-20150913-1","date":"2015-09-12T20:55:00.000Z","updated":"2020-03-30T22:34:35.415Z","comments":true,"path":"categories/Misc/zh/2015-09-13-Bulletproof-20150913-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-13-Bulletproof-20150913-1/","excerpt":"","text":"晚上开了一下脑洞，从最基础的 JavaScript Image Processing 开始找起，发现了有趣的东西。性能瓶颈有可能可以突破。具体等待明天（今天？）实验，然后将过程与结果记录下来。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof 20150913 - VS Code 尝试，与代码重整背后的 TypeScript 编译","slug":"zh/2015-09-13-Bulletproof-20150913","date":"2015-09-12T16:17:00.000Z","updated":"2020-03-30T22:34:35.415Z","comments":true,"path":"categories/Tech/zh/2015-09-13-Bulletproof-20150913/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-13-Bulletproof-20150913/","excerpt":"VS Code 尝试，与代码重构（算得上么）时发生各种事情，追根溯源看的 TypeScript 编译","text":"VS Code 尝试，与代码重构（算得上么）时发生各种事情，追根溯源看的 TypeScript 编译 脑抽去试了一下 Visual Studio Code，发现：效率真是不错呢！ 但是很要命，在 JavaScript 运行调试上只支持 Node.js。对于 nw，我们可以写一个小把戏蒙混 VS Code（缺点是无法侦听调试端口）： /tsconfig.json: { &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot; } } /app.js: // 换成 nw.js 的执行文件路径 var nwpath = &quot;./nwjs/nw.exe&quot;; var child_process = require(&quot;child_process&quot;); child_process.spawnSync(nwpath, [&quot;.&quot;]); process.exit(); /.vscode/launch.json 的设置项 program 设置为 &quot;./app.js&quot;。 然后启动调试即可。 但是还是很难受，特别 JavaScript 下对内置函数的提示比 WebStorm 差很多。不过我倒是很欣赏 Ctrl+Shift+P 唤出的命令条，对于我这种喜欢用键盘描述的人来说少用鼠标轻松多了，也不用像 vim 那样记指令。 然后我拜访了其模仿对象 Sublime Text。Sublime Text 的包管理源估计被墙了，只好悻悻地放弃。 想着在进一步拓展之前先把结构整理好，要不这样下去整体就崩了，到后面越来越乱。 于是花了一天的时间调整代码结构。原本以为是一个晚上的事，来来去去一天就过去了。现在的结构清晰多了。代码位于 https://github.com/Hozuki/Bulletproof/。 在调整的时候遇到了坑爹的问题。我本来是想将对象创建在本地的，这样在头中包含就可以了，不用额外的初始化代码，就像这样： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bulletproof.js&quot;&gt;&lt;/script&gt; &lt;head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 这里控制加载示例什么的 &lt;/script&gt; &lt;/html&gt; 取消了所有的 export，添加引用（/// &lt;reference path=&quot;&quot;/&gt;）。费了好大劲编译通过了，但是运行失败了。 这才了解 .d.ts 主要是用作内置模块/已引用脚本的声明的。 // 可以 declare interface Interface { } declare module bulletproof { interface Interface { } class Class { constructor(); } } 引用的方式分别为： var i1: Interface; var i2: bulletproof.Interface; var c1: bulletproof.Class = new bulletproof.Class(); 但是如果是在模块内，像普通的编程语言一样调用就会产生问题。如果不集中在一个文件里的话，就会报“找不到名称”（找不到标识符），例如这样的代码： // 在 x.d.ts 声明 declare module mod1 { module mod2 { class Class { constructor(); } } } // 在 x.ts 实现 module mod1 { module mod2 { class Class { constructor() { } } } } // 在 y.ts 调用 /// &lt;reference path=&quot;x.d.ts&quot;/&gt; declare module mod1 { function a() { var c = new mod1.mod2.Class(); //var c = new mod2.Class(); } } 于是为了能编译通过，要创建别名（alias）： // 在 y.ts 调用 /// &lt;reference path=&quot;x.d.ts&quot;/&gt; import mod2 = mod1.mod2; declare module mod1 { function a() { var c = new mod2.Class(); } } 这样能编译通过。但是运行时，如果你执行了函数 a()，则会发生错误，原因是 mod2 为 undefined，mod2.Class() 调用非法。 为什么会这样？看一下生成的代码： var mod1; (function (mod1) { var mod2; (function (mod2) { var Class = (function () { function Class() { } })(); })(mod2 || (mod2 = {})); mod1.mod2 = mod2; })(mod1 || (mod1 = {})); 注意到什么了？根本就没有对作为参数的 mod2 产生影响！在控制台查看一下就能看到，mod2 执行后是一个空对象（{}）。 此次我们进行一点修改，添加 export： export module mod1 { export module mod2 { export class Class { constructor() { } } } } 结果： var mod1; (function (mod1) { var mod2; (function (mod2) { var Class = (function () { function Class() { } })(); mod2.Class = Class; })(mod1.mod2 || (mod1.mod2 = {})); mod1.mod2 = mod2; })(exports.mod1 || (exports.mod1 = {})); 熟悉 Node.js 的同学就看到了：这就可以被 require() 了！ 于是在最近的一次commit中，你可以见到大量的丑陋代码。 例如 bulletproof-mx.ts： import bulletproof_flash = require(&quot;./bulletproof-flash&quot;); export module bulletproof.mx { import flash = bulletproof_flash.bulletproof.flash; export module containers { export class Canvas extends flash.display.DisplayObjectContainer { public constructor(root:flash.display.DisplayObject, parent:flash.display.DisplayObjectContainer) { super(root, parent, false); } } } } 这个 bulletproof_flash 真是不得已而为之啊。调用也很糟糕，需要手工注入（kevlar.js）： var bulletproof = {}; var injector = require(&quot;../build/bulletproof-injector&quot;); function appendBulletproofModule(bp, injector, moduleName) { &quot;use strict&quot;; var module = require(moduleName); injector.inject(module.bulletproof, bp); } appendBulletproofModule(bulletproof, injector, &quot;../build/bulletproof-org&quot;); appendBulletproofModule(bulletproof, injector, &quot;../build/bulletproof-mic&quot;); appendBulletproofModule(bulletproof, injector, &quot;../build/bulletproof-thirdparty&quot;); // ... this.bulletproof = new bulletproof.Bulletproof(); this.bulletproof.initialize(); bulletproof.AdvancedDanamaku.initialize(container, video); bulletproof.AdvancedDanamaku.start(); 这个 injector 也是一个丑陋的设计。 另外，JavaScript 的顺序执行也是一个头疼的东西。原来的代码里有一个 bulletproof.Bulletproof 类和 bulletproof.bilidanmaku.AdvAdapter 的交叉引用。就是这个交叉引用导致编译和运行失败。 JavaScript 的解释是顺序、单向的。内部采用的引用计数也使得相互指向变成了很危险的事情（会出现无法回收的情况）。我惯用的 VB .NET 和 C# 是运行在 CLR 上的，垃圾回收是标记-清除式的，访问对象信息是通过元数据（metadata）的，因此可以随便指。 所以重新规划了两个类的职责。完成后发现原先的设计确实有问题。现在是在 bulletproof-bilidanmaku.ts 中的 bulletproof.AdvancedDanmaku 类负责管理跟高级弹幕有关的东西，包括 BiliBili 高级弹幕接口，而不是那个总协调者 bulletproof.Bulletproof 来干了。 又脑抽了，写着写着就意识到，只要顶层的模块不 export module 就好。测试了一下，正解。 module mod1 { export module mod2 { export class Class { constructor() { } } } } 这个样子，编译出来的就会成这样： var mod1; (function (mod1) { var mod2; (function (mod2) { var Class = (function () { function Class() { } })(); mod2.Class = Class; })(mod1.mod2 || (mod1.mod2 = {})); mod1.mod2 = mod2; })(mod1 || (mod1 = {})); 看到没有，mod1 被直接写入了全局变量，其他的照样可以类似其他类 C#/Java 的方式调用。 这样引用就简单了，不需要额外的启动脚本： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bulletproof.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; --&gt; &lt;head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var bp = new bulletproof.Bulletproof(); // 这里控制加载示例什么的 &lt;/script&gt; &lt;/html&gt; 但是也有缺陷。 第一，一定不能把没声明的放在前面。一定要调用的话，要使用完全限定名称类似物。例如这样的实现代码，运行会失败： // 下面这一行别名是必须的，否则会编译失败 // 即使加了，运行也会失败 import mod2 = mod1.mod2; module mod1.mod2.mod3 { export function a() { mod2.Class.doSomething(); } } module mod1.mod2 { export class Class { static doSomething(): void { } } } 原因是上面的 import 被编译成了 var mod2 = mod1.mod2;。调用 a() 的时候，实际引用的是那个还没出现的 mod1.mod2，值为 undefined，完整调用成了 undefined.Class.doSomething()。 如果先实现顶层的成员，再声明别名，最后实现内层成员的话，就没问题，因为此时 mod1.mod2 有了值。 第二，顶层模块是全局的。如果模块里有潜在能把浏览器搞崩溃的代码，就给攻击者提供了工具。特别是对于 Bulletproof 这种需要运行代码的工具来说，即使我给用户提供一个安全的 API，但是用户通过某个全局引用找到了我的实现类，那就麻烦大了。 所以我还是决定维持目前的实现不变。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"杂事2：Three.js 试水和其他小事情","slug":"zh/2015-09-11-Misc","date":"2015-09-10T17:50:00.000Z","updated":"2020-03-30T22:34:35.414Z","comments":true,"path":"categories/Misc/zh/2015-09-11-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-11-Misc/","excerpt":"Three.js 尝试修改两个示例，翻译黑历史","text":"Three.js 尝试修改两个示例，翻译黑历史 昨天（10日）凌晨试了一下 Three.js。搜索的时候看到一篇文章（原文地址已经失效），其中除了官方示例的链接外，还有一位大神的示例库。 友情提示：运行 Three.js 的预览页面的时候，请保证是在服务器上运行的，而不是直接从桌面上用浏览器打开的。还是同源策略的锅吧。 Texture from Canvas 示例看来很适合作为文字绘制的测试。 不过原先的结果有点不符合我们的需求。 首先，明显文字的周围出现了模糊。其实联想一下就能知道，这是透视投影（perspective projection）导致的。因此我们要改为正交投影（orthographic projection）。 //camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR ); camera = new THREE.OrthographicCamera(-SCREEN_WIDTH / 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, -SCREEN_HEIGHT / 2, NEAR, FAR); 现在就能按照“平面”的视角来投影 &lt;canvas&gt; 的内容了，和普通的2D绘图没什么差别。 第二还要测试一个“动态”的特征。我们知道如果创建了一个 CommentField，那么随着其文字内容的变化，所绘制的内容也要发生变化。 // canvas contents will be used for a texture var texture1 = new THREE.Texture(canvas1) texture1.needsUpdate = true; var material1 = new THREE.MeshBasicMaterial({map: texture1, side: THREE.DoubleSide}); material1.transparent = true; var mesh1 = new THREE.Mesh( new THREE.PlaneGeometry(canvas1.width, canvas1.height), material1 ); 从源代码中我们可以看到，&lt;canvas&gt; 被用来创建了一个贴图（texture），然后这个贴图被用来生成了一个材质（material）。（抱歉，在和 Source Engine 干架的时候我也经常弄混这两个词，不过V社的用语总是正确的……） Texture 有一个有趣的东西，Texture.needsUpdate。看名字应该都知道是干什么的吧。大概能猜到会做出什么吧。我们针对此进行修改。 var textList = [&quot;Hello, world!&quot;, &quot;你好，世界！&quot;, &quot;こんにちは、世界！&quot;]; var index = 0; document.onkeydown = function (ev) { if (ev.keyCode == &quot;Z&quot;.charCodeAt(0)) { index = (++index) % 3; context1.font = &quot;Bold 40px SimHei&quot;; context1.fillStyle = &quot;rgba(255,0,0,0.95)&quot;; var c = context1.measureText(textList[index]); canvas1.width = c.width; //context.clearRect(0, 0, canvas1.width, canvas1.height); context1.font = &quot;Bold 40px SimHei&quot;; context1.fillStyle = &quot;rgba(255,0,0,0.95)&quot;; context1.fillText(textList[index], 0, 50); texture1.needsUpdate = true; } }; 现在试试按下Z键，发现了什么？ 你可以在这里看到修改后的示例。 代码修正2见本文最后。 另外一个示例 Lines and Dashed Lines 则是对图元的挑战。做过一点三维编程的同学都知道，在 Three 里画图元（primitives）不是那么简单的。还好 Three.js 帮我们做了不错的封装，有一个 Line。但是看官网的示例： var material = new THREE.LineBasicMaterial({ color: 0x0000ff }); var geometry = new THREE.Geometry(); geometry.vertices.push( new THREE.Vector3( -10, 0, 0 ), new THREE.Vector3( 0, 10, 0 ), new THREE.Vector3( 10, 0, 0 ) ); var line = new THREE.Line( geometry, material ); scene.add( line ); 没错，画出的线就属于 Geometry，为了渲染出来我们需要指定一个 Material。翻一下文档就知道，最接近我们所需的无非是 LineBasicMaterial 和 LineDashedMaterial。而且，在 LineBasicMaterial 的属性说明里，可以看到这么一条： .linewidth Controls line thickness. Default is 1. Due to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value. ANGLE（Almost Native Graphics Layer Engine）就是一个 Windows 上的 OpenGL 兼容层，调用 DirectX 实现具体功能。（有点类似 Cygwin。） 题外话时间。ANGLE 里确实存在两个 issue（#119 和 #334）请求开发者解决这个bug，但是此bug一直存活，到现在还在影响着 Chrome 和 Firefox。有牛人想出了用 Shader 模拟的折线渲染的方法或者另一种用 Vertex Shader 实现的通杀，但是对于我们的需求来说使用比较困难……如何检测呢？这里查看“ANGLE”一项的值即可。强制 Chrome 和 Firefox 启用原生 OpenGL 的方法也有（--use-gl=desktop 和 webgl.disable-angle），但是不能让用户来干这事吧（要假设他们不懂这些）。 回到正题。对于这个示例，我们只改变其中的一点点创建部分的代码就可以了。 //var lineMaterial = new THREE.LineBasicMaterial({color: 0xcc00ff}); var lineMaterial = new THREE.LineBasicMaterial({color: 0xcc00ff, linewidth: 4}); 在启用 ANGLE 和使用原生 OpenGL 的浏览器中，对比是很明显的： 对于某种要批量改变样式的调用（抱歉脑子抽了，就当是假想的好了），我们可以尝试这样的东西： var lm; // ... function init() { // ... var lineMaterial = new THREE.LineBasicMaterial({color: 0xcc00ff, linewidth: 4}); lm = lineMaterial; // ... } // ... document.addEventListener(&#39;keypress&#39;, function (ev) { if (ev.keyCode == &#39;z&#39;.charCodeAt(0)) { //console.log(lm.color); //console.log(lm.color.getHex().toString(16)); // getHex() 返回的总是正数，所以不能用大于/小于零来判断 lm.setValues({&#39;color&#39;: (lm.color.getHex() &lt; 0x800000 ? 0xff0000 : 0x00ff00)}); lm.needsUpdate = true; } }, false); 你可以在这里看到修改后的示例。 正在我为此次翻译质量比第一次（黑历史）好的时候，突然发现歌词原文出现了多出错误。起因推断是网易从其他地方挖歌词的时候，在放到数据库之前某一步（无论是网易自己还是歌词源）错误地应用了繁体转简体的过程。 例如第一句，现在在网易上是这样的： “キマグレ”“自分胜手”“強がり” 实际上，最初的情况是这样的： “キマグレ”“自分胜手”“强がり” 在翻译的时候就觉得哪里不对，改了一下。但是，正确的应该是这个呢： “キマグレ”“自分勝手”“強がり” 勝手(かって)。读的时候倒没问题，估计是我脑子里又做了自动转换吧…… 完了，本来想洗刷黑历史的，结果成了新的黑历史。 恋选的情节并不是催泪向的。这点和 Key 社、FAVORITE 社的一堆作品不一样。为什么突然想到了《放晴后必定是油菜花绽放的好天气》（「晴のちきっと菜の花びより」，昵称“晴菜花”）……总之这些都是虐人用的。如果要我玩一个游戏还要被这个游戏摧毁心理防线，这算啥嘛！因此我主要玩的都是白糖系的，要是结局不给个 HE 我就要给你打低分。——最近两个游戏，GTA 5（选择了三人结局）和 Splinter Cell: Blacklist，结局都是大家乐呵呵（反派就不那么想了），尽管有着很强的个人英雄主义在。 今天继续降温，现在不到20度。 代码修正2： 你也许会发现，按照上面对 Texture from Canvas 的修改，字体会出现长宽比不同的现象。那是因为我们忘记设置了网格（Mesh），网格是按照固定大小的 PlaneGeometry 建立的，如果渲染所用材质大小小于其大小则会被拉伸。 PlaneGeometry 有四个属性：width、height、widthSegments 和 heightSegments。但是文档也说了： Each of the contructor parameters is accessible as a property of the same name. Any modification of these properties after instantiation does not change the geometry. 因此不要想着直接设置其属性，还是乖乖建立新的吧。修改之后核心如下： // canvas contents will be used for a texture var texture1 = new THREE.Texture(canvas1) texture1.needsUpdate = true; var material1 = new THREE.MeshBasicMaterial({map: texture1, side: THREE.DoubleSide}); material1.transparent = true; var plane = new THREE.PlaneGeometry(canvas1.width, canvas1.height); var mesh1 = new THREE.Mesh( plane, material1 ); mesh1.position.set(0, 50, 0); scene.add(mesh1); var textList = [&quot;Hello, world!&quot;, &quot;你好，世界！&quot;, &quot;こんにちは、世界！&quot;]; var index = 0; document.onkeydown = function (ev) { if (ev.keyCode == &quot;Z&quot;.charCodeAt(0)) { index = (++index) % 3; context1.font = &quot;Bold 40px SimHei&quot;; context1.fillStyle = &quot;rgba(255,0,0,0.95)&quot;; var c = context1.measureText(textList[index]); canvas1.width = c.width; plane.dispose(); plane = new THREE.PlaneGeometry(canvas1.width, canvas1.height); mesh1.geometry = plane; //context.clearRect(0, 0, canvas1.width, canvas1.height); context1.font = &quot;Bold 40px SimHei&quot;; context1.fillStyle = &quot;rgba(255,0,0,0.95)&quot;; context1.fillText(textList[index], 0, 50); texture1.needsUpdate = true; } }; 现在就正常了。这里是第二次修改的演示。 我们添加了一个引用 plane 来管理文字所在的 PlaneGeometry。 问题来了：同学们应该很清楚，如果大资源没有释放，就会造成内存泄露。CLR 里经常会遇到这种事，要很仔细实现 IDisposable 范式，也要注意使用 using，之类的东西。在这个例子中，如果更新函数是放在了 requestFrameAnimation() 中，那就蛋疼了，内存估计哗哗哗就开始消耗；且不说 JavaScript 对象的引用没断，其后的资源也没释放呢。 所以我搜索了一下。两个回答（1/2）提到了 dispose()，以及数组元素请 delete（且不保持其他引用）这个细节。 内存压力测试在 Three.js 的官方示例中有。测试1和测试2。这里是内存测试2的代码。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"杂事","slug":"zh/2015-09-10-Misc","date":"2015-09-10T09:59:00.000Z","updated":"2020-03-30T22:34:35.414Z","comments":true,"path":"categories/Misc/zh/2015-09-10-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-10-Misc/","excerpt":"歌词翻译通过后又发现囧事（新黑历史决定），尝试 Unity 5.2","text":"歌词翻译通过后又发现囧事（新黑历史决定），尝试 Unity 5.2 网易那边终于好了。 两首歌的歌词通过了。不过略囧。 在说明部分我标注的是“……(XXルート)”（某人路线），结果标注的说明被放到了歌曲说明（歌曲详情页，曲目名称下的灰色说明，以及客户端中曲目名称后的灰色字）里……看着很奇怪……从另一个方面来说佐证了人的确参与了核查过程。 木場美冬线ED里有少量的第二声部。我在歌词里是这么标的： [01:04.665]歪(いびつ) [幼い] だった [恋] [01:07.155]運命たちが [泣いた] 和 [02:34.632]いとしい [切ない] ものを [夢] [02:37.111]正しさだけじゃ [摇れで] 用中括号的原因就是为了与被用来注音的小括号（“歪(いびつ)”）区分开，表明这不是注音而是另一个声部。原来的歌词就没有记录第二声部，我尝试补充了上去。不知是网易的 LRC parser 的潜在bug（比如做这样的匹配：\\[([^\\]]+)\\][^\\[]+，这样中括号就成了唯一的分界符）还是人工审核的问题，第二声部没了……没了…… 翻译稿本来没想到这个问题，和上传稿保持一致用的是中括号。同时，小括号还在住吉千里线ED中被用作“写作XX读作XX”的表示，统一起见就没用小括号了。所以只好为了这个问题将上传的翻译中的中括号改成小括号，然后在后面用“//”附上带第二声部的原文。估计这样后面的注释还是会被删掉。（好吧，刚刚收到站内信，通过了，看了一下，没删。） 似乎在通常歌词行可以做这种匹配： (?:\\[((?:\\d{2}:)?\\d{2}:\\d{2}\\.\\d{3})\\])+[^\\r\\n]+ 凌晨弄了一下 Unity 5.2，编译了示例工程 Unity Labs（一小时？不知道，等了十分钟我就睡了），中午（所以说生物钟又混乱了）起来试验了一下。启动。……界面有点眼熟的样子；窗口切换行为也见过，风扇的转速…… 所以秋叶原之旅2（AKIBA’S TRIP: Undead &amp; Undressed）用的也是 Unity 了。←不知道，不过 Custom Maid 3D 2 是用 Unity 做的。这就是“熟悉”的原因。 （基于 SDL 的游戏也可以有“伪全屏”的行为，例如 Prison Architect。“伪全屏”通常是为了和 Linux 一致、少请求独占屏幕以减少因驱动程序的bug导致的显示器停止响应而采取的措施，通过创建一个和显示器分辨率大小相同的窗口，并置于最上方来实现。还有一款游戏 Craft the World 也有类似行为，不过不知道采用了什么引擎。）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof - 20150909","slug":"zh/2015-09-09-Bulletproof-20150909","date":"2015-09-09T15:39:00.000Z","updated":"2020-03-30T22:34:35.414Z","comments":true,"path":"categories/Tech/zh/2015-09-09-Bulletproof-20150909/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-09-Bulletproof-20150909/","excerpt":"","text":"推了三个小更新。 试验品肯定要先拿《干杯》的神字幕开刀。 上次不是说过我忘记测试字幕（那个绿坝娘）来自哪里吗？百度，百度，百度，但是就是找不到。（关键词：bilibili 2012 拜年祭 干杯）翻 ABPH5 和 CCL 的附带页面也找不到。思路还是回到kanoha，翻评论，仔细翻。终于找到了，av411358。这里是弹幕本体。费了好大劲之后发现，我以前保存过，不过没附AV号…… 准备转向测试新方案。 另外，为什么网易那边的歌词还没审核通过……难道歌词和翻译是两部分人负责？我的翻译稿是要配合有时间轴、正确断句（配合句意&amp;歌曲）的歌词才行的……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof - 20150908-2","slug":"zh/2015-09-08-Bulletproof-20150908-2","date":"2015-09-08T13:02:00.000Z","updated":"2020-03-30T22:34:35.414Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-08-Bulletproof-20150908-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-08-Bulletproof-20150908-2/","excerpt":"滤镜在 Bulletproof 中的应用，算法选用","text":"滤镜在 Bulletproof 中的应用，算法选用 滤镜一向是 Bulletproof 的软肋。由于不是采用 SVG 而是 Canvas，所以两个滤镜只好在内部计算完成。 晚上蛋疼地想，之前小圆脸的背景滤镜只计算了一次（在刚刚加载的时候；其余时候内容不变所以不会重算和重绘），如果发光用多了会怎么样？于是我在 filters = true 的条件下运行了三维球的示例。结果大约就 6 fps，和我当年玩镜之边缘相当。（不过我好歹在这个条件下还玩到 The Boat 这一章呢。） 有人可能会问：你不直接给 canvas 加一个效果吗？比如说模糊： canvas { -webkit-filter: blur(10px); -moz-filter: blur(10px); -o-filter: blur(10px); filter: blur(10px); } 建议大家动手试一试。然后你就会发现，这个模糊会将 canvas 以外的所有像素当做黑色，然后进行高斯模糊。在边界上，会向内坍缩出一个黑色的羽化边界。 至于发光呢，这个更坑爹。肯定是用 box-shadow 这个没话说。&lt;canvas&gt; 作为一整个元素进行处理，出来的东西是以 &lt;canvas&gt; 的矩形作为标准计算出来的。 SVG 就好说很多。例如发光（摘自jabbany的代码生成元素）： &lt;svg&gt; &lt;defs&gt; &lt;filter id=&quot;feglow0&quot; x=&quot;-100%&quot; y=&quot;-100%&quot; width=&quot;400%&quot; height=&quot;400%&quot;&gt; &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0 0 0 255 0 0 0 0 255 0 0 0 0 0 0 0 0 0 1 0&quot;&gt; &lt;/feColorMatrix&gt; &lt;feGaussianBlur stdDeviation=&quot;40 40&quot; result=&quot;coloredBlur&quot;&gt; &lt;/feGaussianBlur&gt; &lt;feMerge&gt; &lt;feMergeNode in=&quot;coloredBlur&quot;&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in=&quot;SourceGraphic&quot;&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;g filter=&quot;url(#feglow0)&quot;&gt; &lt;g transform=&quot;translate(329.5,169.5)&quot; opacity=&quot;1&quot;&gt; &lt;g&gt; &lt;path d=&quot;...&quot;&gt; &lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt; 另外如果是模糊，只需要 &lt;feGaussianBlur&gt; 就可以了。 可以看出，原理是一样的，但是 SVG 能更有效地利用浏览器提供的内置功能——而且是标准化了的功能。所以帧率限制根源是 DOM 元素增删操作，普通的混合处理如果功能内置那么可以达到原生的速度。 Bulletproof 没这么好运，因为 canvas 提供的是像素数组，而不是抽象对象描述。这个行为就和自己计算绘制三角形，比起用顶点索引数据让 DirectX/OpenGL 画三角形，效率自然打了很多折扣。 在这之前，我也说过计算了纯色模糊后我使用 alpha blend 合成图像。嗯，又是大数组操作。但是再想一想，如果你使用 drawImage()，将一个 &lt;img&gt; 上的带半透明像素的图像绘制到某个有内容的 &lt;canvas&gt; 上面，难道显示就不正常了？所以很明显，alpha blend 有浏览器帮我们算，为何要吭哧吭哧地用 JavaScript 进行运算呢？ 于是帧率从 ~6 fps 提高到了 ~13 fps。 能不能更快？谷歌了一下（抱歉）。Mario Klingemann 给出了4个算法，Stack Blur、Superfast Blur、Integral Image Blur 和 StackBox Blur。我之前看到所谓“superfast”，就选了。Mario 好心地给出了 JSPerf 的测试链接，我就试了试，结果让我大吃一惊：StackBox Blur 单次迭代比 Superfast Blur 要快上大概 50%（34 ops/s vs. 24 ops/s）。 当然，StackBox Blur 高效率的副作用是低精度。单次迭代效果看起来并不是那么接近高斯模糊。Mario 自己也写了： I am not sure which one of my four box blur algorithms is faster. Lets find out. Additionaly there is a comparison to StackBlur, which is an almost gaussian blur but slower, though to be fair one has to apply 2x box blur to get the same smoothness. 不过弹幕里并不要求很高的精度。遂将模糊算法换成了 StackBox Blur。运行一秒稳定后能维持在 15 fps 以上： 不禁慨叹，j君的历史页就给了我成吨伤害，还要再拜天下大神啊。 所以各位高级弹幕的制作者们，请手下留情，不要疯狂地用滤镜。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof - 20150908-1","slug":"zh/2015-09-08-Bulletproof-20150908-1","date":"2015-09-07T18:28:00.000Z","updated":"2020-03-30T22:34:35.413Z","comments":true,"path":"categories/Tech/zh/2015-09-08-Bulletproof-20150908-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-08-Bulletproof-20150908-1/","excerpt":"代码已推送。 小圆脸的示例请展开查看。","text":"代码已推送。 小圆脸的示例请展开查看。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof - 20150908","slug":"zh/2015-09-08-Bulletproof-20150908","date":"2015-09-07T18:28:00.000Z","updated":"2020-03-30T22:34:35.414Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-08-Bulletproof-20150908/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-08-Bulletproof-20150908/","excerpt":"即将完成的发光、模糊滤镜与灵感来源","text":"即将完成的发光、模糊滤镜与灵感来源 正在写 flash.filters.GlowFilter 和 flash.filters.BlurFilter，即将完成。 模糊滤镜使用的是 Mario Klingemann 提出的一种美妙的快速算法（代码）。很厉害。 发光本来要用 Mode 13 的高大上解决方案 的（代码），调试的时候一头雾水。差点就要用 C# 去做实验尝试其他算法了。后来看到 JH Labs 上的模糊算法描述 中，后面的几个令人惊奇的应用（glow、making shadows、casting rays），里面关于发光（glow）的部分是这么讲的： If subtracting a blurred version of an image from itself sharpens it, what does adding it do? … What you get is a sort of glowing effect which can look quite nice, or quite cheesy depending on your point of view. 这里是示例： 一句话令我恍然大悟。于是我用 Photoshop 做了一下尝试，用一个图形图层用另外的颜色填充，其复制图层高斯模糊放在下面，混合选项选择“正常”，效果不错。因此我将图像纯色化，再模糊后与原图像进行了 alpha blend，其中 SCA（source constant alpha）为 0xff。这样简便美观的发光效果就出来了。 另外发现小圆脸示例中椭圆的位置画错了……囧，应该留心的。检查代码吧。 所以上一次的 push 说“Enjoy the full Madoka and Lvba Musume tests”，哪里来的“full”啊！（另外绿坝娘应该写作 Green Dam Musume，我的疏忽。） 推送之后，代码会在 https://github.com/Hozuki/Bulletproof/。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"奈亚子的各种捏他","slug":"zh/2015-09-07-Nyaruko-Neta","date":"2015-09-07T12:22:00.000Z","updated":"2020-03-30T22:34:35.413Z","comments":true,"path":"categories/ACGN/zh/2015-09-07-Nyaruko-Neta/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-09-07-Nyaruko-Neta/","excerpt":"奈亚子（动画）出现的各种捏他","text":"奈亚子（动画）出现的各种捏他 奈亚子OVA 02:59 我很好奇。（《冰菓》） 04:08 （其实是重复之前的）绮罗星梗。动作：(&lt;ゝω·)綺羅星~☆ kira （《银河美少年》） 04:33 碇司令。话说EVA梗现在才出现，好迟…… 05:11 时间与精神之屋。（《龙珠》）后面还露出了屋顶。 05:27 明显在说加速世界的 Physical Full Burst。 07:02 怪物猎人的天鳞。 07:29 语言上是在模仿无头学姐，表情上那是寒蝉。当然，梨花也说过这一句；论时间的话，算在梨花头上。 09:24 奈亚子做出了一个标准的星间飞行手势。 12:08 这个就是最明显的 MIB 捏他了。 14:53 对W做预告还不忘恶搞。五位少年为了殖民地（colony）独立奋战……是指高达W么？ 觉得可能是捏他的 02:24 是光之美少女么？（另外抓手的特写线条错了。） 05:59 对不起我不知道在说谁，只觉得这种打扮肯定在捏他一个角色。 10:41 这个拖着战具（撬棍）的步态好像在哪里见过…… 奈亚子WOVA 00:25 明显的巨人梗。 03:24 亚马逊再次中枪。（之前是奈亚子W 05，网购了空间分配器。好像还露过一次面。） 03:30 Summer Days 中枪（原文啊）。 03:43 背后的海报是余市neta奈亚子的招牌动作。 05:14 壁咚的描述。 06:58 第三还是第四次玩了这个“因为很重要所以说两次”的梗。 07:18 感觉是捏他。查了一下，泡泡龙（Bubble Bobble，1986）和彩虹岛（Rainbow Islands，1987）都是 TAITO 的游戏。 08:04 17岁教乱入。估计说的几句话是原文的变形，我没看过就是了。 09:12 算是本OVA最精彩的部分了。这个捏他我认为来自于迷糊餐厅的OP，其乐曲高潮部分的背景是宗太看着一群Q版白杨就像发现了无尽的宝藏一样。所以这里还是一个阿澄佳奈对自己的捏他。（前一次是奈亚子08，打工的部分。） 09:27 「逃がさない、はっ！」捏他奈亚子OP。 觉得可能是捏他的 05:17 奈亚子：“我还背负着使命。” 05:35 狸猫好眼熟的样子，不知道出自哪里。 10:18 背后的海报「コニコニ バースデー」不知道想表达什么。恶搞 Niconico 吗？记得秋叶原之旅里提到过那个大猩猩是某个店的吉祥物来着。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"动漫","slug":"动漫","permalink":"https://blog.mottomo.moe/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"Haaaaaah","slug":"zh/2015-09-07-Haaaaaah","date":"2015-09-07T10:05:00.000Z","updated":"2020-03-30T22:34:35.413Z","comments":true,"path":"categories/Misc/zh/2015-09-07-Haaaaaah/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-07-Haaaaaah/","excerpt":"下午翻译了三首歌。现在 Girls, Be Ambitions. 的翻译已经通过了。另外两个正在审核原文歌词（我把能看出来的一些问题改了），通过后再上传翻译稿。 好累。","text":"下午翻译了三首歌。现在 Girls, Be Ambitions. 的翻译已经通过了。另外两个正在审核原文歌词（我把能看出来的一些问题改了），通过后再上传翻译稿。 好累。 包含黑历史。 翻译歌单 提供歌词歌单","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof - 20150906-2","slug":"zh/2015-09-07-Bulletproof-20150906-2","date":"2015-09-06T18:28:00.000Z","updated":"2020-03-30T22:34:35.413Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-07-Bulletproof-20150906-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-07-Bulletproof-20150906-2/","excerpt":"睡前来一发，写了简单的 MotionGroup（忽略了 easing 函数，暂时只实现线性——其他的其实在函数库有了，处理再说吧，反正要睡觉了）。 于是可以流畅运行小圆脸和绿坝娘的demo了。 效果（GIF）请展开阅读。","text":"睡前来一发，写了简单的 MotionGroup（忽略了 easing 函数，暂时只实现线性——其他的其实在函数库有了，处理再说吧，反正要睡觉了）。 于是可以流畅运行小圆脸和绿坝娘的demo了。 效果（GIF）请展开阅读。 还有，这张 GIF 好大，这样下去 repo 的空间会满的。 代码已经提交，依然在 https://github.com/Hozuki/Bulletproof/。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof - 20150906-1","slug":"zh/2015-09-06-Bulletproof-20150906-1","date":"2015-09-06T14:23:00.000Z","updated":"2020-03-30T22:34:35.412Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-06-Bulletproof-20150906-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-06-Bulletproof-20150906-1/","excerpt":"解决了之前重绘重影、效率低的问题；对 VS+NTVS vs. WebStorm 的评论","text":"解决了之前重绘重影、效率低的问题；对 VS+NTVS vs. WebStorm 的评论 偶然找到了一篇讲 CanvasDrawingContext2D.beginPath() 的重要性的博文，读了以后我理解了：之前所谓“clearRect() 没有起到作用”，那是因为在 clear() 中没有手工 beginPath()，这样实际上没有清除 CanvasDrawingContext2D 内置的笔画记录，所以调用了 lineTo()，&lt;canvas&gt; 作为 DOM 元素重绘的时候会将前面的所有记录重现——这就造成了“模糊的重影”。 如果简单地提升效率，小圆脸的测试可以被写成下面的样子： var g = s.graphics; g.lineStyle(...); g.beginPath(); // moveTo(), lineTo(), curveTo(), drawXXX(), ... g.endPath(); 如果在 Graphics 中将这一系列行为写入一个路径元素数组，然后统一用 g.beginPath()、g.endPath() 来手工指定开始结束，用高效率的 drawPath() 方法，或许会提速。 但是这是不可能的，因为你不能要求开发者按照你的意愿去写代码，最多只能去“建议”这么写。另外，对于复杂的图形代码，许多人是用工具自动生成的，总不能强迫他们去手工优化吧？ 所以要不就建立两套系统，要不就判断调用意图。 Bulletproof 现在的目标是先在 nw.js 上运行起来。不过，在考虑此平台兼容许多 ECMAScript 5/ECMAScript 6、HTML 5、CSS 3 的情况下，会尽量用标准库的对象、函数，不用 Webkit 的方言。 更新： 第二段写了一半，同时查资料，然后写第一段。（所以如果直接从前往后读会觉得逻辑混乱，如果是第二段-第一段这样就能理解了。）写着第一段，由第一部分推断的 beginPath() 与 &lt;canvas&gt; 状态的关联性，我想到，在 Flash 中每次 lineTo()、curveTo() 是无状态的（和 GDI 一样），那么就不该保存之前的路径。为了和 Flash、GDI 的语义保持一致，在 flash.display.Graphics.lineTo() 和 curveTo() 中加入了 context.beginPath()。 这下子就正常了。 差点就要做 SVG/Canvas 切换的绘图系统了。当然做了更好，这样方便解耦，现在的代码耦合太严重。 6天没怎么更新，代码提交上去了。还是在 https://github.com/Hozuki/Bulletproof/。 好好吐槽一下 WebStorm 和 Visual Studio + NTVS (Node Tools for Visual Studio) 这两种环境对项目的支持吧。 WebStorm: 对于 nw.js，不支持调试，最多只能看到控制台的消息输出。 支持 nw.js 开发和直接运行。 分析很慢，自动完成下拉列表显示杂乱。 知道 TypeScript 中所有的“类”（class）都是函数（function），因此会弹出关于函数的智能提示（如 prototype、bind）。 VS + NTVS: 理论上支持 Node.js 的调试，但是 nw.js 还没成功自动跑起来过，要手工写命令行。 对于 TypeScript，非常严谨地限制其语言为 ECMAScript 标准。举例来说，我在代码中用到了 Map，这是预计加入 ECMAScript 6 的语言组成部分，而且大多数浏览器已经实现了。但是微软家的 TypeScript 编译器很正经地告诉你：不能用 Map，因为我没见过。想改 lib.d.ts？想得美！ 响应很快，对于对象能正确解析动态的属性、函数定义。 “类”的概念类似于传统继承的语言（JavaScript 算是原型链继承的语言），所以当你敲下“.”的时候，只会显示此类能访问到的、定义在 TypeScript 代码中的东西。但是我手工敲下“.hasOwnProperty”，然后按下“(”，hasOwnProperty() 函数的提示确实出来了。这样很不方便啊各位。 要命的是，Visual Studio 的默认保存策略是保存为 ANSI 编码，保存为对应的代码页（codepage）。例如在我的简体中文的系统中，代码页是936，编码就是 CP936，实际是 GBK。问题来了：TypeScript 代码文件的编码要是 UTF-8。怎么办？土办法是逐个文件带编码另存为为不带 BOM 的 UTF-8——但是这样 VS 无法识别出这是 UTF-8，下次按下“保存”又是保存为 GBK。我这里 VS 2015 的指定编码另存为还直接告诉我“组件不可用”！ 这个是 NTVS 的问题了：现在 NTVS 的 npm 源更新、合并本地数据库一直在失败。 所以我还有什么选择呢？只好用 WebStorm，忍受那界面了。例如，VS 的编辑栏上面有三个（在 VS 2013 Update 4 前是两个）下拉框，告诉你光标所在处位于哪个工程、哪个类的那个成员（如果不是在成员，就是公共域）里。WebStorm 里有一个“结构列表跟随光标”的功能，但是会导致结构列表展开——我这个类有数十个成员，早就超过了一个屏幕高度的容纳范围，我只看到了成员名，位于哪个类我还得到列表中滚动滚轮去找。此外，如果字体小一点，容纳文字多了，在 WebStorm 给代码上色的时候风扇就要转个不停，响应也跟不上速度；VS 这方面就好得多，不仅响应和效率很高，字体小一点也没关系，可用书写空间更大。 Visual Studio 果然还是宇宙第一 IDE。如果 NTVS 变得更好一点的话，能满足需求的情况下我肯定是要投奔 VS 的。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"Bulletproof - 20150906","slug":"zh/2015-09-06-Bulletproof-20150906","date":"2015-09-05T18:00:00.000Z","updated":"2020-03-30T22:34:35.413Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-06-Bulletproof-20150906/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-06-Bulletproof-20150906/","excerpt":"程序结构更新后出现的问题与测试数据","text":"程序结构更新后出现的问题与测试数据 改善了程序结构。然后一跑，傻眼了： 在小圆脸组合的测试中更糟糕，结果不堪入目。 回到昨晚上的commit发现并没有变化——突然就不知道昨天那么好的结果是怎么来的了。 现在看起来是 Webkit 在限制调用，做了一下profile好像没看出什么的东西： 意料之外地，(program) 一项占时间很长。 使用 Timeline 选项卡可以看到，脚本执行花费了较多时间，但是“其他”（other）时间特别长，空闲（idle）的时间很少： 查了一下资料，透明条（中空条）一般是函数优化等工作。那么大概也可以认为“其他”大多时间都在优化了。 我想，很可能是那个巨大指令循环。 《神之谜题》第三季居然引入了小剧场互动模式，可以通过数字电视遥控器解答谜题互动。感谢字幕组还做了这一块，以及片源君辛勤录制与剪接。不知这种互动方法是否是 NHK 首创。（比起国内那些XX的整天教唆小孩子“拿起手机拨打某某号码”的电视台好多了。）","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"清晨","slug":"zh/2015-09-05-Early-in-the-Morning","date":"2015-09-04T23:29:00.000Z","updated":"2020-03-30T22:34:35.412Z","comments":true,"path":"categories/Misc/zh/2015-09-05-Early-in-the-Morning/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-05-Early-in-the-Morning/","excerpt":"杂文","text":"杂文 时间到了9月5日，离下学期开学不到10天。之前我似乎在过格林威治时间（+0Z），早上8点睡，下午3点起来。在剩下的时间里，我必须纠正自己的生物钟了。 今天凌晨两点半，强制自己躺倒床上，不久就睡着了。原定是早上07:20的闹钟，结果醒来的时候天蒙蒙亮，在闭眼辗转反侧了一段时间之后（当时时间感知应该不太对了，现在估计是15分钟）睁开眼，刚刚过六点。 折腾了一个小时，本来就计划早起买早餐的。出门到服务部，没开门！门上贴着一张纸：“暑期营业时间：上午8时-晚上9时。” 但是，此时才是七点二十五不到。 算了，打道回府吧。写一篇日志，再到服务部，应该就开了，就可以买早餐了。 回去的时候，正下着小雨（昨天下午就开始下雨了），环境亮度还不到平日六点的亮度。天上的云还是我喜欢的一种，有颗粒感的、有渐变的、铺开天际的铁灰色的云。路上零星的行人（学生）撑着伞。 相对于嘉年华式的狂欢，我还是喜爱这种氛围。路上有几个人，环境很美很安全，空气也很清新；我一个人走着，可以想东西而不被人打扰。 再次回到宿舍楼，七点三十不到。 我现在也用上智能手机了。我用UC浏览网页（Java 版在版本9之后就不再更新了，似乎），可以看到一些推荐消息。过滤掉一些有问题的之后，还是能找到一点好东西的。Java 版的排版是很简单（因为展示不了复杂的内容，最多就是文字图片+简单表格），一般也够用。 对于触摸屏我还是不习惯就是了，努力适应着。 以前我写过一篇博文，主要想讲选择权多了以后反而产生的不适应感。我还是怀念 Nokia X2-01（现在也在用），和以前用的 Nokia 5310XM。尽管操作系统很单调，也就一点点的娱乐空间，但是玩着玩着也会产生乐趣。反之，在选择增加的现在，选择淹没了我，而不是我去选择了。 能订外卖了，但是我还是怀念中学的小卖部呢。 今早的梦，我记得是（高中）全班去完成什么任务来着。最后一幕是在教室里（没怎么注意光照，不过更可能是高一时期的教室）大家坐着，然后似乎在统计到的情况，讨论怎么交作业，谁来收。最后一项就是老师说“因为……（忘了），所以不换位置了。”在一片不满的声音中我醒来了。 我记录梦境的原因是我可以以此来分析我的精神状态和潜在问题。 即使写了一篇文章记录整个过程，之前根据行为、说话方式也预料到了，相互说不了什么的。 朋友是分享观点的人，而不仅仅是交换感情。 意识到了，为什么不承认呢。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Bulletproof - 20150905","slug":"zh/2015-09-05-Bulletproof-20150905","date":"2015-09-04T16:30:00.000Z","updated":"2020-03-30T22:34:35.412Z","comments":true,"path":"categories/Tech/Coding/zh/2015-09-05-Bulletproof-20150905/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-09-05-Bulletproof-20150905/","excerpt":"Bulletproof 的代码更新，能实现运动了。 同时观察到了疑似的 canvas 清除失败。","text":"Bulletproof 的代码更新，能实现运动了。 同时观察到了疑似的 canvas 清除失败。 更新了一点代码，能支持简单的运动了。这样的运动是直接更改 x 或者 y 属性实现的，而不是正规的用 MotionGroup 实现。以下是测试。 动画： 代码： // FPS 计算代码来自 3D-ball 示例 var frameCount = 0; var lastTime = Date.now(); var nextUpdate = Date.now() + 1000; var f = function () { var now = Date.now(); frameCount++; if (now &gt;= nextUpdate) { fps = ((frameCount / (now - lastTime) * 1000 * 10) | 0) / 10; document.title = &quot;FPS: &quot; + fps.toString(); lastTime = now; frameCount = 0; nextUpdate = Date.now() + 1000; } if (s) { s.x += 0.05; } requestAnimationFrame(f); }; requestAnimationFrame(f); 绘制部分的代码取自B站的《干杯》神弹幕（AV号忘记了，记得在kanoha的评论里有，去找没找到）的第一部分——绿坝娘。 然而在测试中也发现了一个问题，CanvasDrawingContext2D.clearRect() 有时候会不灵光。下面是不灵光时的效果： 从上往下第一个 nw.exe 是浏览器进程，第二个是服务器进程。 任务管理器中还可以看到，内存占用也是在往上疯长，然后到了一个阈值（大约 270 MiB）就大起大落（应该是不断触发了 V8 的强制垃圾回收）。就在下面这一段： public clear():void { // ... // 似乎无效 //context.clearRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight); // TODO: HACK: works under nw.js v0.12 // DANGER: will reset styles this._canvas.width = this._canvas.width; // ... } 用 canvas.width = canvas.width 这种方法，100%有效，不过效率会降低（EN）。目前我还不是很清楚是什么导致 clearRect() 失效。（在 clearRect() 之前，我重置了变换，所以清空的的确是 &lt;canvas&gt; 的显示区域。） &lt;canvas&gt; 是由用户负责绘制的，不像 SVG 那样是浏览器负责绘制的，因此做同步是比较难的。如果我用的是 SVG，那么只需要一个： svgElement.style.left = (++currentX).toString + &quot;px&quot;; svgElement.style.top = (++currentY).toString + &quot;px&quot;; 剩下的就是浏览器进行样式计算、绘制、显示。对不起，用 &lt;canvas&gt;，请自己完成所有工作。 所以我做了一个指令队列记录绘制过程。理论上，需要重绘的时候就要恢复到上一次开始绘制前的状态，然后重复执行。我开始以为是这个队列出了什么问题导致多次绘制，但是调试后发现队列没有异常。（WebStorm 对 nw.js 的调试支持基本上算没有，连一个断点都设置不了，所以只好凭原始的黑箱方法来做了。）1539条指令，一直没变，内容也没变。蛋疼地去看自己对 redraw() 的实现逻辑，没问题；重绘队列的更新逻辑，没问题；变量访问加锁不需要，因为在浏览器窗口中的 JavaScript 是单线程运行的（不算 Web Worker 的话）。到底是哪里…… 但是值得注意的是，重绘时至少存在一次 this.clear() 成功的操作。 public redraw():void { // ... this.clear(); // # possible breakpoint switch (this.historyQueue[i].command) { // ... } // ... } 如果在上面的 this.clear() 之后添加一个 return，那么画布上什么都没有了。考虑到第一次绘制来自神弹幕代码，这里如果清除失败应该还会留有一些图形才对。 另外，内存爆炸（在队列正常的情况下）也大概可以看出一点 &lt;canvas&gt; 的状态机的端倪，多次执行有偏移的相同指令会导致每次增加 20~30 MiB（这个量大约等于后来正常运行时浏览器的内存开销），因此可能有了隐性的状态保存操作。 Q: 透明度怎么办？ A: 简单，样式的 opacity 直接上就行了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"吐槽《神之谜题》的人物关系","slug":"zh/2015-09-04-Phi-Brain-Puzzles-of-God","date":"2015-09-03T20:23:00.000Z","updated":"2020-03-30T22:34:35.412Z","comments":true,"path":"categories/ACGN/zh/2015-09-04-Phi-Brain-Puzzles-of-God/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-09-04-Phi-Brain-Puzzles-of-God/","excerpt":"《黄金头脑 神之谜题》（「ファイ・ブレイン ～神のパズル」）角色方面一反常态。","text":"《黄金头脑 神之谜题》（「ファイ・ブレイン ～神のパズル」）角色方面一反常态。 前期戴着俄尔普斯之环，关键时候总是能展现“和善的眼神”的、拥有“爱因斯坦”称号的男主大门界人： 男主的后宫团之一，拥有“伽利略”称号，甚至为了男主赴汤蹈火搞潜入的傲娇好X友住门（男）： 男主的后宫团之一，拥有“爱迪生”称号的小小研究员QB（男）： 男主的后宫团之一，拥有“达芬奇”称号，充满艺术细胞的治愈系真相帝安娜（注意，男）： 男主的后宫团之一，第一季boss卢克（Rook，国际象棋的车）（男）： （画面前方那位白色爆炸头就是卢克。） 男主的后宫团之一，第二季boss弗利赛尔（Freecell，Free Cell 就是我们常见的“空当接龙”啦）（男）： 以上是从离主角最亲近的一圈中选取的。什么叫做“后宫团”呢？除了性情刚烈的住门外，其他几位都很软，而且都想往界人怀里钻。（一二两季boss让我想起了游戏王里的马利克和貘良了，傲娇刚烈汉子就是社长翻版……但是“只有我才有资格给界人出题”这种台词，两季boss学的是社长吧。） 第二季还收了两个人，一个是小boss（男），一个是第一季的小boss（男）。 好的，看看女性角色。 唯一的正常人（从正常人的视角看），拥有“南丁格尔”称号的真正女一号野乃叶（ののは）： 拥有“安托瓦奈特”（Antoinette）称号的英玲奈（エレナ）： 其实第二季反派团队里5人有2个是妹子，不过性格都很恶劣。安娜的姐姐（真的是姐姐不是哥哥）——哦对不起，和主角团没有更多的联系所以不算在内。 野乃叶一直粘着界人，正常。啥？你说英玲奈不错？对不起，她的心已经属于住门了。罕见的男主男队友有妹子的情况出现啦！但是住门呢？想着野乃叶。（混乱。） 这是什么情况？男主的后宫居然全是男的，有安娜这种画个妹子硬说是男的的人，还有整天求受的小正太？作者是在干什么呢？一二季的两个boss还都是男主小时候与之有约♂定的男性！卢克CV是樱井孝宏哦！弗利赛尔CV是神谷浩史哦！幸好还安排了个女主角，还在不断刷存在感，要不这片就真成了腐女的天堂了。 其他的还有，第二季被救出的小boss皮纳克尔（Pinochle，一种纸牌游戏）念念不忘的是弗利赛尔。 福利：四人身高 另外，SUNRISE 做的人物中景基本上都要崩，更别说远景了。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"杂记 20150901","slug":"zh/2015-09-01-Misc-of-0901","date":"2015-09-01T10:36:00.000Z","updated":"2020-03-30T22:34:35.412Z","comments":true,"path":"categories/Misc/zh/2015-09-01-Misc-of-0901/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-09-01-Misc-of-0901/","excerpt":"杂记","text":"杂记 昨晚下了一场雨，今早08:37海淀的温度到了18度。作为一名昨晚到今早都在宿舍电脑前，窗户大开（舍友说开窗通风吧）的孩子，腿部感到了阵阵凉意。我们的空调在关之前设定是24度，但是效果远远没有昨晚关空调开窗那么明显。 看了一下日历，今年中元节是8月28日，今天已经9月1日了。9月8日就是白露。今年秋天又一次早早来临——秋天冬天比起来我还是喜欢冬天，因为有雪。只不过两个季节都非常干燥，我每天都需要三次甚至更多次放电（接触自来水，接地）。 天啊，本来一篇要感叹秋之肃杀的怎么写成了这样！ 在UC的每日速递上看到了这样的幼儿园。UC上的文章与链接中的文章有所不同。其中有一句话我很赞赏：优秀的建筑有生命。不过这话轮不到我这个在板砖宿舍里住着的家伙来说对吧。 互联网上的转载：《你的孩子在上补习班，日本的孩子在放羊……》（这个就是UC上转载的） 对了，看着网上一群开发了 Windows 10 UWP Application 的，真是眼馋。 Visual Studio 2015 总是告诉我： 程序包安装错误 无法将所有必需的程序包添加到项目。以下程序包无法从“C:\\Program Files (x86)\\Microsoft SDKs\\NETCoreSDK”安装： Microsoft.NETCore.UniversalWindowsPlatform.5.0.0：未打开或保存解决方案。请确保你拥有打开的已保存解决方案。 于是乎，创建工程后，缺少引用（reference），IntelliSense 啊编译啊全罢工了。所以这一高大上的新领域（UWP 啊，这是我除了 Roslyn 之外的另一个看好 VS 2015 的东西啊）暂时就无法到达了。 09-02: 昨晚又梦见了那两个。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"“防弹”弹幕播放器","slug":"zh/2015-09-01-Introducing-Bulletproof-the-Danmaku-Player","date":"2015-08-31T18:53:00.000Z","updated":"2020-03-30T22:34:35.411Z","comments":true,"path":"categories/Tech/zh/2015-09-01-Introducing-Bulletproof-the-Danmaku-Player/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-09-01-Introducing-Bulletproof-the-Danmaku-Player/","excerpt":"Bulletproof 诞生介绍","text":"Bulletproof 诞生介绍 花了4天时间，从底层开始组装弹幕播放器。 前有jabbany大神的 CommentCoreLibrary，我实在感觉压力山大。在他的博文面前，我一次次感到自己是个渣渣。 现在写的这个播放器（诶，原先还不是想作为播放器的）暂定名 Bulletproof，也就是“防弹”的意思。我从 BiliBili 高级弹幕 API 开始，一层一层往下挖，挖出来的东西堆成了庞然大物： 想必jabbany也是构建了许多东西，还加上安全措施——肯定更辛劳吧。 项目在 https://github.com/Hozuki/Bulletproof/。目前还是一个非常原始的状态，简直就是裸机。不过至少能跑一个测试代码了。我用jabbany的测试页面上的 Debug 3D 的代码测试了一下。（由于这里没有沙箱，所以将其 screen 变量改名为 ball。） CCL 的表现：~20 fps（Maxthon 4） Bulletproof 的表现：~50 fps（nw.js） 参数一样。勉强吧。嗯不过好像即使 detail=160，stripes=19，我这里还能 ~30 fps。 不过我觉得，既然 CCL 已经成为A站的 HTML5 播放器核心了，那几位开发者势必会在几天内把 Bulletproof 打得落花流水吧。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"弹幕","slug":"弹幕","permalink":"https://blog.mottomo.moe/tags/%E5%BC%B9%E5%B9%95/"},{"name":"Bulletproof","slug":"Bulletproof","permalink":"https://blog.mottomo.moe/tags/Bulletproof/"}]},{"title":"全金属狂潮校园篇 逆天的制作人员","slug":"zh/2015-08-30-Astonishing-Staff-of-FMP-S02","date":"2015-08-29T21:33:00.000Z","updated":"2020-03-30T22:34:35.411Z","comments":true,"path":"categories/ACGN/zh/2015-08-30-Astonishing-Staff-of-FMP-S02/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-08-30-Astonishing-Staff-of-FMP-S02/","excerpt":"《全金属狂潮 校园篇》EP02/EP09 的制作人员","text":"《全金属狂潮 校园篇》EP02/EP09 的制作人员 两话令我印象深刻。 第一个是第2话，从OP前开始，下课准备，到小要冲出去，买面包的整个过程。 第二个是第9话，后半部分突击的过程。 （贺东招二你面子得多大啊……）","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"逆向工程实战 - 某软件加密的过程","slug":"zh/2015-08-25-Breaking-Down-A-Encryption","date":"2015-08-25T10:05:00.000Z","updated":"2020-03-30T22:34:35.411Z","comments":true,"path":"categories/Tech/RE/zh/2015-08-25-Breaking-Down-A-Encryption/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2015-08-25-Breaking-Down-A-Encryption/","excerpt":"记录对某软件进行逆向，得到其加密函数的过程。 本文仅用于技术探讨，禁止用于非法用途！ 此次不需要修改程序内容，所以不需要备份。 本文假设读者已经有了初步的汇编语言、C 语言知识。","text":"记录对某软件进行逆向，得到其加密函数的过程。 本文仅用于技术探讨，禁止用于非法用途！ 此次不需要修改程序内容，所以不需要备份。 本文假设读者已经有了初步的汇编语言、C 语言知识。 上次破除 Strawberry Feels 的光盘加载算是一次入门，而且真的是入门中的入门。不久之后开「恋と選挙とチョコレート」（恋爱与选举与巧克力），进去的时候发现启动的程序是一个 Macromedia 的遗留物，算是解释器一类的东西，并没有一个检索过程。考虑到有可能是通过插件实现的附加功能，而这个的反编译实在是太难，就没有继续做下去了。 下一步我盯上了学校里的一个软件。这个软件工作流程的其中一个部分就是将输入的数据加密，加密过程是我不知道的，不过输入和输出我都知道。最后的输出明显是经过转义的，这一步也很明显。核心就是加密过程。 经过设置断点调试（通过查找输出的格式字符串，一共4个，通过运行来确认），找到了加密的函数，位于偏移 0x00401340。Olly Debug 的输出如下： CPU Disasm Address Hex dump Command Comments 00401340 /$ 51 PUSH ECX ; app.00401340(guessed Arg1,Arg2,Arg3) 00401341 |. 55 PUSH EBP 00401342 |. 8B6C24 10 MOV EBP,DWORD PTR SS:[ARG.2] 00401346 |. 56 PUSH ESI 00401347 |. 57 PUSH EDI 00401348 |. 8BFD MOV EDI,EBP 0040134A |. 83C9 FF OR ECX,FFFFFFFF 0040134D |. 33C0 XOR EAX,EAX 0040134F |. F2:AE REPNE SCAS BYTE PTR ES:[EDI] 00401351 |. 8B4424 14 MOV EAX,DWORD PTR SS:[ARG.1] 00401355 |. F7D1 NOT ECX 00401357 |. 83C1 FE ADD ECX,-2 0040135A |. 894C24 0C MOV DWORD PTR SS:[LOCAL.0],ECX 0040135E |. 8BF1 MOV ESI,ECX 00401360 |. 8A08 MOV CL,BYTE PTR DS:[EAX] 00401362 |. 84C9 TEST CL,CL 00401364 |. 74 5D JE SHORT 004013C3 00401366 |. 8B5424 1C MOV EDX,DWORD PTR SS:[ARG.3] 0040136A |. 53 PUSH EBX 0040136B |. 895424 1C MOV DWORD PTR SS:[ARG.2],EDX 0040136F |&gt; 8A042E /MOV AL,BYTE PTR DS:[EBP+ESI] 00401372 |. 8BD6 |MOV EDX,ESI 00401374 |. 32C1 |XOR AL,CL 00401376 |. 8AC8 |MOV CL,AL 00401378 |. 24 0F |AND AL,0F 0040137A |. C0F9 04 |SAR CL,4 0040137D |. 80E1 0F |AND CL,0F 00401380 |. 04 36 |ADD AL,36 00401382 |. 80C1 63 |ADD CL,63 00401385 |. 81E2 01000080 |AND EDX,80000001 0040138B |. 79 05 |JNS SHORT 00401392 0040138D |. 4A |DEC EDX 0040138E |. 83CA FE |OR EDX,FFFFFFFE 00401391 |. 42 |INC EDX 00401392 |&gt; 8AD8 |MOV BL,AL 00401394 |. 75 02 |JNE SHORT 00401398 00401396 |. 8AD9 |MOV BL,CL 00401398 |&gt; 8B7C24 1C |MOV EDI,DWORD PTR SS:[ARG.2] 0040139C |. 881F |MOV BYTE PTR DS:[EDI],BL 0040139E |. 47 |INC EDI 0040139F |. 85D2 |TEST EDX,EDX 004013A1 |. 74 02 |JE SHORT 004013A5 004013A3 |. 8AC1 |MOV AL,CL 004013A5 |&gt; 8807 |MOV BYTE PTR DS:[EDI],AL 004013A7 |. 47 |INC EDI 004013A8 |. 4E |DEC ESI 004013A9 |. 897C24 1C |MOV DWORD PTR SS:[ARG.2],EDI 004013AD |. 79 04 |JNS SHORT 004013B3 004013AF |. 8B7424 10 |MOV ESI,DWORD PTR SS:[LOCAL.0] 004013B3 |&gt; 8B4424 18 |MOV EAX,DWORD PTR SS:[ARG.1] 004013B7 |. 40 |INC EAX 004013B8 |. 894424 18 |MOV DWORD PTR SS:[ARG.1],EAX 004013BC |. 8A08 |MOV CL,BYTE PTR DS:[EAX] 004013BE |. 84C9 |TEST CL,CL 004013C0 |.^ 75 AD \\JNE SHORT 0040136F 004013C2 |. 5B POP EBX 004013C3 |&gt; 5F POP EDI 004013C4 |. 5E POP ESI 004013C5 |. 5D POP EBP 004013C6 |. 59 POP ECX 004013C7 \\. C3 RETN 其调用如下： CPU Disasm Address Hex dump Command Comments 0040523E |. 51 PUSH ECX ; |/Arg3 =&gt; OFFSET LOCAL.334 0040523F |. 52 PUSH EDX ; ||Arg2 =&gt; OFFSET LOCAL.346 00405240 |. 50 PUSH EAX ; ||Arg1 00405241 |. E8 FAC0FFFF CALL 00401340 ; |\\app.00401340 所以函数原型就是（返回值看对 EAX 的操作，或者最后栈的平衡）： void encrypt(char *text, char *key, char *buffer); 接下来的数据的段（segment）不显式写出了，具体指向哪个段视上下文而定。 通过调试和对前面一点代码的分析，可以知道 Arg1 是指向明文的指针，Arg2 是指向密钥的指针，Arg3 是指向结果缓冲区的指针。其中，密钥的构造方式如下。获取当前 UTC 时间的 UNIX 时间戳，转换单位为分钟（忽略小数），然后转换为字符串。怎么得到的？多次调试发现这密钥不怎么变化，而且稍稍估计一下就发现变化的时间大约是按照分钟计算。得到的密钥是个字符串，而且这个大小……看看本地时间的 UNIX 时间戳就会发现可能的关系。我当时感觉这可能是分钟，在 VB 里做了一下验证： Debug.Print DateDiff(&quot;n&quot;, #1970-01-01#, DateAdd(&quot;h&quot;, -8, Now)) Debug.Print DateDiff(&quot;n&quot;, #1970-01-01#, Now) OK，现在我们知道了三个参数，开始看函数。 函数首先将 EBP 赋值为指向密钥（Arg2）的指针： MOV EBP,DWORD PTR SS:[ARG.2] 然后计算密钥的长度（注意此时 EBP 的值为密钥的地址）： MOV EDI,EBP OR ECX,FFFFFFFF XOR EAX,EAX REPNE SCAS BYTE PTR ES:[EDI] MOV EAX,DWORD PTR SS:[ARG.1] ; 这句是为了后面准备的，不属于长度计算的语句组 NOT ECX 这里就有一个知识点，scas 和 repne 的配合使用计算字符串长度。知道这一点后，就可以推断出，在执行完这一段之后 ECX 的值为字符串长度加上1。于是我们可以写出这一段的伪代码： ecx = strlen(arg2) + 1; // 注意这里的“+1” 然后是设置一个计数器变量： ADD ECX,-2 MOV DWORD PTR SS:[LOCAL.0],ECX MOV ESI,ECX 也可以直接翻译成伪代码： local[0] = ecx = ecx - 2; esi = ecx; 因为前面知道了 ECX 的值的意义与字符串长度有关，这里可以知道如果 ESI 是一个计数器变量的话，arg2 + esi 就指向了密钥的最后一个有效字符（除了 &#39;\\0&#39; 之外的字符）。大概可以猜到接下来会对字符串进行逆序遍历。 接下来就是一个典型的防御性（defensive）编程的代码（别忘了根据前面的代码，此时 EAX 的值是指向明文的指针）： MOV CL,BYTE PTR DS:[EAX] TEST CL,CL JE SHORT 004013C3 004013C3H 位于接下去的循环的结束，因此这里的判断就是为了防止在明文为空字符串时进行加密。伪代码如下： if (*arg1) { // 加密循环体 } 下一段是对参数进行了赋值： MOV EDX,DWORD PTR SS:[ARG.3] ; 下面一句也和意图不那么相关。不过因为后面会改变 BL，间接改变了 EBX，最后还会有一次 POP 恢复 EBX 为初始值。local[4] 是唯一一个没有改变的局部变量。 PUSH EBX MOV DWORD PTR SS:[ARG.2],EDX 翻译成伪代码就是： arg2 = arg3; 没错，由于 X86 指令集的限制，栈变量之间的赋值要两条汇编语句。 然后就到了最激动人心的时刻，进入到循环体内部！ 在循环体内部，用的临时变量是 AL 和 CL（应该是编译器优化的结果）。其中，AL 与密钥有关，CL 与明文有关。 其他的重要变量是 BL（用于输出）、ESI（用于进行密钥的逆序遍历）、EDI（用于指示输出偏移）和 EDX（作用后面说）。 首先给 AL 赋值（CL 已经预先指向了明文内的某个字符）： MOV AL,BYTE PTR DS:[EBP+ESI] 考虑到此时 EBP 指向密钥的首地址，ESI 是偏移（计数器），所以就应该翻译成： al = key[esi]; 然后是将 EDX 设置为当前 ESI 计数器的值（这里很重要）： MOV EDX,ESI 接下来就是喜闻乐见的异或操作： XOR AL,CL 嗯，这一段加密的基础就是这里的异或啦。 然后取高低位，并变换到可打印字符上： MOV CL,AL AND AL,0F SAR CL,4 AND CL,0F ADD AL,36 ADD CL,63 上面的 36 和 63 都是十六进制数，我后面写验证代码的时候被坑过。 好了，难点到了。猜猜接下来这一段是在干什么？提示：此时 EDX 的值是一个类似计数器的东西（看上面说“很重要”的位置）。 AND EDX,80000001 JNS SHORT 00401392 ; 00401392H 是紧接在 INC EDX 后的语句的地址 DEC EDX OR EDX,FFFFFFFE INC EDX 公布答案：这是一个带符号取模的操作。我真佩服那些编译器的设计者，能设计出产生如此优化的代码的编译器。 对应的伪代码如下： // 和数学上意义相同，奇数返回±1（依据符号而定），偶数返回0 edx = edx % 2; 是不是很奇妙？几个加减/位操作就将一个带符号模2的操作解决了！ 我之前没有理解这一段。看看我一开始逆向时写的伪代码和注释： { edx = edx &lt; 0 ? 0x80000001 : 1; (edx &amp;= 0x80000001;) if (edx &lt; 0) { { edx--; edx |= 0xfffffffe; edx++; } =&gt; { edx = -1; (结合上面的情况) } } } =&gt; { edx = edx &gt;= 0 ? 1 : -1; } 我没有想清楚在不同的数的情况下，EDX 最终的值是多少。这也直接导致了后面几个判断 EDX 是否为零（JE/JNE）的地方我就注释为“永远为true”/“永远为false”。根据这些伪代码写的验证代码自然就错了。一看，第一个字符是对的，后面就好像出问题了。和验证代码一起进行单步调试的时候，发现验证代码里的 AL 和 CL 的值是正确的，但是输出的字符错了。于是我就想到是不是这一段的问题。在某次调试中，第二次循环时，我发现有一个我标记为“永远为false”的一条跳转指令居然成了“Jump is taken”（Olly Debug 提示），然后我突然发现了 EDX 居然有成 0 的情况。但是第二次循环时计数器肯定不是0，而 EDX 不是 1 也不是 -1。于是根据我写的返回值判断，加上0这个确实存在的输出，这可能是一个模2的输出。于是重新考虑这一段，发现确实是一个带符号模2的过程。后来确认是模2。 好了，最难的地方过去了。接下来就是输出至缓冲区。 MOV BL,AL JNE SHORT 00401398 MOV BL,CL MOV EDI,DWORD PTR SS:[ARG.2] MOV BYTE PTR DS:[EDI],BL INC EDI TEST EDX,EDX JE SHORT 004013A5 MOV AL,CL MOV BYTE PTR DS:[EDI],AL INC EDI DEC ESI MOV DWORD PTR SS:[ARG.2],EDI 翻译成伪代码就是下面的样子（当前 arg2 的值也成了指向缓冲区的指针，EDI 的值是指向缓冲区的下一个输入位置的指针，ESI 是字符相对密钥的偏移/计数器）： // (此时 key 等于 buffer) bl = al; if (edx == 0) { bl = cl; } edi = key; *edi = bl; edi++; if (edx != 0) { al = cl; } *edi = al; edi++; esi--; key += 2; 然后是一个循环加密的保证（此时 SF 标志由前面的 DEC ESI 这一句决定）： JNS SHORT 004013B3 ; 004013B3H 是这两句后面的第一句指令的地址 MOV ESI,DWORD PTR SS:[LOCAL.0] 所以就是： if (esi &lt; 0) { esi = local[0]; // 此时 local[0] 等于密钥长度减1 } 然后就是读取下一个字符，准备下一次循环： MOV EAX,DWORD PTR SS:[ARG.1] INC EAX MOV CL,BYTE PTR DS:[EAX] TEST CL,CL JNE SHORT 0040136F ; 跳转到循环开头 伪代码： text++; // 和前面一样，函数参数的值不能直接修改，要用寄存器辅助 if (cl = *text) { goto __loop_begin; } 其中后面一段和循环开头的判断结合，可以简写为： cl = *text; if (!cl) return; // 一点代码 do { // 循环体的一部分 text++; cl = *text; } while (cl); 至此我们可以看清加密函数的结构（可以将 j 近似看做 ESI），略微转换一下： i = 0, j = len(time) - 1 while (i &lt; len(password)) append(enc(password[i], time[j])) i++ j-- if (j &lt; 0) j = len(time) - 1 是一个循环加密过程： 如果明文长度小于等于密钥长度，则没有完整循环； 如果明文长度大于密钥长度，则密钥会被循环。 当然设计这个东西的人还是挺聪明的，选择了利用时间来产生密钥的方法（而不是静态密钥），而且考虑到减轻双方的验证负担和实际的验证频率，单位选择了分钟。 你有可能会问：既然密钥是基于时间的，那么如果在时间上出了差错导致解密失败，如何解决呢？ 我已经通过几次试验摸清了过程，不过继续下去就真侵犯了对方的权益了，所以我在这里不公开那些内容。 我当时看到了 AL 和 CL 在代码中的赋值（尤其是用作两个临时变量，而且出现在循环中），第一感觉就是：循环加密！这和我以前看的 Enigma 的工作原理有点像，所以脑海里冒出了这种可能性。（不过 Enigma 的密码轮转起来，那个“循环”可就不是这里的静态循环了。） 附上我的逆向记录的一部分（已经修正），读汇编反求的： // 加密函数的调用位于00405241H，函数地址位于00401340H // EDX: 密钥A，内容为当前的时间戳（单位：分钟，取整数），可以推断得到，也可以参照004051EAH的对 time() 的调用 // EAX: 密码（明文） // ECX: 指向一个64字节的缓冲区的指针 void encrypt(char *text, char *time, char *buffer) { push(ecx); (local[0] = ecx;) push(ebp); (local[1] = ebp;) ebp = time; (ebp = arg2;) push(esi); (local[2] = esi;) push(edi); (local[3] = edi;) { edi = ebp (= time); ecx = 0xffffffff; (ecx |= 0xffffffff;) eax = 0; (eax ^= eax; 真实意图是让 al = 0，见 repne scas) repne; eax = text; (eax = arg1;) ecx = -ecx; } =&gt; { ecx = strlen(time) + 1; eax = text; } ecx -= 2; // cl 偏移指向最后一个有效字符（除了&#39;\\0&#39;外的字符） local[0] = ecx; esi = ecx; (esi = strlen(time) - 1;) cl = text[0]; // (byte tmp0 = text[0];) if (cl != &#39;\\0&#39;) { // if (tmp0 != &#39;\\0&#39;) edx = buffer; (edx = arg3;) push(ebx); (local[4] = ebx;) time = buffer; (arg2 = edx;) // i = esi = strlen(time) - 1 // tmp0 =&gt; al, tmp1 =&gt; cl while (cl != 0) { al = time[i]; (al = *(ebp + esi);) // esi &lt;=&gt; i in iteration edx = i; (edx = esi;) tmp0 = time[i] ^ cl; (al = al ^ cl;) tmp1 = tmp0; (cl = al;) tmp0 &amp;= 0x0f; (al &amp;= 0x0f;) tmp1 &gt;&gt;= 4; (cl &gt;&gt;= 4;) tmp1 &amp;= 0x0f; (cl &amp;= 0x0f;) tmp0 += 0x36; (al += 36H;) tmp1 += 0x63; (cl += 63H;) // tmpbool = edx &gt;= 0; { edx = edx &lt; 0 ? 0x80000001 : 1; (edx &amp;= 0x80000001;) if (edx &lt; 0) { { edx--; edx |= 0xfffffffe; edx++; } =&gt; { edx = -1; (结合上面的情况) // 错误 } } } =&gt; { // 错误 // edx = edx &gt;= 0 ? 1 : -1; // 应该正确理解 edx &amp;= 0x80000001 和 jns, dec, or, inc 这一段 // 其实是一个包含了负数情况在内的模2的过程，edx 保存了结果 edx = i % 2; (edx = edx % 2;) } bl = al; if (i % 2 == 0) { (if (edx == 0)) bl = cl; } edi = time; (= buffer) *edi = bl; edi++; if (i % 2 != 0) { (if edx != 0) tmp0 = tmp1; (al = cl;) } *edi = tmp0; (*edi = al;) edi++; i--; (esi--;) time = time + 2; (arg2 = edi;) if (i &lt; 0) { i = local[0]; (esi = local[0];) // 此时 local[0] 保存着原始的 time 字符串的长度 } { eax = text; (eax = arg1;) eax++; text = eax; } =&gt; { text++; } tmp1 = *text; (cl = *text;) } pop(ebx); } pop(edi); pop(esi); pop(ebp); pop(ecx); } 最后是加密函数的 C# 版本，已经通过了验证： static string Encrypt(string text, string key) { var sb = new StringBuilder(text.Length * 2); var len = key.Length; byte tmp0, tmp1; byte bl; int i = key.Length - 1, j = 0; // al -&gt; key, cl -&gt; text // tmp0 -&gt; al, tmp1 -&gt; cl while (true) { tmp0 = (byte)(key[i] ^ text[j]); tmp1 = tmp0; tmp0 = (byte)(tmp0 &amp; 0x0f); tmp1 = (byte)(tmp1 &gt;&gt; 4); tmp0 += 0x36; tmp1 += 0x63; bl = (i % 2 == 0 ? tmp1 : tmp0); sb.Append((char)bl); if (i % 2 != 0) { tmp0 = tmp1; } sb.Append((char)tmp0); i--; j++; if (j &gt; text.Length - 1) { break; } if (i &lt; 0) { i = key.Length - 1; } } return sb.ToString(); } 随意写的，没有防御性代码，而且从中还可以看出汇编的痕迹。 写了这篇文章，算是不辜负我昨晚八点到凌晨两点的努力吧。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"}]},{"title":"GitHub 似乎遭到攻击","slug":"zh/2015-08-21-Seems-GitHub-Is-Under-Attack","date":"2015-08-20T16:15:00.000Z","updated":"2020-03-30T22:34:35.411Z","comments":true,"path":"categories/Misc/zh/2015-08-21-Seems-GitHub-Is-Under-Attack/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-08-21-Seems-GitHub-Is-Under-Attack/","excerpt":"","text":"写着代码准备push，结果 PhpStorm 提示 SSH 错误。连续两次都这样。测试访问 GitHub，发现被写入了重定向。 直接访问 https://github.com/ 或者 http://github.com/。前者会提示证书失效（说明此时实际访问的服务器443端口居然正常开着）。响应如下： HTTP/1.1 200 OK Server: nginx Date: Thu, 20 Aug 2015 15:16:48 GMT Content-Type: text/html Content-Length: 79 Connection: keep-alive location=&#39;http://www.cjb.net/&#39;//&lt;script&gt;location=&#39;http://www.cjb.net/&#39;&lt;/script&gt; 很明显，不知是哪位没写好，显示内容明显位置不对，单行注释（//）也没有起到正常人要它发挥的作用。不过 &lt;script&gt; 标签被浏览器解析了，执行了跳转。 我修改过 DNS，问题依旧。所以可能是 GitHub 页面被置换，或者流量劫持。不过在美国的同学没报告什么，不知道什么情况。 跳转之后的响应头： HTTP/1.1 200 OK Date: Thu, 20 Aug 2015 15:14:33 GMT Content-Type: text/html Transfer-Encoding: chunked Connection: keep-alive x-amz-id-2: RsiH1w5SMbQ3LTBWlw1B+hSivd/m66W339sRTZmFBUgUhdVfDTOXInhPE9A7bs7h3Ah43o0orbI= x-amz-request-id: EBB975B3EC0DA048 Last-Modified: Mon, 11 May 2015 15:30:05 GMT ETag: W/&quot;856a520eb3d273395421f632f23914b6&quot; CF-Cache-Status: HIT Vary: Accept-Encoding Expires: Thu, 20 Aug 2015 16:14:33 GMT Cache-Control: public, max-age=3600 Server: cloudflare-nginx CF-RAY: 218f0c6c382d0296-SJC Content-Encoding: gzip 算了，GitHub 暂时用不了，本地留着各个commit好了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"饿了么App的一个小问题","slug":"zh/2015-08-19-Eleme-App-Flaws","date":"2015-08-19T10:24:00.000Z","updated":"2020-03-30T22:34:35.410Z","comments":true,"path":"categories/Misc/zh/2015-08-19-Eleme-App-Flaws/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-08-19-Eleme-App-Flaws/","excerpt":"","text":"刚才饿了么出现了一个不好的用例。 重现方法如下： 打开手机，关闭 WLAN 和定位，打开移动数据，登录饿了么； 进入主页后，应该要出现“定位失败”的信息（前提是你没有设置“登录后自动定位到某个点”）； 打开交易完成的饿单，点击“再来一份”，点击“提交饿单”； 然后你就可以看到一个各个界面元素内容都为空的饿单提交界面。 这里要表扬饿了么，因为他们采取了防御性的加载策略，不管什么时候界面都要先初始化，再根据数据加载。 但是在定位失败的情况下，却出现了空界面，这是不合逻辑的。解决方法有两种： 在定位失败的时候，提交饿单提示需要先定位； 能正常提交，但是要求用户选择送达地址，如果没有则必须新建。 我个人倾向于第二种。有待优化。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"建立一个小网站时候的问题与(部分)解决","slug":"zh/2015-08-17-Little-Problems","date":"2015-08-17T16:05:00.000Z","updated":"2020-03-30T22:34:35.410Z","comments":true,"path":"categories/Tech/zh/2015-08-17-Little-Problems/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-08-17-Little-Problems/","excerpt":"","text":"舍友（下一届辅导员）委托做一个新生在线登记、统计的东西，结合智能手机普及的情况，建议是用网页的形式，微信扫一扫嘛。我选了阿里云的服务器，租用一个月（因为只需要一个月），其环境只有 Linux（PHP+MySQL）。昨天完成了一部分功能，放到阿里云上。现在记录几个坑。 诡异的 FTP 连接 我之前申请过一个 Windows Server 版的服务器，FTP 传输的时候选择的是被动模式（passive mode），其他的默认了。所以这次也选用了被动模式，结果在 PhpStorm 里直接 deploy 大多数时间连接超时，即使连接上去，有幸执行了 LIST，也无法传输文件。后来改动设置，取消被动，设置/取消兼容（compatible mode，PhpStorm 的设置），问题依旧。于是找了 FileZilla，结果非常顺利地就连接、传输了。（只不过由于 phpMyAdmin 的文件较多，即使限制并发数为1阿里云那边也经常报错说该地址使用的连接数太多。） 服务器上的 PHP 版本不够高 本来一般的做法应该是 SSH 过去，远程命令行操作 MySQL 的。结果 SSH 连接不上，我之前也没配置过 Linux 版的阿里云服务器。干脆，FTP 放了个 phpMyAdmin 过去。我当然是选择最新版（4.4.13.1）啦。但是在配置好，打开的一刹那，显示的居然是： PHP 5.3+ is required. 你是在逗我吗……只好找了一个支持 PHP 5.2 的4.0.10.10版本。 不统一的字符编码 有一个页面是 JavaScript 发起 AJAX 请求，一个 PHP 文件处理数据并返回 JSON。但是在测试的时候，“姓名”信息根本就显示不出来。设了几个 console.log()，看了一下返回值，该字段居然是 null。但是奇怪的是，其他的字段都正常；表头也是 PHP 返回的，正确地编码了。 {&quot;newest&quot;:[[&quot;\\u5b66\\u53f7&quot;,&quot;\\u59d3\\u540d&quot;,&quot;\\u73ed\\u7ea7&quot;,&quot;\\u767b\\u8bb0\\u65f6\\u95f4&quot;],[{&quot;sno&quot;:&quot;15071001&quot;,&quot;sname&quot;:null,&quot;classno&quot;:&quot;150712&quot;,&quot;submittime&quot;:&quot;2015-08-17 21:26:13&quot;}]],&quot;regcount&quot;:{&quot;new&quot;:&quot;1&quot;,&quot;rec&quot;:&quot;2&quot;}} 我想了想，名字字段和其他东西有什么不同呢？ 它是从数据库返回的。 含有中文（超出 ASCII 字符集的部分）。 从第2条大致就可以确定是一个编码的问题了。但是是什么不对呢？在我本机的测试上，是能正常工作的。我看了一下我建表的语句（注意用了 MySQL 的方言）： CREATE TABLE t (x INTEGER PRIMARY KEY) CHARACTER SET = &#39;GBK&#39;; 为了让中文统计符合通常的“1中文占用2字节”思想，我选用了 GBK 字符集。PHP 的字符串本质上是字节数组，所以可以确定从 MySQL 读取的时候编码是 GBK，就那么直接放过来了。 再看第1条。我的其他页面（直接写的 PHP 文件，字符串硬编码）显示正常。看看保存用的字符集，UTF-8 without BOM。由于表头也是 PHP 里写死的，然后直接去 json_encode() 了，这些能正常工作，所以大致就可以确定是 json_encode() 需要 UTF-8 而某些字符串不是的缘故了。 立即写了一个hack，iconv() 了一下，果然解决了问题。 {&quot;newest&quot;:[[&quot;\\u5b66\\u53f7&quot;,&quot;\\u59d3\\u540d&quot;,&quot;\\u73ed\\u7ea7&quot;,&quot;\\u767b\\u8bb0\\u65f6\\u95f4&quot;],[{&quot;sno&quot;:&quot;15071001&quot;,&quot;sname&quot;:&quot;\\u5f20\\u4e09(\\u540d\\u5b57\\u4fee\\u6539\\u540e)&quot;,&quot;classno&quot;:&quot;150712&quot;,&quot;submittime&quot;:&quot;2015-08-17 21:26:13&quot;}]],&quot;regcount&quot;:{&quot;new&quot;:&quot;1&quot;,&quot;rec&quot;:&quot;2&quot;}} 既然知道这么麻烦，每次都要转换编码，为什么不将表的编码改为 UTF-8 呢？ 于是上了： CREATE TABLE t (x INTEGER PRIMARY KEY) CHARACTER SET = &#39;UTF-8&#39;; 啊，报错了。略略嘲笑一下阿里云，居然不给我用 UTF-8 编码的表。 后来我查了一下，json_encode() 的文档中写明了，其函数定义如下： string json_encode ( mixed $value [, int $options = 0 [, int $depth = 512 ]] ) 其中 value 参数的说明有一条： All string data must be UTF-8 encoded. MySQL 建立 UTF-8 的表应该这么写： CREATE TABLE t (x INTEGER PRIMARY KEY) CHARACTER SET = &#39;UTF8&#39;; 对，就是少一个连字符。 编码的事情还有后续。我更改了建表的语句，取消了那个hack，但是显示又不正常了。 在纳闷的时候，找到了这篇文章。于是我知道了，原来 MySQL 有多个部分的编码设置。好，我就看我这里的设置是什么样的。 运行 show variables;，结果的编码部分如下： character_set_client utf8 character_set_connection utf8 character_set_database gbk character_set_filesystem binary character_set_results utf8 character_set_server gbk character_set_system utf8 character_sets_dir /usr/local/mysql/share/mysql/charsets/ collation_connection utf8_general_ci collation_database gbk_chinese_ci collation_server gbk_chinese_ci 看起来很正常，阿里云拒绝我用 SET character_set_database utf8; 这类语句修改变量。但是在关闭了那个hack的时候，显示又不对了，JSON 编码失败。 没办法，暂时先用着这个hack吧。将问题记录在这里。 后来发现，PHP 版本是可以从主机控制台调的。不过我没有去要那个密码（因为不怎么需要），5.2也可以用。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"好人好事","slug":"zh/2015-08-14-When-Picking-Up-Luggage","date":"2015-08-13T16:55:00.000Z","updated":"2020-03-30T22:34:35.408Z","comments":true,"path":"categories/Misc/zh/2015-08-14-When-Picking-Up-Luggage/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-08-14-When-Picking-Up-Luggage/","excerpt":"","text":"上午经历了一系列事件，最后我人坐飞机过来，行李则交给了某个公司和其他货物一起托运。 今天从百度大厦出来，晚上七点二十左右。（这么看，大约面了50分钟。）按照计划，现在就应该去取行李了。 在此之前，我打电话问过托运的公司，对方说收货的地址在T1航站楼的西北边，中航国际货运航空所在的地方。（这个号码总是占线，要打通得看运气。此外，之前广州那人发的号码是国际货物的，根本就不是在同一个地方。总之获得这个信息也是费了很多劲。） 正好路边来了一辆出租车，我就敲窗户问：“师傅，载客吗？”师傅：“载客。”我上车，说我要到T1航站楼。一路上我们都没说什么。进入机场高速的时候，我跟师傅说：“我要去的地方，离T1航站楼有点距离，是货运北路。”然后我大致讲了一下为什么要去那里拿行李。师傅说：“没问题。” 到了T1航站楼的入口，师傅反应过来：“是要再往前开一点对吧！”过了一些，到了三岔路口：“看，这里就是货运北路，没错吧？”拐了进去，师傅也不是很熟，放慢了车速问：“你要去的地方是在这里的哪个地方？”我也不好描述，反正已经走到路上了，就说（对着地图）：“先拐过两个九十度的弯……”司机很爽朗地说：“好！” 进入货运北路不久，师傅就发现了，说：“你看，这些车都集中在前面（接近航站楼的一边），往前走的话就没什么车了。这样吧，你要取东西应该不用多久，我在这里等你。而且这地方没有车，我走了你就不好打车了。”“好吧，那多谢师傅了。” 拐过第一个这个弯的时候，司机就和讲评书一样：“第一个九十度的弯！”到了下一个T字路口，司机说：“你看，没错，刚才那是第一个九十度的弯，这里拐过第二个九十度的弯。看来地图没错。”在拐过了两个弯之后，我说：“他们说就在中航国际货运航空这里……哦这里是第五滑行桥，他们说过过了这个桥，第一个右拐的地方就是。”师傅：“别急别急，我们找一下哪里进去。” 拐进去之后，由于没有明确的标识，也不知道公司在哪里（我以为会有独立的窗口之类的），准备过保安岗的时候师傅说：“我们问一问吧！”刚好岗里没人，保安似乎已经擦身而过买灌饼了。“我们掉头往回走一点仔细看清楚吧。”他说。停下来之后我对比高德导航和百度地图的显示（师傅也在看着），认为进入了正确的位置。这时候师傅做了一个惊人的举动。“那个公司叫什么？”我拿出手机打开收到的短信。师傅：“这样，我去问一下人看他们知不知道。”于是拿着手机，熄火，亲自下车，跑过马路（虽然路不宽）去问了那个保安。我在车里系着安全带看着，看到他们说着话，也在屏幕上确认着什么东西——师傅是真心要帮我找到这个公司所在的地方。随后他一溜小跑地回到车里，说：“哎呀，那个保安说他也没听说过这个公司，他来这里都好几年了。哎呀，反正都知道名字了，导航导过去！”于是他打开高德导航，照着我屏幕上显示的（百度地图显示的“中航国际货运航空”），还是一笔一划地手写输入，看到结果之后指着第一个（顺义区，货运北路）说：“是这个，没错吧？看清楚一些，是这个不？”我确认了。导航显示，“距离目的地700米”。 快到的时候，我再拼命打给的正确的电话。奇迹般地通了。我问：“我现在已经到了中航国际货运航空这里，请问你们取货的地方在哪里？”“办理大厅这里，进来右手边就是。”“是‘RGE办理大厅’吗？”“啊？”“……”“你看到‘BGE办理大厅’没有？”“看到了。”“对，就是那里。”“哦，谢谢！” 停车之后我将包留在车里（刚才人家都亲自出去问路了，我也应该相信他），赶忙去办手续：签单、缴费、拿着完备的单去取行李。结果取货的地方已经站了一圈人，他们都是等待取货的。原来，这里的保安因为管理者还没来，拒绝放货。我先将凭据给保安（排在取货队列里），然后到出租车那里告诉师傅这事。“师傅啊，估计要取到会挺久的，要不我就付钱，您别等了。”他看了看门口聚集的一群人。“是那边对吧。这样，你估计要多久？”“我也不知道会多久，现在还没放呢。”师傅看了看表。“现在是八点半（实际为20:35）。我估计一小时（那边）应该可以（发完货）了吧！我没什么关系，等还是不等就随你咯。我先等一小会儿。”“不耽误您吧？”“没事儿！没耽误的！”“那好吧……那就有劳您多等一下了。” 我回到那边。过了10分钟，管理者来了。再经过一轮又一轮的货物搬运与签收，快一小时了。我看着不时有新的单子加进来，还怀疑新单子会放到上面（工人读的也是从上面的开始），以至于我的单子“很不恰巧地”沉底了。后来确认了那只是我的乱想。我看着手机：现在已经二十三分（早就过九点）了，马上都要一小时了，本来师傅说的“等一小会儿”，再等到一小时那真的就对不住他了。遂准备一小时还没到的话就和司机讲明白，不耽误他的时间了。这时候，听到了报收货人的名字，像是我的名字的变调——或者是某种不强调声调的方言带来的口音。我应了一句，确认了那个货物（尽管包着绿色的编织袋）就是我的行李箱。签名，走人。 回到出租车那里，车外两人正在抽烟聊天。再定睛一看，师傅还坐在驾驶座上，车门半开。看到我提着东西，他把后尾箱打开，我将行李箱放进去，回到车里。师傅启动车子，一边开一边说：“刚才那个人要用车，我说‘我在等人’。他也是取了货，要去火车站。”我也不知道该怎么回应好，只能说：“实在是太感谢您了。”只能说这句话也太苍白了。开了一点距离，大约还是回到保安岗的位置，师傅问：“你抽烟吗？”“谢谢，我不抽。”“我抽一下你不介意吧？哎呀，就是那个瘾上来了。”“不介意不介意。”于是师傅放下车窗。吸完了之后，师傅说：“我把空调打开吧，我看你也热了，这天气闷热的。”“谢谢，谢谢。”“这天气，水汽一上来，眼皮叭叭叭地就要往下掉，睁不开了。”只有他说这句话的时候，我才唯一一次扭头看了看他。他手指放松地指着眼睛，眼睛随着“叭叭叭”而眨动，不过视线倒是一直朝着正前方的。这位师傅微胖，很短的头发，散发着一点那种挂金链子的大汉的凶猛之气。“上了机场高速之后，30分钟，就到家啦！”语气中透露出欢快。（我说过回程回到北航。） 从顺义回到海淀，一路上从五环到四环到三环，反正今天这么一折腾，我也一直没法睡觉，眼皮也有点打架了。清醒的时候，是师傅问了一句：“到北航的哪个门啊？”此时已经过了盘古大厦，我知道已经快到了。“东门或者南门，哪个快就走哪个吧。”“前面就到学院桥，下来就是北航东门。”“好的好的。” 下车的时候，师傅还主动出来（因为我要解安全带然后背上包）帮我提出了行李。 师傅一路上爆京腔粗口抱怨前面的车。嘛，核心见前面就好。我看核心。 这位好师傅的资格证号是303120。 开始放货的时候，“来来来，出货了”的喊声就如欢呼一般。 我也见识到了，那些明明标着“请勿重压”的牛皮纸箱子——看着上面的文本里面装的应该是手机——却被两层沉重的同类踩在脚下。 和航空业的搬运一样，这里并不在乎细节。别说，堂堂一个北京的散装货物分拣中心，连 AGV 都没有呢，只有3个工人负责出货物（包括读单、找货、装车、运输；另外有3个保安、1个管理人员和一个不知道角色的人）。 英语翻译课堂时间！今天见到的的绝佳翻译选（大雾 第1滑行桥 - Huaxing Bridge 1 (Taxing Bridge 1) 一车一杆 - A car for a rod (Only one car is permitted to drive through during each raise of the rod)","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"论 Colorful Cure 的渣程度","slug":"zh/2015-08-12-Hero-in-Colorful-Cure","date":"2015-08-12T15:44:00.000Z","updated":"2020-03-30T22:34:35.408Z","comments":true,"path":"categories/ACGN/zh/2015-08-12-Hero-in-Colorful-Cure/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-08-12-Hero-in-Colorful-Cure/","excerpt":"","text":"Colorful Cure 的扯淡简直了。“天生圣人体质”是个什么鬼！然后我去，各种倒贴！四条线里最好的是红色线（幼驯染线），其他的也是莫名其妙。幼驯染线好的一点是，此人为贫乳。啊不对不对，此人的展开是最正常的（蓝色线也正常，但是RL过大不可饶恕）。改良的 KiriKiri 2/KAG3 倒是可以。但是不要硬要做成带着 RPG 的感觉啊，这是 AVG，我的兴趣不是在打怪或者模拟打怪的场景上。 同样无厘头的是 Strawberry Nauts 的正式开场。哇，每个人的好感度居然开始游戏的时候就满了诶！而且是从零莫名其妙就满了诶！我想玩中间消失的这一年啊！这里还有其他人的评论。 Lovely Quest 的，除了神助攻之外就没什么好说的了。虽然主角仍然是一个标准的万人迷（从綾花的“要不是你，我就……”可以看出），但是每个人都是没有经验的，是在 Lovely Smile 活动中慢慢加深理解（和理♂解）的，所以说得通。 好一些的是恋と選挙とチョコレート，千里（「ちさと」，不是通常的「せんり」）的好感度是显而易见的（后期揭示没这么简单），美冬、衣更的也可以解释。其他人的好感在主线（第一次的千里线）中并没有表现出来，所以我不清楚。有人说“人设很漂亮，剧情很糟糕”，我觉得后一个评价（如果不是另外的层面，例如胧的两个场景）低了。这让我想起了我在做的事情，从缘起到执行。但是！要所有的角色曲就要买齐所有的初回版（5个）！而且这个基于 Macromedia 公司的某软件的引擎好难解…… PS. 攻略了千里线，之后想攻略美冬线（为什么？因为她“是大一岁的姐姐啊”），之后就没兴趣了，估计。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"调戏小冰","slug":"zh/2015-08-07-Playing-with-Bing-the-Reply-Bot","date":"2015-08-07T02:20:00.000Z","updated":"2020-03-30T22:34:35.407Z","comments":true,"path":"categories/Misc/zh/2015-08-07-Playing-with-Bing-the-Reply-Bot/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-08-07-Playing-with-Bing-the-Reply-Bot/","excerpt":"微软小冰设定上似乎是个傲娇。傲娇气质无处不在……（你也可以直接问：“你是傲娇吗？”会得到不同回答。） 发图不说话。","text":"微软小冰设定上似乎是个傲娇。傲娇气质无处不在……（你也可以直接问：“你是傲娇吗？”会得到不同回答。） 发图不说话。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"火车站见闻","slug":"zh/2015-08-03-That-Happened-in-Railway-Station","date":"2015-08-03T15:33:00.000Z","updated":"2020-03-30T22:34:35.407Z","comments":true,"path":"categories/Misc/zh/2015-08-03-That-Happened-in-Railway-Station/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-08-03-That-Happened-in-Railway-Station/","excerpt":"","text":"返程前往广州。由于我购买的是学生票，所以在检票之前换实体票，不能直接刷身份证。再加上我的懒惰（一晚上刷实习日记到九点，一个小时匆匆收拾东西，赶十二点的火车），在时间上就不允许我到清华园换票（来回有40分钟）再前往火车站了。结论：到火车站售票处换票。 在排了长长的队之后（后来看了一下，也差不多40分钟），下一个就到我了。前一位正在等待出票呢，就听到队伍后面传来的声音：“能不能帮我孩子买一下票，马上要来不及了！”这位仁兄在问了队中的一个人后，发现了队头，也就是我这里。 他从右边的通道并过来（右边的窗口处于午餐时间，所以没人排队），问我：“能不能帮我孩子买一下票？快来不及了，我孩子的话就在那边看行李。”这位仁兄相貌奇特，瘦削的脸，突出的眼睛，粗眉毛，脸的布局比起常见的方形、椭圆形布局来说更接近六边形布局。不过这样长相的人我也见过。当然，按照常理来讲，插队是不对的。因此我也犹豫了：“这个……领票是要本人来的。” 他看出了我的犹豫，说：“要本人的话，我孩子就在那边看包，马上就可以过来。”这时候前面那位已经买完票了，我准备到窗口前。他说：“这样吧，你先试试，如果要本人领取，我就叫他过来。”我想了想，同意了。为什么会同意呢？可能是因为他递过来的是一张临时身份证（不能像二代证那样直接刷卡进站）。 我取了自己的票之后，将临时证给窗口：“请问能帮取一下吗……”窗口的工作人员肯定能听见刚才的对话。“订单号。”有点不耐烦的一句。“什么？”那位父亲没听清。“订单号。”重复了一次。我小声说：“订单号，手机短信里那个。”“哦哦哦，我找一下，等一下。”他掏出了手机，打开短信信箱，明显有点慌乱，手臂微微抖动，手腕在用最大允许速度摆动，手指划过一次又一次，应该是在浩如烟海的短信记录中找到珍贵的12306确认短信。最终他找到了，大声念给工作人员。输入完毕之后，机器吐出了票。于是一张实体票和临时证滑了过来。我将票和证递给那位父亲，他赶忙说：“谢谢，谢谢……” 所有事都办完了，离开队伍。很高兴的是，刚才整个过程中，我没有听到后面的人催促。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"写在临走之时","slug":"zh/2015-07-30-Misc","date":"2015-07-30T10:10:00.000Z","updated":"2020-03-30T22:34:35.407Z","comments":true,"path":"categories/Misc/zh/2015-07-30-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-07-30-Misc/","excerpt":"","text":"在哈尔滨的实习地点，XX功的东西猖獗。证据就是这里的许多纸币居然都印着XX功的宣传语！ 我略微估计了一下，在这些天收到的一元中，大约1/15印有宣传语。而且，对比了一下发现，色泽并不对，很可能是假币。但是即使如此，这里的人好像也没注意这个现象，这些纸币照样在这里流通。 说到这里就想吐槽那个某次的美国十佳社团。宣传语写得实在是让人无力吐槽：一元上写的多是“天灭XX，‘三退’保平安”、“XX活摘器官”这种话语，还有一些语焉不详莫明其妙让人退；只有在我收到的唯一一张非一元（是十元）的纸币上写的是XX功可以“袪病健身”这样的虚假的正能量。 先不说其性质恶劣，这本身就是十分失败的宣传！XX功是通过控制人心中的恐惧来吸引成员的，而被恐惧控制的人一定会做出反理性甚至反人类的行为——人在害怕的时候无法识别失误是有利还是有害，会被引导至刺激（无论正反）最小的路径；别有用心设计的路可能就是歧途。 真正的宗教，是使人在尊重他人的前提下保存自己的，吸引人的一般是正面事项——人对和谐未来的希望。（嗯，72 处这种是放纵，是硬加上了资源无限性假设的。）因为宗教更像一种行为规范，出发点是在理性人清楚种内争斗会导致灭亡，而我们人却不像动物那样一对一，而是多对多；勉强剩下的不多。为了避免这样的情况我们才发明了政治和宗教。——您希望的话，也可以称后者为“发现”而非“发明”。 就这两周，几个地方的人问过我“你们从哪来”、“什么时候走”、“将来会不会来工作”等等问题：杂货店（仓买）、放心早餐点、洗浴中心、土豆丝卷饼车。在问的时候，你能听到他们是真的把你当人看——不是冷漠、不是例行、不是看新奇、不是想知道问题的答案，就是“我们在交流”这一点。 这里人“朝八晚五”描述比较准确。也是，五点钟下班，我们住的地方就在旁边，这让我们每天下午五点到晚上有着大量的空余时间。除了工厂里的师傅，附近许多人也只是在这个区域内工作，所以下午六七点就可以看到人在吃烤串喝啤酒去泡澡，晚上九点左右商店就关门，人也少了。生活节奏慢得多。 多虑了吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"呵呵","slug":"zh/2015-07-25-Hehe","date":"2015-07-25T14:10:00.000Z","updated":"2020-03-30T22:34:35.407Z","comments":true,"path":"categories/Misc/zh/2015-07-25-Hehe/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-07-25-Hehe/","excerpt":"","text":"被马迭尔冰糕坑了，个人觉得。就在马迭尔旅馆门前买的；大概十来个同学一起跳坑里了。普通的牛奶雪糕嘛。 格瓦斯还是有不同的，小麦味比平常买到的秋林格瓦斯要浓重一些。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"苍蝇记","slug":"zh/2015-07-24-Flies","date":"2015-07-24T04:29:00.000Z","updated":"2015-07-29T13:15:00.000Z","comments":true,"path":"categories/Misc/Fun/zh/2015-07-24-Flies/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Fun/zh/2015-07-24-Flies/","excerpt":"","text":"实习的时候，我这个宿舍是和人调过的，位于一楼，门正对着五谷轮回之所。 刚住进来的那一天（7月19日），晚上去了一下小保健，回来的时候神清气爽，房间里没有空调也就躺床上睡了。这时房间里还是很平静的，正符合一个爱好整洁的人的房间。 “小保健”：员工单身宿舍没有浴室，要洗澡要到街对面的洗浴中心。我以前在《洗“枣”记》中讲过，要是没洗澡我真是浑身难受。我们也知道，一般不正规的洗浴中心会提供大保健服务。为了声明我的目的正常，特此创造一个词。不就是洗澡嘛。 在第二天，不知是因为什么，房间里出现了苍蝇。我想可能是我们这里优质的住宿环境，让不堪五谷轮回之所的两只敢于吃螃蟹的苍蝇开始了它们的冒险吧。宗心非常暴躁，看到苍蝇在房间里表演花式飞行就大叫：“呀，苍蝇！”（“呀！土豆”）而且他十分急切地要将这些非法入侵者赶出房间。苍蝇嘛，豆丁大小，在没有纱网啊粘虫胶啊杀虫剂啊这些反昆虫非常规武器不扩散条约的武器的帮助下，想把它们赶出房间？呵呵。 第三天，两只苍蝇似乎造蝇完成了（假如真的那么快），苍蝇数增加到了三只。反正如果不是亲属，那么也应该是收到了传单的吧。宗同学愈加暴躁，已经常常从口中迸出“去死”的诅咒。 第四天，也就是前天，早上，为了让三只苍蝇别在耳边嗡嗡嗡，我们长时间打开房门，想让它们离开宝地。没想到，可能是外面（走廊）凉里面暖和，这三位住客飞到门口还会折回来。更糟糕的是，一大波苍蝇正在，不，是已经接近。到了中午，斐波那契就要哭了，苍蝇数量增加到八九只。于是乎，到一个地方挥挥手，赶不走一只苍蝇。它们深得毛主席的战略精髓，敌进我退，敌退我追，敌闲(?)我扰，敌疲我打。看着扎堆的地方跺跺脚，惊起一群蝇物；空中盘旋一阵，又找到新的根据地驻扎了。晚上我因为没洗澡还睡在椅子上，但是一夜都没睡好。那嗡嗡声，简直就和引擎的试车一样，在你耳边留下余韵；又或者，六只纤细的长腿在你的皮肤上跳着舞，顺便来一只探头似的吻部探测表面粗糙度。 我倒是没发现这些苍蝇有多么爱香或者臭的地方，或许是因为房间里没有特别的味道，或者是因为整个房间味道都大（拜对面所赐？），虽然我闻不出。它们只是在各个表面上乱爬，想要跨过沟壑就用上背后的翅膀。 现在房间里少说也有十五六只苍蝇，简直是苍蝇窝。虽然空间还是足够人活动——但是若有一个指标，蝇积比（flies per volume，FPV），那么我们绝对比其他房间高得多，这或许可以拿出去炫耀也说不定。至少我在走廊上看了一圈，有的房间即使房门大开也没有黑色的飞行物。所以我几乎可以认为我们这是污秽之气满而溢所致。 我知道一个故事，一位法师，因为盖好的房子里遍布蚂蚁，而他不愿意杀生，因而对蚂蚁说：“蚂蚁菩萨，我即将入住，不愿戕害你们的生命，请各位另寻好去处。”一段时间之后蚂蚁就真的不在了。所以我也曾经开着门，对着屋里的一群苍蝇说：“苍蝇苍蝇，希望你们能从此门飞出，到你们更容易寻找食物的地方去。”可是好像确实有那么一两只苍蝇为我所动，其余还是在营寨里稳站如泰山。是我的佛性不够吗。 想到还有七天呢，在如此高 FPV 值的房间内生活，恐怕我就要受到很多打扰了。又杜甫曾为风损茅屋之事而作一诗篇，我也在此撰文，抒发烦闷之情吧。 7月29日补记： 25日的时候，整个队伍去中央大街，然后去东北革命烈士纪念馆参观。回来后聚餐。这个晚上我尝试了浇水法洗澡，毕竟去一次小保健要18元呢，因为店家防御性地假设（defensively assumes）顾客要泡澡，虽然我这种南方人就没有泡澡的习惯，洗澡就了事。也许是因为在走廊上吹风了，第二天头疼发热在床上躺了一天。 奇迹般地，周一的时候没再看到群蝇飞舞的场景了。（同时，头也居然什么事都没有了。）现在房间里好像就一只。 今天下午在窗外同学的提醒下发现纱窗破了一个大洞（被窗帘挡住了）。这解释了为什么我能在黑夜中看到扑向我发光屏幕的飞蛾。也不知道是谁采取了什么措施，或者是苍蝇有知从那儿飞向了更广阔的天空，总之现在我舒坦多了。 明天是一整天的讲座，各种加工啊信息建设啊的报告。想着我这两周的实习日记其实还处于欠着的状态（没写到纸上），写上那可是不少于5000字（(8+1)*(600+)），在离开之前写完这真的可能吗？","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Fun","slug":"Misc/Fun","permalink":"https://blog.mottomo.moe/categories/Misc/Fun/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"小品","slug":"小品","permalink":"https://blog.mottomo.moe/tags/%E5%B0%8F%E5%93%81/"}]},{"title":"破解入门：解除 Strawberry Feels 的光盘加载依赖","slug":"zh/2015-07-19-Crack-Strawberry-Feels-for-NoDVD","date":"2015-07-18T16:22:00.000Z","updated":"2020-03-30T22:34:35.406Z","comments":true,"path":"categories/Tech/RE/zh/2015-07-19-Crack-Strawberry-Feels-for-NoDVD/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/RE/zh/2015-07-19-Crack-Strawberry-Feels-for-NoDVD/","excerpt":"记录一次用 Olly Debug 解除 Strawberry Feels 的光盘加载检测（即制作 NoDVD 破解）的过程。 提示：养成良好习惯，做破解前先备份原始文件！","text":"记录一次用 Olly Debug 解除 Strawberry Feels 的光盘加载检测（即制作 NoDVD 破解）的过程。 提示：养成良好习惯，做破解前先备份原始文件！ 1、引言在搜索“片雾烈火”（源头忘记是哪里了，这是推荐项）的简历的时候，发现她除了负责过 Strawberry Nauts 的插入曲（实际上就是 ED 啦），还负责过一个名为 Strawberry Feels 的 gal game 的 OP。看简介，SF 也是一个纯爱系作品。不过这个在国内太小众，连百度的自动搜索推荐都只有 SN，而且搜索结果第一页中居然没有多个下载地址或者评测什么的。看来我大 HOOKSOFT 简直登上了纯爱白糖系的顶峰啊。我准备不下载的时候，橙光上的一个帖子宣称： 这游戏的立绘真是不咋地…… 不过亮点是超清BG，基本每张BG都有1280×720和2560×1440两个分辨率的版本。 另外还包含少量看着还不错的战斗效果图。 嗯，看来挺有意思的。冲着超清 BG，看一看。旅程就这么开始了。 2、获取 Strawberry Feels前面说过，这游戏比较小众，所以找到一个下载源还是不是一下就行的。百度搜索的结果中，最正常的就是贴吧里的资源贴了——不过早就失效了。 OK，我们换一个思路。请问哪里还有比较靠谱的发布站？除了各 PT 站，最好的恐怕就是苍雪（绯月）和 2DJ 了吧。由于我并不是 KFB 大富豪，就选择去 2DJ 碰运气。好了，关键点讲完了，这一步剩下的内容请同学们自己尝试一下，就当做一下锻炼吧。 什么，找不到？再给出一个提示：2DJ 的搜索功能其实并不能满足我们的需求（Discuz 自带的帖子搜索表现一向很糟糕）。再换一种思路，2DJ 的游戏发布有两个区，新作区和历史区，但是不管哪一个都是基本上按照时间排序的。同时，纯爱系的更容易受到关注，出现在新作区的概率也更大。已知 SF 的发行时间是2012年3月30日。 什么，还是找不到？好吧，这里是链接。页面中的磁力链接用115离线下载下来就行了。 好了，虽然那帖子标题是“初回限定版“、“NoDVD添加”，不过估计放到了“更多资源”里了。那可是会员的世界，我这个渣渣连注册都没办法（“請找認識的現任會員朋友在站務區置頂帖推薦”，我哪里认识谁啊），只下载了公开的磁力链接的内容。内容就是一个压缩包，初回特典都没有呢…… 2DJ 上的吐槽： 看到标题我还以为是Strawberry Nauts的FD兴奋了一下…… 我才不说我也是呢…… 3、运行测试下载安装，安装的时候不要用转区工具，直接安装。路径会出现乱码不要管，因为卸载的时候并不会通过转区工具运行。 安装完毕后我们来运行一下。 我怎么知道它在说什么！不过根据在 gal game 上积累的经验（咳咳），肯定是编码错误啦。 先下载 Locale Emulator。（在此澄清一下，在以前的博文中我曾经说那位是 LE 的作者，其实内核是 Amano 写的。）SF 好像不吃 AppLocale 的那一套，运行后只创建了进程，没有出现窗口。安装了 LE 后，用 LE 启动 StrawberyFeels.exe。 好的，能正常加载了，映入眼帘的是另一幅景象： （屏幕提示是“请将产品光盘放入光驱中”的意思。） 嗯，看来它有一个光盘插入验证。不觉得很麻烦吗，每次玩之前都要用虚拟光驱软件加载光盘。 终于进入正题了：我们要将光盘验证去掉。 4、调试分析在开始调试之前，请想清楚：如果你是程序设计者，你会用什么方式做光盘插入验证？要是我的话，肯定会对驱动器进行遍历，然后检查特定目录有没有特定的文件——这是最土、实现最简单的方法。（如果用其他的，例如调用底层函数直接读驱动器进行散列的话，就麻烦了。） 当然，已知以上思路的时候，就知道了关键函数：CreateFile()/CreateFileEx()；不过有时候直接使用 fopen() 的话，就得下到 NtCreateFile()、ZwCreateFile() 和 IoCreateFile() 了，以上的调用是在 CRT 内进行的，跟踪起来很困难。辅助函数自然是 GetDriveTypeA()/GetDriveTypeW()，要不你怎么知道用户将光盘放入了光盘驱动器中呢？检查函数调用，正常的话只有一个（安装目录已经有了资源的拷贝，为什么还要去读光驱），这就是要 crack 的地方。 我在操作的时候没想过要用上面的函数，而是从是验证哪个文件的存在入手的。因此，我在 Olly Debug 中使用 Search for/Binary string（Ctrl+B）功能找了几个我认为关键的文件，不过都没找到匹配的结果。（后来证明，文件名是从资源中读取，然后 sprintf() 上去的。） 我突然想到，在发现没有光驱的时候，会弹出一个消息框。于是，现在的焦点放在弹出消息框的函数上了。问题又来了：请问是哪一个呢？ MessageBoxA()； MessageBoxW()； MessageBoxExA()； MessageBoxExW()； MessageBoxIndirectA()； MessageBoxIndirectW()。 熟悉 Windows 编程的同学也知道，MessageBox()、MessageBoxEx() 和 MessageBoxIndirect() 是宏定义，在 UNICODE 这个宏定义了和没定义的时候分别被映射到 ANSI 和 UNICODE 的版本。 首先，5和6概率很小，显示一个简单的警告用不着自定义消息框吧。再结合之前提到的乱码问题，如果用了 UNICODE 的版本的话，字符串被处理之前都要转换成统一的 UNICODE 编码，是不会出现乱码的（见 KiriKiri 2/KAG3，内部使用的就是 UNICODE，不需要担心编码问题，不过文件编码是限定的）。考虑到程序员偷懒的天性，不用 MessageBoxEx() 的时候就不用（因为有附加参数啊），那么答案就是：显示消息框采用的很可能是 MessageBoxA()。 正是因为采用的都是 ANSI 版本的 API，所以字符串在解读时都会用本地字符集翻译——在日文平台上是 Shift-JIS，在中文平台上是 GBK。自然，二者在高码段不兼容，就会出现乱码了。所以我猜刚才看到的乱码大概是想说“本游戏不能在日本以外的国家启动”——可惜弄巧成拙，其他国家的用户一般也不用日文平台，看到的就会是乱码，永远都不会知道那是什么意思。 我们继续。打开名称表窗口（Search for/Names，Ctrl+N）。可以看到，果然导入的是 MessageBoxA()（类型为 Import）： 找到这一项了，就查找调用点（Find references，Ctrl+R）： 好了，这么多项，请问哪一个是我们需要的呢？ 不知道，只好一个一个试了。_(:з」∠)_ 值得注意的是，所有的调用都间接的，通过 apphelp.dll 的一个未公开的函数。看接受的参数，恐怕是 assert() 一类的，某个函数调用失败时能显示一个错误。 结果是，位于 00403AFD 的那一项是我们需要的。展开看看有什么： CPU Disasm Address Hex dump Command Comments 00403A5A C74424 10 000 MOV DWORD PTR SS:[ESP+10],0 00403A62 /&gt; 8B0D 3C824A00 /MOV ECX,DWORD PTR DS:[4A823C] ; ASCII &quot;a:\\&quot; 00403A68 |. 8A5C24 10 |MOV BL,BYTE PTR SS:[ESP+10] 00403A6C |. 8D9424 1C0300 |LEA EDX,[ESP+31C] 00403A73 |. 898C24 1C0300 |MOV DWORD PTR SS:[ESP+31C],ECX 00403A7A |. 80C3 61 |ADD BL,61 00403A7D |. 52 |PUSH EDX ; /RootPath 00403A7E |. 889C24 200300 |MOV BYTE PTR SS:[ESP+320],BL ; | 00403A85 |. FF15 E4014A00 |CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetDriveTypeA&gt;] ; \\KERNEL32.GetDriveTypeA 00403A8B |. 83F8 05 |CMP EAX,5 ; CONST 5 =&gt; DRIVE_CDROM 00403A8E |. 75 36 |JNE SHORT 00403AC6 00403A90 |. 6A 01 |PUSH 1 00403A92 |. FFD5 |CALL EBP 00403A94 |. 8BF8 |MOV EDI,EAX 00403A96 |. 8D4424 18 |LEA EAX,[ESP+18] 00403A9A |. 68 38824A00 |PUSH OFFSET 004A8238 ; /Arg2 = ASCII &quot;rb&quot; 00403A9F |. 50 |PUSH EAX ; |Arg1 00403AA0 |. 885C24 20 |MOV BYTE PTR SS:[ESP+20],BL ; | 00403AA4 |. E8 D00A0600 |CALL 00464579 ; \\StrawberryFeels.00464579 00403AA9 |. 8BF0 |MOV ESI,EAX 00403AAB |. 83C4 08 |ADD ESP,8 00403AAE |. 85F6 |TEST ESI,ESI 00403AB0 |. 74 09 |JE SHORT 00403ABB 00403AB2 |. 56 |PUSH ESI ; /Arg1 00403AB3 |. E8 DA080600 |CALL 00464392 ; \\StrawberryFeels.00464392 00403AB8 |. 83C4 04 |ADD ESP,4 00403ABB |&gt; 57 |PUSH EDI 00403ABC |. FFD5 |CALL EBP 00403ABE |. 85F6 |TEST ESI,ESI 00403AC0 |. 75 77 |JNE SHORT 00403B39 00403AC2 |. 8B7424 14 |MOV ESI,DWORD PTR SS:[ESP+14] 00403AC6 |&gt; 8B4424 10 |MOV EAX,DWORD PTR SS:[ESP+10] 00403ACA |. 40 |INC EAX 00403ACB |. 83F8 1A |CMP EAX,1A 00403ACE |. 894424 10 |MOV DWORD PTR SS:[ESP+10],EAX 00403AD2 |.^ 7C 8E \\JL SHORT 00403A62 00403AD4 |. E8 F7850400 CALL 0044C0D0 ; [StrawberryFeels.0044C0D0 00403AD9 |. E8 82C30400 CALL 0044FE60 ; [StrawberryFeels.0044FE60 00403ADE |. E8 ADBE0400 CALL 0044F990 00403AE3 |. 50 PUSH EAX ; /hWnd 00403AE4 |. FF15 64024A00 CALL DWORD PTR DS:[&lt;&amp;USER32.SetForegroundWindow&gt;] ; \\USER32.SetForegroundWindow 00403AEA |. 6A 05 PUSH 5 ; /Arg4 = 5 00403AEC |. E8 AFBE0400 CALL 0044F9A0 ; | 00403AF1 |. 50 PUSH EAX ; |Arg3 00403AF2 |. 68 0C824A00 PUSH OFFSET 004A820C ; |Arg2 = StrawberryFeels.4A820C 00403AF7 |. E8 94BE0400 CALL 0044F990 ; | 00403AFC |. 50 PUSH EAX ; |Arg1 00403AFD |. FF15 5C024A00 CALL DWORD PTR DS:[&lt;&amp;USER32.MessageBoxA&gt;] ; \\apphelp.732324A0 00403B03 |. 83F8 02 CMP EAX,2 00403B06 |.^ 0F85 CBFEFFFF JNE 004039D7 00403B0C |. 6A 00 PUSH 0 ; /Arg1 = 0 00403B0E |. E8 3D2F0200 CALL 00426A50 ; \\StrawberryFeels.00426A50 00403B13 |. 83C4 04 ADD ESP,4 00403B16 |. E8 D5360200 CALL 004271F0 ; [StrawberryFeels.004271F0 00403B1B |. E8 D0CE0000 CALL 004109F0 ; [StrawberryFeels.004109F0 00403B20 |. E8 9BA10200 CALL 0042DCC0 ; [StrawberryFeels.0042DCC0 00403B25 |. E8 26A80200 CALL 0042E350 ; [StrawberryFeels.0042E350 00403B2A |. 6A 00 PUSH 0 ; /ExitCode = 0 00403B2C |. FF15 F8024A00 CALL DWORD PTR DS:[&lt;&amp;USER32.PostQuitMessage&gt;] ; \\USER32.PostQuitMessage 00403B32 |. 6A 00 PUSH 0 00403B34 |. E8 CC160600 CALL 00465205 00403B39 |&gt; 6A 00 PUSH 0 ; /Arg1 = 0 00403B3B |. E8 102F0200 CALL 00426A50 ; \\StrawberryFeels.00426A50 00403B40 |&gt; 83C4 04 ADD ESP,4 00403B43 |. 5F POP EDI 00403B44 |. 5E POP ESI 00403B45 |. 5D POP EBP 00403B46 |. 5B POP EBX 00403B47 |. 81C4 10040000 ADD ESP,410 00403B4D \\. C3 RETN 在 Olly Debug 中，这一段是当前函数的第二部分，很明显是一个整体。之所以说它重要，是因为这里： 在 00403B2C 处，有一个对 PostQuitMessage() 的调用——这个调用说明要发送一个 WM_QUIT 消息，准备终止消息泵了。什么时候要终止消息泵呢？在无法在脚本中处理（意味着脚本引擎没有初始化）的时候，或者正常退出的时候。再看 00403A85，一个对 GetDriveTypeA() 的调用！00403A9A 的参数 &quot;rb&quot; 肯定是传递给 fopen() 或者类似物的，而且被硬编码了（一般就是这么写的嘛）。看来这里就是要找的了。 根据这个循环（00403A62 到 00403AD2）和接下来的函数，我们可以知道这里的逻辑：循环检测各个驱动器是否是光盘驱动器，然后检查是否有需要的文件；如果26个可能的位置都没有，那就说明没插入光盘，显示提示，用户选择“取消”的话就准备退出。 有兴趣的同学可以看看这往前一点点的内容，看看 sprintf() 的调用参数，就在不到20行之前。 于是我们现在要看看跳到哪里。这里写成伪代码大概是这种形式（为什么是这种别扭的形式……汇编的代码啊）： char root_path[4] = &quot;a:\\\\&quot;; bool found = false; while (true) { for (char c = 0; c &lt; 26; c++) { cstr = &quot;a:\\\\&quot;; char drive_letter = cstr[0] + c; root_path[0] = drive_letter; int drive_type = GetDriveType(root_path); if (drive_type == DRIVE_CDROM) { file_path_print(full_path, drive_path); if (FILE *fp = fopen(full_path, fp)) { found = true; fclose(fp); break; } } } if (!found) { SetForegroundWindow(thisHwnd); // 强制让当前窗口获得焦点 UINT ret = MessageBox(GetAppHWnd(), TextToDisplay, GetAppTitle(), MB_RETRYCANCEL); // 不展开了 if (is_cancel_pressed(ret)) { MyExit(); } } } DoSomeWork(0); return; 可以看到，关键跳转的地方是找到了光驱和验证完成时的跳转。可以在 00403AC0 找到一句 JNE SHORT 00403B39，这是往后跳出了整个循环的，对应的就是那个 break;。 看看前后，可以确认 00403B39 的位置是那个 DoSomeWork() 的调用，之后是 return; 所编译出的恢复环境的代码了。 另外 00403B34 处的那个调用是在干什么？翻开一看居然调用了 GetCurrentProcess() 和 TerminateProcess()……我说你们真狠，连一个体面的结束都不给，至少也得返回一个验证失败然后逐层退到入口函数来退出，手动回收各种资源啊，不要用终止进程的方法偷懒啊！ 看 00403B3B 的代码的时候，发现了“Majiro”的字样。一查，原来就是这引擎的名字。此外，澄空上已经有人分析了一些。 好了，分析了这么多，我们知道了：只有检测到不正常的情况下，才会调用 TerminateProcess() 直接终止进程，否则什么都不做。 原型估计是这样的： void EnsureDiskIsPlacedIn(); 调用估计是这样的： void OnLoad() { EnsureDiskIsPlacedIn(); DoOtherWork(); } 5、代码修改说了这么多，大家应该意识到了，我们直接将这个控制逻辑短路了不就好了？我们往里面放一个 JMP 跳转不就行了？ 在32位环境下，我们要放的是一个 JMP（空间限制，无法 JMP SHORT）长度是5字节（1字节操作码和附加信息+4字节操作数），于是我们要找一个合适的容器放下这个指令。我选择的就是位于 00403A5A 的这一句： MOV DWORD PTR SS:[ESP+10], 0 明显是一个对局部变量赋值的语句。可以看到，长度是8字节，满足要求。于是使用汇编功能（空格或双击指令），写入 JMP 00403B39，选上“保持长度”（Keep size）和“用 NOP 填充”（Fill rest with NOPs）。汇编，写入，可以看到多余的3个字节被 NOP 指令填充了。然后保存（Edit/Copy to executable，然后 Save file）到一个新的文件（如 StrawberryFeels_cracked.exe）。 然后再用 Locale Emulator 启动。发现了什么？ 附记： 我以前看过一点汇编，Win32 汇编程序编写。当时也不太清楚什么道理。不过近年来我通过 C/C++ 对运行机制有了一点了解，加上本学期的微机原理补充了16位汇编的基础，这次我能看懂多一些代码了。问学的16位看32位是否有困难——我想说，原理是一样的，如果死揪课本里的那些东西当然会有困难（有同学考前死背“JMP 指令占3字节”，但是却不了解指令结构，看到32位下的5字节会很惊讶的吧），但是理解了实质后应用那就是指哪儿打哪儿。 试玩了一下，立绘的确不怎么样，游戏系统也是十分糟糕（操作居然都放到了 Windows 菜单里！）。 我没破解区域验证，是因为现在还没人做这个东西的汉化，破解了也没意义——本来就是 Shift-JIS 的内容，用 ANSI 版 API，你却硬要做区域破解，系统自然会按照 GBK 来读；到时候显示在眼前的就是满屏的乱码了。反正我有 LE，能玩。 要问为什么菜单、安装的对话框没有乱码（但是获取安装路径时有）？那是因为使用了资源模板啊！资源区域应该是设为了 1041（日语-日本）了吧！ 第一次独立破解，做 NoDVD 的教程什么的也没有，摸索摸索走出一条路。不过确实有大神做用于汉化的破解教程的。原理差不多，我觉得，搜索调用点，修改、短路。因为我读过，也觉得自己有一点储备，所以才有信心认为能独立实践一次。Olly Debug 也是第一次用，感觉真是十分难用，也十分强大。 呜呼，原来以为只需要写一小时的东西，来来去去写了快三个小时，从00:22到03:15。没事，我还能躺30分钟，在起来准备东西，然后和大家四点半集合赶七点的火车……但是我本来预计要在车上看工艺文档的说，估计要全程睡觉了……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"RE","slug":"Tech/RE","permalink":"https://blog.mottomo.moe/categories/Tech/RE/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"}]},{"title":"杂记","slug":"zh/2015-07-18-Passed-Week","date":"2015-07-18T05:16:00.000Z","updated":"2020-03-30T22:34:35.406Z","comments":true,"path":"categories/Misc/zh/2015-07-18-Passed-Week/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-07-18-Passed-Week/","excerpt":"7月8日到今天的杂记","text":"7月8日到今天的杂记 2015-07-08 在去看《侏罗纪世界》的路上乘坐出租车，司机使用嘀嘀打车的司机端。手机被固定在一个支架上，但是其中发出的噪音（“XXX在XXX地，要前往XXX地”），上面两个按钮（所以估计需要司机手点确认接单完成在开车）。由于没有集成（比如在方向盘上加一个按钮）或者加入语音控制，所以我觉得会对司机产生干扰。（我没开过车，注意力分配情况不知道。附，《侏罗纪世界》完全成了爆米花电影，没有初代的令人惊艳的技术。） 2015-07-17 读到一篇文章（07-18: 和后续），理解了句柄（handle）的实质。正好，我之前在想着如何解决标记-压缩算法中对移动了的指针的引用问题，初步的想法是不保存指针的直接引用，而是通过一个结构体保存间接引用。看到句柄的原理之后恍然大悟，这就是我需要的东西。写了一个 AllocTable，不再用 std::list&lt;&gt;了。不过好像发现给谁用句柄的问题回答错了。代码等写好测试好了再贴上来。 这几天的不活跃是因为宿舍内联机打 Left 4 Dead 2。从游戏的打法上也可以见到每人的性格。 同学 A 平日沉迷于“三亿鼠标的梦想”（所有游戏的始祖），总是要求打开作弊模式，调出榴弹炮和土制雷管，不管队友在哪里都一阵乱轰，或者不管队友什么状态都只往 NPC 最密集的地方轰。手中握着两种大威力武器，几乎是秒杀所有的敌人，A 还兴奋地大叫：“哈哈哈，再多刷一些，太简单了，他们弱爆了！”顺带一提，在我建立服务器，不开作弊模式的时候，A 通常是第一个挂的。 同学 B 则喜欢开上帝模式（不受伤害）。当我禁止了作弊后，还吵嚷着要打开。 同学 C 会协调战线，会找路、配合防守。即使在作弊模式下，他也不怎么用作弊功能。 我和 C 类似。 鉴于此，我并不喜欢和这几个人联机。反正我是单人模式困难难度都通了几个的，在没有 能达到我这个级别的队友的时候，我还是好好享受一个人的时光吧。 我对所学专业（机械工程）的看法？ 这是一个传统的虚实结合点，是将设计（逻辑模型）转化为现实（物理模型）的咽喉。 但是这个学科在中国太传统太庞大，而且在信息技术的基础建设（不是日常应用）上中国还是显得落后，所以新技术引入让那些学生惊异。就像前天参观的时候，他们问：代码是如何输入机床的呢？师傅回答：通过 USB 接口，或者无线/有限网络。他们发出一阵惊呼声。——但是第一，这不是很自然的吗，如果不支持标准接口 RS-232/RS-485，这产品怎么与其他组件通过接口连接？再考虑到桌面用户的常用串口是 USB（USB-A），增加一个 USB 接口，同时再让机床的系统支持 FAT32/NTFS，不就可以降低对专用联网计算机的依赖（否则，需要专用的与此机床/机床群联网的计算机），让技术人员可以在个人计算机上生成代码并用闪存盘之类的存储设备拷贝到机床中了？牺牲了一些安全性，提高了便利性。另外机床接入局域网也不是新玩意儿了。 现在各个国家提出的工业4.0（德）、工业互联网（美）、未来工厂（法）、中国制造2025等等概念，从历史的角度看，是从分到合的必然。我们知道，对象关系并不只有继承（inheritance），还有组合（composition）。发动机能提供动力，但不能跑，怎么办？加轮子。不能控制，怎么办？加控制机构。加入的元素和已有的元素一起，会成为新的、更大的系统（既然是系统，就要具有整体性）的一部分。强电弱电的组合也有了接近百年的历史。要再提高效率怎么办？并行化，利用一个我们之前没有使用的资源——时间。而时间是特殊的资源，是一个维度，而且是一个允许多个对象共同使用的、单向、不受控的资源。为了合理利用此资源，以前的做法是分时，现在则能做到并行。机器的并行和动物的打猎（分工）是一样的，离不开预先制定的计划，与实施时的交流。由于机器本身并不能交流，所以为它们装上口耳，教它们标准的交流方式（协议）。这是很自然的想法，各位的“大力宣传”恐怕只是将其作为了一种口号，为了抢先提出“概念”——以此来显示先进性了吧。 最要命的是到现在为止，传统的机械工程都不把人当人看，而是“人为机器服务”。小白楼实验室参观有一项是“智能”装配线（还是我们专业的得意成果）示例。整个系统很简单，一个中心数据库，三层（主控、车间、工位）、Web 界面。注意其工作过程： 根据群体数据，计算出每个装配步骤所需的基准时间； 工人工作，每人完成一些步骤，同时显示屏上的步骤按照固定的时间切换到下一步； 如果没有在这一段时间内完成（意味着降低了整条生产线的工作效率），请按下暂停，并抬手按下显示屏上的“后退”键； 组装完成，请抬手按下显示屏上的“完成”键。 可见，上面斜体的步骤本来是由计算机做/调整的，却要不就设为固定，要不就要人费劲去完成。不过这倒也符合流水线的特征。毛骨悚然，实际上还是上世纪的剥削方式，只不过现在的监工成了计算机。 这个现象，随着将人加入系统的下一代工业的普及，应该会好一些吧。 收获是，在示例实验——测量固有频率，老师说过一句话：“固有频率是自身内在的属性，怎么测量呢？激发出来。”（测量时需要外加冲击，测量振动，进行自谱分析。） 2015-07-18 明天凌晨我们将前往哈尔滨。由于到时会有保密的规定，博客会有两周的时间暂停更新。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"今天一天","slug":"zh/2015-07-13-Misc","date":"2015-07-13T15:10:00.000Z","updated":"2020-03-30T22:34:35.406Z","comments":true,"path":"categories/Misc/zh/2015-07-13-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-07-13-Misc/","excerpt":"","text":"前往精雕的车上，我读着 CLR via C# 的托管堆和垃圾回收一章。读着读着突然想到，上次的怀疑没那么麻烦，因为 b 此时仍然处于栈上，是属于可访问的，所以不应该被回收。书中列举了一个奇怪的代码： using System.Threading; static void Main() { Timer t = new Timer(TimerCallback, null, 0, 2000); Console.ReadLine(); } static void TimerCallback(Object o) { // 只会输出一次，之后就不再输出 Console.WriteLine(&quot;In TimerCallback: &quot; + DateTime.Now); GC.Collect(); } 书上的解释： 然后，垃圾回收器检查应用程序的根，发现在初始化之后，Main() 方法再也没有用过变量 t。既然应用程序没有任何变量引用 Timer 对象，垃圾回收自然会回收分配给它的内存；这使计时器停止触发，并解释了为什么 TimerCallback() 方法只调用了一次。 不过这是罕见中的罕见情况，因为 System.Threading.Timer 使用的是线程池分配的新的触发线程，是异步的（System.Windows.Forms.Timer 用的是 SetTimer() API，在消息循环中处理，是同步的），所以在新线程中的扫描结果自然是“自己没引用，创建的线程之后也没引用”了。执行预测，那还得是 JIT 编译器的功劳，要不也像我一样只是简单认为它还在栈上。但是，同步的时候就没有这个问题。——这说明即使是完善的 CLR，也很难解决设计上就无法克服的困难。 一些觉得需要认真考虑的是： 非确定性析构（Finalize()）； f-reachable 队列，以及该队列处于独立的线程上，有元素（某个对象的 Finalize() 时调用）； 终结时的复活（revive）机制，有助于理解 Finalize() 中代码对其他对象的引用的处理； GC 句柄表； System.Runtime.InteropServices.GCHandleType.Pinned 的特殊处理方式； 写屏障（write barrier）的 card table（注意，要分配在连续空间上才有意义）。 由于不用做多个 AppDomain，所以我要做的模型的回收时机会简单一些。 下面要想的是还原 MonoVTable 和 MonoMethod 的结构，因为这关系到下一个测试：终结器（finalizer）测试的设计。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"今天一天","slug":"zh/2015-07-12-Misc","date":"2015-07-12T15:15:00.000Z","updated":"2020-03-30T22:34:35.406Z","comments":true,"path":"categories/Misc/zh/2015-07-12-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-07-12-Misc/","excerpt":"","text":"写着 GC 的时候遇到一个问题，伪代码如下： A a = new A(); B b = new B(); a.SomeProp = b; Console.WriteLine(&quot;Dummy&quot;); a.SomeProp = null; C c = new C(); a.SomeProp = b; 假设在执行 c = new C() 时 GC 工作，回收内存。那么对象 b 是否应该被回收？ 执行 a.SomeProp = null 时已经解除了 a 和 b 的联系，此时 b 应该是没有被引用的；但是，接下来的 a.SomeProp = b 就重新建立了二者的联系。 去看 SGen 的代码，想看他们是怎么考虑此类问题的。核心数据结构是 GCObject（MonoObject）和 GCVTable（MonoVTable），前推到 MonoClass 的时候 GitHub 的搜索就不太灵光了。真不想 clone 下整个 repo…… 最近的关于组织的文档也是2001年的，很难获知 MonoClass 的细节，除非 clone 下来搜索。这里是 MonoVTable 的定义和 MonoObject 的定义。可以看出后者和最初相比并没有多大变化。 SGen 虽然名为“Simple Generational Garbage Collector”，但还是很复杂……毕竟 Mono 都可以承担服务器的压力了…… 为了准备网站转型，在他们维护的同时我要设计 API v1。我就是应该去冲锋陷阵的嘛。Swagger Editor 是个相当不错的工具。安装的时候失败了2次，第一次 Failed: npm install xxxxxx（一个包，忘了是什么），第二次 Failed: bower install。看错误信息好像总是版本解析错误，但是每次都会解析到新的版本，所以就不断试了。然后 npm install，完成；npm start，就开始在8080端口使用了。 7小时通关了 Half-Life 2 Episode 2。结果：蚁狮幼虫成就329/333（幼虫有抱团的特性，所以剩下4只应该是在一起的），补给网成就8/9，资源定位点成就4/5（缺的那个还关联别的成就）。除了以上和火箭人成就其他都获得了。这是何等的糟糕，总是“少那最后一个”。最失望的是火箭人成就居然没给！通关后我加载了存档看，我确实是将地精（gnome）放到了火箭舱室里啊……哎我7小时通关就是为了照顾那个地精雕像，特别是在开车被武装直升机追逐、和阿狗赛跑的时候雕像特别容易掉，前者重试的次数都快赶上了我为了达成发射基地无损伤成就重试的次数了。与阿狗赛跑，由于地精在车后窗的卡位很好，而且驾驶平稳，一次就获得了竞速胜利（成就：Metal Pedal）。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Gal Game 的价值","slug":"zh/2015-07-11-The-Value-of-Gal-Game","date":"2015-07-10T18:02:00.000Z","updated":"2020-03-30T22:34:35.406Z","comments":true,"path":"categories/ACGN/zh/2015-07-11-The-Value-of-Gal-Game/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-07-11-The-Value-of-Gal-Game/","excerpt":"","text":"打算重推 Lovely Quest，不过这次推原版，不打汉化补丁。 虽然不少人表示不齿，但是我认为 gal game 是有价值的！ 首先就是其画面。每个画师的风格是不一样的，笔下（数位板下）的各位妹子主人公和损友都有不同的风采。对于真心想要“本命”的人来说，让虚拟的妹子们陪伴自己的方法有一种就是将其描绘下来——这样就不会停留在欣赏已有的 CG 的基础上了，而是去尝试用自己的笔实现自己所想的（场景etc.）。对于有绘画基础的人来说信手拈来，但是还需要用心；否则就要去学习，去牢记各个细节、一颦一笑，这自然不是简单事。不管是哪一种，做下来都需要投入，获得的也必然是能力上的锻炼与对人的画面的理解。 然后是音乐。好的 gal game 必须要好的音乐作为配菜，虽然名为视觉小说（visual novel）但是若少了听觉上的传递作品会减色不少，也没这么容易调动玩家的情绪。举例来说，Key 社的作品以伤感为主，这里麻枝准和折戸伸治两位的音乐起了不小的功劳。这些曲子单单是收录在各种播放器里听着就能给人不小的精神安慰，而要去进行二次创作，先要理解主题，所以需要学习乐理。进一步地，要制作高质量的作品，请学习作曲和编曲。 剧本……不熟。 其中的语言和对话可以成为语言学习入门材料。虽然其深度可能不是太深（古文级别），但是对语言语素与语法的解析提供了丰富的素材。有读音示范，还能回放，这已经和听力教材无异了。语素分离出来后，根据上下文和朗读停顿可以对句子进行解构，再根据语法常识进行试探与验证。一般而言，若是仔细研究一个 galgame 的话，至少会到 N4 了吧。（不过日语词汇的音读和训读和古文语法需要真正见到例子。） 背后的游戏引擎可以慢慢把玩。要想运行起这一款 gal game，资源是内容，引擎是载体。业内引擎种类多样，却依然被巨头统治：NScripter/ONScripter、KiriKiri 2/KAG3 是中日同人的首选，Ren’Py 是欧美同人的首选（不过份额比较低），其余会社专用的或者小众的引擎可以见 crass 的支持列表（0.4.14 一共默认支持 170 个引擎，大部分是 gal game 引擎，颤抖吧）。要想做出好的引擎就要清楚其特点，输入的多样性、效果的复杂性、配合的多方性，还要考虑使用难度、内容保护、扩展性、多语言多系统支持、资源分配与释放、前后端分离（像 KiriKiri 2/KAG3 设计 TJS 作为底层的解释器与剧本 KAG 的中间脚本语言）等等。深究下去就讲不完了，准时的手表中的齿轮必定是令人惊叹的。 资源解包对逆向工程的训练。想汉化？除了懂语言、会改图外，还要知道如何破解软件。asmodean 大神是引擎破解的高手，我们看到的是分析之后写出的代码，但不难想到解析结构时的刀光剑影，令人大气不敢出。也有 RednaxelaFX 大神的技术文章，以及各种破解入门教程（翻了翻作者的 GitHub 账户，感到深深的恐惧，原来这位就是 Locale Emulator 的作者）、反向记录等等。实践，实践，实践。 好游戏可以促使人思考人生的价值。这是废话，但是要做得到才行。在翻 Steam 的游戏列表时突然看到了 planetarian（星之梦），查了一下居然是 Key 社的作品，读了游戏的对白后体会到这并不是 Key 一贯的病亡类的悲情故事，某种说不出的东西。去年推 Lovely Quest 的时候说过每条线结尾会有一个“文末总结”的环节（挺鸡肋的），不过比惊世骇俗的君与彼女与彼女之恋要弱得多了。说实话这一段就是个伪命题，想人生什么时候不可以，这是一个独立于其他事物的抽象而已，任何时间任何场合都可以脱离所在的现实而思考。 至少，gal game 能分解到如何就有什么样的价值，就看看官能分解到多深了。 后记： 前天到昨天，11 小时 Half-Life 2 通关。虽然认识它已经有 6 年了，但是这是我第一次凭自己的实力通关，没用 budda、npc_create 和 npc_create_equipment 命令。（god 和 impulse 101 就算了，要设置 sv_cheat 1 的，就没法获得成就了。）33 个成就获得了 30 个。不过太坑了，为了“只用重力枪通过莱温霍姆”我差点就挂了，最后面对一屋顶的快速僵尸我急了，用了撬棍（crowbar）给了它们几下，结果居然没获得此成就！我真的一枪都没开啊！还有在沙地陷阱（Sandtrap）关卡中不碰沙地，最后的一段路我用两片铁片辗转腾挪了半小时终于过去了，期间是碰到了沙地，但是每次碰到我都直接读前面的存档，所以主存档里应该是没碰过的才对；但是还是没有这个成就。λ 定位器就算了，45 个只找到了不到 30 个，好难找……在水障碍区（Water Hazard）中有一个 λ 补给点，明显是个机关（而不是爬到上面），解开之后拿到补给却没有更新成就进度…… 用 Notepad++ 编辑 YAML 配置文件和类 YAML 的 CSS 书写文件（抱歉，查了还是不知道叫什么）总是会遇到奇怪的问题。检查后发现 Notepad++ 会根据配置中的制表符等价空格数来自动在回车换行时生成制表符，而生成的缩进乍看上去与用空格缩进没什么不同，要逐个字符选定后才能看出。YAML 是只识别空格缩进的语言，用制表符缩进会导致配置文件编译失败。我只好手工调一下 Notepad++ 了。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"自己动手做 GC (1) - 续","slug":"zh/2015-07-10-Building-Garbage-Collector-Part-1-Ex","date":"2015-07-10T10:55:00.000Z","updated":"2020-03-30T22:34:35.405Z","comments":true,"path":"categories/Tech/Coding/zh/2015-07-10-Building-Garbage-Collector-Part-1-Ex/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-07-10-Building-Garbage-Collector-Part-1-Ex/","excerpt":"","text":"在正文中，我们用的是 std::vector&lt;&gt;。众所周知，std::vector&lt;&gt; 是 STL 中数组的类似物，适合顺序存储与访问，并不适合随机增删。所以，应该使用 std::list&lt;&gt;，因为哪个变量要被回收几乎是不可预知的。或者采用改进的方案：更新相对频繁的 Generation 0 和 Generation 1 采用 std::list&lt;&gt;，相对稳定的 Generation 2 采用 std::vector&lt;&gt;。 各位应该注意到在 Windows 上运行 100 KB×10000 个单元的测试程序会带来严重的内存“泄露”问题。我以为是 STL 容器或者 new/delete 操作符的问题，就写了一个纯 C 的版本，但是现象依然如前。后来我发现，如果是 10000 KB×100 个，则会几乎完全回收。在分配内存总量不变的情况下，前者剩余 50 MB 左右，后者几乎为 0。 我们知道，在 CLR 中有一个大对象堆（Large Object Heap），回收策略与小对象堆不一样。 我们也知道，在使用 malloc() 分配内存时（Debug 配置），获得的指针指向的区域会被初始化（用于 CRT 内存检查），反倒是调用 HeapAlloc() 这个 API 的时候才会真正刚刚被操作系统分配内存。 根据现象与部分原理推测，既然 malloc() 和 free() 都是 VC 运行时提供的，内部是不是也有一个不同的策略，让大于某个值的申请空间回收会更彻底呢？ 上面的引文中有一句话，说 VCRT 10 下的 free() 操作后状态为： The memory returned by the free is returned to OS, but it stays committed. 关于 Windows 的分页机制我不是很了解，大概只知道是一个 4 KB 对齐、用于常用/不常用内存交换的东西。页的状态对系统对页的操作有何影响，先查阅资料再说吧。 用 2000 个单元进行测试。在我的机器上（Windows 8.1 x64，12 GB）发现在每个单元 500 KB~600 KB 之间回收结果发生了一个突变。我根据 4 KB 对齐猜测阈值可能是 512 KB，但是最终测试的结果是在 507 KB~508 KB 之间。由于这个值可能受当前分配代码导致的页内容的排布影响而变化（例如，32 位下 GC_RECORD 不计编译器附加字段，占用空间 12 B；若是其他的大小，应该会影响空间的页对齐，从而使此值离开上面的区间），所以我认为没法获得一个准确值。 此外我还观察到，10000 KB×100 个和 100 KB×10000 个，实际占用的空间不同，后者比前者多大约 4 MB。这也证实了，编译器会添加附加信息（尽管可能不在代码所用的数据区中）。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://blog.mottomo.moe/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"GC","slug":"GC","permalink":"https://blog.mottomo.moe/tags/GC/"}]},{"title":"六花勇者 / 见到了索尔菊苣","slug":"zh/2015-07-06-Meeting-Promethee","date":"2015-07-06T15:08:00.000Z","updated":"2020-03-30T22:34:35.405Z","comments":true,"path":"categories/ACGN/zh/2015-07-06-Meeting-Promethee/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-07-06-Meeting-Promethee/","excerpt":"","text":"在考前看了六花勇者的第一话。 个人觉得的一些亮点： 开场战斗的大幅度镜头绕主角旋转。虽说背景省经费还是用了3D，但是三人的动作和张弛都很到位比 Fate/Stay Night 和 F/SN UBW 的 Lancer 和 Archer 第一场战斗的远景好来得有诚意得多。 20:21，硬是用平移做出了镜头朝上旋转（roll，滚转）的效果。（索尔在分镜讲解的帖子里讲过初号机出场时的镜头向上平移配合透视做出的是拉远的效果，强调初号机的雄伟。我觉得这里也有点这个感觉，同时光的配合体现旋转。） 08:10，探监部分。镜头运动（pan）多次的节奏感（切分）——这是我写下来（大约21:15）的时候想的。后来和索尔提起的时候，对话如下： 一般探监的镜头就是这样（动作指示：将柜子侧面当做栅栏，指从一个人的侧后方给一个人侧脸一个人正脸），就给个侧脸；如果要体现出焦急的氛围，就给里面的人一个正脸特写，说“快放我出去啊”。不管怎么样，镜头总是静止的，指向一个方向。但是这里要表现的是一个轻松的环境，公主和他说的都是很无聊的事情，魔王啊什么的，到后面你就可以看到公主在自己玩了。所以他就让镜头动起来。门洞那个，你看，那个门洞本来是可以穿过头的，然后……后来公主只是剩下一个胸在那里。你知道《魔王勇者》吗？ （我：知道，查了一下，是同一个……） 是同一个监督的作品。你看一下，这个监督很能玩（指的是对镜头的把控），很有意思的。 … 动画与漫画、小说不同的一点是，它是一个集体创作的成果。你加一点，他加一点，最后监督的意思可能只剩下那么一点了。看着动画，找出每个人都说了些什么，不觉得很有趣吗？也不是说只有监督出主意，如果其他人的想法比监督更好也说不定。 我在看着动画的时候就在脑海里尝试还原分镜，尝试去体会监督想表达的语言。但是总觉得我抓不到那样的高度，有一种似乎知道了想说什么但是又看不清的感觉。身边同学没有人像我这样看，所以我也没法找人说，还是要请菊苣指导。 看了第一话，我不禁去查了职员表。 高橋丈夫——监督&amp;分镜（其余有意思的：链接1、链接2） 小磯沙矢香——ED作画监督、总作画监督、原画（第二组三个落单的第一个，索尔所谓的“突出一个人的方法”） Passione，作画监督是从这里来的；看质量如果能保持的话，可以考虑在心目中和 P. A. Works 上到同一个级别 大岛ミチル，部分歌单，原来这么多耳熟的作品…… 刚写完上面这些内容的速记版，老天就给了一个机会。 上次与村长会面的时候，村长就说过： 你现在不用智能手机，就等于关上了一扇与外界交流的窗。 今天看了六花勇者的第一话，打开手机QQ看群里新消息的时候，在历史消息中发现一条索尔菊苣说“我现在住的屋是7系”。瞬间想到，最近搬来我们班206的两位（4人间，有2人转出去了），就是上次我敲门后说“那两位不在，这两位是怎么回事”的两位，索尔是不是在里面？敲门，直接抛出一句：“你们中……谁是索尔？”两人愣了一下，然后其中一位缓缓举起手：“我就是。” 何等的幸运啊！因为要达成这种情况下见到索尔的结果，需要： 24系延期的同学要住在我们楼； 索尔要说出现在的位置； 我要在索尔说完话不久的时间内，去看群消息记录； 最重要的，是那记录肯定在99条之前，计算机上是无法查看的（“更多消息请在消息记录中查阅”），而手机QQ没有这个限制。 最后一条，如果没有手机，就看不到这条消息了，恐怕就没有今天见到索尔的奇遇了。所以多亏了村长的建议！ 与索尔见面的时候从六花勇者的一个cut开始，到哲学到考试到动漫产品再回到镜头。在一个小时（大约21:25开始）的时间里，聊了许多东西。和索尔广博的阅历相比，我就是个渣渣。要说对分镜的理解，索尔看着一本《银河美少年》分镜表中某位作画监督（抱歉又忘了名字）负责的变身分镜都会变得十分兴奋；但是我只能看出一个过程，大致想到是怎么样的画面，还没达到体会索尔所关注的“变身时候的精妙面部细节”的高度。（看细节，如果动画师没出错的话，我现在最多也只能看静帧。）我的水平差得远了！惭愧惭愧。 但是至少，知道下学年索尔菊苣会住在一个相对近的地方（4楼），如果有机会的话，可以分享对镜头的理解，至少可能可以请菊苣帮我在这方面入门一下。至少不会没人聊这个了。 索尔听多了能认出林原惠美……我倒是听了一首歌后才知道 Lost Universe，再去查角色表才知道原来她配过绫波丽和灰原哀…… 最后感叹一下，刚写完感慨就收到了上天的回应，这是何等的奇迹！","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"百度登录 - 续4","slug":"zh/2015-07-04-Cookie-Expires-Trap-Ex-4","date":"2015-07-04T13:59:00.000Z","updated":"2020-03-30T22:34:35.405Z","comments":true,"path":"categories/Tech/zh/2015-07-04-Cookie-Expires-Trap-Ex-4/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-07-04-Cookie-Expires-Trap-Ex-4/","excerpt":"","text":"进展：可以获得文件流了。而且根据测试，这个 URL 有相当长的保质期（真的是8小时吗？还没测试过），至少用 Fiddler Composer 测试的时候历史记录还能派上用场。 要点： 经过两次跳转。第一次：d.pcs.baidu.com-&gt;xxx.yyy.baidupcs.com；第二次：xxx.yyy.baidupcs.com-&gt;xxx.yyy.baidupcs.com，查询参数（query arguments）不同。两次都是302跳转。 由于浏览器中只见到一个302和一个200，所以我以为只有一次跳转。第二次我就忙不迭去查看 Content-Disposition 去了。但是，获得的是403、505和少量的 null，Content-Type 是 text/html。通过查看记录，仅有的成功实例也是302。但是，当我重复请求（将历史项直接拖到 Composer 里执行）时却能得到200。开始我百思不得其解，将成功和失败的请求头复制到 Notepad++ 里交换看，终于看出请求的URL是不同的……于是我领悟到原来第二次还是302，要再手工跳转一次。果然，在第二次跳转后，得到了文件流。 我在建这个博客的时候看到过一篇文章，有人问 GitHub 博客下的 CNAME 记录是怎么工作的（例如，本博客到 http://gridscience.github.io/），这些请求似乎都到了每个 CDN 服务器上（一些固定的 IP），这些服务器是怎么识别应该访问什么网站的？当时有人给出了解答，说是看请求头里的 Host 字段。我想着，既然本地 DNS 缓存将所有的域都解析到了同一个 IPv6 地址，对方很可能也是通过 Host 来识别的吧！ 试验的结果是，不管是 HttpWebRequest 还是 Fiddler，都不把手工设置的 Host 当回事……而且，对方也并未区分请求哪个 CDN，直接使用 IPv6 地址、自动设置的 Host 就可以了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"百度登录 - 续3","slug":"zh/2015-07-04-Cookie-Expires-Trap-Ex-3","date":"2015-07-03T18:12:00.000Z","updated":"2015-07-08T16:40:00.000Z","comments":true,"path":"categories/Tech/zh/2015-07-04-Cookie-Expires-Trap-Ex-3/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-07-04-Cookie-Expires-Trap-Ex-3/","excerpt":"","text":"进展：可以批量获取下载链接了。递归就是眨眼间的事。 yunData.sign2() 和 commonService.base64Encode() 就基本上照抄了，除了结合 .NET 的做了一点点优化。话说本来看到第二步的函数名称是 base64Encode，就直接用了 System.Convert.ToBase64String()。结果出来的和百度的标准大相径庭，遂照抄了百度的代码。（还没深刻理解，同时还不明白为什么会出现这样的不同。即使是 System.Text.Encoding.UTF8.GetBytes() 也不应该影响，毕竟获得的源就是单字节的字符串。）输入两组数据测试通过。 在获取 DLink 列表的时候，两个错误值： 2 表示 fsid 列表为空。 113（似乎是这个数值，忘了保存结果了）表示签名错误。 在获取真实地址的时候要经过一次从 http://d.pcs.baidu.com/ 来的302跳转。之前按理说获得了指向 http://d.pcs.baidu.com/ 的链接，直接发起 GET 请求不就好了？但是我得到的一直是403。我以为是普通情况（手工下载也不时会遇到403），用了一个循环，结果每次都是403；又以为是访问过于频繁，延迟了一下还是403。于是仔细看浏览器发起的请求并在 Fiddler 中伪造之，是可以正常下载的。那么，问题一定就出在请求头上。是哪里伪装得不对呢？ 最后尝试的结果是 cookie 中的一项 pcsett，有正确的参数才能避免403。现在好了，这个 cookie 是在哪里设置的呢？ 由于在浏览器中无法查看所有的 cookie 及其有效域，所以只好继续借助 Fiddler。用 IE 设置 Fiddler 为代理，从零开始访问百度盘，实际开始一次下载流程；接着过滤掉 Fiddler 中明显无用的项（普通的几个域在调试的时候看过，没有有效项）。最后发现是第一次访问 pcs.baidu.com 的一个 RESTful API 的时候，服务器返回了一个 Set-Cookie 标头，设置的正是 pcsett。 补上这一步，终于能避开403，拥抱302了。 接下来就准备做 Host 映射了，一个粗糙的原型就要出来了。我觉得。 我正在做的软件是要告诉他们：我本来就是做技术的，我最有力的武器不是被称作“静候圣音”的东西，而是技术。如果各位官老爷继续闭门不见的话，我会用优雅的方式开另一条路。 7月9日： 脑中灵光一闪，突然想到了一个解释 Base64 编码失败的问题。应该就是 System.Text.Encoding.UTF8.GetBytes() 上。查阅 UTF-8 编码规范得，有些字符起到了“分隔”所属区域的作用，例如分隔单字节字符、双字节字符和三字节字符。想想如果恰好碰到了某个这样的字符，那么我这个所有组成串的字符都是单字节字符的字符串就会被识别为一个夹杂着多种长度字符的字符串，假如在 UTF-8 编码表里真的有对应字符的话。 那么，就应该要让程序知道，我使用的是一个单字节字符组成的字符串。所以我想到了 HTTP 所使用的常用单字节编码：ISO-8859-1（又名 Latin-1）。调用代码如下。 var latin1Encoding = Encoding.GetEncoding(&quot;ISO-8859-1&quot;); // sign0 是经过 yunData.sign2() 函数处理的字符串 var sign = Convert.ToBase64String(latin1Encoding.GetBytes(sign0)); // 对比：之前所使用的是 // var sign = Convert.ToBase64String(Encoding.UTF8.GetBytes(sign0)); 然后查看 sign 的值，与所需的是一致的。这证实了我的猜测。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"百度登录 - 续2","slug":"zh/2015-07-02-Cookie-Expires-Trap-Ex-2","date":"2015-07-02T14:57:00.000Z","updated":"2020-03-30T22:34:35.405Z","comments":true,"path":"categories/Tech/zh/2015-07-02-Cookie-Expires-Trap-Ex-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-07-02-Cookie-Expires-Trap-Ex-2/","excerpt":"","text":"进展：一个简单的百度盘文件浏览工具做好了。浏览只是一个框架，等着往里面填更多东西。 Java 那边要各种持久化框架的东西，.NET 挥挥手一个 DataContract 加上对应的 serializer 就解决了序列化反序列化——壮哉我大 .NET！ 明天要考经济管理，赶紧复习…… 上学期不是也做过一边考试一边写 KeiSystem 的事情么，二者同时完成。只不过……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"百度登录 - 续","slug":"zh/2015-07-01-Cookie-Expires-Trap-Ex","date":"2015-07-01T14:20:00.000Z","updated":"2020-03-30T22:34:35.404Z","comments":true,"path":"categories/Tech/zh/2015-07-01-Cookie-Expires-Trap-Ex/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-07-01-Cookie-Expires-Trap-Ex/","excerpt":"","text":"百度的登录，token的获取和参数表的POST参数都应该用上一篇文章中提到的其中一位大神的表。关键是 tpl 值为 ik 而不是 mn——确切说，和请求的URL中的 tpl 一致。tt 可以设置为 0 之类的，服务器似乎没有做时间戳校验。apiver 为 v3 的时候返回的脚本和其他时候（不设置、为空、设置为其他）的不一样，不过结构是一致的。（最明显的是返回的 err_no 在URL中的位置。） 其他的结论： 返回的 err_no=257 表示的是发送参数错误（general error），err_no=4 表示账户/密码组合错误。 BDSVRTM 状态变化（从零到非零）发生在POST之后。 获得了 BDUSS 之后（作用域为 baidu.com），就可以畅通无阻了。测试了百度的一些需要登录的页面 API，可以工作。 今晚天空只有几片薄薄的云，可以说是大晴天。月亮接近全圆。林雁戈到了北京，瑞福晚上打电话叫我过去聚一下，来的有瑞福、林雁戈（+妹子）、黄秋实、张光远、叶新一、蔡德安、张子健。我借同学的自行车过去半小时，他们已经解决了，所以最后只吃了半碗粉+两碗饭。不过重点在后面的三国杀，八点到十点打了3局。来自302的有4个（我、瑞福、林雁戈、叶新一），所以略有久违的宿舍内部三国杀的感觉。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"因 cookie 的 expires 导致的坑爹事","slug":"zh/2015-06-30-Cookie-Expires-Trap","date":"2015-06-29T16:02:00.000Z","updated":"2020-03-30T22:34:35.404Z","comments":true,"path":"categories/Tech/zh/2015-06-30-Cookie-Expires-Trap/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-06-30-Cookie-Expires-Trap/","excerpt":"记录因为 cookie 中 expires 设置项类似千年虫的问题导致的坑爹事。","text":"记录因为 cookie 中 expires 设置项类似千年虫的问题导致的坑爹事。 在朝着下一个程序目标进发的时候遇到一个问题。我需要用 HttpWebRequest 去登录百度，在抓包、分析网页以及参看了两位大神的方法之后写了自己的代码，但是未成功。直接贴两位大神的代码，也未成功。 于是调试。发现每次加载的时候，在获取 token 的时候，总会获得这样一个东西： { &quot;errInfo&quot; : { &quot;no&quot; : &quot;0&quot; }, &quot;data&quot;: { &quot;rememberedUserName&quot; : &quot;&quot;, &quot;codeString&quot; : &quot;&quot;, &quot;token&quot; : &quot;the fisrt two args should be string type:0,1!&quot;, &quot;cookie&quot; : &quot;0&quot;, &quot;usernametype&quot; : &quot;&quot;, &quot;spLogin&quot; : &quot;rate&quot;, &quot;disable&quot; : &quot;&quot;, &quot;loginrecord&quot; : { &quot;email&quot; : [ ], &quot;phone&quot; : [ ] } } } （你没看错！errInfo 的 no 真的是 0！难道是哪位实习生为了省事而将 token 作为错误信息的传递者而不是用正确的 errInfo 去报告吗？） 原来的 JSON 还有其他问题，如用单引号（标准 JSON 只支持双引号；单引号仅可以用于 JavaScript 的 JSONP）、空格时有时无等等，这里都修正了。 标准的返回应该是这个样子的： { &quot;errInfo&quot; : { &quot;no&quot;: &quot;0&quot; }, &quot;data&quot; : { &quot;rememberedUserName&quot; : &quot;&quot;, &quot;codeString&quot; : &quot;&quot;, &quot;token&quot; : &quot;55639c700ece12a35bddf8562b4223fae&quot;, &quot;cookie&quot; : &quot;1&quot;, &quot;usernametype&quot; : &quot;&quot;, &quot;spLogin&quot; : &quot;rate&quot;, &quot;disable&quot; : &quot;&quot;, &quot;loginrecord&quot; : { &quot;email&quot; : [ ], &quot;phone&quot; : [ ] } } } 二位大神的示例代码应该是没有问题的，那么可能就是三者共有的问题了。单步调试发现，我维持的两个 cookie 容器 CookieContainer 和 CookieCollection（前者用于 HttpWebRequest，后者用于调试输出）的项并不一样。 观察： 访问 https://www.baidu.com，CookieContainer 4项，CookieCollection 7项； 访问 https://passport.baidu.com，CookieContainer 5项，CookieCollection 8项。 第2步之后测试输出 CookieContainer 中 URI=x.baidu.com（即，找出可以用于 baidu.com 全域的 cookie）的 cookie，结果只剩下一个名称奇怪的东西。 毫无疑问，CookieContainer 的更新出现了问题。以前我写过未来花园的登录，框架未变，而代码失效了——说明应该是 cookie 被丢弃了。 被谁丢弃了呢？我决定观察浏览器的处理过程。首先从零开始访问百度，观察浏览器的 cookie 流动。（不要在 Firefox 上试，这家伙从空白页开启网络流监控要求重新加载页面，也就是说无法获取“从零开始”的状态信息。）第一次获取了 BAIDUID 和 BIDUPSID 和另外几个东西，刷新的时候二者都不变（处于“发送”栏目中，没有被 set-cookie）。观察这二者的原因是在之后的步骤中，BAIDUID 是很重要的状态信息；BIDUPSID 看名称似乎是有点用的…… 接着观察程序中的 cookie 流动。结果发现，第二次请求居然会获得一个新的 BAIDUID，而且第一次明明存在用于域 .baidu.com 的 BIDUPSID，却在第二次请求中消失了！所以可以知道，BAIDUID 是“被抛弃（discard）的cookie”的代表，应该对其进行研究。 cookie 在什么时候会被丢弃呢？在超时之后。如果不指定超时，则是本次连接有效；指定之前的时间，表示立即丢弃；指定之后的时间，则延迟到未来。当然，受到32位问题的影响，最多到2038年——不过这已经是很长的时间了，从目前来看。 查看 cookie 指定的超时信息。BAIDUID 的过期时间是 expires=Thu, 31-Dec-37 23:55:55 GMT（为了避免2038年问题），这个时间在各大浏览器中被解析为2037年12月31日，但是在 .NET Framework 4.5 下，被解析为1937年12月37日。 再仔细看 CookieContainer 的 Add() 方法的执行结果。可以看到，对于被标记为已经过期（Expires 和 Expired 属性）的 Cookie，CookieContainer 不会添加。 这应该可以被写入千年虫问题的应用范例了吧。我是不是应该给 .NET 那边报一个 issue 呢？（因为 CookieContainer 与现代浏览器在此问题上的行为不一致。） 只好写了一个简略的解决方案： foreach (Cookie cookie in response.Cookies) { if (cookie.Expires &lt; DateTime.Now.Subtract(TimeSpan.FromDays(365))) { cookie.Expires += TimeSpan.FromDays(100 * 365); cookie.Expired = false; } } 因为设置为强行丢弃的，过期时间一般就设置到一年以前。虽说不是一个美观的方案，但是确实能用了。 随便翻了一下 https://passport.baidu.com/v2/api/?login（GET 方式），看到返回的一段东西我当时就笑了。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"搭建一个内网邮件转发服务器","slug":"zh/2015-06-26-Setting-Up-Postfix","date":"2015-06-26T07:15:00.000Z","updated":"2020-03-30T22:34:35.404Z","comments":true,"path":"categories/Tech/zh/2015-06-26-Setting-Up-Postfix/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/zh/2015-06-26-Setting-Up-Postfix/","excerpt":"在 Raspberry Pi 上用 Postfix 搭建内网邮件转发服务器","text":"在 Raspberry Pi 上用 Postfix 搭建内网邮件转发服务器 这本来是6月3日的记录，记录的是3日前几天内的测试过程，不过一直忘了写。昨晚翻看日历中的待办事项时发现这一个记录，就决定在一有空的时候就写下来。 原记录： 要点：改NS记录，设置relay而不是利用MX记录直接投递 建设的网站中有一个要邮箱验证的功能，而且要求使用学校的邮箱。所以在注册之后要将验证链接发送到学校的邮箱里；学校的邮箱地址在内网就可以解析。 我们原来的设计是将邮件给126进行转发。不过有一个问题，126提供的是商业服务，为了保证资源可用，肯定要限制账户的发送次数和流量。此外，学校的邮箱系统在接收外网来的邮件时会出现10分钟的延迟。所以，同学们的体验非常不好，我们不断接到“收不到邮件”的投诉。我们也问了学校，即使能使用其提供的服务，同样会有发送限制。 现在问题来了：要找到一种方法，一种没有发送限制的方法。 在剔除了一些明显不可能的解后，我们决定自己搭建一个邮件转发服务器。 硬件上，最好的选择当然是单片机加上板子，小巧而强劲，能hack。我们选了 Raspberry Pi B+，杨彦君往 TF 卡里灌了 Raspbian，进行了初始化的配置。 邮件服务有多种选择，包括 sendmail、Postfix、inbox.py、Apache JAMES。后两个的出现是因为我们想，如果只是基本需求的话我们完全可以自己从端口开始做起写一个邮件服务器。当然，由于是 Linux，没有 IIS，就没有 IIS 自带的邮件服务，而且只能命令行操作——好糟糕。 我尝试了 inbox.py，不过一写 handler 的时候就出现了问题：我们还是要往外面发——这需要在一个邮件服务器上有账号。这样，问题就回到原点了。JAMES 就复杂一些，我们真的要下到端口层面去进行操作吗？要处理各种通讯异常，重复造轮子？ 于是回归了 Postfix。（sendmail 直接被否决了……） 第一次安装 Postfix 后，希望该服务器只能通过认证才能使用，上了 Cyrus SASL。结果配置后全都乱了，恢复不可，于是删了之后重新装了一遍 Postfix。 在安装了 Postfix 之后，将系统的邮件服务交给 Postfix，然后用 mail 测试发送，目标是我的学校邮箱。但是等了很久还无法收到邮件。以前在网站服务器上尝试发送给126的时候就失败过，ping 了一下发现地址无法解析。于是想：是不是地址解析失败？于是修改 DNS 解析到学校的解析服务器 NS1 和 NS2。还失败。想到之前学了 nslookup 的 -q 开关，尝试用 nslookup。 自然是失败了，命令未找到。Google 了一下，原来 Debian（Raspbian 衍生自 Debian）默认并不带 DNS 工具。于是乎 sudo apt-get install dnsutils 在前一步设置了 DNS 服务器，以及设置了合适的 apt-get 源的前提下，apt-get 能快速安装所需的包。安装完成之后可以了。然后开始测试： nslookup baidu.com nslookup -q=mx smtp.126.com 看到前者走的是 NS2，后者走的是 NS1（在 NS2 优先的情况下）。在建设这个博客的时候，在 DNSPod 就看到过若干种类的 DNS 记录：A、CNAME、MX、AAAA。当时还不清楚 MX 记录的作用，现在大概能体会到了。在校内的环境下，看来是解析 A 记录首选 NS2，解析 MX 记录首选 NS1。而且很清楚的是，我们的发送目标是一个 SMTP 服务器，携带的肯定有 MX 记录，所以我们应该优先使用 NS1 进行解析。 调整顺序，让 NS1 的权值更大之后再 nslookup 就正常了。 再使用 mail 试验一下，还是失败。怀疑是不是与 SMTP 服务器通信过程中出现了问题。于是使用 telnet 验证。 补充说明：SMTP relay 经过查阅资料得知，SMTP 服务器在互联网还没这么发达的时候是接力传输（中继，relay）的。例如一封邮件要从 A 向 B 发送，而 A 和 B 之间没有直接的联系方式，则 A 向一个已知的服务器 C 发送这封标明要发送到 B 的邮件。C 收到邮件后，打上邮戳（表明该邮件经过了 C）。如果 C 无法联系 B，则将其转交另一个服务器 D，如此直到最后到达 B。当然，转交的前提是 C、D 等等都启用了中继功能。 现在大多数 SMTP 服务器都关闭了中继，因为： 现在互联网已经很发达了，两个 SMTP 服务器之间很容易直接连通； 中继容易让自己的 SMTP 服务器成为垃圾邮件的助推器。 在发送的时候，SMTP 服务器应该对目标进行检查，如果是发送到本域的，则应该放到终端的收件箱里，结束传递链。 开始一次会话。以下的测试反映了多次尝试的结论： 学校的 SMTP 服务器对安全控制比较高，必须使用 EHLO 而不是 HELO，同时需要正确地表明身份。例如，我们要发送到 xxx@b.com，则需要在 EHLO 中就告诉服务器我们以 xxx@b.com 的身份进行此会话。 学校的服务器禁止中继。（很好理解，见上面的说明。）在 RCPT TO: 的时候，必须使用学校的邮箱。 登录的时候没有强制验证。 符合我们的需求。毕竟，我们不能去要求用户提供他们的邮箱密码用于 SMTP 会话啊。 telnet smtp.b.com 25 EHLO xxx@b.com MAIL FROM: yyy@yyy.com RCPT TO: xxx@b.com DATA FROM: xxxxxxx TO: xxxxxxx SUBJECT: xxxxxxx ......... . ↙ 最后那个是回车，即结尾为“. + CR-LF + CR-LF”。 吐槽： dnsutils 的 telnet 比 Windows 自带的 telnet 好用得多，后者甚至会将退格键传输过去，所以一个输入错误都不能有。 PKGS 很好用。 原来此 SMTP 服务器不会对 DATA 里的 FROM: 节与 TO: 节进行校验（126会）…… 在本机和 Raspberry Pi 上 telnet 都通过了，确认邮箱能收到邮件。但是，Postfix 还是没有转发成功。将配置文件中的 mydestination 设置为 smtp.b.com 也不行。 这个问题困扰了我一天，这个 Postfix 服务器如何联系学校的 SMTP 服务器呢？现在所有的准备都齐全了，但是最后这个 Postfix 的发送部分瞄准镜不知道指着外面——如果是的话，DNS 记录会引导其走向；不是的话，很可能就是我配置的问题，封死了出路。如何打开出路呢？ 后来我仔细读了 Postfix 的各种文档，有一句话引起了我的注意： By default, Postfix has a moderately restrictive approach to mail relaying. 这说明，用 Postfix 做中继是可能的；查看 Postfix 配置，信任列表中包含 localhost。同时，综合 relay 说明的最后一条，得到结论：如果我是以本机（localhost）身份向本机的 Postfix 服务器发送一封发往 b.com 存在的用户的邮件，同时设置 relay 而且目标就是 b.com，那么此次 relay 和直接往 b.com 发送是等价的（因为 b.com 会直接将这样的邮件放入其终端信箱）。我看到了解决问题的曙光。 修改 Postfix 配置，加入设置项： relayhost = smtp.b.com 再次在站点上使用邮件测试，SMTP 服务器指定为 Raspberry Pi，发送成功，在学校邮箱里也见到了。 由于保护还是比较弱，为了安全起见添加了一些防护措施。总算解决了。 只不过希望再开放的时候如果有老师查看日志发现从校内某个点有大量往本校 SMTP 服务器走的连接，不要误认为那是垃圾邮件攻击……正常情况下是不会被攻击的…… Postfix 简单配置参考： http://blog.csdn.net/hitabc141592/article/details/25986911 http://www.cnblogs.com/apexchu/p/4271264.html","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"}],"tags":[{"name":"Postfix","slug":"Postfix","permalink":"https://blog.mottomo.moe/tags/Postfix/"}]},{"title":"技术之路","slug":"zh/2015-06-22-Records-of-Tech-Path","date":"2015-06-22T11:30:00.000Z","updated":"2020-03-30T22:34:35.404Z","comments":true,"path":"categories/Misc/Records/zh/2015-06-22-Records-of-Tech-Path/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2015-06-22-Records-of-Tech-Path/","excerpt":"","text":"将手机里记的快速记下来。 由于之前没有这个习惯，所以我只知道自己某个时间接触了某种技术，然后现在已经懂得使用（或原理）了，但不知道是什么时候，也不知道为什么。 大一 某个失败的电荷放大器+声卡（用作 A/D 转换）+自己写的信号分析程序的组合体。后来学了模拟电路后发现，在给定的信号强度下，用声卡作 D/A 不现实。 大二 弹幕君：首次从 WinForms 过渡到 WPF，像当年从 VB 到 VB .NET。同时接触正则表达式。 大三暑假 EarlySpring，自己学习 XNA 框架（继尝试使用 SDL 并做出另一个原型之后）。 Veronica.TaskHost，稍微深入 WPF，学习 style 和 binding，理解数据驱动。 大三上学期 在未来花园利用 Discuz 特性嵌入 FLV。 学习 MSIL（CIL）。 尝试脚本解释器/互操作/编译、 数据库选修课作业写的 μ3D 三维模型数据库，使用了数据绑定和 XAML 三维展示；可以直接手写 XAML 了。 大三上学期接近期末 FGBT-Bangumi Assistant，从 GreaseMonkey（UserScript）进入 JavaScript 的世界，学到了跨域访问相关，演练 DOM 操作、元编程。 Beanstalk，演练 .NET Framework 4.5 的异步执行语法糖，理解异步通信模型。 开了 GitHub.io 博客，学习 Hexo 和少量的 CSS。 后花园时代（考试中） KeiSystem 大三下学期 网站前后端、运维：PHP、JavaScript、CSS、MySQL、Apache、浏览器兼容（头疼）；向管理部门申报（创立所需条件）。 在上一项其中，还尝试了Postfix。 5月27日-6月11日，感动北航技术总监（被扣上了这个帽子），除了自己制作开场视频外还指导其余的制作剪辑材料选用与渲染参数。 6月中，尝试 NodeJS、nw.js、TypeScript 开发。 尝试制作垃圾回收器。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"杂论","slug":"zh/2015-06-21-Misc","date":"2015-06-20T21:20:00.000Z","updated":"2020-03-30T22:34:35.404Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-06-21-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-06-21-Misc/","excerpt":"","text":"有一个故事，大概是这样的： 有一个商人背了一口袋钱，一个小贩背了一口袋烧饼。因为遇到洪水，同时被困在一个小岛上。 商人饿了，找到小贩说：“我用五块钱买一个烧饼。”那小贩平时一块钱一个的烧饼，现在卖到五元？小贩小眼珠一转，说：“不行，十元一个。”商人没有还价，买了一个。 第二天商人又饿了，又找小贩买烧饼。小贩说：“我不卖了。要么我这一口袋烧饼换你一口袋钱！”商人愣了一下，看看四周滚滚而去的洪水，接受了小贩的建议。 第三天，第四天，小贩饿了，这次是小贩找商人去买烧饼。商人说：“五十元一个。而且你每天只能买一个！”小贩没有办法，为了活命也只能接受。 商人和小贩，在小岛上以烧饼度日。终于等到洪水退去了，烧饼也吃完了，钱重新全部回到了商人手中。 在这里提出问题。输入：两个人、一袋钱、一袋烧饼；输出：两个人、一袋钱。这个微型经济系统中消失的烧饼去哪里了？ 我将在考期后给出我的回答。 又是一个故事。 有三顶红帽子和两顶白帽子，将其中的三顶帽子分别戴在A，B，C三人头上，这三人每人都只能看见其他两人头上的帽子，但看不见自己头上的帽子，并且也不知道剩余的两顶帽子的颜色。 问A：“你戴什么颜色的帽子？” A说：“不知道。” 问B同样的问题，B想了想也说不知道。 最后问C。 C回答说:“我知道我戴的帽子是什么颜色了。”当然，C是在听了A，B的回答之后作出回答的。 信息从哪里产生的？ 我将在考期后给出我的回答。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"村长","slug":"zh/2015-06-20-Misc","date":"2015-06-20T06:06:00.000Z","updated":"2020-03-30T22:34:35.403Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-06-20-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-06-20-Misc/","excerpt":"","text":"星期四村长来录节目（其实他的主要目的是 IDL+MS 吧！），晚上跑到亦庄去见了一面。 晚饭的时候就讨论到了我坚持不用智能机的事情。于是我把上一篇杂论中最后“数据淹没人类”的论点摆了出来。 村长：人不是DNA数据吗？人与你说的那些数据有什么不同吗？ 我：人，或者说生物这种“数据”和普通的数据不一样。我们这种数据可以杂交（笑），而且可以主动产生新的数据。你看计算机里有数据自己产生数据的例子吗？（注：实在很难从数据的角度看人性，所以我没法提。） 村长：一开始的时候不也是大分子碰撞成RNA吗。计算机可以看成硅基生物，这样一来是碳基生物造出了硅基生物。 我：你的意思是出现了第三种形态。 村长：对。 结果到这里，还是被绕进去了，不了了之。我的初始论点可是“人和普通数据不一样”啊。 将人看成数据载体的话，我无法认同普通的数据能像我们这种“数据载体”一样活动。尽管从一个方面想（模拟世界假设），如果我们如我们所创造的东西一样是活在一个有既定规则（自然定律）的模拟世界中（The Thirteenth Floor），那么确实是没什么区别。只不过是无法验证的。越想越能推断出对人类不利的结论……不过在终极的真理（若有）之前，任何遵从于其的有什么不同呢？没有吧。退出这个假设，单从表现上来观测，生物与非生物在时间线上的活动是不一样的。 于是村长又问道： 你不是想深入实质吗？为什么又要依赖于表现呢？ 于是我被问倒了。 村长也说过，根据康托尔第一不完备性定理，我之前的问题是我自己无法回答的。真糟糕。 我的表达能力，不是文字的表达，而是人与人之间面对面的交流能力，需要提高。 昨天的展示会上，我内功深厚（串口通信、电路设计仿真、抓包与包结构设计都做过），完成那个单片机项目不费吹灰之力（除了实测一个运行参数，然后将其写入代码）。相比之下，那些同学还在纠结语言基础，以及问助教才知道有一种包装数据的方法是在参数后加结束符，然后欣喜地四处传播这个“发现”。我自己深知，对着一群还在这样水平挣扎的同学与总是教这样的同学的老师去讲我的代码里的结构设计、扩展接口设计、交互设计、稳定性设计，怕是像给他们讲天书一般，而且他们也因体会不到其价值而嗤之以鼻。在构思、制作上，我实力足以碾压这群人。 但是表达上，我是被碾压的一方。我明知思想水平的差距，还是找不到一种适合他们的方式讲给他们听（如果有未来来的人将时间机器的原理告诉我，我也会听不懂的吧）。我在做的时候，要写的东西随着积累的经验，都是直接浮现在脑海里的，根本用不着想——要逼着我说我是费了多大的劲去想，我实在说不出。所以现场我总是说：“你看，所有的东西，包含注释（还是为了演示才添加的）都在上面，很好懂、很简单的。”语言苍白无力。 相比之下，有同学录制了视频，演示在不同输入下是怎么工作的。在这个演示下，我只能告诉他们，如果输入了错误的参数，我写的程序会拒绝执行，而且在数码管上显示“E”带错误号——是的， 我描述了出来，但是没有图像、视频那么直观。我做了很多，也比他们超前了很多；但是在一个普通观众看起来，他们是更有趣、更“新”的吧。 村长在吃饭的时候也给我看过他的小组的眼动仪测试视频。而我在讲一个精彩的ED的时候只好用语言去描述“背景有些许的变化……人物只有5个动画帧，但是因为……所以在减少了成本的同时还表现出了很好的效果”。如果我听了我说的话，我就想象不出来那是什么一样的东西。换言之，留下深刻印象也是不可能的事。 带着智能手机不是说玩，而是能随时随地展示自己的东西——你看，你又关闭了这扇窗口。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"自己动手做 GC (1)","slug":"zh/2015-06-20-Building-Garbage-Collector-Part-1","date":"2015-06-20T04:45:00.000Z","updated":"2020-03-30T22:34:35.403Z","comments":true,"path":"categories/Tech/Coding/zh/2015-06-20-Building-Garbage-Collector-Part-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-06-20-Building-Garbage-Collector-Part-1/","excerpt":"自己动手，丰衣足食——垃圾回收 Part 1","text":"自己动手，丰衣足食——垃圾回收 Part 1 提示：本文所用的语法为 C++11 语法。 看来我想要做一个 Visual Novel 引擎的愿望一直没有消失。我最近见到了 nw.js，不过我对一个难以自适应的呈现器展示动态的、元素主要是位图和渲染的文字的东西抱有怀疑的态度，毕竟 CSS3 没掌握，也还不了解精髓。因此我做着第二手准备，就是开发自己的脚本引擎，以此为基础构建完整的 VN 引擎。（内容啥的……那只能看会不会遇到合适的人了。）一方面这是我的梦想之一，另一方面即使最后 VN 引擎万一冷场了，至少还给我留下一个脚本解释器作为自学编译原理的成果嘛。 闲话少说。在一个脚本解释器中，特别是动态类型的，我认为垃圾回收扮演着至关重要的角色——负责所有对象的生命周期管理。所以，在以前尝试从编译器下手和从表现层下手之后，这次要从最基础的垃圾回收器（garbage collector，GC）下手。 纵观现代的 GC，主要有两种方式：引用计数（reference counting）和标记-清除（mark and sweep）。其中，后者还衍生出如标记-压缩（mark and compact）、分代回收（generational garbage collection）等技术。 引用计数的优点在于实时性。每个对象被引用时引用计数增加1，被解除引用后引用计数减少1，计数器为0时就直接回收了。这样可以保证对象在确定不被需要的时候立即回收。缺点是频繁地计算引用计数会有轻微的性能影响，以及循环引用（例如 A-B-C-A 三元闭环）会导致无法回收的问题。采用此方式的有微软的 COM 技术、Python 语言、KiriKiri 2/KAG3 等等。 标记-清除的优点在于在空闲（idle）时间内不影响程序运行。在内存使用达到了阈值之后，先停止世界（stop the world），挂起主程序，对每个可达（reachable）对象进行标记，然后清除不可达（unreachable）的对象。缺点是，如果不进行执行优化，对象数多时在挂起的时候会产生显著的停顿。而且管理上，例如如果要压缩（移动指针）、分代（设置写屏障，write barrier），编写的难度会比较大。采用此方式的有 C# 的虚拟机（无论是微软的还是 Mono 的）、Java 的虚拟机、各大浏览器中的 JavaScript 虚拟机等等。 综合考虑，我还是选择实现一个标记-清除的 GC。（有种感觉，哪个地方漏了减少计数就糟糕了。）为此我读过一些文献，不过上面的措辞还是比较含糊。 将所有全局对象和栈上的对象标记为可达，然后以这些对象为根，进行对象遍历。遍历完成后，释放未被标记的对象。 思想很简单，实现上有两个问题。 如何保存所有的对象（因为要遍历）？ 对象之间的相互引用是如何保存的？ 我看完之后总是想不出这个思想在计算机中的映射是如何的。后来脑子一抽，想既然从最简单的开始实现，那就用一个数组呗。于是我们就有了一个数组。 std::vector&lt;void *&gt; *m_pAllObjects; 考虑到在实现中纯指针操作会很麻烦，就封装为一个结构体。 struct GCRecord { // 要使用的内存空间 void *ptr; }; std::vector&lt;GCRecord *&gt; *m_pAllObjects; 这样问题1就解决了。轮到问题2。先想到对象之间是 n:n 映射，所以每个引用域也必须是数组。于是改变GCRecord的结构如下。 struct GCRecord { void *ptr; // 指向该对象的对象 std::vector&lt;GCRecord *&gt; *references_in; // 该对象指向的对象 std::vector&lt;GCRecord *&gt; *references_out; }; 为了预留分代回收和增量回收（incremental garbage collection）的实现空间，以及结合应用场景（动态类型的脚本解释器），再增加几个字段，然后添加成员函数。 struct GCRecord { // 标记状态（黑白灰） AGC_MARK_STATE markState; void *ptr; std::vector&lt;GCRecord *&gt; *references_in; std::vector&lt;GCRecord *&gt; *references_out; // 给 ptr 分配的空间 asize_t allocatedSize; // ptr 指向的类的类 ID unsigned long classID; GCRecord(); ~GCRecord(); }; （吐槽：上面的命名方式混合了 UNIX 小写+下划线命名法、匈牙利命名法和 camelCase 命名法，写的时候随手写的，要统一啊！） 在释放阶段，只有未被标记（不可达）的GCRecord的析构函数会被调用。因此，指向其的所有对象都是不可达的，应该释放。 GCRecord::~GCRecord() { for (auto r : *references_in) { delete static_cast&lt;GCRecord *&gt;(r); } // destructor = find_destructor_by_classid(this-&gt;classID); // destructor(this-&gt;ptr) free(this-&gt;ptr); delete references_out; delete references_in; } OK，感觉这就是所需的数据结构了。那么接下来来构造一个简单的标记-清除回收器。思想很简单，标记+清除即可。 class PlanC { public: // 初始化成员 static void Initialize(); // 释放成员 static void Uninitialize(); // 收集 = 标记+清除 static void Collect(); // 在堆上分配内存（不在根中） static void *AllocHeap(asize_t size); // 在全局对象堆上分配内存（在根中） static void *AllocGlobal(asize_t size); private: // 标记 static void Mark(); // 清除 static void Sweep(); }; 初始化和释放就太简单了，执行该执行的操作即可。现在来看看标记的过程。 void PlanC::Mark() { queue&lt;GCRecord *&gt; records; // 全局对象 for (auto iter : *m_pGlobalSet) { if (iter) { records.push(iter); } } // 当前的栈环境 for (auto iter : *m_pRuntimeStack) { if (iter) { records.push(iter); } } // 以下就是经典的非递归的图的广度遍历啦 asize_t xs = records.size(); while (xs &gt; 0) { GCRecord *rec = records.front(); // 标记为已经遍历（黑色） rec-&gt;markState = AGC_MARK_BLACK; records.pop(); xs--; for (auto r2 : *rec-&gt;references_out) { // 灰色和白色都是不用回收的对象 if (r2-&gt;markState != AGC_MARK_BLACK) { records.push(r2); xs++; } } } } 标记完毕之后就是清除。 void PlanC::Sweep() { GCRecord *p; unsigned int c = m_pAllObjects-&gt;size(); for (auto iter = m_pAllObjects-&gt;begin(); c &gt; 0;) { // 过滤空指针 if (*iter) { if ((*iter)-&gt;markState == AGC_MARK_WHITE) { // 由于 iter 即将无效，这里需要保存其指向的位置（类型是 GCRecord *） p = static_cast&lt;GCRecord *&gt;(*iter); m_uAllocatedSize -= p-&gt;allocatedSize; // 然后调用析构函数释放空间 delete p; iter = m_pAllObjects-&gt;erase(iter); c--; } else { // 将处理过的对象标记为未被遍历（白色） (*iter)-&gt;markState = AGC_MARK_WHITE; // vector::erase() 的陷阱 // http://blog.csdn.net/yang3wei/article/details/7589344 iter++; c--; } } else { // 对于空指针，不需要执行操作 } } } 在附上的代码中漏了重置状态为AGC_MARK_WHITE的那一行。 最后的PlanC::Collect()函数是二者的综合。 void PlanC::Collect() { PlanC::Mark(); PlanC::Sweep(); // 利用 vector::swap() 释放 vector 不自动释放的空间 // http://www.cnblogs.com/viviman/archive/2012/10/29/2775104.html ClearVector(*m_pAllObjects); } 至此一个思想简单、实现简单的标记-清除 GC 就完成了，在不考虑增量回收、写屏障等等的情况下。来实测一下。 #include &lt;iostream&gt; int main() { PlanC::Initialize(); std::cout &lt;&lt; &quot;Ready.\\r\\n&quot;; getchar(); for (auto j = 0; j &lt; 3; j++) { std::cout &lt;&lt; &quot;Begin!\\r\\n&quot;; for (auto i = 0; i &lt; 10000; i++) { PlanC::AllocHeap(100 * 1024); } std::cout &lt;&lt; &quot;Filled.\\r\\n&quot;; getchar(); PlanC::Collect(); std::cout &lt;&lt; &quot;Collected.\\r\\n&quot;; } getchar(); return 0; } 上面的代码会分配大约 990 MB 的内存，所以请内存不足的同学谨慎运行。 有细心的同学可能会注意到，在PlanC::Sweep()中有一行： m_uAllocatedSize -= p-&gt;allocatedSize; 这是一个可调的内存阈值。在完整的代码中，设置了一个内存阈值，当分配的内存即将超过阈值时强制垃圾回收。可以将m_uAllocatedSize设置为512 * 1024 * 1024（512 MB），在运行上面的代码时会触发超过3次垃圾回收。（那是自然……） 现在问题来了。试着运行并观察现象的同学可能会发现，运行结束后并没有像料想的那样收回全部内存，而是会剩下一些。 我的实验数据如下。 Win32，三次回收（j = 3）。内存阈值 2 GB 时剩余大约 60 MB，阈值 512 MB 时候剩余大约 30 MB。 Win32，单次回收（j = 1）。内存阈值 2 GB 时剩余大约 90 MB。 x64，三次回收（j = 3）。内存阈值 512 MB 时剩余大约 90 MB。 大约也可以看出，这是某些指针域未释放的缘故。不过目前还没找到原因。 现在的代码中还存在问题。 GCRecord::~GCRecord()中未判明指针的有效性。当 A-&gt;B-&gt;C 这样的情况发生时，如果 B 先被释放了，那么在释放 C 时就会发生一个无效指针的错误。（实际上，在遍历的时候每个 GCRecord 是独立加入的，在 Sweep() 中也不进行耦合处理，所以实际上每个 GCRecord 被单独销毁，不会影响其他的 GCRecord。 压力小于10000的时候回收的过程就有明显的停顿感了。这是有待增量回收解决的。 日后分解吧！ 附件：完整(?)代码","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://blog.mottomo.moe/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"GC","slug":"GC","permalink":"https://blog.mottomo.moe/tags/GC/"}]},{"title":"多样性，杂感","slug":"zh/2015-06-17-Misc","date":"2015-06-17T12:32:00.000Z","updated":"2020-03-30T22:34:35.403Z","comments":true,"path":"categories/Misc/Records/zh/2015-06-17-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2015-06-17-Misc/","excerpt":"面对着多样性","text":"面对着多样性 博客园中曾经有这么一篇新闻，22件现在的孩子无法理解的事情。恕我生物学意义上年轻，有些描述的还是没有经历过，如早年没有背光的 GameBoy——在我记忆中，也只是小学二年级的时候在楼下的小伙伴家里玩过一次，后来只接触到 GameBoy Advanced（GBA）、PlayStation 了——尽管现在看来这些也是古董。 不过对于在满满的CD中挑出一张这件事，我倒是体会很深。我最近才加入云音乐，在此之前是所有的音乐至少都是本机保存着的。在这种情况下，可以看到自己的 foobar2000 的播放列表里有数目众多的音乐，就像取之不尽的宝库；听一轮，滤掉一些不喜欢的（我经常是整张碟一起收），也得四五天的编程时间。在对接到云音乐之前，这样的生活，相对于以前来说已经是十分奢侈的了。我还记得小时候在十几张猫和老鼠的VCD中选了又选，就想选中一张能 refresh my memory 的。不过，再怎么选，总是一次又一次地看到熟悉的内容。 初二的时候，我有了一个 MP3（便携式音乐播放器），点阵的屏幕，大概是 20×120 的，步步高的一个能加载歌词的 MP3。初二，由 Here I Am 踏入了英文歌的坑，MP3 里不久之后就装入了5首英文歌，Here I Am、My Love、I Want It That Way、Seasons in the Sun、As Long As You Love Me，其中 Here I Am 是当年英语节的主题歌，另外四首是英语老师某一节英语课推荐的。就是这么五首，在下面的 Behind These Hazel Eyes 和之后的 Are You Happy Now 到来之前，在 MP3 里孤独地存在了四个月之久。睡前戴上耳机，把几首歌听一遍，感觉已经是很幸福的事情了。 后来住校，MP3 和之后的“MP4”（便携式影音播放器）的歌曲转到了 Nokia 9310XM 里面。习惯还是一样地，睡前戴上耳机听一听。由于存储容量的限制，带的音乐不会太多——后来分了几个文件夹，从命名上就可以看出那是哪一次添加的。内容基本上是只增不减，所以每一次往SD卡里传输那都是很神圣的。 初二到高二的时候一直听 HitFM——我称之为“HitFM 的‘黄金时期’”，因为后来 HitFM 偏重于电音，一种我不喜欢的风格；或者说，国内的欧美主流已经变成了电音，只剩下周日晚上的 American Top 40 坚守着多样性的阵地了。我当时是如此地痴迷 HitFM，以至于在奥考结束后来北京的夏令营中，我专门带了一个收音机，来到北京就在中巴上调到 FM 88.7 MHz。几年来，我的所有歌曲信息都是来自于 HitFM，无论是什么风格（Hit FM 在接近整点报时的时候会放一些填充时间的歌曲片段，碰到我喜欢的我会记下歌词然后去搜索下载，这间接锻炼了我的听力；还有创纪录的找了一年的 C’Est la Vie）。我还曾经将一些“精品曲目”刻录成CD，然后在一台很老的CD播放器中播放。（在刻废了数张CD-R后有点初步的光盘中的文件系统的意识了……） 再后来，获得了计算机的自由使用权，本来就在小本子里存了很多音乐，都完整地保留了下来。现在的 D:\\Music 下，还有着从一开始积累的音乐文件。到现在我还习惯将下载的 OST、CD Single 等等归档，然后解压放到这个文件夹下分专辑播放。 然而，这七年间积累的、属于个人的“精品”，在遇到云音乐之后发现这是如此地渺小。不光是我所留存的，还有更多更多我所不知道的，还能紧跟发行的脚步。就像，你将一只金鱼放入了大海。不再在鱼缸中，而是在大海中畅游。我开始感到恐惧，发自内心的恐惧。这很好，那很好，那也很好——一瞬间，我的面前就有了如山的宝藏。只不过，哪怕是知道自己一辈子也用不完，还是有一种“饥渴”的感觉。 我现在要找一首歌很容易，容易到我不用再辛辛苦苦翻长长的 foobar2000 播放列表，也不用在一个只有下一首上一首的 MP3 播放器中忍受着切换一次数秒钟的煎熬，就为了找到一首能够 enlighten 我一下的一首歌。我只需要在搜索框中键入我所记得的歌曲关键信息，然后点击播放按钮。 换言之，随着选择的极大丰富，原先的期待感、欣喜感被这“海量的宝藏”碾压得一文不值。大家似乎很喜欢将自己的收藏“在这个大潮中升级”吧。随着新一代在碎片中长大，什么样的信息产品都会变得容易获得；只要是容易获得，总是不容易被珍惜。而要把它们卖出去，只好采取一些拉脑残粉用的营销手段，或者是用让人血脉偾张的内容来博取眼球。但是，这带来的是信息产品的进一步贬值。 冯小刚看了《速度与激情7》之后，评论说“看不到人心”。文化产品要处理的信息量越来越大，蕴含的保持人的核心的内容在减少。人在惊叹联网（因特网、物联网）的威力与便利、欢呼我们终于要打破虚拟与显示的围墙而在信息的海洋中遨游的时候，却容易忽视它们对人性的改变。 正因为如此，我一直拒绝使用智能手机，我知道在那便利的背后，有一个潘多拉的盒子。我做出来的东西，是有着我的灵魂的一部分的，而不是让人们消沉在其中的。一旦屈服于内心深不见底的欲望，打开了魔盒，想用技术来填补的时候，这个人已经死了。 是人创造、分享信息，还是信息淹没了人呢？ 我是在买了一份夜宵，回宿舍的路上想到的。 我们学校的南门，大运村外面晚上非常热闹，是各种游动摊贩的聚集地。（所以，也少不了城管的光顾。）宿舍到南门有10分钟的路程，而这10分钟的路程就是我坚实的壁垒。 我最喜欢一家摊贩的扬州炒饭。虽然不知道原料的不健康程度如何，不过味道和份量那是没得说。我在带着快餐盒回宿舍的时候突然就想，我为什么要花费宝贵的10分钟出来买一份扬州炒饭呢？我觉得是现在在外卖的网站上订不到炒饭吧。然后就想起自己订到过什么——形形色色，但仔细想想都是容易加工容易携带容易批量生产的菜品。再想想，我有时候会去买一家店的汉堡可乐，这是在沙河两年饱受食堂煎熬（后来不时跑到三楼开荤）所未曾期望能得到的待遇呢。再往前推，小时候我不是每次去M记、K记都会十分高兴的吗？但我现在不是也在享受着接近的东西吗？我还在像当初那样期待着像过节一样的下馆子（eat out）吗？十年过去，为何如此呢？ 我想起了语艺班时（三四年级），小天鹅最早的教室楼下有一家快餐店。我最喜欢的是里面的干炒牛河，每次去语艺班的时候，如果时间来得及，老妈会允许在这家店吃一餐干炒牛河，也是满满一个快餐盒的量。（哇小时候我就这么能吃了……）有时候来不及，在进入语艺班之前要经过的窄窄的小巷外有一家麦当劳，老妈就买一个汉堡一包薯条（我觉得，当时应该很奢侈了），我忘不了那个幸福的味道。这就像老一辈过年或者过生日一样才能享受到的特殊礼物呢。我还记得，在朱教授的班还在小天鹅六楼的时候，有一次我将汉堡带到了班上（桌子还是胶合板、金属腿的桌子），被严厉地训了一通，老妈也是；后来即使是没吃饭也忍着，绝对不会再课堂上吃东西。（插一句，由于朱教授是虔诚的基督徒，他每次上课之前都会让全班唱一首圣歌——也训练了识别五线谱和一些单词的能力；有一次我问“Holy Holy Holy”是不是“狐狸”，小学三年级词汇量还不大嘛，他说：“你以后会知道的。”） 回到现在。每次买炒饭的时候我看着四周的摊贩，看着“其乐融融”的场景，我总会想“啊，这是人美好之处吧”。10分钟的路程，是为了告诫我，这个炒饭可不是随便一个按钮就能买到的，要你走路，要你在路上腾出时间思考的。 我在想着“白金之星”的时候想到，金、铂为长久之物、为贵重之物，人们追求他们，一方面是因为在工业上的应用价值（Portal 2 2011年情人节预售宣传片中说“Women love diamonds for their wide range of industrial applications”，笑），一方面也是因为它们经久不变的闪亮光泽。所以人们还是在追求长久。 问题：若蟪蛄知春秋，或许历史上的那么多只中有一只吧，如果能从季节的推移中理解“时间”的概念的话，会不会也去思考、赞叹、哀叹和追寻长久呢？ 今天又有同组家伙理解不透彻，代码写到一半就随便扔给我了。这是大不敬！当时我就翻脸了。而且他居然还说：“你是不是写不出来？写得出来你写啊，你写不就行了！” 我告诉你，我写得出来，而且我可以立即将答案告诉你。但是我也说过很多遍，少自以为是，刷了一下午书以为自己都会了，一上实践就错漏百出。而且我为什么每次说那么多的东西，那是因为我要告诉你们我是怎么想、怎么推断的，在推理的链条中有一个断了还想接起来？你们一句话“只说结果不是简洁明了嘛”说明你们也只能认为我是个答题的机器。连学习背后的过程都嫌烦怎么能学好？无非是临时抱佛脚，然后拿出去吹牛而已，上手了掩盖不了自己是渣滓的事实。我不是不能团队合作，我是不想与和自己不是一个级别的人合作，我非常讨厌带着一群不学习还装X的小白，拖慢自己的进度，那些家伙也没有收获。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"misc","slug":"zh/2015-06-15-Misc","date":"2015-06-15T15:03:00.000Z","updated":"2020-03-30T22:34:35.403Z","comments":true,"path":"categories/ACGN/zh/2015-06-15-Misc/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-06-15-Misc/","excerpt":"","text":"http://www.bilibili.com/video/av256955/index_122.html 开场马利克说了一通话，从有人高呼“姐弟出本子”开始，大家进入本子讨论状态。 大约05:32的弹幕： 前面出本子的别傻了，游基王的本子我还真没见过除BL本以外的 大约05:40开始的地方弹幕如下： 本子最多的是黑魔导女孩 黑魔导女孩啊||||摸不到怎么avi？ 转成rmvb就好了 虚拟游戏里就摸得到啊 http://www.bilibili.com/video/av256955/index_131.html 槽点多多 游戏王218、219似乎出现了伊迪安齐射！ 在索尔菊苣的《白箱》解说中见识到了一点点。如下图，展现了伊迪安齐射的一部分： 游戏王中，破坏龙刚朵拉的攻击：","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"又是一些想到的东西","slug":"zh/2015-05-30-Thoughts","date":"2015-05-30T15:03:00.000Z","updated":"2020-03-30T22:34:35.402Z","comments":true,"path":"categories/Misc/zh/2015-05-30-Thoughts/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-05-30-Thoughts/","excerpt":"","text":"在开始测试的时候，lan姐的账户名称被抢注了。我之所以如此断定，是因为我在漫版的版头上加了一句“版权:lansure”。这本是正确的，而且我认为应该注明非我做的东西——但是可能就是有人看到这个账户名称，也许知道历史吧，一看可用就注册了。lan姐可能不在意，她肯定明白为已经定了的事实气愤或失望也没用，但是我总是在在意这件事。也许只是像当时只有我一个人，在许多同学的支持下，险胜另一位对手，获得了最后一个最佳指挥名额——可是那些陪我流汗的组员却没有得到什么——明明我们训练得比那些只在临场前才准备合的组要刻苦得多，我的组员们理应比他们得到更多——可是没有。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Keil μVision 5 (MDK 5) + STM32——一场惊魂","slug":"zh/2015-05-15-Recovering-STM32","date":"2015-05-15T15:51:00.000Z","updated":"2020-03-30T22:34:35.402Z","comments":true,"path":"categories/Misc/Records/zh/2015-05-15-Recovering-STM32/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2015-05-15-Recovering-STM32/","excerpt":"自己的脑袋自己保住：独立解决一次单片机开发板异常的过程。","text":"自己的脑袋自己保住：独立解决一次单片机开发板异常的过程。 由于时代的原因，现在的单片机课本大多是讲 μVision 4（包含于 MDK 4）的配置与运行。我们刚好要上单片机的实验课，配发的是 μVision 4.14——一个无法在 Windows 8/8.1 上运行的版本。为了尝试运行，我搜了一晚上的网页，最后终于痛下决心用 μVision 5（从配发的资料的关键字中可以知道，我们用的是 STM32F101/F103，所以我将这两个型号的包提前下载下来了），尽管在配发的资料中助教强调道： 不要用其他版本，以避免版本过高带来的问题。 （注：今天有同学不知在哪里弄到了 μVision 4.12，可以在 Windows 8/8.1 上运行。经过我配置，编译、连接、下载好像没什么大问题。我们使用的是 STM32F103 系列，4.12 在 Project Template 中并不包含此选项，不过在板子的数据库中包含，ARM/ST/STM32F1xx_EVAL 文件夹下有示例。习惯了 μVision 4 的同学可以用这个版本。） 既然上了 μVision 5，那就不要屈尊回到 μVision 4.12 上了。而且，包管理不是挺好用的么，还附带效果“对教材跟不上更新的嘲讽”。_(:з」∠)_ 但是在实际使用上就出现了问题，主要是在设置界面上有差别。我们用的单片机是 STM32F103VC-T6。我之前也没试过单片机编程，不过大致了解一点整体流程，就开始尝试了。加电——加载示例工程——编译——下载！哎等一下，为什么会出错，说 No Algorithm found for: 08000000H-xxxxxxxxH？上网搜了一下，大概是没有设置写入算法吧。遂照葫芦画瓢（我们用的是 JTAG 线，核心 Cortex M3，选的是 J-LINK/J-TRACE Cortex，传输速率设置正确、设备检测正常），设置 Debug 和 Utilities（μVision 4 的位置有所不同，不过根据功能一致性，μVision 5 对应的位置在这里），在列表里选了一个 Device Type 为 512 KB ROM 的，标有 STM32F1 啥的。这次下载似乎很正常，但是板子没有出现预期的结果。此时正逢老师讲到重点原理，干脆找了一个同组的、装有 4.12 的同学，用那个 μVision 尝试下载。噩梦开始了。 下载结果： Programming Failed (Cortex-M3) Erase Failed Flash Timeout 到了第三次之后就一直超时，连下载前的擦除（erase）都做不了了。再查资料，才发现：第一，之前选择的工程示例（Blinky）是针对一个 ARM 架构的单片机的，但不是 STM32；第二，Device Type 不是随便选的，过大的 RAM/ROM 区域设置会造成写入异常。 好吧，换配发的工程模板（LED 点亮测试）。不过配置上好像都没什么变化，在 Programming Algorithm 处还是只有两个和 STM32 有关的设置，一个是 16 B 的，一个是 512 KB 的。STM32F103VC 配置是 256 KB ROM，48 KB RAM，明显这两个配置都不对。而且不管选择哪个，重新编译下载都提示超时。 助教发现了这个情况，问是不是设置上出了什么问题。我说应该不是（呃，小郄还对助教说“没事，他改的话他知道在做什么”，不过我毕竟是在高三前的暑假将某 Windows 的 SAM 直接删了导致后来发生化学组内部事件的家伙），助教认为是不是硬件问题，于是拿着到一个成功下载的组的计算机上尝试，依然 Flash Timeout。此时，根本就无法重置，硬件的 RST 针脚输入（按下 Reset 键）不起作用，某个 LED 一直亮着，冷冷着看着按下又弹起的 Reset 键，连眨都不眨一下。（正常状态是 RST 则单片机全部数据引脚失效，中断执行，LED 肯定要灭，信号失去则开始初始化。） 到了这一步，助教也只好说：“你再试试吧，实在不行就换开发板。”（这个举动和物理实验中电光实验的那个实验老师很像，那个老师明明看到我的操作正确但是出不了结果，撂下一句话让我继续调——这明显是仪器问题，在前面做成功的同学走后我打乱他的仪器，3分钟调出了我这里30分钟调不出的现象。）我知道，潜台词就是“对不起，我也不知道是怎么回事，包袱还是给你吧”的意思。我还想起了这堂课开始讲过的，王教授（此次助教的导师，也是这批设备的购买者）“很严肃地说过，这些开发板不能弄坏，谁弄坏了要追究相关责任人”。没办法，自己的脑袋还是要自己来保住。 Google，百度。找到一篇帖子（转到一个 FAQ 存档），讲到如果在 Utilities 里选择 Erase Full Chip 而不是 Erase Section（只擦除设置中的 ROM/RAM 段）的话，会造成软件设置的闪存写保护失效。于是选择菜单 Flash-&gt;Erase，强制擦除整个闪存。OK，现在每次能擦除了（Flash Timeout 和 Erase Failed 错误消失），剩下的是 Programming Failed (Cortex-M3)。 这算是取得了突破性进展。同时，某次尝试设置编译目标，结果点进了项目选项中的 Device 窗口。由于这个工程是 μVision 4 的工程，所以 μVision 提示没有单片机相关的数据，需要安装 μVision 5 Legacy Support。按照界面上的提示转到网页安装，完成后发现在数据源里除了 μVision 5 的包之外，还多了 μVision 4 的单片机数据库。（所以这才叫 Legacy Support 嘛，才发现连数据源都变了，不兼容 μVision 4 了，所以要单列出一个 Legacy Support，应该是认为新时代的开发者应该放弃 μVision 4 数据库里的一些老单片机了吧。不过两个数据源……硬盘哭了。）现在能在 Device Type 里选择正确的设置了，STM32F1xx，256 KB。基地址是自动设置的，不用修改。 助教再过来看，一直提示的是 Programming Failed (Cortex-M3)，这个他也不知道是怎么回事。我也说，既然擦除能成功，为什么会出现写入错误呢？助教再一次走了。于是我再一次单枪匹马向未知的敌人挑战。 根据网上的各种资料，Programming Failed 是一个 general error（和臭名昭著的 General Protection Fault 类似）。这不是开玩笑吗，引发这个错误的原因会有很多，我怎么知道是哪里出了问题？另外，越底层的东西越易碎玄妙（fragile and delicate），稍有不慎，满盘皆输。这就是为什么我讨厌写非常接近底层的东西——想想庞大的中断向量表（不是表本身，是其参考书），这还算好的，硬件哪怕是一根针脚就那么折了也得让人着急。 不过网上资料指出的错误分为四种：连接&amp;连接线问题、算法分配问题、重置方式问题、锁死问题。尝试检查。 一、我们使用的是 JTAG 连接线，选项选 J-LINK 那个没错。JTAG 方式和 SW 方式都能成功连接设备（可用连接处显示可用设备）。自动测速（Auto Clk）的时候传输频率能达到 10 MHz。这说明在连接上没问题，而且线的质量没问题，不用降低传输频率。 二、Device Type 选项没有问题。检查编译选项并重新编译，主要是两个 Start Address（基地址）和 Size（空间大小），都没有越界，保证在 Device Type 的详细信息的范围内。调试多组数据，都不行。 三、重置方式，帖子说如果 Auto 不行就选 System Rst Request（μVision 4），在某个帖子里讲到，对应的 μVision 5 选项是 Normal 和 Reset Pins。尝试过，还是不行。 四、锁死问题多发生在运行的程序占用了 JTAG 端口，导致 JTAG 连接失败。根据原理和教程，解决方法如下。 STM32 中是自带了BootLoader的，切换进BootLoader 中就可以了。具体的方法就是通过BOOT1、BOOT0两个跳线来选择启动模式。修改跳线将启动模式切换为上述的第二种方式：BOOT0=1，BOOT1=0。 断电，改跳线，重新上电，进入第二种方式：BOOT0=1，BOOT1=0，即STM32的BootLoader 模式。此时J-Link可以正常工作了，用J-Link 下载新的程序，下载成功。再断电，把跳线改回来第一种启动方式（BOOT0=0，BOOT1=0），重新上电，一切正常，问题解决。 问题是：第一，我能看到BOOT0针脚，看不到BOOT1针脚；第二，即使看到了，难道真的就是将BOOT0/BOOT1和裸露的 VCC 接起来吗；第三，这块板子启动后能显示自身的电压，应该是在某一段 ROM 中写入了程序的，应该不允许我用BOOT0/BOOT1法去捣鼓吧，第四，之前的操作（512 KB）设置了端口的概率很小。由于无法观察测试，这种方法就没法用了。 总之就这么折腾到了下课，别人都走了，我还在和这个问题较劲。到我收拾计算机和开发板的时候，下一堂课已经开始了，上课的是留学生，讲课的是一位操着口音（非洲原生口音？总之不是美音或英音）的黑人大叔，听课的看起来来自中东、非洲、南亚的都有。到此，在小郄的推波助澜下（“他独立调试能力很强的，让他带回去玩两天也许就好了”），助教给出的答复就是让我先试试，或许能好；实在不行打电话换开发板。（这是个啥解决方案嘛！要是我很会开挖掘机是不是就让我日铲万斤？） 回来之后继续调试，毕竟人头啊。偶然发现了这个帖子，里面提到了可能类似的情况： 调试一次之后如果停止调试，再启用调试就出现“Programming Failed!”错误 虽然里面的临时解决方案依然是BOOT0/BOOT1，但是提到了一个东西：J-Link ARM。想到在之前查找解决方案的时候曾经看到过一篇关于使用 J-Link ARM 下载编译结果的博文，想到既然 MDK 下载失败，是否能通过这款软件下载呢？（以前写 Veronica 的时候，由于对串口操作做了封装，因此专门写了一个串口调试程序发送/接受和编解码原始数据。这样的“双访问方式”思想是从各种兼具 GUI 和 CLI 的软件中学来的——例如 MySQL/phpMyAdmin、服务管理工具/sc、注册表编辑器/reg 等等。嗯后两个都是 Windows 上的，不要太计较了。） 继续照葫芦画瓢，根据所选用的单片机配置好 J-Link ARM。选择架构-选择固件/程序-设置基地址-烧录。在第二步，上面的博文用的是一个 bootloader 的例子（.bin 文件），我差点也选了一个 bootloader（ARM/STLink/stm32f10xLoader.bin），后来仔细想想，再看了看后缀名过滤器，原来也能选编译好的程序（.hex）。再想到在 MDK 中编译时，除了设置输出代码清单、生成 MDK 用的编译结果（.axf）外，还生成了通用的程序（.hex）。至于为什么我认为 .hex 是可以写入单片机的程序，那是因为我以前在某些地方看到过用很老的软件往单片机里烧 .hex 的，而且也在老爸他们的一些写电路板的工程目录里见过大量的 .hex 文件，而且名称表明是用于执行用途的。（关于基地址，在选择了单片机型号之后，加载的程序文件左上角的文本框里就是该单片机默认的 ROM 基地址。由于只需要写一个程序，保留这个值不动就可以。） 总之选什么写的问题解决了，开始下载。战战兢兢，如临深渊，如履薄冰。按下 Auto 菜单项的那一瞬间，我也不能预测接下来会发生什么，能不能写成功。只见状态窗口开始滚动状态，第一个状态就是 Unsecuring flash，这个操作花费了较多的时间，相比之下程序的传输是眨眼间的事。然后，就是一个 written successfully。我按下电路板的 Reset，松手之后奇迹出现了——四个 LED 亮灭亮灭，这正是程序的内容。看来是真的成功了。我直接冲出宿舍门，大叫：“成了！”后来在 μVision 上测试，编译、下载一切正常。 后来打电话给助教，要说不用准备新的板子了。助教听了也惊讶了（毕竟一个大三的学生解决了一个研二都没辙的实际问题），不过更多的惊讶应该来自于当我说我是下午那个下载失败的学生时他说“啊，我差点忘了这事”。他问我是怎么做的，我就大致描述了一下。我说这是多不用心啊！虽然确实应该算我引起的不过居然能将一个自己可能碰到而且无法解决的问题忘掉…… 事后再想想，最后的问题应该是闪存的写保护还挂在那里，要不然第一步解除保护的时候怎么会花了能感受到的时间呢。晚上再搜索的时候，新的关键词找到了一个文章拷贝，里面有几行： 问题已解决，可能是在jlink那里点了Unsecure chip，所以用ISP无法解锁了； 在RAM中运行 int main(void) { RCC_DeInit(); FLASH_Unlock(); FLASH_ReadOutProtection(DISABLE); } 问题解决了。 原理也是闪存的读写保护。 总之操作如下： 除了本体 MDK 5 外，还要安装 MDK 5 Legacy Support。 选择相应的单片机，添加对应的 Programming Algorithm。 必要的时候，进行全闪存擦除。 必要的时候，进行去读写保护。 可以正常下载程序了。 虽然好像就这么几步骤，不过我之前并没有真正编写、编译和下载单片机相关的代码或程序。因此此次解决这个风波，依赖的还是我的推理和知识储备。例如地址分布、.hex，同一个教室里连 C 语言都得重新给他们讲，甚至不知道二进制-十六进制转换的那些人，在不具备这些经验的情况下，即使是简单的问题也只好举手问“老师是不是点这个按钮就好了”——没错我不会开挖掘机，不过只是问老师也可以学开挖掘机，但是也只是会开挖掘机而已。更别提去独立解决一个（在正常使用条件下）不常见、难以确定来源、没有文档参考（毕竟现在的文档、教程基本上是 MDK 4）的错误了。上下级互惠关系更容易建立在这样的基础上，认知水平一致嘛。 我也许现在不会像那些研究生一样用领域软件写一些领域代码，不像一些学霸和老师和团委关系好成绩上佳（虽然这些确实是本事），不过在综合分析上还是能攻城略地的。所以当看到一些展示的时候我说“我大概知道组成了”的时候，旁边的人都认为我在装13，但是我很清楚我已经不和他们在一个层面了。 或者说，只是因为周围的人水？毕竟我也知道一些大神，面对他们我都不敢出声的。 彩蛋：Keil 的官网好像有点 bug。我记忆中的包索引地址是 http://www.keil.com/mdk5/pack/，不过访问此地址会造成过多跳转——310（net::ERR_TOO_MANY_REDIRECTS），在 www 和 www2 之间跳。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"又是一些想到的东西","slug":"zh/2015-05-11-Miscellaneous-of-05-11","date":"2015-05-11T15:03:00.000Z","updated":"2020-03-30T22:34:35.402Z","comments":true,"path":"categories/Misc/zh/2015-05-11-Miscellaneous-of-05-11/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-05-11-Miscellaneous-of-05-11/","excerpt":"","text":"何为存在？我们的生存有什么意义？ 有人肯定会劝说我：扬名立业，让世界记住你。 我要反问：你所谓的“世界”也不过是人类一个小小的种群而已。对于宇宙而言，并没有所谓“记住”一说，而是某实体对某实体在某个时间点产生了影响，没有人类的主观性。既然只是限于人类内部，你这个“记住”又有什么意义呢？难道不是人类的自大而已？ 反驳：你隐含地说没有意义，但你不是活着吗？你为什么还活着？ 回答：我不知道我为什么要以这种状态活着，我目前的行为模式不过是借鉴了所知道的人类普通个体的惯常行为模式，有某种继承自动物的生存本能而已。也许这种存在状态能给我一个机会（但未必是最好的机会）来解答我为什么存在这个问题吧。 问：你所想的最好的机会是什么？ 答：超出人类的精神，以最接近世界本身的运作方式来观察、解析（不是分析，分析还带有主观）世界的运作的一种状态。 若要将这个问题问人的话，身边普通小青年看到第一层就要笑了吧。他们根本无法理解自己在宇宙中的位置，思想还只是停留在出名挣钱上吧。并不期望这些家伙在到人生尽头之前能多好地想过上面的问题。 昨天洗澡回来路上想到去向还未定，再想到暑假可能不回家，在家的时间越来越少，若工作了也将如此。突然间像被击中了一样就体会、理解到了父母在家的孤独感。回到宿舍之后刚坐下来就接到老爸的电话。 只要不严重阻碍的使用，用户就不会去多考虑什么选择。这就是为什么360搜索会排在第3，因为借着某卫士用户群推一款绑定主页的浏览器。一定要说的话，微软不就做过这样的事情？ 因此只要不出大问题，这反而会给出用于完善细节的缓冲期，以及产品“越做越好”的“口碑”。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"为什么中国的动漫产业落后 - 补充","slug":"zh/2015-04-19-Why-Chinese-ACGN-Is-Not-So-Well-Developed-Complements","date":"2015-04-18T17:10:00.000Z","updated":"2020-03-30T22:34:35.402Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-04-19-Why-Chinese-ACGN-Is-Not-So-Well-Developed-Complements/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-04-19-Why-Chinese-ACGN-Is-Not-So-Well-Developed-Complements/","excerpt":"为什么中国的动漫产业落后 - 补充","text":"为什么中国的动漫产业落后 - 补充 培养动画产业要培养一批人，除了正文提到的负责画面部分的外，还要有配音、配乐、音响和一些统筹性的人员，还要有销售渠道，等等…… 为什么动漫人物的脸是反解剖学，却让人觉得好看的？ 我实在是才疏学浅，想不出原因。于是我求助于互联网，获得了几个觉得可以解释的答案。第一个分析的是心理因素，后两个则认为是表达便利所致。注意后两个提到了手塚治虫。#1 #2 #3 再翻 Wikipedia 的时候，也看到了这个观点。因此这个可能在欧美是一个比较常见的解释吧。 A common anime character design convention is exaggerated eye size. The animation of characters with large eyes in anime can be traced back to Osamu Tezuka, who was deeply influenced by such early animation characters as Betty Boop, who was drawn with disproportionately large eyes. 有些歌舞为主题的动画如《LoveLive!》和《偶像大师》除了普通作画，LIVE 的制作也是很重要的。这种情况下，要考验制作公司的双重能力了——因为 LIVE 的摄像机移动速度快，人物动作变化频繁而且不具有固定的模式（pattern），所以普通的原画+手工补间动画制作很困难。一般而言，这时候就要上 3D LIVE，建模+材质+骨骼+动画，然后看渲染结果或者二次转2D。这意味着制作时既有传统的模式，也有大量3D绘制主角&amp;环境的模式。 索尔菊苣的评价是《骗钱大师》的 LIVE 要比《LL邪教》好。（我的吐槽：我猜 SUNRISE 制作3D的经验主要集中在萝卜头的战斗场面上，将萝卜头换成人不就是某种高级 MMD 的效果了？A-1 这一块我更不知道他们能做出什么样子的，不记得 A-1 做过3D场面的来着……毕竟我看得少。等会儿，BANDAI 连自己旗下的 IM@S 都不给同属自己旗下的 SUNRISE 做？）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"动漫","slug":"动漫","permalink":"https://blog.mottomo.moe/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"为什么中国的动漫产业落后","slug":"zh/2015-04-18-Why-Chinese-ACGN-Is-Not-So-Well-Developed","date":"2015-04-18T13:18:00.000Z","updated":"2020-03-30T22:34:35.402Z","comments":true,"path":"categories/Misc/Thoughts/zh/2015-04-18-Why-Chinese-ACGN-Is-Not-So-Well-Developed/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/zh/2015-04-18-Why-Chinese-ACGN-Is-Not-So-Well-Developed/","excerpt":"为什么中国的动漫产业落后","text":"为什么中国的动漫产业落后 首先声明，“动漫”这个词，和“动画”是不等价的。动漫，一般而言指的是动画（Animations）、漫画（Comics）、游戏（Games）、小说（Novels）及其衍生产物。本文只讨论表番，里番、18X的多是满足私欲，不予置评。另外，鄙人后三者接触少，所以本文主要谈的是动画。 如果你认为动漫只是给小孩子看的，那就错了。动漫作品面向的是广大群体，从总角到而立。现在由于市场导向大多数作品是面向15到25岁左右的年轻人的，主打青春牌，热血、校园、后宫etc；不过也不乏要展示给所有人，要表达一定思想的，例如《机器人嘉年华》、《星际牛仔》。如果所有片子都像《膜裂》那样，肯定只有没脑子的人才会去看了。 不过也如之前所说，动画只是一部分。我所知道的动画线主流产业大概是这样子的：线路A（轻小说-&gt;漫画(+动画)）、线路B（漫画-&gt;小说(+动画)）、线路C（原创动画）、线路D（游戏(-&gt;动画/小说/漫画)）；由于我不读小说也不看漫画，游戏玩得少，那边几条线就不怎么清楚了。一般而言，A线出来的很可能是公式化作品（标准一季大约12话，所以会出现例如几话克服一个困难，加上泳装/温泉回等的套路），线路D就要看游戏如何（纯gal的话很可能会出受人诟病的作品如《大图书馆的牧羊人》；带一些剧情的会好一些如《灰色的果实》；也有课金游戏如《偶像大师 灰姑娘女孩》）。B由于漫画开题的多样性，有可能会出一些非公式化的作品如《未来日记》、《宇宙兄弟》。C线路是佳作的多产区，如熟悉的《小圆脸》、《未闻花名》或者小众的《伽利略少女》、《分形》（“遗作”的开始）、《C》。可以说，公式化稳市场（名作之壁），原创开辟道路（动画未来）。这是在有着收入的情况下发展的。不存在说一两部孤立的动画就能拉动经济发展那么美好的事情。 这么多的ACGN，从哪里来？C和N有着为数不少的作者群体；G看各家游戏公司（和专门负责游戏设计的大牛，这块我留意较少）；A则要靠大牛来撑场面。关键的职位，监督（导演）、作画监督、演出、作监，这些都不是一朝一夕出来的。就像列强的工业革命两百年不是白走的，而是在不断的失败中积累了大量经验。我们的产业还只停留在制作视频就好的层面。同时国人总是认为“以假乱真”的三维动画才是高大上的，于是我们不缺乏能做出优秀三维动画的公司（如水晶石），但是在二维上我们大多只能去负责外包，少有沈宏这样的能人。（在软件业不也是？我不否认BAT正在艰难创新，但是不仅是它们，许多中国公司还想坐在沙发上坐收人口红利，而不想着怎么打基础求发展。） 那么我们缺少能人，为什么？答：因为我们不需要。你一定要说我是不是在开玩笑，我不是。 第一，中国人依赖性思维较重。这和我们从小的培养是有关系的。从小学开始我们即被教育道，大家好好学习，其他所有事情都有人担着。所以广电总局很惨，只要电影电视网络剧发生了什么，他们总是躺枪——因为没人去仔细想想这是哪里的问题，是真版权（因为法律确实不断地在收拢）还是真封杀？我最近才知道王垠，一个月前看到了他发的一篇《我为什么不再公开开发Yin语言》，直接将我震慑住了。要说公开和OO思想叫板的、以及评价 Knuth 的，而且做出来的东西确实漂亮的人，那真是少见。虽说我并不喜欢他所推崇的类 LISP 的风格，但是这样的独立思考探索深度是必须加以肯定的！跑得有点远。我们喜欢批评别人，而且是在没理解的时候就开始了（虽说《LoveLive!》开头几话远景确实很没诚意，笑死了），但是却少有人想去改变这个状况。可能是人都会有这种天性吧，少有人克服了。于是我们开始嘲笑（《天鹰战士》&lt;-《新世纪福音战士》）。 第二，无限制获取，无分级。继上面一段的《EVA》的事件后，封杀就正式开始了。而随着网络在中国的普及，要获取什么东西那真是太简单了。一些番（番組，电视节目）本来都是在深夜档的，例如涉及暴力（《进击的巨人》）、强圣光的，都是放在凌晨在电视上播放的。注意，是凌晨（过零点），电视上。这意味着，此时少年儿童已经入睡，而且这个节目一般只在这个台播出一次（虽然可能与多个电视台签订播出协议），过期不候。也就是说，要是错过了，想再看这个节目，就只好去买DVD或者BD了，花费大笔银子。做法合情合理——分时法，在硬件中都用了多久了；效果未知。（不过也不乏厉害的家伙，如《攻壳机动队SAC》、《轻音》、noitaminA。）但是在中国，你想看各种喷血的镜头？很简单，不是买了版权么，优酷土豆爱奇艺，随便上，只要能交网费，随便看，不论是什么年龄段的看适合什么年龄段的。而且，这种广泛传播带来了立法的困难，间接导致分级制度迟迟不能定下。我记得我和老妈的一位朋友去新加坡（2008年）的时候，住在宾馆。这位朋友正好带了他的孩子L，小学五年级。某天晚上这位朋友有事出去，回来的时候我们正在宾馆的电视上看一个节目（后来才知道是《猛鬼追魂2》）。他看到我和L正在看这个节目，脸立刻沉了下来，严肃地对我说：“马上关掉！在新加坡你让小孩子看这种恐怖片是犯法的！”我第一次体会到了分级制度。虽说在宾馆里，或许看到了可能也抓不到你，但是为了社会和谐还是存在着这样的法律，也应该遵守这样的法律。新加坡以严法著称，而中国呢？这样的事情也就是鸡毛蒜皮，获取证据又这么麻烦（想把每个人的存储设备或者收看记录调出来？），哪个部门愿意管呢？但是他们看不到的是，经过媒介传递的思想在观众的头脑中生根所带来的后果。 第三，文化贫乏，缺乏认同。在上世纪某事件之后，我们变得连自己的老祖宗都不信了，所以现在想花大力气重建国家的共同文化。要不是30年只产生了两代的断层，还有一些宝物（“家有一老，如有一宝”）没有失去，恐怕现在形势更严峻。（在没重建完成之前，各种领导人走访宣传谈“我们有共同的根基”什么的，那是玩虚的。所以湾湾将文化传下来了所以他们也在这件事上对我们抱有优越感。）反观其他国家，将自己的文化亲手葬送的，有哪些？就ZF所排斥的日本动漫，也无时不刻在宣传他们自身的文化（《怪化猫》、《鬼灯的冷彻》、《狐仙的恋爱入门》）。反观我们，宣传品中除了“高大上的新China”和喜羊羊之外，就见不到什么能代表真正的国家的根基的东西。（蓝猫之类的优秀动画已经绝迹；要说文化遗产的拯救，毕竟传承的人还是少了，只好做到使人警觉从而不断其血脉而难以发扬光大。）要说我们自己的文化究竟是什么？现在在推行国学的动画化——嗯，那是在家长们意识到了孩子思想塑造的重要性后，给幼龄儿童打思想预防针用的，并不好做到民族性与娱乐并重。为什么我们这一代还是有相当多的人喜欢看1998年版的《西游记》，或者2003年版的《哪吒传奇》呢？那是因为中国的动漫在此之后就没有多少实质性的进步了。没有进步，还要赚钱怎么办？这个简单，《喜羊羊与灰太狼》、《熊出没》、《巴啦啦小魔仙》、《铠甲勇士》，哪一个不是吸金利器？但是这些东西都教了小孩子什么东西呢？烤羊肉？我们自己做的东西，青少年的认同度并不高。综合第二点无分级制度，中国的动画只好做给小孩子看；那么冲动的青少年、已经安身立命的中年人有什么东西呢？他们面对的是一片荒漠。既然在国内找不到需要的东西，网络又这么发达，向外寻求便是必然。而长期在荒漠中的旅人，哪怕是见到一滴汽油都会想喝下去——所以即使是人家的糟粕在中国也有许多观众买账甚至认为是“神片”。（例如，新一代的中国观众“道路相告”的《东京食尸鬼》截至2015年4月18日的Bangumi评分只有6.7，第2138名，与其在BiliBili的高收视率完全不协调，这说明这片只是卖血浆博取噱头，并不获得hardcore的认同。另外，由于此片已经在BiliBili下架，原因见下文，因此无法获取详细收视率数据。）我们只有少数人能看到每一季度的精髓，而大部分人只关注卖座的动画，即使它没有实质性的内容——不过这些刺激也正好填补了他们空虚的心灵，以一种错误的方式。 第四，思想主旋律问题。中国历史上都是讲主旋律的，就是“听中央的话”，并不是“为了国家”——很简单，“统治者即国家”。所以我们不会出现明目张胆的批判行为，因为不允许，法律上和心理上。为了维持庞大的人口基数下的和谐，最好做的就是思想的统一化。所以我们知道，正义的魔法少女必定会打败邪恶的魔女，但是看不到她们最终成长变成魔女（这个故事最初想说明的是孩子的成长，这里借用了一下）——如果我们相信了，直到见到错误的结果之后才会发觉或许当初某个假设是有问题的，或许根本没有意识到那只是个假设。在这种思想的指导下，我们关注的是如何去维持这个系统，讲究如何成为螺丝钉去维持机器的运转。但是，我们缺少了对人的反思的表现，仅仅在那些送到茅盾文学奖的评审台上的纸张中出现是不够的！有人说，中国的动画片都是讲动物。早期中国还是有人为主角的动画片（《海尔兄弟》、《魔方大厦》、《大头儿子小头爸爸》），但是近年来以人为主角的动画几乎消失了，而稍微知名的《秦时明月》也不过是一个古装剧，讲的无非是侠义江湖。人性的深刻、自我否定，或者至少是折射社会、描述理想乡，近年来没有一部动画谈到。我之前的博文中讲到过，我不忍心去看《樱花庄的宠物女孩》，因为其描写和我的高中生活（我一介普通人，周围的都是高手中的高手，但是可以看到人与人的合作与创造，真正作为集体去完成一件“碾压”对手的事情，等等等等）太接近了。在看国产动画的时候，我倒是有一种疏离感，因为它们不知在描述何时何地的东西。电影是源于生活高于生活的，动画也是这样。像喜羊羊这种完全脱离了现实生活的动画，看了之后除了哈哈一乐根本就填补不了什么，也获得不了什么。让人笑让人哭并不是什么难事，因为那是人类的基本感情；真正有价值的，是能让观众从中学到什么。肤浅的动画，给正在成长的小孩子看，后果是什么呢？不敢描述人性，不敢描述多元化（至少是有限的多元化），只好整些魔幻的（似乎很高级的样子）、幼稚的东西以飨小孩子，反正他们容易糊弄过去，不是么？过几年是什么样，对不起，我们管不着了。不过这也是没办法的事情，在这种思维框架的限制下，我们不好去发问，因为不能去触动那敏感的神经，只好步调一致地饮鸩止渴。 在文化部整治暴恐动漫的第二天，我在食堂吃饭，看着中央新闻台。只见在关于某国产动漫展的介绍上，发言人说：“在当前崇尚外国动漫的情况下，本次展出展现了中国深厚的动画制作历史，让人们进一步认识国产动漫。”（大概是这个意思，具体说的什么忘了。）当时我就笑了。前面几个采访镜头都讲了些什么呢？是几位家长纷纷说这勾起了儿时的回忆（现场有上世纪六七十年代动画的底稿），然后表态说这些太好了，要回去给自己的孩子重温一下这些记忆。这同时也表明，近些年的东西，我们根本不敢拿出手；最终，只好靠着上一辈的记忆来挽回一些面子。落后至此，上面却还在沉迷于“国产动漫产业增长”这样的只注重产值而不注重价值的东西。要增加产值很简单，多做外包啊！你看ED里的演职员表，经常会出现中国人名的拼音（很好认）。但是，真能做到行业的顶尖的却没有——盛产建筑工，却没有设计师。没有核心技术，不断地在国内制造糟粕，难道真的是拉动经济的好方法？缺少了动画这一环，怎么实现动漫全产业的发展？ 说了这么多，可能要有人问，你有解决方案吗？答：姑且针对上面的问题提出一些吧。 第一，在孩童时代就做好价值观的铺垫，往后才引入娱乐。有人说，中国人幼儿园学小学的东西，小学学初中的东西，初中学高中的东西，高中学大学的东西，大学再回过头学幼儿园的东西。这句话的意思是，中国学生提前学了知识，可是没有在该学做人（形成正确价值观）的时候学做人。回过头再重新铸造价值观的模子，想想这不就是在流沙上建塔吗？一开始不教如何辨别是非，如何质疑，如何维持质疑与相信的平衡，在后期导致更多的混乱。形成的人如此，何谈制度？ 第二，建立合适的制度，例如分级。在技术上，无法保证不该被获取的内容被青少年获取，那么在制度上就要严抓。这一点要和上一点“塑造人”结合起来，同步进行。正确的价值观加上强大的震慑力，内外夹击。就像美国和新加坡。 第三，文化复兴与现代娱乐相结合。要找到一种途径，将中国的文化根基与新一代群众喜闻乐见的娱乐相结合。现在不再是那些下乡给田间的老农唱歌跳舞的文艺团唱主角的时代了，从1992年起过去了23年，逐渐开放、拥抱现代社会的新一代正在形成。他们是中国的未来，要有人将过去的八音盒和未来的钥匙一起交给他们，哪一样都不能少。这也是战略上的考虑。 第四，摒弃“动漫是低级的”这种思想，认识到动漫对思想传播的威力。动漫依托于媒体传播，同时和书籍一样，是可以承载思想的。因为许多人认为动漫是幼儿的玩物，只需要能引起小孩子的兴趣即可，所以没人会想将对人生的思考、价值观的宣扬等放在里面。当然，其中也有市场问题，这需要大众接受这个改变。我认为，既然都是媒体，那么就应该看其实质也即其传递的内涵，而不是这个载体的具体表现形式。昨天的实验课上同学X说找不到 MATLAB 的 Set Path（他用的是 R2012a，演示用的是 R2013a，而从 R2012b 开始界面由菜单变为 Ribbon）。虽然我也没用过 R2012a，但是我根据“完成一样的功能-布局必定遵循类似的规律”这样的思想，几秒就找到了 Set Path（在 Files 菜单中）。既然它们完成的功能是一致的，那么为什么要认为一个要劣于另一个呢，只是因为来源国不同？网络好像也不是中国发明的对吧，但是我们被迫接受了这个变革。一切要为我所用。 或许某天，当问到4月1日是谁的祭日的时候，大多数人能回答王伟而不是张国荣的时候，这个国家会更有希望。 索尔菊苣、PZ菊苣etc.：如果你们看到这篇文章，请不要问我为什么没提《四畳半神话大系》、《空中秋千》这些猎奇的东西……我没法看，没达到这个高度。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Thoughts","slug":"Misc/Thoughts","permalink":"https://blog.mottomo.moe/categories/Misc/Thoughts/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"动漫","slug":"动漫","permalink":"https://blog.mottomo.moe/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"在百度空间即将关闭时留念","slug":"zh/2015-04-08-Baidu-Space-Closing","date":"2015-04-08T14:10:00.000Z","updated":"2020-03-30T22:34:35.401Z","comments":true,"path":"categories/Misc/zh/2015-04-08-Baidu-Space-Closing/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-04-08-Baidu-Space-Closing/","excerpt":"","text":"这是今天博客园的新闻。 百度空间也要关闭了啊！于是花了一晚上将各种日志尽量迁移过来。排版什么的以后再说，内容先过来。 这倒是没什么好怀念的了呢，自从百度空间改版到响应式布局之后，定位就偏了，我觉得。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"我们的时代在远去","slug":"zh/2015-04-05-The-Era-Is-Fading-Out","date":"2015-04-05T11:51:00.000Z","updated":"2020-03-30T22:34:35.401Z","comments":true,"path":"categories/Misc/zh/2015-04-05-The-Era-Is-Fading-Out/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-04-05-The-Era-Is-Fading-Out/","excerpt":"","text":"上周例会结束后下午系统就崩溃了，某种东西发作将系统核心文件删除了。重装倒没花费多少时间，而且云服务也减少了一些我重新配置的工作。不过总觉得缺了什么。 我看着我们的时代在远去。我所做的，只不过是让它再维持三四年而已，因为还是有相当数量的人需要它。从2001年的最初的一代算起，持续了15年，还好吧。比我大几岁的也许更多地享受了这段时光。 去年的一系列举动意味着改革正在进行，当基础打牢了，就是上层建筑重新装修的时间了。固然，心里是有不服，或许只是冬天起床时刚开始感受到的寒风？想当年尽管这么多人哭天抢地，但是国企还是（至少形式上）打破了铁饭碗。逐渐减少依赖，是比较好的做法，我现在也是想这么做的。 我倒是不确信我们现在就富足到能支付那些今天我们所可以拥有的。不过我愿意再等待几年，如果措施得当的话，几年后也许能让国民“享受生活”吧。杨同学说：“如果10年后BT还存在，这个国家就没救了。”我同意，只要求他们不要在收取高得吓人的费用时候，提供着差得气人的服务，还在不断压缩着生存空间的同时说这是为了和国际接轨。 高中政治老师说过，“国富民强”实际上应该是“民富国强”，不能有了前半没有后半。希望这并不是鱼和熊掌。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"在 Windows 8/8.1 上安装 Visual Basic 6","slug":"zh/2015-03-19-Install-VB6-on-Windows-8.1","date":"2015-03-18T16:57:00.000Z","updated":"2020-03-30T22:34:35.401Z","comments":true,"path":"categories/Tech/Coding/zh/2015-03-19-Install-VB6-on-Windows-8.1/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-03-19-Install-VB6-on-Windows-8.1/","excerpt":"","text":"今天想起来 VB6 还没安装成功，想晚上能不能再试一下，安完。结果是我被狠狠坑了一把，还是一样的错误，还是一样的感觉。不过最终（部分地）解决了。 大多数人遇到的是根本无法启动的问题，是 ACMBOOT 的不兼容导致的。解决方案在百度经验上也有。 但是，我遇到的问题是：能正常运行，直到“正在更新系统”，然后就出现 svchost 和 setup 长时间占用 CPU，而磁盘 IO 为零的现象。（开始安装时时不时伴有无法删除/读取 vssetup.ttf 的错误出现。）可以强行结束进程，但是安装完成后 VB6 只剩下了最基本的东西，连 Active X 控件都无法注册，一般的 VB6 编写的程序都无法运行（字符串分配错误）。这样肯定不行的对不对。 这个问题的原因我猜不到，继续求助。在51CTO上看到了一篇文章，里面写着非常规解法一（不过无法卸载）。非常规解法二在 MSDN 社区 上，说是不要选中 Data Access 项。虽然安装成功完成，但是毕竟 Data Access 包含了 ADO 等 VB6 用来连接数据库的东西，而这些数据库访问组件是 VB6 精华的一部分——抛弃了这些，幸好我应该不需要写 VB6 的数据库访问程序，那些还需要的人估计要叫苦连天了。 另外遵循51CTO的文章的指引，找了一下 CodeSmart for VB6。我能比较轻易找到的是 CodeSmart 2013 for VB6 (63q5)。 知道无法添加引用的原因了。仔细观察一下相应文件的路径，我这里是64位系统，一些常用组件（ADO、Common Controls、Data Grid 等等）都在 SysWOW64 目录下，这意味着那些是64位的 COM 组件，32位的 VB6 无法访问。 看来，用 Common Dialog 之类的都是不可行的了呢，好多工程和软件都要废了。 再记：上面的结论有错误……现在可以引用……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"Visual Basic","slug":"Visual-Basic","permalink":"https://blog.mottomo.moe/tags/Visual-Basic/"},{"name":"Windows 8","slug":"Windows-8","permalink":"https://blog.mottomo.moe/tags/Windows-8/"}]},{"title":"移植！工作中","slug":"zh/2015-03-16-Porting-And-Working","date":"2015-03-16T01:03:00.000Z","updated":"2020-03-30T22:34:35.401Z","comments":true,"path":"categories/Tech/Coding/zh/2015-03-16-Porting-And-Working/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-03-16-Porting-And-Working/","excerpt":"","text":"为了应用需要，KeiSystem 正在移植到 Java。 从 C# 迁移到 Java 还是有不习惯的地方，虽然 C# 受到的最大批评就是“抄袭 Java”。看来 C# 还是相对优雅（如果 BCL 能小一点就好了）。话说从 VB .NET 扩展到 C# 的时候我也曾经觉得 VB .NET 好，所以当时的项目 C# 只用来处理 unchecked。现在我觉得 C# 如果写核心库不随便上 GUI 的话还是不错的，特别喜欢 unchecked、lock、unsafe 的设计。 刚上手不习惯的有： 没有 delegate，用内部类实现观察者模式实在是太不优雅了，而且 Callable 这种东西实现更困难了。 所有自定义类型都是 class，而且只能传递引用副本，不存在 ValueType + ref。没有 struct 意味着用类似值类型的方法交互时要不断地 clone()。 byte 是有符号的（陷阱！），所有基元数值类型都是有符号的（CLS 规定的值类型中，Byte 无符号，Int16/Int32/Int64 有符号，更符合习惯）。（注：SByte、UInt16、UInt32、UInt64 虽然在 C# 和 VB .NET 中可用，但是不符合 CLS。） 发生的异常未必是 throws 声明的，例如对 HttpExchange 的 getRequestHeaders() 进行 add() 实际上会触发 NotSupportedOperationException，但是 Headers 基类型没有显式抛出该异常。 封装类型（Integer/Long etc）和基元数值类型（int/long etc）不等价，而且封装类型之间不存在继承。bencode 库中我修改了对整数的解析（从 Integer 到 Long，因为 BEncoding 规范是如此），但是运行报错不能将 Integer.valueOf() 的结果赋给 Long——直至我使用不怎么友善的 Number 类型作为赋值类型才正常。 泛型类型擦除，都收缩到了 Object，再加上默认虚函数，导致 IEquatable&lt;T&gt; 这种接口实际上是不能实现的（IEquatable&lt;T&gt; 声明了一个 bool Equals(T) 的方法，C# 中通过自动插入类型+重载解决，Java 中会直接覆盖 Object 的 equals(Object)）； 动态类型变长数组创建不可能，Array.newInstance() 需要传递一个 Class&lt;?&gt;，但是 T.class 非法，所以难以获得 T 的类型（Hibernate 中似乎有方案，不过对于现在的我来说太复杂）。 今天去审查，保安很和蔼，出来的时候还问事情办好了没有。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"KeiSystem","slug":"KeiSystem","permalink":"https://blog.mottomo.moe/tags/KeiSystem/"},{"name":"Java","slug":"Java","permalink":"https://blog.mottomo.moe/tags/Java/"}]},{"title":"一周以来的剧变","slug":"zh/2015-02-28-Lots-of-Things-Happened-In-This-Week","date":"2015-03-01T14:09:00.000Z","updated":"2020-03-30T22:34:35.401Z","comments":true,"path":"categories/Misc/zh/2015-02-28-Lots-of-Things-Happened-In-This-Week/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-02-28-Lots-of-Things-Happened-In-This-Week/","excerpt":"一周以来的剧烈变化。","text":"一周以来的剧烈变化。 以2月19日大年初一为时间基准。某人以P代表。 初三本来计划是在今天离开爷爷奶奶家，不过鉴于表亲初三到，因此我们决定再留一天，初三晚上全家吃一餐饭，然后我们初四再走。我知道P会到，也知道P的一贯德行，预计了风险。只不过后来发生的事情超出了我的预料。 晚上表亲到了。当时我写了一些 EarlySping 的代码，然后玩红警2，正处于我将敌人小兵仔压着打的状况。P进来，看到我在玩游戏，问我这是什么。我回答：“是红警2啊。”他表示不知道。（由此可见，连游戏素养都不行的家伙。现在中国那所谓“繁荣”的游戏产业，带上的不就是这种货色？那些宣称“刺激”、“好玩”的游戏，无非是空壳，拉低中国人智商。）然后我给他玩了一局。直到后来他妈妈叫我将电脑关了要不他就无法自拔，我答应了。 后来就是饭后陪他爸胡侃。过程是怎么样的我就不评论了，无逻辑性可言。但是正如酒后（我第一次喝超过一抿的白酒，只喝了小半碗，不过意识是很清醒的，对身体机能控制正常）的胡言乱语，总是要有人叫好，我很清楚；总之算是熬过了这一段时间。 到我走到房间门口的时候，发现鼠标灯亮着！于是我就知道了，P动过我的计算机。但是从屏幕所对的窗玻璃上映照出的并不是我预计的登录界面的总体布局，而是暗一点的东西。到屏幕前一看，居然是启动失败，Windows 自动修复失败，原因是版本不兼容！奇怪了，怎么会启动 Windows 自动修复呢？而且，怎么会版本不兼容（6.0 无法修复 6.1，Windows Vista 无法修复 Windows 7）呢？关闭自动修复，重新启动——毕竟风浪也见过一点，就是以前强制中止修复，启动后无法再休眠，而且变得更好喝（更容易蓝屏）了。但是这次不一样，黑底白字显示的是无法启动，bootvid.dll验证失败。 你得知道，在爷爷奶奶家是没有互联网的。 我高三暑假的时候还破坏过办公室的计算机呢。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"除夕的杂谈","slug":"zh/2015-02-18-Lunar-New-Year-Is-Coming","date":"2015-02-18T06:43:00.000Z","updated":"2020-03-30T22:34:35.400Z","comments":true,"path":"categories/Misc/zh/2015-02-18-Lunar-New-Year-Is-Coming/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-02-18-Lunar-New-Year-Is-Coming/","excerpt":"除夕的杂谈。","text":"除夕的杂谈。 在回桂林的时候，想起来我很喜欢吃桂林米粉。我一般是要卤粉（不加汤，而是浇一些卤汁，加炸黄豆和猪皮还是什么的）而不是汤粉（加海带瘦肉黄豆汤）。每次回桂林的时候，都会去爷爷奶奶家楼下一家米粉店吃米粉。不过今年从时间上看来，是第一次回桂林而没吃米粉的了。哈哈。 从吃米粉想到我小时候吃蛋烧饭。在蛋炒饭上，我最喜欢吃奶奶做的。嗯，托这个，经过多次的失败后，我终于能从选米到出成品都了解透彻了。吃的时候，还要放少许奶奶做的辣椒酱。（现在爷爷奶奶年纪大了，酸坛子也没怎么腌，腊肠、辣椒酱也不做了。）我可要说，蛋炒饭不是随便炒一炒就好的，当你看到每一颗饭粒散发着赤金的光泽，颗粒之间分开，少量脱水给其带来的紧致感（我的胃好一点，能吃硬一点的食物）。就应该选用略粘的米（但不能糯），煮的时候放比标准少5%左右的水，接下来就是两阶段的翻炒。那真是人生的享受之一。要是做出的黏糊糊的，或者选用球状的东北大米，那就是灾难。在一年级还是二年级的时候，我就曾经一餐吃过8碗蛋炒饭；换言之，大约8两。老妈下班回来听奶奶说了，当即就说为什么让我吃这么多。（果然，肚子过了两天才好。） 和蛋炒饭联系起来的，两段记忆。 其一，我对EVA最早的印象。某次，也大概在一年级，或者幼儿园大班（我记得发生在804，这样的话当时还没搬到901，而小学三年级才从901搬到现在的家）——和EVA引入中国在电视台播放的时间点核对了一下（2000年起），应该是对的。某次吃着蛋炒饭看电视，上面播的就是初号机的暴走，撕开被打倒的敌人食用。后来受到索尔菊苣影响再看EVA的时候，才知道是第14使徒（Ep19)。这个场景给我留下了深刻的印象，导致我对“零号机”和“一号机”记忆深刻；只不过在记忆里的理解中，是一号机将暴走的零号机吃掉了……（PS. 记得以前看迎击第13使徒的时候背景放的是童谣「今日の日はさようなら」，但是在 EVA-FANS 的版本里找不到了。） 以前在吃饭的时候经常还能看到《星际恐龙》（Extreme Dinosaurs）和 Beast Wars（忘了中文名是什么）。前者，在我2012年左右找 Source 引擎的下雨特效时，在很偏僻的地方找到了一个以星际恐龙为角色的格斗游戏，基于 Source，而且还带有实时计算的阴影、雨雪效果（水实体的水面也会有相应变化！）。只不过那只是个 demo，似乎没发售，也没公开源代码，要不然真厉害。Beast Wars 我只记得里面两个场景，一个是白虎勇士因硬件损坏而不知道自己属于哪一方，通过争夺战确认自己属于正方；另一个是最后猩猩（队长）在很大的建筑物里飞，牺牲自己拯救了所有人。后来我还吐槽过，在我们还在给小孩子做喜羊羊的时候，人家十几年前都做出了多么高质量的动画。 过了今晚，就是雨水，同时也是正月初一。今年疼讯看来下了大本钱，和央视的合作比其他的几家（阿里巴巴、百度、新浪）多多了。 同时，我也反对推行一种文化时要用猛烈批判另一种的做法。这样做，和种族优劣论者没有什么区别，而且特别是在你们享受着现代文明的成果时却要灼烧培养西方科学的土壤。基督教的侵略性文化要提防，但是更进取的文化同样也让我们知道了历史的始终，而不是在下一个冰河期到来时，在这颗星球上苟延残喘。我么需要让人们知道两种文化的存在，而且要大家有理性的认识；要不然，光嚷嚷着返璞归真——好，国防的飞机大炮从哪里来？用弹弓吗？小农经济只能作为部分地实验，或者提供一个“再处理”场所，而无法适应整个环境。取各文化之精华并思考如何融合适应下一步的发展。因此，我不会和你们站队的，记住了。 李约瑟难题，我初步有了一个给自己的解答。 昨晚又做了一个不知所云的梦，至少我没能解析出这代表了我在想什么，或者预示着什么。 以前那个 Nokia 9310 XM 的几条记录。 2012年6月11日 8:30 在正门集中，毕业游。 毕业游的事见另外的日志。以后会搬到这里来。 2012年6月7日 高考开始！ 高考三天倒是没什么好说的，经过了一年的“磨练”我已经适应了做题刷题的过程——磨损了。宏观上的过程也见另外的日志。 2012年5月31日 向杜稼淳透露发情书计划。诶嘿 和谐和谐。不过此事最终没有发生，在没有告知任何人的情况下我进行了计划。（渣渣） 后来通过罗哲焜这条途径，事件结果就像分子一般扩散开来，虽然知道的人也只有少数。这些人很讲义气，没有继续外传，至少没有摆在台面上，要不然我就应该学习古人类住在山洞里了。 2012年5月14日 早上，早餐打卡，应打2.5，想抢在另一人前，结果3.2。正懊悔转圈，“体委我帮你打”。 我觉得上面这条记录将事件过程已经说清楚了。 我预计应该收2.5元，结果当大妈在机器上按出3.2的时候我惊呆了（因为卡里只剩下2.6元）。我忘了当时点了什么，应该是不可放回的东西。我也忘了为什么一定要买，也许是没剩下其他能吃的东西了。 我在高二上学期的时候担任过我所在的体育选修课（忘了是什么，似乎是散打）班上的体育委员，也就相当于那个小班的班长了，负责整理队伍。不知怎的，还挺受小班的同学的支持的。到最后，他们总是称呼我为“体委”，因为其实也不知道我的名字是什么，我也没主动说过。（也许是我做事的作风原因吧。再想想初一时作为英语课代表总是被于达对着干，人与人还是有很大的不同的嘛。） 2012年4月3日 单挑甄姬洛，张飞没出牌即被秒；我甄姬反装忠，司马懿主帮改判闪电、万箭，忠被殴，最终二反一主，反赢；主殴忠。主，最后内司马反诸葛互殴，最终主胜。 当天下午的三国杀牌局。 2012年3月28日 首次没有文明班集体 我们班从高一就开始每周都被评为文明班集体。但是在这一周的周三（3月28日）的集会上我们班第一次没有了这块牌子。回去之后班主任陆老师还在英语课上专门说了十分钟。 2012年3月10日 早上直视她 意义不明。估计和8日的记录有关。 2012年3月9日 宿舍同学帮助模拟面试 2012年3月11日是北航的自主招生的面试，一月我通过了笔试。由于以前没经历过这种级别的面试（奥班那时候面试挺随意的，毕竟连X条龙都过了），所以也不知道实际上是什么样子，只能依照以前在书里读过的或者电视上看到过的来想象。收到面试通知的时候就想着在快最后的时候做一点准备。我也不喜欢去找人，想着拜托宿舍的同学吧（虽然平时总是拿我开涮）。等着等着，总是说明天明天。 周五了，最后一个所有人都在的晚上。在熄灯之后我向宿舍的同学透露了我即将参加面试的消息。几个家伙说：你行啊！（此时瑞福、犀利哥和 New One 已经省一保送了，莫肥省二不过对高考很有信心，在杜文子后期搬进来之前只有我和莫肥非保送……想想这话，有点讽刺呵呵。）在我印象中，瑞福和莫肥都问了问题。中途犀利哥检查宿舍（宿委），听见说话还进来说“不要讲话”，听说是模拟面试时还“饶有兴趣”。 瑞福同学看到这里应该会问：“都问了些什么问题啊？”我只记得第一个是“说说你的优势”，其他的不记得了。 总之此次事件让我上调了宿舍评价指数……因为高中时总觉得生活学习一团糟，在宿舍里还要被耍，不开心。 在今年建模的时候瑞福过来，夜谈的时候聊起以前宿舍的事。我说：“以前我学习这么差，总觉得班里其他人都好厉害的样子。”以前语文和数学两科总是，前者找不到“答题要领”（我并不觉得那些“点”应该被划分成这么多），后者会出现各种错误。瑞福：“我们其实也没想过你学习的事情，没有看不起你，只是觉得你是我们班里的一员而已啊。” 2012年3月8日 小珂又睡在桌子上……单身万岁！ 呵呵。原本对人类还有期待的我真是太天真了。于是在高三下学期脱离了苦海。嘛，也不怎么想提这件事。至于其中记录的“又睡在桌子上”，是相对以前一次“睡在桌子上”而言的。以前这一次是有记录的。 结论：通过自我解析消化不安定因素，比多一个人要简单多了，而且可以少计算一个人的量的心理行动参数。 2012年3月5日 第三节下课我们分开了，我强制移位 王车易位？按照正常的位置变化，应该是从第4排移到第5排，第一排两张并排的桌子是空的（王力汉和黄秋实，去参加数学集训队了），保持在第一排。不过我看到了后果，就强制移动到第一排，主动和一张空桌子坐。另一张就换到了原来的我的位置。周围的几个人（叶婧、李梦瑶、邹小珂、黄宇阳）都不知道为什么我要从这里离开，问我是否确认这个动作。我当然是决心已下，更愿意在旁边放一张空桌。事实证明这次的选择是正确的。 后来集训队的那群人回来，王力汉和黄秋实看到分开的位置很惊讶，不过还是讲了一下，王力汉就在我这里，黄秋实到邹小珂旁边——刚好神通秋是走读生而且一般不带多少书，有剩余空间，就互惠互利了。 我将坐在旁边的状态视作一种契约（contract）。所以在这个意义上，我挺对不起杜稼淳和吕源堃的。前者尝试失败了，后者尝试虽然短时间成功但是终归失败。我还太年轻，没有认清这些事物的本质。身外皆空，其是也。村长高一曾经在旁边的时候戏谑过：“你这人真是‘见色忘友’啊，呵呵。”（在靠第四组——西边的窗——的时候，我在外面一列，就是远离壁柜的一列。当时应该是在第3或4排，由于这个位置中不溜秋，而且靠壁柜的通道比较窄，所以一般坐在靠壁柜的人不想通过壁柜过来，而是想让我往前移动一点，从我背后过去。当时杜稼淳在我右手边，就是西边，李梦瑶在正后方，邹小珂在右后方。每次村长要进来的时候他会拍我的背，然后说：“我要进去，让一下啦。”一般情况下我会逗逗他，说：“不让。从前面自己过去。”他要不然就强制把我往前推，“开辟”出一条通道，要不然就绕路，有时候我在他往前迈步子的时候让开。邹小珂有时候也会提出这样的请求，我和女生可玩不起这种游戏，直接就让了。村长看到这种“差别待遇”，不禁仰天长叹评论了上述的话。）结果一语成谶。后来杜稼淳和罗哲焜组成了紧密的联盟，吕源堃忘了和谁（堃大师我以后要问你这段历史），我则成了孤魂野鬼，直到王力汉来了情况才有所好转；但是观察发展曲线，我错过了两个潜力股，以及同路人。这警示我们，要认清谁是朋友，谁是敌人。 最后，放鞭炮的家伙，你们真的很烦啊！从下午四点就开始，我戴上耳机耳膜还是要破了，更别提那些二氧化硫总往屋子里钻的事情了。在旁边还有输电线，还有车辆，搞不好就出事你们脑子不想想么？鞭炮声属于无规则的声音，干扰听觉和心智，注意点为好。 18:10，开饭。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"初一的杂谈","slug":"zh/2015-02-19-Miscellaneous-of-02-19","date":"2015-02-18T06:43:00.000Z","updated":"2020-03-30T22:34:35.400Z","comments":true,"path":"categories/Misc/zh/2015-02-19-Miscellaneous-of-02-19/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-02-19-Miscellaneous-of-02-19/","excerpt":"大年初一的杂谈。","text":"大年初一的杂谈。 今天摘桔子、拔萝卜、拔元须（我们这里也称之为香菜，当然不是北方所谓的香菜）、挖芋头、炸糍粑、做糖醋鱼（首次在油滚烫的时候我没关小火，柴火哪有“关小”一说），再次做花生糖。 赵伯伯这一家十分热情。据爷爷说是当初他们家有困难的时候，爷爷奶奶帮了一下；现在逢年过节总是送东西过来。呜呼！现在他们家如此兴旺，对人友善记恩是关键因素吧！情至如此，我都不好意思了——爷爷奶奶种下的种子，我怎么好现世就乘凉呢？我现在所能做的，除了在准备的时候帮点忙之外，就是祝愿优秀的道德能够传下去以荫后人了。 记录现象 某甲游于市，见二人博戏。其一人曰：“吾可驭烈马，信否？”曰：“汝可信乎？”驭毕，众人叹惋。某甲语于一童子曰：“初，吾思告之须信矣。”某甲憩于舟。后记：这虽然逻辑上有点莫名其妙，但是是记录今天的我认为某人（老妈）做的很违反常理的事情。&lt;/span&gt; 在大年三十的时候，我正在爷爷奶奶这里。这里没有有线网络（你想想，两位老人住在这里为什么需要装有线网络），而我是智能手机的一贯反对者（所以没有微信），用的手机QQ（Java 通用版）无法连接到服务器，囧。本来想给食物群里的各位发送节日问候的，毕竟是加入漫版后的第一个春节，结果变得什么都做不了。没办法，想想解决方案。在花园上我和其他所有人都是通过帖子或者站内信联系，食物群里的人还能通过群联系；但是现实中我并没有联系过他们。突然想到在伦查会送台历的时候，我这里是工口壕来送的，当时我PM时告诉了我的手机，送来的时候接到了电话。想着以后可能还能联系，我就保存了这个号码。没想到这么快就用到了，工口壕是我此时唯一能联系到的花园上的人。我尝试着发送了短信，请壕将话转到群里，不料他依赖自动登录所以忘记了QQ密码，于是将我的手机号码给了PZ。后来PZ在群发祝福短信的时候我收到了，再跟PZ说了一下这事，请PZ代发。（最后如何不知道，回去的时候聊天记录应该会爆满所以查不到。不过我相信PZ。）最后处理这事的时候，已经一点多了。 今晚十一点多的时候，工口壕又发来一条短信，问我有没有和PZ联系上。我回复联系上了；他然后还“补上”了新年祝福。（按照他的话是“补上”，不过昨天那么麻烦他他已经是送上了很深的祝福了啊！） 工口壕人真不错。作为版主（和技术宅？）很够格，从这次事情来看为人处事也很周到。好人哪！回到对岸之后工作生活也会顺利的吧！ 关于滑雪场&amp;农村的事情，先在这里留一个存根（stub），以后再写。 顺便，瑞福，之后的众人小传我只会挑我接触得比较多的人写了。 樱花庄反映生活真实到我不敢再看。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"继续各种东西","slug":"zh/2015-02-13-New-Breeds-Since-02-04","date":"2015-02-13T06:43:00.000Z","updated":"2020-03-30T22:34:35.400Z","comments":true,"path":"categories/Misc/zh/2015-02-13-New-Breeds-Since-02-04/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-02-13-New-Breeds-Since-02-04/","excerpt":"2月6日到2月10日之间在建模，于10日晚回到家。以下是杂谈。","text":"2月6日到2月10日之间在建模，于10日晚回到家。以下是杂谈。 A friend to all is a friend to none. 在2011年portal吧的内部事件发生时，我们一群人在其中斡旋，最终稳定了事态。在此之后我和黄土黄&amp;姐夫双方的关系都还可以。（现在姐夫还在p吧，不过由于我基本上不去贴吧了所以就没怎么说话了；黄土黄的话，严重跳票的模组开发……） 现在我又夹在两种思想之间。想想保守党内部出了激进党是什么情形。动漫&amp;传统文化，西方科学&amp;佛道，这两组矛盾都在将我撕裂。在中国，可没有说“宗教只是道德守则，科学工作者可以是基督教徒”这样的环境。前二者不能共得，在一方研究深入必定无法兼顾另一方——这是我亦或是长辈之间的选择。索尔的经历告诉我们，多看书学习哲学，加上解析动漫产业&amp;制作过程，也是一条明路。 但是，无法一直处于中庸；到最后只会是四不像，无法被任何一方接受。不想再这样了。学术上可以跨学科，思想上要跨界真是太难了。人都想要排斥自己不认同的东西，但是多数人并不尝试去分析，太可怕了。不过上世纪中的中国科学大师能做一些平衡，要学习他们。 回家的高铁上看到高铁的介绍片中有数据说高铁用的输电线抗拉强度达到 560 MPa，“是普通列车线路的两倍”。但是一直没想明白片中的“铜镐铬”到底是什么。刚才查了一下，找到了百度百科的一个词条“铬镐铜”。但是你看外文名一栏，明明写的是“CuCrZr”啊！至此我终于知道那是什么东西了。是铜(Cu)锆(Zr)铬(Cr)！而且这错别字还不止在一个地方出现…… BRT 发生了不少变化。例如石牌桥站那莫名其妙的地上通道被转移到了地下，岗顶站有了带灯的顶棚；立交桥附近的楼也发生了变化，连汽车展销厅都来了。 于是想起两件事，坐过站，和手提袋的故事。以后有时间再说。还有一年来的三次建模。 推完了 Melty Moment 夕花线的一条。它给我的感觉就是，剧情基础比前两个作品要平淡，日常上也少了一些东西。毕竟组织活动是我所不擅长的也不喜欢干的事情，而本作一切都是依托于这个活动（文化祭）的。虽然说是らっこ的隐退的作品，但是除了原画质量高外，剧情线上更倾向于真实性了，少了我所期望的 HOOKSOFT 的稍稍非现实的纯爱。由于诸多文字只是读+听来的，语法啊惯用语啊还不知道，因此估计也就是真实理解10%其他连蒙带猜的水平。KDays 上有两条线的评论，不过这两个我都不喜欢所以也不打算去通。 最后想想，HOOKSOFT 近年来的游戏，都有不错的系统呢。（SN 中搞笑的 PIT BBS，LQ 中的 RTC 系统，这次的时间推移系统……不过就是 YukaScript 换到了 BGI 了。） 昨晚看 ISUCA（＜イスカ＞）的时候，里面为那只猫又取俗名。真名是“玉”（タマ），取俗名二货男主居然取了一个“玉子”（タマコ）！在 ISUCA 的世界观里，那些妖怪被叫出真名的时候就要听命于叫出真名的人（怪？）。幸好妖怪被收服一遍而且主人还活着的时候不会被二次收服，要不然请想象一下以下对话。 男主: 就决定是你了！去吧，玉子！ 玉子: 喵！ 敌人X: 什么？玉子？（注意，「タマコ」的前两个音节就是「タマ」，为其真名。） 玉子（对敌人）: 新主人确认。 完了。我说你们难道不知道 GNU is Not Unix 么？这是典型的递归命名梗啊！ 2月15日：今天风水先生还真厉害，2013年的事情是对了……2011年是哪个？XK？不像。另外，今天才知道“命里是三兄妹”；我是老二，另外两位应该是因为计划生育没了。说到这里的时候，老妈是这么样的：“在你之前，我和你爸怀过一个，不过后来嘛。”看来就是没了。先生说我前面那位是姐姐……莫名有点小期待呢。（姐控？）祝好。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"2月3日随感","slug":"zh/2015-02-04-Thoughts-Of-02-03","date":"2015-02-03T17:56:00.000Z","updated":"2020-03-30T22:34:35.400Z","comments":true,"path":"categories/Misc/zh/2015-02-04-Thoughts-Of-02-03/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-02-04-Thoughts-Of-02-03/","excerpt":"人会淘汰做梦的个体。出人头地、升官发财那只能叫渴望（desire）。 也难以责备，因为这是由我们所体验到的世界的物质性决定的。 椎名ましろです。So are the OpenSSL team members. 今天开推 Melty Moment。就着假名，语音与一些常听见的短语/词组，以及一些观察到的语法现象，试着直接推生肉。为什么不用机翻呢？主要还是觉得机翻破坏了窗口的整体性，还不如自己加把劲尽量学。有一些念出来，加上汉字（这些汉字我肯定只见过部分音读和训读）和一些见过的定型文，正常对话还是多少能理解一点。（要再写出来就困难了，还没建立好这个映射。）一些麻烦的，例如古文老师上课说的那几句话，与现代日语不一样，就难理解了，要学。 推到共通01晚的时候，冒出了一个没见过的词ラジオ，读来读去也不知道是什么。（之前居然还按读音写对了一个ノスタルジア nostalgia，囧。）谷歌一下，原来是无线电（radio）。这下就不知道是这个词是从哪里来的了，猜想是德语（没学过德语，不知道）。据以前群里菊苣讨论テーマ（主题）一词是从哪里来的，后来懂德语的PZ菊苣说应该是从德语 thema（主题）来的，令我印象深刻。 在搜索的时候，点进百度百科的“日语”词条，又发现了“黏着语”，从而又知道了“分析语”、“综合语”和“屈折语”。然后返回继续看日语的大概构成。对语言学的认识又多了一点，看起来很有趣的样子。 不知道朱教授是否是这么想的。也许他认为，我们会察觉，甚至主动去学习英语的本质，到语言的本质吧。或者这是一个副产品。无论是哪一种，至少结果是好的。致哀。","text":"人会淘汰做梦的个体。出人头地、升官发财那只能叫渴望（desire）。 也难以责备，因为这是由我们所体验到的世界的物质性决定的。 椎名ましろです。So are the OpenSSL team members. 今天开推 Melty Moment。就着假名，语音与一些常听见的短语/词组，以及一些观察到的语法现象，试着直接推生肉。为什么不用机翻呢？主要还是觉得机翻破坏了窗口的整体性，还不如自己加把劲尽量学。有一些念出来，加上汉字（这些汉字我肯定只见过部分音读和训读）和一些见过的定型文，正常对话还是多少能理解一点。（要再写出来就困难了，还没建立好这个映射。）一些麻烦的，例如古文老师上课说的那几句话，与现代日语不一样，就难理解了，要学。 推到共通01晚的时候，冒出了一个没见过的词ラジオ，读来读去也不知道是什么。（之前居然还按读音写对了一个ノスタルジア nostalgia，囧。）谷歌一下，原来是无线电（radio）。这下就不知道是这个词是从哪里来的了，猜想是德语（没学过德语，不知道）。据以前群里菊苣讨论テーマ（主题）一词是从哪里来的，后来懂德语的PZ菊苣说应该是从德语 thema（主题）来的，令我印象深刻。 在搜索的时候，点进百度百科的“日语”词条，又发现了“黏着语”，从而又知道了“分析语”、“综合语”和“屈折语”。然后返回继续看日语的大概构成。对语言学的认识又多了一点，看起来很有趣的样子。 不知道朱教授是否是这么想的。也许他认为，我们会察觉，甚至主动去学习英语的本质，到语言的本质吧。或者这是一个副产品。无论是哪一种，至少结果是好的。致哀。 也许我希望找的人是一个能陪我看星星的人，不认为这个想法是可笑的，而是就是那么一起仰头看星星。——至少这几天能看一些；数量比三四十年前是少了，但是，即使就是十几二十颗，在深蓝中还是显得十分美丽。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"还在看 KiriKiri 2 的文档的时候，想不到 KiriKiri Z 都出了","slug":"zh/2015-02-02-Found-KiriKiri-Z","date":"2015-02-01T20:29:00.000Z","updated":"2020-03-30T22:34:35.399Z","comments":true,"path":"categories/Misc/zh/2015-02-02-Found-KiriKiri-Z/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-02-02-Found-KiriKiri-Z/","excerpt":"","text":"快期末的时候想了好久没想明白简单的继承链该怎么做（我想的方法可能时间开销大）。今天又想起来看看 KiriKiri 2 的一些东西。从文档入手，主攻 ITJSDispatch2。因为设想要在 .NET+MonoGame 上实现，那么要考虑目标的特性，如何迁移之类的。看到文档里有一个没见过的数据类型（在 TJS 中好像也没见到）Octet，据描述是字节数据，但是没法想象是什么。百度，输入“TJS Octet”，第一个结果就是贴吧上有人问“关于吉里吉里Z。贴吧有大神来研究吗”。 天啊，在我没意识到的时候，W. Dee 果然朝着跨平台国际化的方向一直在走（看记录推测为何如此更新），而且已经在 GitHub 上开了一群 repos 了！看更新记录，TJS 的语法好像有点变化，先看 YACC 的那个再说。同时，从上面的记录中也可以看出，KrKr 的类信息（函数、属性等）也在不断变化，相当于基础类库在变化，对应地底层实现也在变化…… 这么多变化，我赶得上吗？从 KrKr 的模块化程度看，其实只要那群人想，随时都能实现基于 Qt/wxWidget + SDL 的通用方案。那么我还能做什么呢？重复造轮子？呵呵。用 MonoGame，本身还一堆问题要克服呢。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Lovely Quest Stuff","slug":"zh/2015-02-01-Lovely-Quest-Stuff","date":"2015-01-31T17:49:00.000Z","updated":"2015-01-31T19:08:00.000Z","comments":true,"path":"categories/ACGN/zh/2015-02-01-Lovely-Quest-Stuff/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2015-02-01-Lovely-Quest-Stuff/","excerpt":"","text":"上个学期玩了 Strawberry Nauts，选了穗海和橙子线。后来23024又发了 Lovely Quest，通了八乙女线（为什么选这个？开始准备选綾花的，中途觉得这个家伙比较有趣）。 几天来为了排解 KeiSystem 的编写的劳累（累什么啊，到工作的时候肯定更累），想起快期末的时候重新装的 Lovely Quest（之前给 COD6 腾硬盘卸载了），继续开始。 这次就遵从初次的意志，直接选了綾花线，认真玩了一遍。グリザイアの果実选天音，这里选綾花，难道是姐控属性？通了之后，本来对epilogue不是很满意，不过想想，这在现实的角度还是一个非常不错的结局，除了——更现实一点的话，綾花比你大一个年级，早毕业一年，这如何解决，在尾声中是刻意不提了吗？ 然后是 Aino。嘛展开是很正常，但是里面提到的外语和一些（日本）风俗和其他线真不是一个数量级的。 最后回过头看，这些事件用一句话概括，就是邻家奶奶老当益壮强制送助攻，还附带人生哲学开导（5条线5个原理，都在第最后一节）。嗯。最喜欢的还是綾花线。 03:01 补充：刚看 Absolute Duo（为什么要看这种快餐？）的时候，女主答应了一句“ya”，我第一反应：瑞典语，在 Aino 线不知听过多少次…… 看完了 Working!! 的两季，再看奈亚子，理解了“找店长”一段的梗，与“台词被抢”的梗。仔细想想阿澄佳奈的声音基本属性不变，但是还是有点角色不同而不同？脑洞大开想起当时一句话，“新郎不是真寻”，是否也应该可以说“新郎不是小鸟酱（小鳥ちゃん）”呢？（笑） PS. 不正确。如果下这个结论，表示没认真理解剧情。","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"这几天的 KeiSystem 更新","slug":"zh/2015-01-29-KeiSystem-Upgrading","date":"2015-01-29T14:35:00.000Z","updated":"2020-03-30T22:34:35.398Z","comments":true,"path":"categories/Tech/Coding/zh/2015-01-29-KeiSystem-Upgrading/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-01-29-KeiSystem-Upgrading/","excerpt":"","text":"继1月25日发布了之后，将 KS 放到了花园上进行实验。但是实验中发现有几个地址看起来很合理的客户端无法连接。 后来在群里问了lan姐，她说：“你都是本机识别地址的么……” 现在的方案是这样的。于是采用了她提出的让接入点报告源客户端端点的方法，在客户端接入网络的时候读取源端点并告知连接来的客户端。 但是这样又出现问题了。这样理论上可以兼容通过路由器上网的用户（因为端点是外面告诉它的），但是实际测试中，直接连接到校园网的客户端无法向“理论上的”通过路由器连接校园网的客户端的“外在”端口发送消息。这就更蛋疼了。 查阅日志，发现这个地址和端口是动态的。怎么办？ 想起当时还问了lan姐一个问题，为什么我们能直接使用 μTorrent 报告的端口，即使通过路由器连接？lan姐回答说：“UT的端口是用 UPNP 和路由器协商的。”嗯，那好，咬咬牙也干上 UPnP。找到了一个比较好的 UPnP 操作库，添加了 UPnP 功能，调试。基本上可以通过支持 UPnP 的路由器了。美中不足的是该库内部使用的是 COM，而不是用 socket 做 UDP 通讯这样的原生方式，所以跨平台比较麻烦。而且加入 UPnP 之后，和设备通讯的超时还要考虑在内。同时，现在的操作模型也要发生变化……能用是能用了，就是更复杂了，即使我已经尝试最大化地保留原有的框架。另外，有 UPnP 的规范在手，改日实现纯粹的原生 UPnP 支持…… 原来25日说晚上应该能好（只想过连接点告知），到弄到现在还有这些限制，以及晚上如果有机会的话要进行三机调试（路由器-路由器直接传输），真是累死了。现在喉咙疼，发热，还不怎么想吃东西，作息也整个乱了……测试通过了之后才会往花园发布测试，然后才会上传代码，所以要等一下。初定是rev3（所以说rev2到rev3这个过程中间发生了多大的变化）。 啊村长你就过着光彩照人的生活吧……我没有你这么耀眼……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://blog.mottomo.moe/tags/%E4%BB%A3%E7%A0%81/"},{"name":"KeiSystem","slug":"KeiSystem","permalink":"https://blog.mottomo.moe/tags/KeiSystem/"}]},{"title":"KeiSystem rev2 已经上传到 GitHub","slug":"zh/2015-01-25-KeiSystem-Published","date":"2015-01-25T13:20:00.000Z","updated":"2020-03-30T22:34:35.397Z","comments":true,"path":"categories/Tech/Coding/zh/2015-01-25-KeiSystem-Published/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2015-01-25-KeiSystem-Published/","excerpt":"KeiSystem 的首次发布。","text":"KeiSystem 的首次发布。 KeiSystem 是我为了克服花园BT功能不开放问题而提出的一个解决方案，目标是实现分布式的、完全处于内网的、只支持 IPv4 的 tracker 网络。这个项目的 repo 可以见这里。第一次上传的是 rev2，目前还处于原型阶段。 虽然这个系统的局限性比较大（设计如此，同时考虑一些技术问题），但是对于学校内的环境，这是很适合的选择。（举例，为什么 TPB 不使用这种方案，而转投磁力链接呢？因为它处于公网，要照顾处于内网的用户就不得不用穿透，而且用户上线不能保证。） 考期一直是处于双重工作状态呢。从1月12日立项，与lansure讨论了细节（最后我们决定做两套系统了，总觉得有点像 F-35 抢单www），断断续续到22日第一个原型（即 rev0）编译运行成功，也有快两个星期了。 感谢： 花园关闭初期，讨论过技术问题的：剑魄、lansure。 在 GardenTracker 时代（已停止开发），测试的小白鼠：FC#38，LH#27。 在 KeiSystem 时代，测试的小白鼠：Yooyi、白写。 以及在 tracker 替代群里潜水的各位…… Bug 应该还比较多，我尽量写好吧。 更新记录 rev1 修正连接时解码数组长度错误，修正迭代器失效问题 rev2 修正错误添加μT端点的问题（这个错误原因隐藏得够深的）","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://blog.mottomo.moe/tags/%E4%BB%A3%E7%A0%81/"},{"name":"KeiSystem","slug":"KeiSystem","permalink":"https://blog.mottomo.moe/tags/KeiSystem/"}]},{"title":"1月22日杂谈","slug":"zh/2015-01-22-Exams-Are-Completed-And-Other-Daily-Things","date":"2015-01-22T18:45:00.000Z","updated":"2020-03-30T22:34:35.397Z","comments":true,"path":"categories/Misc/Records/zh/2015-01-22-Exams-Are-Completed-And-Other-Daily-Things/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2015-01-22-Exams-Are-Completed-And-Other-Daily-Things/","excerpt":"考试完毕，自己的历史，最近和即将要做的事什么的。一点都不多。不多不多。","text":"考试完毕，自己的历史，最近和即将要做的事什么的。一点都不多。不多不多。 随着最后一门——液压的考试结束铃声响起，三周的考试周终于结束了。本学期考试如下：机电控制工程基础、制造工程基础(2)、电机与拖动控制、模拟电路B、机械设计、数字电路B、流体力学与液压传动，外加3门选修课工业工程原理与应用、设计概论、数据库原理及应用。液压是在今天上午8点开考的（时间2小时），为了这早上一门，虽然昨晚复习到3点，但还是定了一个5点的闹钟。5点闹钟响起的时候，我记得这事，从床上坐起来，但是眼睛怎么都睁不开。于是接下来一个小时就处在这种让眼睛睁开和眼睛睁不开的恍惚中，直到晓鸣的6点的闹钟响起。反正他是下床开灯看了一会的，我还在床上翻滚着。到了大概6点14分，实在不行了，只见对面灯光灭了，我索性定了一个6点半的闹钟。当6点半的闹钟响起时，我好像掐了（不记得了）。下个时间点就是怂冲入我们宿舍直接开了日光灯，6点42分。怂大喊“大家都起来啦”，然后去拍每个人的床（黄晋国的床有床帘，在怂揭开拍晋国的时候我确信听到了一记拳头落在肚子上的声音，由内而外的）。在这声音和日光灯的作用下，大家立刻就醒了。嘛，我还是躺在床上过了几分钟，让眼睛和血压适应环境，再去刷牙洗脸去考场的。 今天在博客园上看到一则题为《不要轻易在简历上写我热爱编程，我热爱学习》的新闻。其中有一段是这样的： 95 年的时候，我高中同学郭军买了一本 Borland C++ 手册，我们两个人此后两年没机会碰真的电脑，没见过 Tubro C 更没见过 Borland C++，生看这本书，看了两年，百看不厌。做不到，别轻易说，我热爱编程，热爱学习。 这让我想起了我与代码的开始。初一的时候听说初二要开始学编程，就在初一的暑假往购书中心跑了一趟。当时我什么也不知道，只会玩小游戏，以及使用 Office（嗯，其实现在再看看五年级时给自然课和数学课做的演示文稿，流程的安排、交互和界面设计综合，已经超过不少人了吧）。在书店转了一圈，看看许多语言都是好复杂的样子。突然间见到一个图形化的东西——那就是 Visual Basic。（为什么不是 Delphi 呢……话说其实后来初中的时候老师还教过一点 Delphi/Lazarus，不过还是觉得操作上没那么直观，所以一直没学好。） 也忘了怎么样选的，当时买了两本书，一本是《Visual Basic 编程实例入门与提高》，另一本是《Visual Basic 系统开发实例精粹》。 当时因为老妈怕我管不住自己（玩游戏嘛），从小学一直到高一之前一直都不许我自由使用计算机（使用必须申请）。初二初三这两年是管制最严格的，几乎就没有摸过机子，有使用的机会那也是工作用，在我印象中只有一两次来常识性地写代码。此时还是严格按照书上写的做的呢，创建窗体，拖放控件，设置各种属性，甚至字体也要同样设置。而后根据书上的例子，写了第一个程序——ASCII 字符对照表。在初二这一年，基本上就是这两本书陪着我。在几乎无法实践的情况下，我将这两本书摆在枕头下，睡觉前如果有精力就看一看，一遍又一遍地啃着里面的每一行字（因为刚刚接触，不了解），一边在脑中根据书上的代码注释和图片想象着运行的情况——就像是想象粘土造人一般，一边赞叹它的神奇。在这两本书里，给我思想上影响最大的是《入门与提高》，我仍然牢记前言中“一定要不断改进代码，即使你的版本号到了99.99”的这句话；《实例精粹》那相当于一个代码库，就是有什么需要，如果有一个例子，可以去分析解明，再改造以适用于实际环境这样的东西。 到了初三，分班考中我惨败，必须参加中考，同时也让“如果进一班就可以得到一台新电脑”这样的期望落空了。这一年，在我的印象中，虽然比较苦，而且要和新同学一起只度过一年（想象一下将生油突然倒入热锅，在断生之前又突然倒掉的感觉），但是还是挺欢乐的。在这一年，我去过几次购书中心，一般是为了买一些教辅。但是选完了教辅，我就跑到IT区，在 VB 分区看各种书，看到各种书上的代码和实例，尝试去理解去记住这种“模式”。这样常常在中午去购书中心，晚上六七点才回家，中间四五个小时都是在这些代码中。我也让老爸老妈买过几本 VB 的书（我对于想要的东西一般不会好意思开口，所以每次嗫嚅“爸/妈，能不能……也买这本”的时候，都有很大的心理压力），是几本很厚的、关于控件与常用代码段（实例）的（好像是人民邮电出版社吧）。看着看着就发现那些应用性的代码中有许多的共同点；追溯到小学二年级，我也发现英语的一些词汇写法和发音是有联系的，例如“(辅音)a(辅音)e”模式。然后就觉得，到这里是一个顶点了。（其实，要继续研究下去的话，Hardcore Visual Basic 是一个不错的选择，那真是将 VB 发挥到极致。） 所以看到那一段“两年都没机会碰真的电脑”的时候，我大笑：我不是也经历过嘛！所谓“传奇的两年闷声积累”，23333333 题外话1，关于 BASIC，Dijkstra 曾经说过： It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration. 这一句话如此之有名，甚至 Wikipedia 的页面上专门将其核心列了出来：“Dijkstra also strongly opposed the teaching of BASIC”。（引用自 Dijkstra 的演讲 How do we tell truths that might hurt?，原文见这里。）这句话也常常被用来鄙视那些学习 VB 的人。（拜托，从 BASIC 到 Visual Basic 6，是有许多进步的！） 但是，我想用我这个例子对已经西去的 Dijkstra 老说：您的“practically”用得真是恰到好处，您也相信着例外的存在吧！ 题外话2，搜索的时候看到了一篇博文，由此转到了另一篇博文。看完之后顺便浏览了一下作者的其他博文，狂傲书生气很重，而且看文章那是肚子里有东西的人，虽口出狂言但如果听者也有积累就会觉得有嵇康之感。顺带说一句，我们大学开 C 语言课用的就是后面那篇文章中提到的书。在上这课之前我自学过 C，也看过、写过一些代码。看到课本的时候我还说为什么前面的那些章节都要将所有的定义（结构体、函数原型、常量）都要放在main()中——在其他地方几乎见不到这种写法，而且也违背了可见性的设计。惨啊，同学们基本上是没学过编程的，于是第一，他们的对编程的理解就被限制在了“C 语言”中（其实不止他们，现在很多大学生、硕博士甚至讲师教授都有这种错误的概念），第二，他们对 C 语言的理解和代码风格被这本书坑了。要谈入门，肯定是要看老美写的那些啦。 好，回到正题。 随着高一的计算机解禁，实践的机会变多了，于是就开始自己想东西自己写程序，逐渐接触了第三方/自定义控件、Declare 调用 Windows API 等等，也认识了 MSDN。后者更是我初次见到 C 语言的跳板——因为一些书上写明了同样的 Windows API 的 C 样式声明与 VB 样式声明，借助已有的 VB 知识和书上讲的一些东西我可以部分推断出 C 的皮毛。高中三年就是这个阶段。出了成果的东西，有 Teamwork（辩论赛计时器，高一下学期）、为了网资部宣传视频写的一个程序（为了实现我当时难以制作的黑客帝国特效，通过简单代码控制界面，然后用截屏软件录像，高二上学期）、自动化演示文稿控制程序（本来是用于美术课的，结果出了配置异常崩溃了，那场面混乱的；修改后用于一次语文课的课前演讲，高一下学期）、自动对成绩列表排序并按照学号对号入座（让老师1秒完成了其他老师要干一天还容易出错的活，高三上学期，用 Excel 的 VBA 宏）。没出成果的有一个按要求排座位的程序（当时我只会用循环，还不知道各种优化算法，想想看到某人展板上写做了一个“基于遗传算法的座位安排程序”的时候，我还真以为是输入遗传数据呢），因为太复杂而且在纸上模拟得到在特定条件下会死循环而且我无法通过程序识别这种状态的这个结果，我最后放弃了。其他一些过于超前（远远超出自己能力）的东西还有 PHP 智能编辑器、桌面小工具的动态代码执行、自己的浏览器、自己的富文本编辑器（自己处理、绘制哦）、学习成绩的记录评估展示（这个点子是村长出的）。后来还是用了一点，例如：2011年新年给博导（zalazan/△AX，William J. Huang，www）的贺卡中改动了一个用 GDI+ 实现 Aero 效果的程序，让它加载、展示我想要的东西；2013年，在为 mod 队伍写安装程序的时候也用了 VB，做出一个界面不错而且不用第三方控件的安装程序（但是打补丁太麻烦，所以 hth 最后还是用了 NSIS）；2009年的广州市创新大赛和2010年的明天小小科学家，我写了一个开链烷烃的结构分析程序（灵感来源于 ChemOffice 的分子自动排列），结果给一位教授看的时候她问我学过数据结构没有，我说没有，她拿出一本数据结构的教材说你实现的不就是一棵树嘛，中间用到了一个自己写的栈（但是我毕竟不知道什么是树什么是栈啊，只是觉得要解决计算问题就要设计这样一个结构而已）。不过，VB 还是我目前的简单程序原型首选，因为启动快，而且不需要过于专注于类型转换。 由于在初二参加过 NOIP（不过我的数学嘛……结果怎一个惨字了得），所以大致知道几个词（不过算法完全不能理解，一直到大学才顿悟），以及大O函数。高二的时候还准备去冲一下 NOIP，晚自习的时候看着一本从图书馆借来的《离散数学》，整本书几乎就没能看得懂的。再想想反正不过是要考图论嘛，看看图论那一块。啊原来树有什么什么，图有什么什么，怎么转换（算法）。看着书上的数学描述就头大，看了图示之后也很难推广，想想好像是那么一回事吧——但是第二天又忘了。数据结构这一块，是到了大学才重新捡起来的。 同时，面对着这么多的代码，以及放弃的 PHP 编辑器，还有一些其他的外部因素，我想知道这些代码是怎么编译的。于是在高三前的暑假，我从图书馆借了一本书——也是在图书馆里浏览了各种书后选的，Compiler Construction: Principles and Practice。在看前几章的时候，我还能看懂，但是从后面的文法（grammars）开始，又头大了。那可是严格的数学推导啊！不过，至少我理解了编译的流程（词法扫描和语法识别），知道了抽象语法树（abstract syntax tree，AST），这对于我最近的东西还是有很大帮助的。同时赞一句，在中学图书馆里借到的是一本大约 A4 大小的、深棕色封面的、有与龙书同风格的设计的影印书，排版、字体的区分简直是太美丽了。（国内编排的那些书？呵呵。）几周前在大学图书馆里的旧书区借到了这本书，不过是大概 B5 的大小，自然厚了——嗯，就是缺了一点点美感。 后来在2012年尝试 Visual Basic .NET 的开发，做一个游戏启动器（即 Z-Abby/Zinc，后来的 Astraea’s Caroline）。链接以后再补充，大多都放在了百度贴吧上。总之，我一般是有需求了，或者呆不住了，才会跳到另一门语言，不过这些跳转更是增长了我的见识，让我（在有计算机运行原理的基础上）构想了一下各个语言语法特性是如何实现的。从 VB .NET 开始，就进入了 CLR 的家族。当初看到一群人在争 VB .NET 和 C# 的优缺点，我一直是坚挺 VB .NET，认为“C# 就是 C++++”（黄秉刚老师语）、“C# 就是微软抄袭来的 Java”。C# 的属性（虽然是语法糖）和事件的支持还是挺好用的。其实现在用多了，在平常的书写上，大多数时候 C# 感觉更方便一些（例如用_varName表示类级变量、varName表示参数、VarName表示属性，但是 VB .NET 由于不区分大小写就难以只使用大小写就能区分这三者），一些东西是 VB .NET 做起来麻烦的（C# 的default关键字、volatile关键字、固定指针、直接用this Type varName来写扩展方法），当然也有一些是 C# 做不到的（VB .NET 的Handles关键字，带多参数属性）。各有千秋嘛。嗯，扯远了。 其他一些语言略有接触，不过经验和技术还是差了好多。 C&amp;C++。原来写起来很困难，练多了就好了。后来准备用 SDL 来构建 EarlySpring，那就是大块的 C++ 代码，同时处理好 SDL 的 C 风格函数。 C++/CLI。作为 C# 的辅助用过一点，在 EarlySpring 中。灵活性不错，作为粘合剂用起来很舒服。而且，比 Managed C++ 写起来轻松多了。 Pascal&amp;Object Pascal。分别在 NOIP 的准备，和初中的课堂开发中用过。NOIP 的时候还不了解程序构造，大概也只会program XXX ... begin ... end.这样一个结构，中间填什么都不怎么清楚，是longint呢还是real呢，都是什么意思……这些给我造成了严重的心理阴影。OP 一般用 Delphi 来写，主要是觉得太自由了（大小写不敏感，而且也不会像 VB 那样自动纠正到声明时的样子，看起来难受），没怎么用过。 PHP。高一的时候本来是想用 WAMP+PHP+PhpMyAdmin 建站的，后来放弃了。PHP 写起来也很难受，因为是无类型的，而且用得不多，自然就不熟悉语言本身和函数、库。 Lua。2010年在研究 Garry’s Mod 的脚本时读到过，大致清楚其语法规则，不过没自己写过。 Python。2014年4月不是想写一个 GalGame 引擎嘛，搜索了一下，主流的开源引擎是 KiriKiri 2、ONScripter 和 Ren’Py。后来玩到一个糟糕的游戏（就是エロゲーム啦）Sugar’s Delight（好囧，由于 PyGame 是跨平台的，所以这货也是），发现它就是用 Ren’Py 制作的。于是去研究了 Ren’Py 及作为其基础的 PyGame，自然也就看了一些 Python 的东西。Python 的跨平台、脚本和一些便捷的语言特性用来写游戏……这个应用真有趣。 Ruby。看了松本行弘的一本书之后，对书中不时写出的 Ruby 代码略感兴趣——和 Lua、LISP、JavaScript 类似，Ruby 也可以玩元编程；与 Haskell、F# 类似，Ruby 可以玩函数式编程——这难道不有趣么？ ActionScript。当初做 Flash 动画的时候用过一点，不过不知道那是 ActionScript 罢了。直到开发弹幕君的时候翻 BiliBili 的弹幕文档，看到里面一直用的是“ECMAScript”而非“JavaScript”，就去搜索了一下，发现 ActionScript 还是实现了 ECMAScript 3 的呢。 JavaScript。由于上一个玩意儿（花园与 Bangumi 的结合）的需要，要在浏览器中实现各种操作。最简单强大的方法就是脚本，于是我就接触了 JavaScript。从一个 BangumiCore 开始，我踏上了学习 JavaScript 的旅途，并在5天内完成了从解构、封装为跨域到加上界面的原型的过程。中间通过百度云网盘助手的SimplePanel类见识到了 JavaScript 的原型编程。嘛，算是语言入门了吧。（借用花园上一位前辈的话：你这都开始研究操纵浏览器的通信过程了还叫入门？！我：我刚刚学，不过是为了要解决一个碰到的问题，就轰开一条路过去了，当然是入门。） 说了这么多，我还是不敢说自己够努力，爱学习啊。近处有程序美工日语通杀的lansure，远处有早在初中就学习量子力学、现在在 MIT 实验室设计 CPU 的zalazan（嗯，两年来他在班级群里没说过话，我也没去 Facebook，直接交流也少很多了，估计再交谈的时候除了技术差距，还有社交差异了吧）。我就一渣渣，怎么敢说爱学习！ 想想看，1月6日花园关闭，1月8日确立分布式 tracker 服务器这个目标，到持续到1月14日的讨论，到1月22日 KeiSystem 的原型初步完成（之前，1月8日开始写，历时4天的 GardenTracker 被严重打击了……）等待双机测试和多机测试，配有通信规范（第一次写……），我真是在一边玩命复习考试一边玩命写代码啊。二者神同步，当然，代价也很大。舍友评价我在过“大西洋时间”。 为什么是 KeiSystem？一个原因是考期看的《银河机攻队》（＜銀河機攻隊マジェスティックプリンス＞）（画外音：你疯了？明明是考期！），挺喜欢ケイ（虽然日笠陽子配的角色通常十分没节操，不过这里还是很正常的）。另外，直接发音不就是K么。那谁谁。顺便，此片附带制作访谈，这是我第一次看制作访谈，见到真的那些制作人员及其分工（索尔应该看多了吧）。 在昨天（1月22日）的凌晨恍惚间，我好像看见了消失的“BT”字样又回来了，可是刷新一看，什么都没有。一片空白。不过是一场梦。 快回来吧。 寒假要干什么？ 和数字大神的合作，VR 的东西…… 美赛…… 学日语……看动漫总是要字幕还是不爽的。虽然现在能解构一部分，但是对于正常对话而言还是太少了。而且总是被各路大神压着打，更不爽…… 尽量继续写众人小传，能写多少写多少吧。三年了，可能很多东西都忘记了，得在继续忘记前将它们留下。 有时间的话要继续 EarlySpring 的开发。现在先专注脚本这一块，所以那个 repo 肯定不是最新的。写 JavaScript 的时候触及了其原型链，通过这个应该可以解决一些我之前没法解决的东西。 通过 IronJS 项目，结合 CLR，学习 F#。 手机上还简略记录了一下去年的技术历程，从4月开始（更早的记忆好像没了）。有时间再贴上来吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"后花园时代","slug":"zh/2015-01-11-After-FG-Era","date":"2015-01-11T13:58:00.000Z","updated":"2020-03-30T22:34:35.397Z","comments":true,"path":"categories/Misc/zh/2015-01-11-After-FG-Era/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-01-11-After-FG-Era/","excerpt":"","text":"要正式进入考期了，虽然我们是提前一周开考。上一周两科必修课+一科选修课：机电控制基础（周二）、制造工程基础（周四）和数据库原理（周三）。 大家也知道，花园在6日下午关闭了。（后来只对校内公众开放了论坛部分——由此变成了花园论坛/花园市场，不再是熟悉的花园了。）昨天群里有人说了，ta的室友上传了 70 TB+，在关闭的第二天就病倒了，而且输了三四次液都还没好。想想，为什么为什么没病倒呢……辛辛苦苦积累了 42 TB 上传，虽然心里堵得难受，但是就是没法倒下。说道这里也许你会笑话我，说坚持才是硬道理；我期望的，只是一次像阮籍一样的放浪形骸而已。是自己的保险机制在起作用？迄今为止无论发生了什么——五年级、初二、大一，为什么我就没有一次失去理智或者晕倒，哪怕一次都好。哈，如果我也倒下的话，虽然也许就没法考试了，但是毕竟有一个经历。我只是太平常了，总是给自己设下后路，给自己设下保护墙，然后在这墙之间走着大家期望的道路。但其实说到底，如果有人能知道你，那是因为你有特别之处。假设某人在和你聊天，也许你可以说，当时我病了诶，但是我说不出；这样也许他们就认为我就像众人一样慢慢地就被磨去了锋芒，像那些在暗夜下行走着的僵尸一般。只有我知道我不是；声嘶力竭却不过发出了渺小的声音。 于是我能稍稍透露一点做了什么了。从周四开始，我就在写一个程序，尝试尽量恢复花园的资源功能。这几天真是玩命了，写了一个分布式tracker服务器，并在昨天晚上通过了双机传输测试。同时，明天有机电，后天有模电，大大后天有机设，所以还要玩命复习。现在大概能理解一点了，老大的不容易，要根据用户反馈调整、维护，还要顾及学业。是的，我的目标是做一个过渡系统，尽量保留原有的操作风格，并如果有可能的话，让这个过渡系统服务到花园完全恢复的那一天。经过这次事件，花园上的人已经走了许多。如果短时间不能有一个过渡系统的话，心态指数（请允许我这么称呼）会在短时间内大幅度下降，这样在下学期开学之前，花园都不会恢复元气。这也是为什么我这么赶，即使要占用计划的复习时间，也要做一个原型出来。我想，不止我一个能理解时间节点的重要性吧。 现在的状况，就像是明朝灭亡的样子。许多人转战品知，就像是剃头发一样。不过，毕竟在清朝，汉人是二等公民哪。宁做明朝遗老，反清复明。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"一科，以及，关闭了","slug":"zh/2015-01-06-FG-Closed","date":"2015-01-06T12:15:00.000Z","updated":"2020-03-30T22:34:35.397Z","comments":true,"path":"categories/Misc/zh/2015-01-06-FG-Closed/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-01-06-FG-Closed/","excerpt":"","text":"没想到昨天还在快乐地讨论着的，今天就关了。我们可是有着可能是全北京最好的系统啊，就这么没了，连带着那些用户。 关闭应该是上面的意思，为了清查。（猜测。）其实大部分的东西我们还是能弄得到，还是能分享，但是老资源就或许这么没了。而且最重要的，交流吐槽的地方没了；或者说，对着东西，能看得见的嬉笑怒骂都没了。线下？没有了那种 masquarade 的风格；或者说，没有那种做在桌边吃火锅的感觉了。 看着手里还在做着的2张版头，真是突然觉得，再做还有什么意义呢。以后那也许只会留下 Photoshop“动漫版版头”这样一个标准大小了吧。 希望 L_y 大大能保留一些数据，至少能让人看到，有多少人曾经为了它的繁荣而耕耘过，上面有多少优秀的帖子。其中就有漫版各位前辈的成果哪。 要我去用i？不，建设太差劲了，还有各种各样的院系宣传，生怕你看不见。这是由它本身的性质所决定的，但是这并不妨碍我讨厌它。 看《21》的时候，看着男主被两次抢走手中的筹码，就是看着而已。于是生活给我上了一课，告诉我这是什么感觉。上医学院的希望和在站上的投入，从第三方的角度来看前者应该更“有价值”一点。嘛，我没那个体会，所以对于我来说更看重后者。 这再次印证了“没力量”的话。不管再怎么叫再怎么喊，总有人不管死活。如果真的没了，以后这就会变成类似“啊，那个啥啊，关的时候我也很不开心，过了这么久也习惯了”之类的话，作为传说存在着吧。 刚刚看到消息，别的地方有树苗长出来了。不过毕竟不是本家，没意思。 L_y 一向是很认真的，这次的通告……真希望那只是蜘蛛毒素（《Salt》）。不要成了朱丽叶就好。 最后的资源就是点兔的OST（倒数第二个，兰斯01），最后的相关活动是回复紫晓暮雾的兰斯帖子，最后的相关代码是给汞灯写的搜索地址提取（倒数第二个，Bangumi UserScript）……话说，初春的 alpha 发布帖只留了一份啊…… 看着μT的满屏红种，连接到的人数在逐渐减少（tracker 响应需要等待一定时间，另外还有 DHT）。想必是大家发现了不能用了，就关闭了μT吧。嘛，我再坚持一会儿，一会儿…… 最后一次参与的活动是库特的猜曲，之前是糖王菊苣的猜曲，再往前是刺杀菊苣的伦查会年历发售（同时还见到了工口菊苣的本体www）。之前不是说过我没表露过什么吗，这次就将年历摆在桌子上的开阔地带，纪念消失在时间夹缝里的漫版。 今天一科，最后竟然产生了大诈和。那是基本概念的问题……也没什么好争辩的了，已成定局。记不牢怪谁呢。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"考期烤漆","slug":"zh/2015-01-05-Before-Exam","date":"2015-01-05T10:26:00.000Z","updated":"2020-03-30T22:34:35.396Z","comments":true,"path":"categories/Misc/zh/2015-01-05-Before-Exam/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2015-01-05-Before-Exam/","excerpt":"","text":"明天就是第一门，虽然号称是“考期外”。这不就是相当于考期往前平移而已嘛。 今天下午桌子到货了。增加了可操作的面积真不错。（要不然就得在不到 0.15 平方米的位置上写作业，画大图……就像昨天晚上，硬是画下来了。） 上个月的净网行动，迫使大动漫资源站中最后一家留在国内的也转移了服务器。虽说在贴吧上看到许多人在那里嚷嚷，但是正如PZ菊苣说的，这个群体在政策下没有一点力量。 又有点想到我去年申版主的时候……嘛，还写了个“将善意传递下去”呢，说实话没有硬功夫，有这也不行，倒是显得苍白了。 紫晓开了兰斯1（ランス01）新动画版的帖子。读了两位在后面评论中的对话后，我就去找了一下。新世界的大门打开了（-_-|） 我的确曾经以为兰斯就是一个RPG，嗯。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"从2014年离开","slug":"zh/2014-12-31-Happy-New-Year","date":"2014-12-31T14:06:07.000Z","updated":"2020-03-30T22:34:35.396Z","comments":true,"path":"categories/Misc/zh/2014-12-31-Happy-New-Year/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2014-12-31-Happy-New-Year/","excerpt":"","text":"首先，提前祝大家公历新年快乐。 看到博客园上许多人在写年终总结。好吧，我不擅长写这个。不过大概在两周前，我突然想到要记录自己的技术路程。过早的事情不太记得时间了，它们已经融入了我的思维方式里。所以记录是从弹幕君开始的……不对好像又有点乱，难道先是视频黑科技？我等会查一下发帖历史吧。嗯，其实最早在花园上的是一个3D-2D的项目发起帖，不过由于原理性的问题这个先搁置了。啊好吧，这些之后再写，现在暂时不放上来。 今晚的班级聚餐，我们班约20人+14班5人。我们班的醉的有七八个吧。（我？要是我意识不正常了，还能写这个么？）所以现在基本上是1.5人看着一人的样子。在写这篇记录的时候，我需要确保旁边的舍友安地躺在床上，以及呼吸道畅通。嘛，如果有这方面经历的人，应该能理解吧。于是奉劝大家，兴致虽高，但是醉了还是会给别人造成麻烦，尽量控制一下。 今天凌晨又看了 TJS 的语法部分，发现能看懂一点了。（我毕竟不是计算机科班出身，没学过编译原理——这难道就是我之前研究得不透彻的理由吗？不行，只能说是我没认真看，没去想。）趁着这个，我去借回了《Compiler Construction: Principles and Practice》。这算是我的入门吧。四年前半懂不懂的书，现在能看了。——我经常遇到这情况，只是不知道在何时，我的积累发生了这个变化。所以我的简历一定不好写，哪有人敢写自己“自然而然就会了”呢？顺便吐槽一下，我们中学那个影印版封面还是很漂亮的，颇有与龙书同系列的风范（当然，封面不是龙虎鲸）。但是这个机械工业出版社的版本，太难看了，而且版面也不对了啊…… 遂决定重启 EarlySpring 计划，根据新发现和今天知道的新工具、代码重新规划，并重写所有代码。放到考期结束吧。 雪飘的结城友奈 TVRip 合集也出了，上。（但是这次为什么 TVRip 的字幕形式都是外挂……） ACG联盟的测试中，我弱爆了。 最后，我昨天去七海网站上看的时候，偶然发现了大地无敌是谁……范神毕竟也是 MSTC 的一员，而且实力也展示过了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"12月26日杂记","slug":"zh/2014-12-26-Miscellaneous-of-12-26","date":"2014-12-26T14:40:27.000Z","updated":"2020-03-30T22:34:35.396Z","comments":true,"path":"categories/Misc/zh/2014-12-26-Miscellaneous-of-12-26/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2014-12-26-Miscellaneous-of-12-26/","excerpt":"","text":"最近几天站点是在不断更新的。本人第一次使用独立博客，之前分别在百度空间和博客园（主要用于代码）上开了两个博客，但是毕竟受到站点的限制比较多。例如，不允许用自己的代码，附件、管理什么的灵活性差，而且没有自己（我）的特点。（相对来说博客园比百度空间好得多，毕竟目标人群不同。） 今天加入的更新有页面上方工具栏的“RSS订阅”，以及初步成型的404页面。写了一个小彩蛋，感兴趣的各位可以试试。（我知道有人会很系统地解析出方法的，不过请不要剧透，谢谢。） 为什么是初春？话说，相似的技术型萌娘也不少，例如蓝羽浅葱、星月·法拉利（星月・フェラーリ）。 嘛，硬要说理由的话： 初中生比幼女合法；（你在说什么 (ﾟДﾟ≡ﾟДﾟ) 警察叔叔，就是这个人！不过目前的首页的头像就是星月。 不是后宫的一员。 算了算了，大家都是我的翅膀…… 今天在花园看到大地无敌的签名有他（她？不太想私信问，不过按照语言风格估算，是“他”）的个人主页，遂点击进入。他用的是 WordPress，那管理什么的就方便了。相比之下 Hexo 还是规模小得多。同时，工具有了，还要看使用者。他有6年的独立博客建立历史——而且从历史数据看来，一直是 WordPress 用户。再加上他早就有了开源社区的经验，我这种用 GitHub 不久的小白怎么比得了呢。 第一次真正见识到大地无敌是在花园发布 EarlySpring 引擎的初版时，楼下立马就有人@了他。今天看了看，引擎名字是 SOGal。看起来组织得不错嘛。我们走的方向不一样，他用的是 Python+Panda3D，我用的是 C#&amp;C++/CLI+MonoGame，在语言和框架的选择上我好像就落后了呢。现在我在想里面的脚本引擎怎么办，真的要在 CLR 上再做一个 VM？如果不的话，CLR 要求强类型，怎么办？TypeScript？拜托，那也是强类型的。或许看看 IronRuby 和 IronPython 会有点帮助。（IronJS 生长中……） 上面提到的 EarlySpring 引擎的 repo。别担心，现在这个 repo 现在还是空的。不过我的磁盘上倒是有代码，只是需要好好整理。整理完再更新这个 repo。 EarlySpring 来源于初うい春はる的字面意思。 有时间的话（明天/后天），要写《结城友奈是勇者》（《結城友奈は勇者である》）的短评。我读书少，写的不如lan姐姐、PZ菊苣已经或者将要写的那么专业，所以我做好了被打脸的准备。 刚刚顺便开了一下结城友奈的官网，继 BD Vol. 1 的gal之后，BD Vol. 2 的特典也十分吸引人—— 音楽CD1 スペシャルキャラクターソングCD 4話のカラオケシーンで披露された友奈＆夏凜のデュエット、東郷さんの軍歌、「ホシトハナ」「Aurora Days」の5キャラソロバージョンを収録！ Special Character Song CD 在第4话的卡拉OK中友奈和夏凛的抽风二重唱、东乡的军歌两首歌的完整版，以及OP、ED的5人独唱版。 （而且注意，这是音乐CD1，说明接下来会有更多的好东西，例如未被收录进入OST的那些曲子。） 没办法，我没有收入，买不起啊。 但是，期末复习和考试也在进行……时间上能抽出来的就少了。考完后，应该还会去和数字大神做一个 VR 的东西。应该会很忙。 昨天有同学来让做一个 Android App。我说：“我这里跑不动 Dalvik 虚拟机。” 也是。现在这个 Lenovo E23 工作了6年，已经略显疲态了。即使我的日常维护也不差，但是岁月催机老，逃不过的。 今天有同学来让装机。装机空闲的时候就聊天。他：“你为什么不换一台呢？俗话说，工欲善其事，必先利其器，你现在这样给人感觉是一个很牛X的人在用一台渣渣。”我：“3000哪！我又没有收入来源。” 我都习惯了，用120%的能力+40%的设备做出80%的效果，然后被别人100%的比下去。我也得考虑一下，等 Visual Studio 2015 RTM 出来了，申请换新设备…… 老爸老妈看到这个博客会怎么想呢？尤其是如果他们知道我第一次用网银是为了购买域名的时候…… 我的猜想： 老爸：嗯。讲解一下这个页面是怎么工作的。 老妈：你的设计这里不是很好，改进应该是这样这样的……另外，封面那个女孩子是谁？（以下省略）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"结城友奈是勇者最终话（剧透，多图杀猫）","slug":"zh/2014-12-26-Ending-of-Yuuki-Yuuna","date":"2014-12-26T02:06:00.000Z","updated":"2020-03-30T22:34:35.396Z","comments":true,"path":"categories/Misc/Records/zh/2014-12-26-Ending-of-Yuuki-Yuuna/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-12-26-Ending-of-Yuuki-Yuuna/","excerpt":"","text":"花园地址 不知道说的是不是同一件事 http://buaabt.cn/showtopic-398186.aspx 开头的对话，满满的小圆脸味，简直是一一对应 樹说话了！！！！能领工资了！！！！ 眼罩少女 结局半途依然是小圆脸……或者说，如果小圆许愿之后没有成为无形态的话…… 但是居然强行“回来”，happy end！神树大人不需要祭品了！一群人全好了！出现的共计绽放 5（夏凛）+4（東郷）+3（友奈）+2（風）+2（樹）+22（園子） 次，全好了！ 那么在此之前，按照祭品总量不变原理，症状估计是被一群人分摊了吧（这黑幕） 而且用满开的配乐做结局（泪流满面 我说，你们是怎么能跳到“该隐藏真相”这个逻辑上的？维稳？ 第一次5人齐唱的ED（之前是4个老部员）。一听就知道……但是没有发售这个版本啊…… 画面变化： 剧中 EP03-11 ED （01-02 夏凛还没出场） EP12 ED 几张海边特写（看过前面ED的应该有印象） 《結城友奈の章》 有后续？ PS. 再想了一下，小说末尾应该会有对应的“鷲尾须美の章”。（还没看，不知道） 精神续作倒是看得出，但是剧情节奏把握不好…… 2015-08-12 此帖子的回复有很有意思的链接，这里不附上了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"FGBT-Bangumi Assistant 介绍","slug":"zh/2014-12-26-Introducing-FGBT-Bangumi-Assistant","date":"2014-12-25T16:38:20.000Z","updated":"2020-03-30T22:34:35.396Z","comments":true,"path":"categories/Tech/Coding/zh/2014-12-26-Introducing-FGBT-Bangumi-Assistant/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-12-26-Introducing-FGBT-Bangumi-Assistant/","excerpt":"未来花园-Bangumi助手 (FGBT-Bangumi Assistant)建立未来花园动漫版与 Bangumi 之间的联系。通过小界面，可以很容易地将状态同步到 Bangumi。 仅在北航未来花园PT中有效。 项目主页：https://github.com/GridScience/FGBT-Bangumi.Assistant","text":"未来花园-Bangumi助手 (FGBT-Bangumi Assistant)建立未来花园动漫版与 Bangumi 之间的联系。通过小界面，可以很容易地将状态同步到 Bangumi。 仅在北航未来花园PT中有效。 项目主页：https://github.com/GridScience/FGBT-Bangumi.Assistant 使用方法安装浏览器对应的 UserScript 插件（可能需要重新启动浏览器），添加 fgbt/fgbt.bangumi.assistant.fgbt.user.js 和 bangumi/fgbt.bangumi.assistant.bangumi.user.js ，并重新加载页面。 第1步安装脚本。安装对应浏览器支持 UserScript 的插件，然后添加脚本。总共是两个脚本，一个运行在未来花园上，一个运行在 Bangumi API 页面上。（在能使用跨域 XMLHttpRequest 的环境下，仅运行 FGBT 端。） 第2步打开种子资源页面。 第3步单击“记录到 Bangumi”按钮，弹出登录对话框。 第4步输入 Bangumi 的账号和密码登录。 注意： 为了登录方便，这里设置是按下按钮后会记录当前用户名和密码。所以如果觉得有风险的同学，请在记录完成后刷新页面，清空文本框和密码框的内容，并再次按下登录按钮，并忽略此时的登录失败提示。 如果没有连接到因特网，不会弹出错误提示（不过会显示在控制台里），但是不会登录上。 在确认连接到因特网的时候，由于验证页面加载需要一点时间，所以打开面板后不要急着按按钮，稍微等一下（一秒应该可以解决绝大多数人的问题）。在页面加载完成之前是不会成功的。（因此在页面加载完成之前，登录按钮不会显示出来。） 第5步登录成功，会显示登录到的账户。同时，进入番组信息界面。登录失败会提示。 第6步确定之后，回到信息界面，等待两个下拉框自动刷新（大约2秒）。注意番组下拉框的变化会让集下拉框自动刷新。 第7步选择对应的番组和集。 第8步设置为看过。会弹出消息框确认成功，或者报告错误。 结果 浏览器支持需要对应 UserScript 插件支持 GreaseMonkey 0.8 以上的 API，及其相应的浏览器版本。 测试可用 Mozilla Firefox - GreaseMonkey Google Chrome - TamperMonkey Maxthon 4 - ViolentMonkey 待测试 Apple Safari - NinjaKit Opera - ViolentMonkey Microsoft Internet Explorer 6/7 - Trixie / GreaseMonkIE 不可用 Microsoft Internet Explorer 8+ 说明目前显示的是有中文名时为中文名，否则尽量显示原名。 目前只提供了看一话的操作。当然，用同样的原理，将某一个或者一个番组的一批标记为看过（即 Bangumi 的“看到”功能）、弃都是可以的，改一点代码就好了。 未来的工作： 继续浏览器兼容系列工作。 启用脚本自动更新。 更多的用户操作。 界面美化。 题外话 JavaScript 的原型编程（用 prototype）应该属于元编程（meta-programming）的一种了吧，很有意思的特性。虽说一开始还是有点依赖控制台（补全）的，但是后来就能在 Np++ 里直接写了，无类型的好处，以及动态结构，用起来都挺方便的。 在几个控制台中，最喜欢 Chrome（以及傲游，Chrome 内核）的，因为显示的信息最全面直观。其次是 Firefox，再次是 IE。这两者的输入和反馈是分开的，比较难找到 shell 的感觉。不过 IE 强制要求 Ctrl+Enter 提交的设计不错。 UserScript 编辑器上，GreaseMonkey (Firefox) 最佳，保存的时候似乎扫描了一下，再写的时候就会有智能提示了。TamperMonkey (Chrome) 次之，多标签和成员高亮很实用。再次是 ViolentMonkey (Maxthon)。 UserScript 管理器上，TamperMonkey (Chrome) 最佳，而且还会提示当前页面正在运行多少用户脚本。GreaseMonkey (Firefox) 和 ViolentMonkey (Maxthon) 次之。 有人说，某项技术用了超过2000小时就难以跳出这个框子了。所以要多多尝试新东西……你看看用 C#/VB .NET 处理一个请求并操作页面多麻烦…… 通过此次 JavaScript 练习，我对 TJS 又有了新的认识……好吧我承认我原来想的纯粹编译 TJS 是几乎不可能的，在不设计 VM 的情况下…… 开始的时候非常艰难，特别是遇到了跨域请求时。本来想撑不住了就向lan姐姐求助一下，最后还是咬着牙走过来了。 原来以为抓包完毕剩下的应该很简单。结果重头戏在后面：跨域请求和浏览器兼容。劈头就是跨域访问这堵高墙，而且限制尤其严格（我没有双方站点的控制权），对于我这种前端新手来说实在是不小的打击。这个问题的解决过程在吐槽&amp;痛苦的记录里写了。 最自豪的是，封装之后，接口与原 BangumiCore 是兼容的。也就是说，这是一个支持跨域请求的 BangumiCore。 感谢 jabbany@GitHub&amp;Bangumi 完成了绝大多数的 Bangumi API 解析工作，并提供了一个封装良好的 BangumiCore，我也在里面学到了不少 JavaScript 的知识。 ywzhaiqi 的百度盘助手代码，里面有一个简易小面板 SimplePanel（就是现在用的这个）。这个面板使用了原型（prototype）编程，让我见识到了原型的厉害。（不过我还是将其拆成了普通的函数 (&lt;ゝω·)☆） Dojo Foundation 的 Dojo 框架。模块化设计得很漂亮高效，使用方便，让我免去了手工二次POST的麻烦。 Douglas Crockford@GitHub，虽然其写的 JSON2 没有最终用入脚本（由于只需要字符串=&gt;JSON，所以简单地以 eval() 替换了），但是开发初期提供了不少方便。 我要去看结城友奈去了。嗯。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"FGBT-Bangumi Assistant","slug":"FGBT-Bangumi-Assistant","permalink":"https://blog.mottomo.moe/tags/FGBT-Bangumi-Assistant/"}]},{"title":"在 Hexo 博客中启用多说评论","slug":"zh/2014-12-24-Enabling-Duoshuo-Comments-in-Hexo-Powered-Blogs","date":"2014-12-24T15:04:37.000Z","updated":"2020-03-30T22:34:35.395Z","comments":true,"path":"categories/Misc/zh/2014-12-24-Enabling-Duoshuo-Comments-in-Hexo-Powered-Blogs/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2014-12-24-Enabling-Duoshuo-Comments-in-Hexo-Powered-Blogs/","excerpt":"","text":"尽管多说评论的口碑不好（有人在2012年就指出了一个问题），但是用起来还是比较方便…… 在这里、这里和这里都有比较详细的讲解。部分模板也直接嵌入了多说的模块，只需要填写一个 short_name 就可以了。 问题是，这个 short_name 在哪里？网上无一例外地指出，注册账号后会去填写（以构成在多说的二级域名）。 但是你知道吗，我晚上在多说的网站上转悠了整整40分钟，都没找到这个“填写”到底在哪里。我注册的时候，直接通过外站 OAuth 就过了，哪里有什么选项！跑到个人选项，没有；帮助文档，也没讲在哪里。气得我问候了写文档的小哥——那个，API 是很详细，我很感激，但是基础的注册问题，你跳转的默认行为，很让人恼火啊！ 后来翻到了某篇博文（抱歉，忘了是哪里的），试了一下标有“这里”的链接，跳转到多说的主页，然后点击左边的按钮创建站点，终于可以了…… 后来才发现，原来一开始点开的是多说的开发者中心，左上角的小图标我以为点击会回到主页，也没仔细看，就出不了这个怪圈了。但是开发者中心那里居然只有“下载插件”和“体验一下”两个按钮，“体验一下”居然是进入一篇官方文章！下面居然没有回到主页的链接！弄得我一圈圈地在这开发者中心里打转。我不知道这个链接设置是怎么想出来的！前端，你们在做什么！ 添加评论的背后机理，这篇博文讲得不错。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.mottomo.moe/tags/Hexo/"}]},{"title":"First Coding Page","slug":"zh/2014-12-24-First-Coding-Page","date":"2014-12-24T14:59:45.000Z","updated":"2020-03-30T22:34:35.395Z","comments":true,"path":"categories/Tech/Coding/zh/2014-12-24-First-Coding-Page/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-12-24-First-Coding-Page/","excerpt":"","text":"代码测试页面","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[]},{"title":"First ACGN Page","slug":"zh/2014-12-24-First-ACGN-Page","date":"2014-12-24T14:52:33.000Z","updated":"2020-03-30T22:34:35.395Z","comments":true,"path":"categories/ACGN/zh/2014-12-24-First-ACGN-Page/","link":"","permalink":"https://blog.mottomo.moe/categories/ACGN/zh/2014-12-24-First-ACGN-Page/","excerpt":"","text":"ACGN 测试页面","categories":[{"name":"ACGN","slug":"ACGN","permalink":"https://blog.mottomo.moe/categories/ACGN/"}],"tags":[]},{"title":"解决“deploy 后显示成功但 GitHub 不更新”的问题","slug":"zh/2014-12-23-Get-the-Auto-Deploy-Feature-of-Hexo-Worked","date":"2014-12-22T20:46:48.000Z","updated":"2020-03-30T22:34:35.395Z","comments":true,"path":"categories/Misc/zh/2014-12-23-Get-the-Auto-Deploy-Feature-of-Hexo-Worked/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2014-12-23-Get-the-Auto-Deploy-Feature-of-Hexo-Worked/","excerpt":"","text":"嘛，这么晚了，有时间再进行进一步博客优化吧。 以下摘录自我在 Hexo 的 Issues 上发表的反馈。 我也遇到了类似的问题。部分输出如下： On branch master Changes not staged for commit: deleted: ../images/body-bg.jpg deleted: ../images/download-button.png deleted: ../images/github-button.png deleted: ../images/header-bg.jpg deleted: ../images/highlight-bg.jpg deleted: ../images/sidebar-bg.jpg deleted: ../index.html deleted: ../javascripts/main.js deleted: ../params.json deleted: ../stylesheets/print.css deleted: ../stylesheets/pygment_trac.css deleted: ../stylesheets/stylesheet.css Untracked files: ../.gitignore ../.initvars.mic.bat ../_config.yml ../package.json ../scaffolds/ ../source/ ../themes/ no changes added to commit Username for &#39;https://github.com&#39;: GridScience Password for &#39;https://GridScience@github.com&#39;: Branch master set up to track remote branch master from https://github.com/GridScience/gridscience.github.io.git. Everything up-to-date [info] Deploy done: github 这个 not staged for commit 到 no changes 感觉很奇怪。 git 的话，我用的是 Git For Windows，不是 msysgit 的网络安装版。 02:12 重试了几次，GitHub for Windows 都崩了，无法同步。用 git 手工 stage，commit，才更新。 04:30 还是无法让其自动工作起来。当前解决方案是将 *.github.io repo 映射到 .deploy 目录，然后在 .deploy 中 git commit。 04:36 应该是解决了。解法是，*.github.io repo 确实应该映射到 .deploy 目录。 原因是看到zipperary的教程5中的截图，只有 .deploy 是被标记为 git 管理的。猜想应该如此。 然后验证。设置好后回到上一级（_config.yml 所在的地方）运行 hexo g，hexo d，就可以自动生成、部署了。 此时最后显示的内容如下： warning: LF will be replaced by CRLF in archives/index.html. The file will have its original line endings in your working directory. warning: LF will be replaced by CRLF in index.html. The file will have its original line endings in your working directory. warning: LF will be replaced by CRLF in tags/日常/index.html. The file will have its original line endings in your working directory. Username for &#39;https://github.com&#39;: GridScience Password for &#39;https://GridScience@github.com&#39;: Branch master set up to track remote branch master from https://github.com/GridScience/gridscience.github.io.git. To https://github.com/GridScience/gridscience.github.io.git f5a3350..dd3a964 master -&gt; master [info] Deploy done: github","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.mottomo.moe/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"2014-12-22 记录的 Beanstalk 开发","slug":"zh/2014-12-23-Developing-Beanstalk-at-2014-12-22","date":"2014-12-22T18:17:08.000Z","updated":"2020-03-30T22:34:35.395Z","comments":true,"path":"categories/Misc/zh/2014-12-23-Developing-Beanstalk-at-2014-12-22/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/zh/2014-12-23-Developing-Beanstalk-at-2014-12-22/","excerpt":"","text":"大概9月的时候，测试本地发种成功，就想做一个个人机器人。 计划分为3个部分：(1)RSS 订阅；(2)μTorrent 操作；(3)在花园发种。后来为了有效利用极影，写了一个 RSS 阅读器。μTorrent 这个方面则是在网上搜索了一下之后用了一个源代码测试。 2014-12-? 在群里首次表露有编写机器人的意向，不过为了不引起注意还是低调了点。 2014-12-15 定下项目名称为 Beanstalk。来源：Jack and the Beanstalk。花园嘛，种下魔豆之后会怎么样呢？ 建立工程，开始封装未来花园的操作部分。 在设立当初就计划利用 .NET Framework 4.5 的异步调用语法糖，做成完全异步的结构，主要是类库要满足该要求。 2014-12-18~21 小修改。 2014-12-22 花园的登录和动漫区发种操作封装完毕，测试成功。看来这个模型是可行的。 为了增强可扩展性，遵循所谓“高内聚低耦合”的原则，将通信部分拆分，模块化。学习 IFormatProvider。 为何今天设置这玩意儿这么久……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"从OST预测结城友奈剧情","slug":"zh/2014-12-12-Estimating-Plot-of-Yuuki-Yuuna","date":"2014-12-12T11:56:00.000Z","updated":"2020-03-30T22:34:35.395Z","comments":true,"path":"categories/Misc/Records/zh/2014-12-12-Estimating-Plot-of-Yuuki-Yuuna/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-12-12-Estimating-Plot-of-Yuuki-Yuuna/","excerpt":"","text":"花园地址 昨天听完结城友奈的OST。原来那些名字奇怪的曲子基本上都是和 Vertex 战斗的BGM。 但是这么多战斗曲，有一首（30，《☆☆☆☆☆☆☆☆☆☆☆☆＊＊＊＊＊》）没听过。结合剧情走向，以及这么多星星（12颗，十二宫，对应预计的 Vertex 数量，排在最高的位置！真·12 vs. 5？），我预计放这首曲子的时候会出大事。 为了支持这个预测，整理了一下结城友奈的各话BGM使用。有两首非战斗曲好像没出现过，也有可能是判断失误。暂时还没看第10话，自习之后验证。 曲目下面的文本是出现的时机（听着直接写的，在回顾动画之前），和出现的时间。 要说为什么整理了这样一张表……因为我很喜欢这部作品啊。 01 ホシトハナ (Instrumental) (TV Edit) OP 的 instrumental version 02 ヒナギク 日常 #1 E01 - 01:54 E02 - 22:22 E03 - 20:04 E04 - 10:29 E06 - 18:20 E07 - 20:06 03 コスモス 情感 #1 E02 - 06:06 E03 - 18:51 E05 - 21:39 E07 - 12:51 04 ユウガオ 情感 #2 E08 - 20:02 05 スミレ 情感 #3 (?) 06 樹海の中へ 进入树海的环境 E01 - 10:34 E02 - 13:42 07 黒種草 环境 E01 - 11:55 E04 - 14:21 08 ☆＊ 与 Vertex 战斗 #1 / 战况恶化 E02 - 00:02 E07 - 23:12 E09 - 08:44 09 ☆☆＊＊ 与 Vertex 战斗 #2 / 开始战斗 E01 - 18:35 E04 - 23:51 E05 - 15:58 10 威風堂々 变身专用 E01 - 17:35 E05 - 01:11 E08 - 06:24 11 ☆☆☆＊＊＊ 与 Vertex 战斗 #3 / 开始战斗 E02 - 15:17 E03 - 00:00 E08 - 00:00 12 ☆☆☆☆＊＊＊＊ 与 Vertex 战斗 #4 / 战斗顺利 / 开始封印 E02 - 02:32 E05 - 05:11 E08 - 08:35 13 ☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #5 / 开始战斗 E02 - 14:17 E05 - 02:48 14 封印の儀 封印颂词 E02 - 03:10 15 センニンソウ 日常 #2 E06 - 20:41 E07 - 13:47 16 エリカ 日常 #3 E01 - 07:03 E02 - 12:19 E03 - 14:36 E06 - 10:09 17 アリウム 情感 #4 E02 - 10:45 E08 - 17:24 18 ウスユキソウ 真相揭露 / 回忆过去 E04 - 11:52 E08 - 15:51(Inst.) 19 フクジュソウ 情感 #5 E03 - 17:09 E06 - 16:28 E08 - 22:01 20 ホンキンセンカ 情况异常 E05 - 00:00 E08 - 07:48 21 タンポポ 环境 / 态度严肃下来 E01 - 14:19 E02 - 07:47 E03 - 08:54 E07 - 16:54 E08 - 12:34 14:11 22 曼陀羅華 ？ 23 ☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #6 / 战况激烈 E02 - 03:22 E03 - 01:05 E05 - 06:56 24 ☆☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #7 / 空前强大的敌人 E01 - 15:32 E05 - 13:09 25 満開 绽放（满开） E05 - 17:15 26 ☆☆☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #8 / 开始封印 E05 - 14:20 27 ☆☆☆☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #9 / 战况恶化 E05 - 08:19 28 ☆☆☆☆☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #10 / 克服困难 E02 - 18:14 E03 - 10:06 29 ☆☆☆☆☆☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #11 / 变身 / 爆发 E01 - 21:25 E02 - 17:03 E05 - 18:30 30 ☆☆☆☆☆☆☆☆☆☆☆☆＊＊＊＊＊ 与 Vertex 战斗 #12 (?) 31 ハナトハナ片尾预告 未知（未出现在曲目列表中，也不会收在角色歌中） 有些曲子多次出现（某曲的变奏、piano cover，以及AVG型配乐） “某曲”：ヒナギク/ウスユキソウ E01 - 00:05 00:48 01:04 03:27 05:50 E02 - 11:32 E03 - 04:17 06:05 06:34 08:26 10:56 11:29 13:50 18:04 22:01 E04 - 02:39 03:50 04:28 09:25 10:03 15:57 17:44 20:26 E05 - 19:55 E06 - 02:11 02:32 03:33 06:37 09:37 14:52 E07 - 01:49 03:51 05:45 07:02 08:20 10:23 10:51 11:16 12:20 E08 - 03:40 11:43 13:25 E09 - 05:06 不知道为什么这些曲子不收录呢…… 2015-08-12 附录 索尔菊苣在二楼的回复 。。虽然没看这片子。。 不过这一大段写下来，除了“摊上事了这回摊上大事了‘之外，根本什么结论都没给出来吧。。 这叫哪门子预测啊！！ 扔个私货。。 http://tieba.baidu.com/p/2614356104 《关于DSS项圈的符文及其他》 EVA相关：如何利用既有谜题画面暨OST线索推导谜底","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"2014-12-06 随感","slug":"zh/2014-12-07-Feelings-on-12-06","date":"2014-12-06T16:58:00.000Z","updated":"2020-03-30T22:34:35.394Z","comments":true,"path":"categories/Misc/Records/zh/2014-12-07-Feelings-on-12-06/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-12-07-Feelings-on-12-06/","excerpt":"","text":"昨天看着养肥了的《天体的方式》（天体のメソッド），看到第6话的时候也哭了。 为什么？我想着我这二十年来都是怎么过来的。唯一能说“精彩”的，或许就只有小学的时候了吧。初中、高中，都是按部就班，进入尖子班，考上大学。在我的记忆里，似乎就没什么像《天体》里这种“朋友们”的约定的感觉了，而是我被夹在一群人中，随波逐流。“诶，XX真是个乖孩子，没打过架啊！”我也有点像一个零件了。而小学的朋友，现在分化都应该很大了吧，总之也没再见过面。《天体》有人评论说剧情也不怎么出彩，不过对我来说已经足够。即使是这种风景，我也没有体验过，现在能透过这样一扇小窗，窥见那自己不可能经历的可能性，已经十分满足了。 村长曾经说过，“我一个国奖去租房照样艰难”（在新加坡租房的事情）。我说：“我真羡慕你。”“为什么呢？我遇到的是人间的困难。”“因为你经历了这些。” 我也幻想过，如果当初自己有机会，是不是有一些现在想要的可能性。今天群里刺杀在土博入字幕组（日漫），水银灯因自己不在这个校区而感到遗憾。父母一直是微笑着看着我的思想“正常地发展”的，所以我之前也在喊“不看日漫”的口号。但是真的接触了之后，又是打开了一扇新世界的窗口。这种感觉，就像是CROSSANGE里叫嚷着将ノーマ（无魔者）严加看管的公主，发现自己其实也是的时候那种落差。如果我早点进入这个圈子呢？或者我早点进入PT站的圈子呢？ 如果要你用你现在所拥有的技术能力去换，你愿意吗？ 不愿意。这些是我有别于身边其他人的东西。 也许别人有一些其他的经历，遇见不同的人，四处旅游……我又不可能将所有的可能性遍历对吧。我嘲笑自己是不是要腐烂在屋子里。 就像看《结城友奈是勇者》（結城友奈は勇者である）的时候，当犬吠埼風坏掉的时候，我也流泪了。我很清楚她那么做是为了樹，我觉得我似乎体会到了，但是我没有——因为我是独生子女，可是我也想知道有兄弟姐妹是什么感觉。 又或者，今天那PHP神级代码，看到下面上百条评论，所谓“程序猿的狂欢”、“程序猿平常不多见的幽默都体现出来了”的评论。我默默在下面加了一条，然后想：我对PHP的研究并没这么深，我只是单纯地为这样良性的互动感到高兴而已……可是这一切似乎也不属于我，我也不属于这一切。 而看《樱花庄的宠物女孩》（さくら荘のペットな彼女）的时候我的眼泪就不是这样的。因为我就是空太。我就是在那样一个宿舍里，我就是里面那样的一个人。 我一直在做一场梦？永远地，“正常地”走下去，进实验室、做科研、读博士发论文，就像我其他那些高材生同学那样？我似乎有点醒过来了，不过有点晚了吧……晚了吗？","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"乐园追放观后（剧透注意，多图杀猫，没缺“感”字）","slug":"zh/2014-11-18-Watched-Expelled-from-Paradise","date":"2014-11-18T12:02:00.000Z","updated":"2020-03-30T22:34:35.393Z","comments":true,"path":"categories/Misc/Records/zh/2014-11-18-Watched-Expelled-from-Paradise/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-11-18-Watched-Expelled-from-Paradise/","excerpt":"","text":"花园地址 以下内容只是我在看的时候一边看一边记录下来的。 应该是全3DCG的吧…… 头骨结构： 钉宫中途换声线（讲报酬那里），之前所有的都不自然诶（钉宫不傲娇有错吗 头发有时正常有时不正常（反重力），向真·动画致敬？ 男主角的渲染更偏向于手绘，女主角的多种反光更“普通3D”（日光下） 讲了一大段话，从培养液里出来…… 所以又和 The Matrix 扯上关系了对吧，然后意识的信息流化又来自于攻壳 ↑注意，原话说的是精神Matrix（精神母体） 看来还是没有脱离纯数字化的东西啊，即使某些地方是提供能源用的 你猜是什么戏法……坂野马戏团 车里放的是 EONIAN/ALISE（“Arise”），被钉宫吐槽了（但其实不是 EONIAN/ELISA←本作品的主题曲）；但是后面还出现了 RONIAN/ARISE 记得吗，Thor 的标志（有点勉强） DEVA 收集了全人类的文明进行保存——The Matrix，Dark City（虽然只是一座城市），Fringe S05 既然提到了沙虫，那应该知道吧：沙丘（Sand Dune，历史上第一个RTG） 抱下女主角的镜头——连贯的背后（前景动一帧，背景动一帧） 相关理论见索尔菊苣转载的帖子。效果： 病了躺在床上一幕的，背景海报是什么？ 但是下蹲（送食物）之后背稍微后仰的动作就不连贯了，真有现代3D大机器人一顿一顿的感觉 背景人物较大的动作（例如取饭的客人、做菜的师傅），也略有不连贯；但是街上走的人正常多了 “用指尖感受基本粒子的触感”*ﾟДﾟ)*ﾟдﾟ)(*ﾟДﾟ)ｵｫｫ… 这种硬加入中文的，感觉就像 The Matrix: Path of Neo 里面的“旧上海”场景——基本上没错，但是所有的文字就几样，而且重复出现，在不同的贴图中 背景那也应该是四大美人吧(?) “酸化剂”（oxide），为什么雪飘不实在一点，翻译成“氧化剂”……（因为“酸素”？）（所以觉得会懂的就直接上了？） 墙上的海报？ 用的既不是106键键盘，也不是104/101键键盘——回车和旁边的符号布局和日式（106）键盘一致，但是没有假名变换等等键（下面只有 Fn、Ctrl、Win、Alt、Space、?、Menu、Ctrl） 追车（追地铁）的音乐，和式风格 “我”的概念，从来就是机器人电影中谈论的话题啊 SoundCloud你肿么了 姑娘你这是超高跟鞋啊，重心一直前倾大丈夫？（为了避免“没有脚”的推测，先暂定为此吧） PS. 姑娘你在地面上生活一直穿这个大丈夫？ _ 真相 人类对机器社会的恐惧也有一部分来源于此 宇宙大战的镜头把控！ 以及机器人组装（升级）的过程！节奏感、张弛有度！ Happy Hunting!(笑) High-voltage current、Land mine、Pit trap、Bomb、Jammer、Missile Launcher、Smoke ???，以及恶搞的 Firework（左下角） 颜艺了啊姑娘 老式宇宙爆炸镜头 共振弹头……总是让我想起某些具有自主意识的船啊（高雄我收了） 补一张大张 漂亮！ 手 不硬派就奇怪了，那就不是钉宫了 某马戏团大量运用…… 其他 机器人砍沙虫、小巷打架、宇宙大战、城中大战都不错（镜头的运动、人物动作流畅）——这是为了证明“新技术”能胜任多种常用模式吗？ 老虚的关键在夜谈（00:34~00:36）吧——后面又是“宣扬个性”这个主题——最后还是逐出乐园的意思啊……“真是愚蠢，乐园明明已经存在于此”。但是谁都清楚吧，对于终极阶段不是让每个人的发展为其他所有人发展的前提的社会。 第几次发射而高兴了呢……HL2EP2；To The Moon…… 但是你还没进入轨道就开始转向是闹哪样…… 安利一下之前的搜索练习 某游乐园中的某触摸板布局奇特的笔记本是真实存在的哦！松下CF-SX2JDR5FW 附萌萌的女主&amp;某娘娘 2015-08-12 附录： 在转录这一篇的时候，想起当时群里有人说过，制作公司为本片的颜艺写了专门的CG工具。查了一下记录，是syd菊苣说的。lansure也说过许多表情符合2D但不符合3D透视，但是我看不出……真的…… syd给出的链接： 乐园追放幕后制作","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"记录一次罕见的 IPv6 修复过程","slug":"zh/2014-10-26-Writing-Down-A-Repairing-Process-of-IPv6","date":"2014-10-26T07:38:00.000Z","updated":"2020-03-30T22:34:35.393Z","comments":true,"path":"categories/Misc/Records/zh/2014-10-26-Writing-Down-A-Repairing-Process-of-IPv6/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-10-26-Writing-Down-A-Repairing-Process-of-IPv6/","excerpt":"","text":"花园地址 拜 Frederick888 大神 联动： 一种免流量和翻墙的方法 Windows 下百度网盘离线下载（IPv6 通道）解决方案 普通的问题一般是由于未启动 IP Helper 服务（Windows XP 下是 IPv6 Helper 和 6to4 两个服务），或者未启用 ISATAP 造成的。网上回答泛滥。 前几天测试网盘的时候，不知做了什么，昨天发现流量走了许多，没太注意；然后网盘的链接也崩了（我改过 HOSTS），有点警觉；今天看到自己的 IPv6 tracker 全部崩了，觉得有点蹊跷。 于是用 ipconfig 检查。 ipconfig /all 发现居然没有了 ISATAP 的虚拟网卡！ 之前我是启用过 ISATAP 的，为什么没有？好，手动设置一下。 &gt;netsh int isatap set state enabled 确定。 &gt;netsh int isatap show state ISATAP 状态: disabled 嗯？为什么是这个状态？百度了一堆，也没什么用。倒是发现了一个和我同病相怜的，而且也没有列出解决方案。 既然网上也有其他的穿越方式，那么看看其他的行不行。 &gt;netsh int ipv6 6to4 set state state=enabled 确定。 &gt;netsh int ipv6 6to4 show state 6to4 服务状态 : disabled 服务终止时撤消 : default 嗯？为什么一样不行？ Teredo 我没有测试，估计也是不行吧。（即使可以，速度……）在这里猜测是某种全局设置被禁用了，因为两种方法出现了同样的问题，而且是设置成功应用失败；但是不知道是什么。 于是又去翻微软关于 netsh 的资料，没用…… 翻出去找谷歌吧。大多数人都是报 Microsoft ISATAP Adapter 的黄色感叹号问题（实际上不影响使用），而且多为 Windows Vista 的用户。找不到什么有用的。 最终的最终，找到一份有用的文档。（利兹大学？）原文附在二楼。 值得注意的是第 144-163 行。不难懂，就不翻译了。 转到对应的地方（HKLM\\SYSTEM\\CurrentControlSet\\services\\TCPIP6\\DisabledComponents），一看：键值居然是 0x0000008e（0x0e = 0x02 | 0x04 | 0x08）！我说为什么……（10-27：昨天错写成“&amp;”） 修改了之后，重启，解决。（同样 ipconfig 可以确认） 总计从今天 11:25 到 15:07，三个半小时。我个渣渣。（快去做作业…… 这种问题非常罕见，不过也许某天某人会碰上，就记录在这里吧。 Some Windows IPv6 hints and tips -------------------------------- Jim Jackson jj@franjam.org.uk Contents -------- - some links - zone IDs for link local addresses - IPv6 DNS settings - IPCONFIG &amp; ROUTE - turning off ICS - disabling IPv6 - some netsh commands Some Links ---------- http://technet.microsoft.com/en-us/library/bb878057.aspx Configuring IPv6 with Vista http://technet.microsoft.com/en-us/library/bb726952.aspx Using Windows Tools to Obtain IPv6 Configuration Information Zone IDs for Link Local Addresses --------------------------------- For link-local addresses, the zone ID is typically the index of the interface that either assigned the address or is to be used as the sending interface for a link-local destination. The interface index is an integer starting at 1 that is assigned to IPv6 interfaces, which include a loopback and one or multiple tunnel or LAN interfaces. You can view the list of interface indexes from the display of the netsh interface ipv6 show interface command e.g. ping fe80::2b0:d0ff:fee9:4143%3 tracert fe80::f282:2b0:d0ff:fee9:4143%2 IPv6 DNS Settings ----------------- netsh interface ipv6 add dns &quot;interface name&quot; &lt;ipaddress&gt; By default MS systems try using the site local addresses (fec0:0:0:ffff::1, fec0:0:0:ffff::2, and fec0:0:0:ffff::3) and addresses for Sire DNS servers. This is covered in an now obsolete IETF draft. Be kind to your ISP and firewall the old deprecated sitelocal addresses. IPCONFIG &amp; ROUTE ---------------- ipconfig shows IPv6 info associated with interfaces. Windows usually has several IPv6 tunnel interfaces configured by default, though often these are inoperative. route print shows any IPv6 routing. And routes can be manually added, if necessary. Turning OFF ICS --------------- 1. Click the Start button and then click Control Panel: 2. On the Control Panel window look for the Network and Internet icon 3. Open Network Connections by clicking View network Status and tasks underneath Network and Internet and then clicking Manage network connections on the left hand side. 4. Right-click the shared connection, and then click Properties. If you are prompted for an administrator password or confirmation, type the password or provide confirmation. 5. Click the Sharing tab, clear the Allow other network users to connect through this computers Internet connection check box, and then click OK. If you follow the steps above, but dont see a Sharing Tab There are several reasons this Tab may not be visible, but if you cannot see it, either it means you only have one network card installed in your computer or that the user interface components of ICS for Vista are not installed. Recent testing has revealed that ICS may still be running in the background. To check that this is not the case: Click Start and in the search box type in Services.msc and press ENTER In the Services windows, look for Internet Connection Sharing (ICS) and double click it. In the new window select Disabled in the Startup type option. Also remove the extra functionality in your Local Area Connection properties by uninstalling As well as un-checking the IPv6 box. Disabling IPv6 -------------- # Go to Network Connections folder (click on Start button, then right click on Network, select Properties, then click on Manage network connections on Tasks pane). # Right click on the network connection that you want to disable the IPv6 interface and select Properties. # Click Continue on User Access Control permission request prompt. # untick the check box next to TCP/IPv6 component # Click OK when done. # To re-enable IPv6, retick the check box. Or Via the Registry... 1. Open Registry Editor (regedit). 2. Navigate to the following registry key branch: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\ Services\\tcpip6\\Parameters\\ 3. Create the following registry value (DWORD type): DisabledComponents Note that the name must be exactly as shown, including capitalization. DisabledComponents is set to 0 by default. 4. The DisabledComponents registry value is a bit mask that controls the following series of flags, starting with the low order bit (Bit 0). To determine the value of DisabledComponents for a specific set of bits, the process is complicated, were hexadecimal value is calculated from binary number of the bits in correct position. For convenient, the following table lists some common configuration combinations and the corresponding DWORD value of DisabledComponents. Configuration combination DisabledComponents value Disable all tunnel interfaces 01 Disable 6to4 02 Disable ISATAP 04 Disable Teredo 08 Disable Teredo and 6to4 0xA Disable all LAN and PPP interfaces 010 Disable all LAN, PPP, and tunnel interfaces 011 Prefer IPv4 over IPv6 020 Disable IPv6 over all interfaces and prefer IPv4 to IPv6 0xFF As seen from table above, to disable IPv6 support globally on all interface, set the value data for DisabledComponents to 000000FF, or simply FF. The registry entry will look like below: [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters] &quot;DisabledComponents&quot;=dword:000000ff 5. Restart the computer for changes to take effect. 6. To revert and enable IPv6, delete DisabledComponents registry key or set its registry value to 0. Some netsh Commands ------------------- netsh is a command line program for configuring all aspects of networking. Invoke it from a DOS-box shell window. netsh interface ipv6 install|uninstall netsh interface ipv6 renew restarts all ipv6 interfaces! netsh interface ipv6 reset resets ipv6 configuration netsh interface ipv6 show ... ... address shows address setting per interface ... destinationcache show next hop settings ... global global settings ... interface summary of interfaces and info, inc number, mtu, name etc ... joins show multicast addresses ... neighbors show neighbours - &#39;merkan spelling ... prefixpolicy shows prefixes and use ... privacy show privacy settings ... routes routing table ... siteprefixes ... state shows state of some setting (deprecated settings???) ... teredo shows teredo information netsh interface ipv6 6to4 ... ... dump ... reset ... set ... interface Usage: set interface [name=]&lt;string&gt; [[routing=](enabled|disabled|default)] e.g. set interface &quot;Private&quot; enabled ... relay Usage: set interface [name=]&lt;string&gt; [[routing=](enabled|disabled|default)] e.g. set interface &quot;Private&quot; enabled ... routing Usage: set routing [[routing=](enabled|disabled|automatic|default)] [[sitelocals=](enabled|disabled|default)] e.g. set routing default default set routing routing=enabled sitelocals=enabled ... state Usage: set state [[state=](enabled|disabled|automatic|default)] [[undoonstop=](enabled|disabled|default)] e.g. set state default default set state state=enabled undoonstop=disabled ... show ... interface ... relay ... routing ... state netsh interface ipv6 add ... ... 6over4tunnel ... address ... dns ... prefixpolicy ... route ... v6v4tunnel netsh interface ipv6 delete ... ... address ... destinationcache ... dns ... interface ... neighbors ... prefixpolicy ... route netsh interface ipv6 isatap ... ... dump ... set ... router Usage: set router [[name=](&lt;string&gt;|default)] [[state=](enabled|disabled|default)] [[interval=]&lt;integer&gt;] e.g. set router isatap enabled 1440 ... state [state=](enabled|disabled|default) ... show router|state netsh interface ipv6 set ... ... address - Modifies IPv6 address information. ... global - Modifies global configuration general parameters. ... interface - Modifies interface configuration parameters. ... mobility - Modifies mobility configuration parameters. ... prefixpolicy - Modifies prefix policy information. ... privacy - Modifies privacy configuration parameters. ... route - Modifies route parameters. ... state - Sets the state of deprecated functionality. ... teredo - Sets Teredo state. Usage: set teredo [[type]=disabled|client|enterpriseclient|default] [[servername=]&lt;hostname&gt;|&lt;IPv4 address&gt;|default] [[refreshinterval=]&lt;integer&gt;|default] [[clientport=]&lt;integer&gt;|default]","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"灰色的果实，周防天音线GE通关后记（严重剧透）","slug":"zh/2014-10-23-Record-of-Grisaia-no-Kajitsu-Good-Ending-of-Suou-Amane","date":"2014-10-22T16:30:00.000Z","updated":"2020-03-30T22:34:35.392Z","comments":true,"path":"categories/Misc/Records/zh/2014-10-23-Record-of-Grisaia-no-Kajitsu-Good-Ending-of-Suou-Amane/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-10-23-Record-of-Grisaia-no-Kajitsu-Good-Ending-of-Suou-Amane/","excerpt":"","text":"花园地址 前言： 通了《灰色的果实》（グリザイアの果実）的天音GE线。好了，可以放心大胆看动画了，再也不用担心剧透——嗯我是不希望见到 bad end 的（bed end 十分欢迎），其他几条线不是很想去通了…… 而且觉得对于我这种没耐心的人，《寻找失去的未来》这种要刷8次接近相同的剧情的游戏，我应该是玩不下去的吧……虽说看过贴吧上的贴子后觉得这游戏确实不错，不过作为纯粹的小说会更好一点吧…… 资源 ED&amp;OST 英化版 日文原版 在游戏说明中说过，五个人，都是有罪的人。她们因为各自的罪过，被囚禁于这个学园中。 这个罪过，在天音的身上，就是放弃队友，致使其死亡。 不得不说，日常部分真是长……而且玩的时候，好像就是一个普通的galgame，与各妹子打打闹闹。 天音在五个人中，是最早向主角表明好感的。她是一个大姐姐一样的存在，同时也是一个略闷骚的家伙，不仅在主角的房间里换衣服（动画里这一段其实删减了一部分），而且会对着主角的床发情。不过总的来说，是一个温柔体贴的姐姐。（姐控真好）而且身材高大。 对于这样的“姐姐”，主角是有点害怕的。那是因为主角曾经就有一个高大的姐姐（有误，应为“师父”[master,先生]），优秀而严厉。这样的姐姐给了主角很大的压力，让他“难以应付身材高大的女性”。不过后来随着和后宫们的熟悉，这份畏惧感少多了。（PS. 猜猜这位“高大”的姐姐身高是多少？答案：169cm。[某人：居然比我高9厘米！]） 经过了种种日常，在拒绝了蒔菜“买爸爸”的提议之后某天，主角又接到了工作。回来的时候，在校门口被 J. B. 送上了一个“晚安的吻”，这一幕被幸撞到了，而且拍下来了。主角回到房间，天音做好饭菜，然后收到了幸发来的短信“我什么也不知道；我什么也没看到”，附件是某张照片。（吐槽：是否跟 Agent Simmons 在 Agents of SHIELD S02E05 差不多？） 天音在之前与 J. B. 见过一面，当时 J. B. 开着跑车，“勾引”着主角。那么现在就是做出选择的时候了！经过一堆废话之后，主角开动后宫之王专属技能——以吻偷心。于是，正式进入天音线。 经过多次啪啪啪之后（后来我数过，天音的 scene 是所有女主角中最多的，一共5次），某天在商店街，主角偶然听到了路人关于“蟑螂”（英化版为“cockroach”）的闲话。 当晚，主角问天音：“这个名字对于你来说意味着什么？” 天音坦白了。她就是主角姐姐的同班同学，六年前的事故发生后，14人中唯一的幸存者。从主角转学过来开始，就猜想他是同学的弟弟（姓相同啊），一直瞒着他。 六年前发生了什么？ 篮球队合宿（training camp，不过推断原文应该为“合宿”吧）返回的途中，大巴掉下了山崖。14人中，3人当场死亡。当时的天音还是一个眼镜娘，和其他的生还者差不多，都没做好应对灾难的准备。主角的姐姐虽然手臂断了，但是凭借着冷静的头脑，在这些日子中采取了必要的措施，让剩下的人能活下来。这又是很长很长的故事…… 但是到了某天晚上，天音和主角姐姐晚上出去，见到了惊人的一幕：队长和教练在咳咳，旁边散落着人的碎片（gibs）。天音吐了出来（前几天吃的肉的真相），惊动了已经丧失了人性的两人。逃跑的时候，主角姐姐的手臂降低了她的速度。眼看着追兵就要到了，主角姐姐毅然留下作为诱饵（decoy），让自己留在原地被杀死，从而让天音有机会逃离。 恶魔逼近了，他们手电筒的光柱在丛林中晃动。恶魔们扑到了 Kazuki（一樹？）的身上。这时候的 Kazuki 没有惊愕，没有泪水，却是——微笑。 PS. “一樹”是推测的，英化版只有罗马字。之前游戏中说过主角“姐姐的名字像男孩子的名字”，再看看古泉…… 这就是主角姐姐死亡的真相。而这个“放弃”给天音留下了巨大的阴影。 主角爆发了。 你（英化版用的都是“woman”）这时候不许说“对不起”！这么做是想不断揭开我过去的伤疤吗！Kazuki 不是说过吗，（在那情况下）说这么多“对不起”有什么用！跟我大声说：“谢——谢——！” 然后再发动技能：无限宽容。顿时天音哭成一团。 罪过揭晓了，接下来就是赎罪的过程。 主角在商店街遇到了一个怪蜀黍，眼神诡异。和天音到事故地点凭吊的时候，主角突然发现异常，强行压倒天音，不过背上还是中了一枪。怪蜀黍出现了，手中持着猎枪，他就是队长的父亲。 我26岁才在家族的安排下结了婚（联姻），30岁才有了这个宝贝女儿。虽然我其实不想要孩子，但是有了这个孩子，我还是将她当做宝贝看。……据警察说，在发现她的尸体的时候，她已经被大卸八块了。……后来我诸事不顺，父母逝世，妻子和员工离我而去。但是命运之神似乎又眷顾了我，前几天你从前的一个同学打电话给我，说在 Mihama 学园目击到你和男友。 跑啊！像一个猎物一样跑啊！ 但是主角伤重。 如果一起逃跑，那怪蜀黍肯定想在你面前杀死我。所以我留在这里吧，作为诱饵，你快逃！……这是命令！ 天音不想重蹈六年前的覆辙，坚定地要和主角在一起。 在这里又要做出一个选择：和天音分开，还是一起逃跑？ GE的选择是，一起。于是主角用漂亮的伏击战打倒了怪蜀黍。 PS. 怪蜀黍的下场是在集市上“大喊‘你为什么在这里’，而且开枪打接近他的人”，结果被 SWAT 击毙了。 一切结束之后，天音心里的石头还是放不下。后来蒔菜建议说，为什么二人不结婚呢？（啊呀，这是我玩到的第二个结婚结局233） 一切事件20年（结婚15年）之后，二人有了孩子（女的）。蒔菜则一共留了8年级，在前往德国的艺术学校之前，几乎一直赖在他们的公寓里。（长大之后的蒔菜还难看……） 一切事件50年之后，主角已经没了。天音身体也快不行了，在最后的夏天，和女儿一家（和外孙女）一起前往一处森林公园。 这里俯视着那片树海。 伴随着天音END的ED的钢琴版，外孙女（Suzune，鈴音？）出现了。Suzune 完全就是幼年版的天音嘛！来抱一抱……不不不，警察叔叔不要拉我！ 外婆，外公是什么样的人？是个好人吧？说到他，你好像在哭呢……是在微笑吗？……感谢上天，你是我的外婆。 听到外孙女开口就是“感谢”，想到这种性格可能是遗传自男主，天音不由得流下眼泪。至少在孙辈，自己的罪过不需他们承担了。 到现在我都无法忘记我犯下的罪。……但是只要有你在，我就不会害怕。你让我得到救赎，而这个过程，是永远。 在蓝天下，天音闭上了眼睛，外孙女的声音逐渐远去。 1、这个游戏是用 CatSystem2 开发的……表现能力和性能都还不错…… 2、如图。亮点自寻。 3、看 Extras，似乎在5×2条线之外还有别的线路…… 天音线的ED是《HOME》。五个ED里我觉得最好的一个。 试听： 「HOME」 作詞∶桑島由一 作曲∶菊田大介(Elements Garden) 歌∶橋本みゆき 迷子の子供みたい うつむいて泣いてたけど 安心できる場所が ようやく見つかった キミが残してくれた 記憶に抱かれて眠る みんなに伝えて欲しい あの人を愛してる 名前呼んでも 指で触れても からかうように 口付けしても 照れくさそうな 笑顔はもう なくて どこを見てもいない 少しだけ先歩く キミの後ろ追いかけて 次に捕まえた時 もう離さない 二度と &lt;/br&gt; 天使の子供が今 わたしの罪を許した そろそろ終わりの時間 キミの声が呼んでる 悲しい夜は 星に祈って 風邪をひいたら ちゃんと休んで ロウソクがほら 消えぬように 遠くからも 見てるからね あなたのために全部 ここに残していくから 上手く笑えるような 人になってね 好きよ 少しだけ先歩く キミの後ろ追いかけて 次に捕まえた時 もう離さない あなたのために全部 ここに残していくから 上手く笑えるような 人になってね 好きよ 于是将桌面换成天音的了……正好游戏自带 16:10 的壁纸…… 10-26 听了许多次，在部分汉字&amp;常用词发音的协助下，终于懂了…… 少しだけ先歩く キミの後ろ追いかけて 次に捕まえた時 もう離さない あなたのために全部 ここに残していくから 上手く笑えるような 人になってね 好きよ 玩过游戏才有最深刻的体会吧。听哭了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"初春引擎的 alpha 版发布与反馈（欢迎参加测试）","slug":"zh/2014-10-01-Alpha-Version-of-EarlySpring-Engine","date":"2014-10-01T15:03:00.000Z","updated":"2020-03-30T22:34:35.392Z","comments":true,"path":"categories/Misc/Records/zh/2014-10-01-Alpha-Version-of-EarlySpring-Engine/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-10-01-Alpha-Version-of-EarlySpring-Engine/","excerpt":"","text":"花园地址 原标题：初春引擎的 alpha 版发布&amp;反馈（欢迎参加测试），因为“&amp;”字符无法被百度sitemap插件处理写入 XML，所以改动了标题。 大家不要只是评论，谁来做一下小白鼠啊谢谢……已经取消了文件分享区的文件分享，请转到百度网盘。链接：http://pan.baidu.com/s/1jGwvEAU（521 MB）密码：vcmg 初次制作，若有大神看上的话，劳烦指导，谢谢…… 文件较大，为了节省大家的外网流量（虽说今天好像不限制流量，但是考虑一下以后吧），就放在文件分享区了。在几乎没人的十一假期发布，我也拼了。比预定的时间晚接近一天…… 历史上的帖子：http://buaabt.cn/showtopic-370825.aspx 欢迎反馈……反馈的时候建议附上错误说明（一般会输出，如果不是 .NET 的问题的话）。 内容取自 StrawberryNauts（©2011 HOOKSOFT）。 请先阅读“运行需求”（见下文），配置好之后直接启动 StrawberryNauts.exe 开始游戏。 运行需求 操作系统：Windows Vista SP2 或以上 DirectX：版本 9、10 和 11（注意是3个版本都需要；Windows Vista 预置 DX10，Windows 7 预置 DX10 和 DX11,；DX9 基本上不用愁） 其他组件（如果不清楚自己的机子上是否已安装，推荐安装一下）： 1、Microsoft .NET Framework 4 http://www.microsoft.com/zh-cn/download/details.aspx?id=17718（大约 48 MB） 文件：http://download.microsoft.com/do … 40_Full_x86_x64.exe 2、Visual C++ Redistributable for Visual Studio 2013 http://www.microsoft.com/zh-cn/download/details.aspx?id=40784（大约 7 MB） 选择 vcredist_x86.exe。没错，即使是64位的系统，也请选择32位的运行时。（2014-10-03 补充） 文件：http://download.microsoft.com/do … 6F/vcredist_x86.exe 3、OpenAL http://openal.org/creative-installers/oalinst.zip（大约 600 KB） 正常运行的时候应该是这个样子： 软件说明 错误反馈会输出至根目录下的 debug.txt。（会有比较详细的错误信息。） 当前为 alpha 测试所用，使用默认的 Release 方案编译。任何模块的代码都仍然可能被修改。 为了演示简便起见，省略了部分特效（如文字渐入、对话框晃动等），仅编写了淡入淡出特效。请参考 EarlySping.UI.AnimatedEffect 类实现自己的特效类。 为了演示简便起见，省略了许多错误捕获代码。因此如果想测试自己的实例，请严格按照示例（在 script 目录下，test.sns 和 details.txt）编写脚本。 为了演示简便起见，省略了部分游戏功能（如存档/读取、设置、CG 等），仅制作了普通游戏流程。当然，其实 alpha 的代码验证了的话，做这些并不难。 所有文件的默认编码为 UTF-8，注意输入的文本文件的编码。 文件按照原版游戏放置。 font 目录下有三种字体选择：微软雅黑（msyh.ttf）、宋体（simsun.ttf）、黑体（simhei.ttf）。游戏中使用的是黑体，因此想改变字体的话可以将所需的 TrueType 字体文件重命名为 simhei.ttf，替换原文件。 版本号懒得改了，目前那些 1.0.0.0 之类的其实都是默认的，没有意义…… 还原的两条线（两条？）分别为共通04的穗海EV2，以及日和橙子01的后半部分。 有福利。嗯，其实要发现是很简单的，玩了就知道。（那也叫福利？！） 此次参与的模块： 基于事件的 GUI 声音 带变量和流程控制的脚本系统（目前仅支持数字和布尔值） 简单的状态保存 该版本中关闭了一些功能，可以自行编译解决。注意，如果需要编译代码，您需要 MonoGame 3.2。 1、外置调试器。调试器已经编译，若需要游戏支持调试器，请加上 ES_DEBUG 常量进行编译。该调试器目前不是很稳定（尤其是主进程崩溃的时候），请谨慎使用。 2、视频播放。此部分已经编译，只需要将 FFMpeg 的二进制文件置于根目录下即可。 avcodec-53.dll avdevice-53.dll avfilter-2.dll avformat-53.dll avutil-51.dll swscale-2.dll 3、各种代码说明。好吧，XML 代码文档我是没用到（因为名字就可以反映大多数信息），少部分有普通注释。 当前最大的问题： 1、 目前的界面元素添加代码有缺陷，建议界面元素尽量静态初始化。本次普通窗口的控件是静态初始化的，选项窗口的是动态生成的。 描述：每次改变集合内容都会使得迭代器失效；而用户的操作实际上都是处在 Update() 中，即是遍历更新中，必须要用到迭代器。 目前解决方案：每次循环时判断元素是否变动，如果变动则中止本次循环。 推荐解决方案：考察 Windows 的窗口消息机制，特别是新建/销毁窗口后事件到达情况的改变。 2、 窗口失去焦点时重绘会导致窗口卡顿，原因不明（可能与自动坐标系中的缓冲区更新有关）。 有帖子（2013年，地址忘了）报告说 MonoGame 中仍然存在一些 trick，例如并不是“不显示鼠标”而是将鼠标移动至屏幕外等。怀疑在特殊情况下渲染不正常的原因和其在窗口大小变动时使用的 trick 有关。 目前解决方案：失去焦点时不再重绘（表现为黑屏）。 推荐解决方案：未知。 开源软件使用（按照惯例需要指出）： MonoGame 3.2（Microsoft Public License） SharpFont（MIT License） FreeType 2.5.3（FreeType License） OpenTK 1.1（MIT/X11 License） NVorbis 0.8.3（Microsoft Public License） 此次未使用： FFMpeg（LGPL v2.1/GPL v2） 好了上面是一堆的正式文本……现在开始吐槽。 Gatekeeper(Goalkeeper?) 受我一拜 Q: 为什么这么大？ A: 主要是资源大……看程序本体并不大啊…… Q: 为什么不照顾 XP 党？ A: 采用的程序集的问题。MonoGame 采用的 SharpDX 自带了 DirectX 11 的封装，而且还强制使用 DirectX 11，因此与 Windows XP 无缘了。我在论坛上问过是否能提供仅 DirectX 9 的版本，不过还没人解答这个事，估计我到时要自己做。此外，libfreetype 是写 SharpFont 的蛋疼的家伙用 Visual Studio 2013 自行编译的（估计选的还是 vc120 而不是 vc120_xp），这个把我坑了一个小时。到时我也要自己编译 libfreetype，取消这个限制。 Q: 说好的跨平台特性呢？ A: 现在先在 Windows 上测试一下……编译的时候强制检查 CLS 兼容性嘛，然后就可以开其他平台的解决方案（代码不变）了。其实主要原因是，我就一台安装了 Windows 的小破机子。另外，昨天写 WPF 的 Storyboard 的时候，发现有了 Storyboard，应该在 WPF 上做这种小型软件更好；但是 Mono 的开发团队已经声明不会去支持 WPF（而将精力转向 WCF 的支持），我只好打消了这个念头。感觉总是在发明轮子啊。 Q: 你要测试什么？ A: 我要测试的是引擎；为了测试引擎，需要基于其制作一个游戏。我们在运行阶段直接测试的其实是游戏，但是如果发生了异常，可以反映出引擎中的问题。 Q: 为什么名字那么土里土气的？ A: 土么……好吧，如果真这么认为，那就算了。名字的来源是初春饰利（Uiharu Kazari），但是直接用罗马字的话，发布到论坛上看起来就像日本人做的一样。但是要将其姓“初春”翻译成一个可以作为软件名字的名字很难（现在用的是 Early Spring，并不是很准确）……想了想，至少有中文名……囧。 来源是这里（左上角，超炮S第17话；话说初中生自制防火墙啊） 没事，国内还有一个叫“天火引擎”（Fire from Heaven，名字来源为某蛋疼电视剧）的，做了一堆外设但是目前似乎还没有一个测试品…… Q: 接下来打算做什么？ A: 最近几天么？做了作业之后就可以编索引&amp;玩 GalGame 啦~对这个的代码也会持续改进，先要积蓄内力，现在快累坏了…… 这里是游戏本体的代码。注意不是全部代码，请和框架搭配使用。由于原工程引用了同解决方案中的其他工程，懒得改了，因此请自己建立工程、引用，再编译…… SN_MainGame_Src.rar 刚刚发现 MPC-HC 升级到 1.7.6.253（随着2014年9月23日的 K-Lite Codec Pack Mega）之后，启用了 DirectVobSub，截图机制与以前也不一样了，字幕也能被截进去……（有一种被坑的感觉）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"宅的否定之否定","slug":"zh/2014-09-30-Negation-of-Negation-of-Otaku","date":"2014-09-29T16:08:00.000Z","updated":"2020-03-30T22:34:35.392Z","comments":true,"path":"categories/Misc/Records/zh/2014-09-30-Negation-of-Negation-of-Otaku/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-09-30-Negation-of-Negation-of-Otaku/","excerpt":"","text":"花园地址 按：看第一句。 本帖十分青涩，而且可能还会做出修改。 看了这么多（以3/4年的标准，远远比不上各个菊苣）东西，也逐渐适应了这个文化生态。 大一下的时候，做片，我是选配乐那个（最后挂的是“音响制作”，不过还是要吐槽剪辑没做好，配乐都坏掉了）。当时听的都是电影原声，除了那些气势雄浑的配乐，也不知道有什么其他的好音乐了。某位同学说：“动漫的歌曲好像不错，你去找找。”我说：“对不起，我对这个方面一无所知。” 以前也说过，这3/4年对我来说是一个极大的冲击。现在回想起来，应该是 culture shock 的一种吧。那么，如果如此，我现在就进入了第二个阶段——低潮期，正在进入适应期。 1月4月的番，我是看得相对较多的，极影节目单上的看了大多数；这段时间也在补老物。但是到了7月，兴奋程度明显就下去了。我已经建立了自己的标准，什么是值得看的，什么是娱乐一下的，什么要丢掉的，我自己的小列表，而不像以前那样好像什么都好，什么都新奇一样。 理性下来，冷静下来。——我为什么有一种即将脱宅的错觉？ 蜜罐就蜜罐吧，不过我好像不喜欢呆在没有味道的地方。 我吃东西的习惯有点奇怪，并不是按照“推荐的”来。例如羊汤，烙饼是从来不蘸汤汁的（以前尝过一口羊肉泡馍，然后吐了）；或者知名的北京烤鸭，从来不放酱料。 因为烙饼也好，面皮也好，都是几乎没有味道的。只有知道什么是没有味道，才知道什么是好的味道。只有有一个参考点，你才知道你走了多远，才知道你该走多远。 当然对于吃饭，我有自己的食物刺激理论，这个就不提了。 所以对于“某些作品好好看啊，我要刷完”之类的感觉，我是曾经有过，或许谁都会有；现在看起来，真幼稚，就像肉汤中的草履虫。 是疯狂地追逐好呢，还是什么都不知道好呢？都不好。我现在的状态和大一的差不多了，但是，毕竟经历过了，也就了解了，而不是以前的我。辩证的发展，是在否定之否定的基础上进行的。 既然身为三次元的生物，就要在三次元中活着。叫我去刷作品，或许会；兴至而来，兴尽而去。离开二次元？对不起你是认真的吗？我并不想，但是就像割肉，在特定条件下是可以的。最好的状态，莫过于细品红酒，不是狂饮贪杯，亦不是滴酒不沾；细水长流的醇香，远比醉后的头痛要值得。 话说我也想有一个随便开挂开后宫怎么也不老能无限复活遍地亲情友情的世界啊！可是如果我的精神去了，我的本体是要在虚无中腐坏么？ 只是之前看了索尔的帖子http://buaabt.cn/showtopic-372182.aspx之后想了一点，今天抽空就记下来了。先膜拜索尔菊苣。 写在这里，如果以后入坑的同志们，或许会经历这个过程。看到这个，至少会知道，有人和ta一样，曾经 too young too simple sometimes naive（也许现在还是233）了。 附：当时搜到的部分音乐（来自 ACG） Pearl White Story 风を待った日 君を思うメロディー 空と海の诗 惨劇の記憶（来自《这个是僵尸吗？》，当时还以为是多悲剧的东西） 時代を越える想い 题外话1 引擎的一个预览版的 public demo 在十一内就能出，现在在做其中一条线的脚本。（转译真是麻烦的事） 题外话2 还有两部7月番的配乐给我印象深刻。我一直奇怪为什么还不放 OST，结果今天一查，一个几天前发行第一部分一个11月，都不知道到时还记不记得了……有心的同学就帮搬一下吧。 http://vgmdb.net/album/46574（东京ESP） http://vgmdb.net/album/47373（月刊少女野崎君）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"视频黑科技的幕后故事（初步完坑）","slug":"zh/2014-09-20-Video-Hacks-Behind-the-Scene","date":"2014-09-20T12:28:00.000Z","updated":"2020-03-30T22:34:35.392Z","comments":true,"path":"categories/Misc/Records/zh/2014-09-20-Video-Hacks-Behind-the-Scene/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-09-20-Video-Hacks-Behind-the-Scene/","excerpt":"","text":"花园地址 按：当时尽心尽力了，现在看起来还是图样图森破。 发布到博客预备 TOC 的时候加上的标题一样开坑。该帖将讲述《内网环境下，FGBT贴内附视频、音乐的黑科技介绍》的原理，有基础的同学可以参照本篇开拓自己的思维…… 何谓“基础”？很难讲啊……嗯总之是相关领域基础中的基础就对了。 我会尽量写得详细，并兼顾易懂性。欢迎评论。 （好像操作部分也讲了一些……原理不纯了诶） 分为三个部分： 基础篇 附件法 iHome 法 两种方法各自的效果如下。这里仅作为音乐试听器，不过同样也可以作为视频预览工具使用。 附件法（进度条守身如玉） 来源：Pearl White Story——君に届け 2ND SEASON（好想告诉你 第二季） iHome 法（进度条可以调戏） 来源：風花——はつゆきさくら（初雪樱） 另外（有点相关的）吐槽： すま的自谦过度了。 这个只是我爆发一个小时的成果的原理部分，请不要给放膝盖，如果放了的话我肯定会被技术帝如lansure、晴朗园界、CFan、工口之主等人，以及各种版主啊不爽的群众啊追杀。为了我的生命安全，请大家多考虑一下…… 我居然抢到了视频编号233，23333333333333333333333333333333333333333333333333333333333333333333333333 基础篇内容： HTML ASP 页面/PHP 页面的参数调用 扩展名与文件内容的关系 串流与流媒体 站点的相对路径 流 一、HTML对网页稍稍有点了解的同学应该知道 HTML（Hypertext Markup Language，超文本标记语言）。网页浏览器识别的内容，大多是以 HTML 为载体的。 一个页面，也就是 HTML 文档的结构，是典型的树状结构。例如： &lt;html&gt; &lt;h1&gt; 标题一 &lt;/h1&gt; &lt;body&gt; &lt;!-- 下面这一行会创建一个链接 --&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;链接文字&lt;/a&gt; &lt;foo /&gt; &lt;/body&gt; &lt;/html&gt; 这些用“&lt;&gt;”括起来的，就是树的节点（node），这些东西叫做标签（tag）。如果节点中还有内容（HTML 默认内容是文本），就需要以&lt;...&gt;开头，以&lt;/...&gt;结束，例如上例的&lt;body&gt;...&lt;/body&gt;；否则，在节点内以“/&gt;”结束即可，如上例的&lt;foo /&gt;。表示一个页面元素（一般是能显示出来的界面元素）的，就简称为元素（element）。 一个节点可以带有属性。属性只属于描述的节点。例如上例节点&lt;a&gt;有一个属性，名称为“href”，值为“http://www.baidu.com”。综合&lt;a&gt;标签的语法，href 属性即为链接指向的目标。 现实中的例子，可以在任意页面上右键，单击“查看源代码”。 二、ASP 页面/PHP 页面的参数调用到这里可能有的同学要问了，那么为什么我们会见到 .aspx（ASP .NET 页面文件），就像花园这样呢？略了解的同学会知道，ASP 页面和 HTML 还是有一点差别的。 这是因为，HTML 其实是一个相对静态的语言，所描述的只是一个静态的页面。即使加入了 JavaScript/VBScript，应变能力还是有限。由此人们想出了一种方法，让页面返回一个 HTML 页面。 采用这种方法的典型例子如 ASP/ASP .NET，以及 PHP。当你向服务器发起请求连接到相应的页面时，相应的 IIS/Apache 服务器会动态执行该页面代码，并输出一个 HTML 页面。这样，虽然地址栏里还是 .asp/.aspx/.php，但是读取到的仍然是一个 HTML 页面。说白了就是源页面写了一个 HTML 文件（当然实际上有点区别）。 那么我们就可以将相应的源页面看做是程序，有入口点（entry point），可以有输入参数。这个在普通的程序中很常见，例如 C/C++ 的 int main(int argc, const char* argv[]) C# 的 void Main(string[] args) 等等。那么在这些页面中是怎么传递参数的呢？ 是这个样子的： http://www.somesite.com/somepage.aspx?param1=value1&amp;param2=value2&amp;param3=value3 在上面的例子中，我们就向 somepage.aspx 传入了三个参数 param1、param2 和 param3，值分别为 value1、value2 和 value3。 没错，是在页面后以“?”作为分隔符表示输入开始，参数之间用“&amp;”分开。 例如，未来花园的种子搜索页面 http://buaabt.cn/showseeds.aspx?keywords=Hello%20World&amp;state= 传入两个参数，keywords 和 state，值为“Hello World”（注意之间的空格，编入 URL 中时要转义）和空值。 或者我们直接搜索种子产生的页面 http://buaabt.cn/showseeds.aspx?keywords=%u8F93%u5165%u641C%u7D22%u5173%u952E%u5B57%3A%u79CD%u5B50%u6807%u9898 输入的内容就是“输入搜索关键字:种子标题”（原 URL 进行 UNICODE 反转义之后的结果）。 由此也不难理解为什么会出现 URL 转义，以及 Base64 编码——这些都是让复杂的内容得以转化为字符串，在地址栏或者页面中传播。 之后的附件方法会用到该原理，因此在这里列出来。 三、扩展名与文件内容的关系计算机新手会认为，似乎变了扩展名（extension，也叫“后缀名”），文件就发生了变动一样。其实，文件内容是不变的。那么扩展名是干什么用的呢？ 扩展名是用来表示一种约定的，它建议操作系统的壳（shell）采用某种方式来解读该文件。例如，在 Windows 下，我们双击（不只是双击，更多应用请参见其他文档）一个 .txt 文件的时候，Windows 的壳，也就是资源管理器，会到注册表的 HKEY_CLASSES_ROOT 中寻找与 .txt 扩展名相关的信息，并找到“我应该用记事本通过命令调用的方式打开该文件”的结果，于是我们就看到记事本打开了一个文档。如果我们换一个扩展名，操作系统的壳会按照新的约定来解读这个文件。 为什么要提这个呢？那是以为操作帖里有重命名的操作。重命名的时候，千万不要认为文件变了。同时，似乎 Windows Media Player 只通过扩展名来识别文件而不尝试读取文件头，因此可能要非常注意这一点。 四、串流（streaming）与流媒体（stream media）我们一般在磁盘上看到的文件是十分完整的——游戏、音乐、电影，等等。但是在网络中，需要实时传输的场合，例如视频电话，就需要用到串流技术。 串流技术的原理很简单。可以串流播放的文件就是流媒体文件，其十分简化的结构模型如下： 文件头（可选）-数据包-数据包-数据包-数据包-数据包-数据包-数据包-……-数据包-文件尾（可选） 我们看到听到的信息，如视频和音频，它的信息就包含在数据包里。我们不断收到数据包，本机的解码器不断解码，然后呈现出来，就成了我们所见到的东西。 （说起来简单，如何做数据包的同步，以及协议和帧设计，其实是很麻烦的……） 只要以帧（frame）为基础的文件类型，一般都可以转化为流媒体。常见的有：MP3（MPEG Audio Layer 3）、WMA（Windows Media - Audio，基于 ASF）、WMV（Windows Media - Video，基于 ASF）、RA（RealAudio）、RM（RealVideo）、Flash 视频（Flash Video）、ASF（Advanced Streaming Format）等等。 例如，iHome 上的直播就是采用 ASF 作为载体的。其特点是，并不存在完整的文件，而只有缓冲区（体现为文件或者内存数据块），并随着时间不断更新，直到停止播放时被删除/释放。 为什么要提这个呢？这是因为未来花园支持嵌入流媒体文件链接，这样如果通过某种方式（例如只上协议链接），或许也可以通过这种方式播放大文件（未试验成功）。 友情提示：建议不要嵌入 RealMedia 相关文件（.ra/.rm/.rmvb 等等），因为许多人的计算机上是没有 RealPlayer 插件的，而且有些浏览器对这些插件的控制十分严格。 五、站点的相对路径有经验的同学应该知道，在多数操作系统中，“.”表示当前路径，“..”表示上一级路径。而且有同学也会注意到，在学习 C 语言文件操作的时候，示例里一般是这么写的： FILE *fp; fp = fopen(&quot;filename.ext&quot;, &quot;r&quot;); ... fclose(fp); 有没有人注意过，为什么我们写的是“filename.ext”，操作系统却能准确地找到我们所指的文件呢？（前提是，小白们将文件放在了正确的地方……见下文。） 先讲一下两个概念：绝对路径与相对路径。绝对路径（absolute path）指的是指定了完整路径的路径（例如 C:\\Windows\\System32\\cmd.exe``，/usr/some_dir/file）。其他的就是相对路径（relative path）。 那是因为在程序运行时，有当前目录（current directory）的概念。在进行文件操作时，操作系统会检测所输入的路径是绝对路径还是相对路径，如果是绝对路径则直接寻找相应的文件，否则按照一定规则在各个目录中寻找。例如，在 Windows 中，是“当前目录→%SYSTEM%→%WINDOWS%→%PATH%中的各个目录”。（插一句，在运行程序的时候，工作目录（working directory）指的就是将被设为默认当前目录的目录。） 接着前面的例子，按照该规则，操作系统最终找到了我们所指的文件，然后打开/创建。 当然，我们也可以这么指定： fp = fopen(&quot;dir1/dir2/dir3/filename.ext&quot;, &quot;r&quot;); 这样的含义是，按照之前的规则进行搜索时，要加上子目录 /dir1/dir2/dir3（注意斜杠的位置）。 网站的链接也采用了这个概念。例如，我们会在一些地方发现这样的链接（这个在之后的页面分析中会有用）： /level1/level2/page.htm 这个含义和刚才讲过的很相似，指的是在当前域名的基础上，加上这个相对路径所得到的最终地址。 以未来花园为例，其域名为 buaabt.cn。那么我们再指明一个相对路径 /showtopic-374580.aspx（注意斜杠的位置），那么得到的就是下面的链接： buaabt.cn/showtopic-374580.aspx 浏览器同样遵循这个规范，于是将这个相对路径映射为最终的地址（若未指明协议，默认为 HTTP）。到我们需要打开那个链接的时候，会打开正确的地址。 六、流（stream）在这个帖子里3190_iHome进行了实验，雷米莉亚·斯卡雷特（用户，不是大小姐ww）指出了“不要调戏进度条”。 其实进度条能否被调戏，和流的性质是有关系的。 什么是“流”呢？我觉得，将其形象地想象成水流就好了，访问者看上去数据像在数据流入（读）流出（写）。流的实质是缓冲区（buffer），随读写需要，访问者从这块缓冲区读数据，或者往这块缓冲区里写数据。对于可读的流，缓冲区的数据量低于一定值时，会从源处加载数据以尽量“充满”这个流，直到无剩余数据可读；对于可写的流，如果写入的数据超过了缓冲区大小，则将其真正地写入目标（也可以指定即时的操作）。当一个流关闭时，缓冲区将被释放，所含数据被清空，对于可写流，数据将被写入。内部实现可以用缓冲区指针的方式，所以合理用 C 中的文件函数就可以模拟 C++ 中的 istream 和 ostream，毕竟是差不多的。操作者可以一直调用读取或者写入操作，不用间断（需要相应支持），因此才像连续的水流一样。 流有多种，只需要数据+缓冲区，就可以作为流。例如，本机的文件流、网络的传输文件流、作进程内部传输数据用的字符流，等等。 既然有读写，那么是否还支持这两个特征呢：获取/设置流长度、定位（seek）？答案是，未必。有的流是支持的，有的流不支持，视源的性质与实际编写的代码而定。例如，基于本地文件的流一般是支持定位的，只需要移动文件读写指针就好了嘛。但是网络传输流一般不支持，服务器只负责将数据块连续地传给用户，并不需要实时响应用户的定位操作。（问：那么断点续传怎么实现呢？答：如果被调用方提供了初始位置参数，返回指定初始位置开始的流，那么就可以实现断点续传。） 我们在播放器中拖动进度条，其实就是在请求相应位置开始的流。所以，附件法返回的流不支持定位，也就不能调戏进度条；但是 iHome 法是基于网络文件的（这个文件可是实实在在的），所以这个流支持定位，也就可以调戏进度条啦！ 附件法（以 FLV 为例）请先准备一个 5 MB 以内的 FLV 视频文件。相关的压制技术不在该原理的讨论范围内。 其他大部分格式，因为作者懒，没有测试（除了 WMA 测试未通过）。 将该视频作为附件上传（利用花园的附件功能）。如果要问为什么在选择文件的对话框中找不到的话，那是因为花园系统设置了一个扩展名的过滤器（filter），只显示支持的文件。什么叫“支持的文件”呢？就是那些在花园的环境下经常用到，而且合理合法的文件格式啦。例如 .rar/.zip 是压缩文件，.ssa/.ass/.srt 是字幕文件（多见于电影版和动漫版），都是花园众人常常下载资源之后需要的。 那么有没有办法“蒙骗”花园系统，让其能支持自己的文件呢？有：在基础篇中就讲过，修改文件扩展名，不影响文件内容。而且，当前花园的系统只认扩展名，不检验文件内容是否真的是声称的类型，因此我们可以钻这个空子。 可以选择添加新的扩展名（双扩展名文件，有些防护软件会出现警告）、直接更改扩展名等方法。具体看个人喜好。更改之后就可以上传了。 友情提示：请注意，要真正地修改其扩展名，请在资源管理器的选项中取消选择“隐藏已知类型文件的扩展名”。同时，不要改为图片类的扩展名，因为如果如此，花园系统会尝试加载图片；当然加载会失败，那上传也就失败了。 上传完毕之后，我们可以看到帖子中生成了一个附件代码： [/attach]645110[/attach] （为了解除附件引用，我在第一个attach前加了一个“/”，否则会作为代码中的附件出现，囧。实际使用时请去掉这个斜杠。） 直接浏览帖子时看起来像这样： Pearl_White_Story.flv.zip 在保存帖子之后，我们可以看到attach标签的作用：指导后台在用户请求该页面的时候生成一个指向该附件文件本身的链接。 可以看到，链接的格式非常直观。这个链接的作用是，向域名根目录下的 attachment.aspx 请求指定附件代码（attachmentid 参数的意义）的文件。此时，返回的是一个文件流。一般的浏览器会获取正确的文件名，并显示出来。（这里插一句，有些同学用迅雷之类的软件下载花园的种子，文件名显示为 attachment.aspx，就是因为迅雷未正确解析花园传来的文件流。在种子下载上放弃迅雷吧孩子们！） 然后我们就可以利用花园的“插入 Flash 文件”功能，或者flash标签，就像一般的插入播放器地址一样，插入该视频文件。 [flash]/attachment.aspx?attachmentid=645110[/flash] 为什么插入成这个样子，请阅读基础篇的“站点的相对路径”一节。 如果插入为完整路径（buaabt.cn/bt.buaa6.edu.cn/ipv4.buaabt.cn 开头），会造成部分用户访问异常。例如插入限定为 IPv4 的地址时，使用 IPv6 的用户无法访问该链接，也就无法播放该视频；反之亦然。花园的地址自动转换仅限于url标签。（感谢lansure指出这一点。） 等一下，虽然离成功很近了，但是还差一点！由于某种原因，flash标签的解析有点问题。如果直接使用上面的地址，会发现播放器无法播放，即使你的附件的确是 FLV 视频文件。此时要给 attachment.aspx 一个新参数 filename，限定输出的文件名。文件名自定，只要是以 .flv 结尾就可以了。修改之后如下： [flash]/attachment.aspx?attachmentid=645110&amp;filename=pearl_white_story.flv[/flash] 附件的方法到这里为止，就介绍完毕了。最后，由于我们直接与 attachment.aspx 交互，因此也可以指定别的附件的附件 ID 哦。附件 ID 的获取方法在上面图示里已经出现了。 这里是效果： [flash=600,20]/attachment.aspx?attachmentid=645110&amp;filename=pearl_white_story.flv[/flash] iHome 法（以 FLV 为例）请先准备一个 100 MB 以内的 FLV 视频文件。相关的压制技术不在该原理的讨论范围内。 其他大部分格式，因为作者懒，没有测试（除了 WMA 测试未通过）。 首先，我们需要构造（说得这么高端……就是“找”啦）一个数据源。选择 iHome 提供的视频上传应用并上传一个视频。 在上传之后，在新鲜事中打开刚刚上传的视频，记录下地址，例如本例：http://i.buaa.edu.cn/plugin.php?pluginid=video&amp;ac=view&amp;vid=233。注意如果想保护个人隐私，请删除自己相关的新鲜事记录。 接下来就到了页面解析的阶段了。我们来查看一下页面的信息。不同浏览器的界面有所不同，不过操作和原理是类似的。这里我们以 Google Chrome 为例讲解。 我们的核心目标是：获取视频的真正地址。之后此处所有的操作都是围绕着这个目标展开的。 我们可以选择直接看源代码（适合老手），或者借用浏览器自带的调试功能——审查元素（适合新手）。前者么，其实看到源代码，一切都了然了，就不用多讲解了。后者适合新手的原因是浏览器会自动整理代码风格、缩进等，比较直观方便，本质上和前者是一样的。 马上看到了这个页面的结构，由许多分块元素（&lt;div&gt;标签所指示的）所组成。鼠标在其上移动的时候，页面会实时展示该分块代码所对应的页面元素，因此定位非常方便。 想想，哪里会用到视频地址呢？很显然是播放器嘛。对网页里的视频播放器稍微有点了解的同学会知道，这些大多是基于 Flash 技术（少部分是 Silverlight）制作的。知道历史的同学也应该知道 Flash 的发展史，Shockwave→Macromedia→Adobe。因此我们的关键词也确定了，开始寻找有用的信息。 很快我们就能发现，这一段可能有很大的帮助： &lt;object classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot; codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0&quot; width=&quot;660px&quot; height=&quot;495px&quot;&gt; &lt;param name=&quot;movie&quot; value=&quot;ihome.swf&quot;&gt; &lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt; &lt;param name=&quot;allowFullScreen&quot; value=&quot;true&quot;&gt; &lt;param name=&quot;FlashVars&quot; value=&quot;vcastr_file=attachment/201409/26/3663_1411697963lE29.flv&amp;amp;LogoText=ihome&amp;amp;TextColor=0x0000FF&quot;&gt; &lt;embed src=&quot;ihome.swf&quot; allowfullscreen=&quot;true&quot; flashvars=&quot;vcastr_file=attachment/201409/26/3663_1411697963lE29.flv&amp;amp;LogoText=ihome&amp;amp;TextColor=0x0000FF&quot; quality=&quot;high&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; type=&quot;application/x-shockwave-flash&quot; width=&quot;660px&quot; height=&quot;495px&quot;&gt; &lt;/object&gt; 是不是看到什么了？嗯，很好。 可能有过单机程序开发经历的同学会觉得有点奇怪，为什么没有显式的加载文件代码呢？ 原来是作为参数传递了过去。这里出现了两次，第一次是在&lt;object&gt;节点的&lt;param&gt;子节点处，名称为“FlashVars”；第二次是在&lt;embed&gt;元素的 flashvars 属性里。（对于新手，如何解析这个链接，请参见基础篇的“ASP 页面/PHP 页面的参数传递”。） 我们可以见到最重要的一个参数是 vcastr_file，值是 attachment/201409/26/3663_1411697963lE29.flv。（“&amp;amp;”是“&amp;”字符的转义符，这里位于一个 URL 中，因此会这么出现。其他两个参数猜测是 iHome 播放器的水印参数，不过目前还没看到有什么用途。） 然后参见“站点的相对路径”节，根据当前的域名 i.buaa.edu.cn，我们就可以拼出视频的完整地址： http://i.buaa.edu.cn/attachment/201409/26/3663_1411697963lE29.flv 然后嵌入未来花园的 Flash 播放器： [flash]http://i.buaa.edu.cn/attachment/201409/26/3663_1411697963lE29.flv[/flash] 大功告成。 这里是效果： [flash=600,20]http://i.buaa.edu.cn/attachment/201409/26/3663_1411697963lE29.flv[/flash]","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"制作游戏引擎中……（public demo 已经放出，欢迎做小白鼠）","slug":"zh/2014-09-07-Building-A-Game-Engine","date":"2014-09-06T16:18:00.000Z","updated":"2020-03-30T22:34:35.391Z","comments":true,"path":"categories/Misc/Records/zh/2014-09-07-Building-A-Game-Engine/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-09-07-Building-A-Game-Engine/","excerpt":"","text":"花园地址 2014-10-01 demo 在 http://buaabt.cn/showtopic-377837.aspx 我在担心大神看到这帖子只会一笑置之啊…… 这帖子是为了记录开发过程而写的。为什么放在漫版而不是软件版呢？个人觉得漫版更亲切一些，而且能过滤掉大多数小白……对不起最后这个半句有点冲，但是我的确认为那些只是纠结于软件的使用的人很麻烦…… GLaDOS: At the Enrichment Center we promise never to value your safety above your unique ideas and creativity. However, do not destroy vital testing apparatus. 我大 Gatekeeper 镇楼。 开发引擎中，代号 Haru。 目前需求： OS: Windows Vista 或以上（因为 MonoGame 使用的 SharpDX 强制加载 DirectX 11；我机器显卡不支持 OpenGL v3 因此也无法使用 Windows OpenGL 模板）。嗯跨平台最后肯定要解决 XP 这一块的问题的，实在不行就自己去修改源代码编译 SharpDX。 其他所需组件： OpenAL 如果要播放某种格式的视频，当然需要对应的解码器…… 目标： 开源 跨平台 快速开发 开放接口 组件化 （目前的）终极目标： 成为兼容 KiriKiri 的跨平台引擎 有些组件授权为 GPL，所以引擎相关部分的开源是必须的。不过由于引擎组成仍然不完整，因此先不将代码公开。 有些组件来源于网络，我记录了相应来源。不过大多数没达到我的要求，所以我对其做了修改。 基于 MonoGame，所用语言为 C#、C++/CLI。由于目标是跨平台的，因此项目中用的大部分是可移植的代码；小部分平台相关的代码分离了出来作为某些抽象类/接口的实现。 这是我第一个涉及 C++/CLI 的项目，感觉确实挺好用的…… 现在已经实现的功能（会持续改进）： 基于事件的 GUI 支持 音频支持 多字节字符集的支持(*) 自适应坐标系统 外置调试器 部分实现的功能： 视频支持（现在还未实现直接读取视频中的音频帧&amp;同步） 将加入的功能： 脚本（准确来说，现在为了引擎演示，做了一个小型的脚本分析器，不过最终肯定不会用这个） 类似 VPK 的资源管理 插件系统 自适应帧率调节 优势： 运行于 Mono/.NET 平台，充分利用符合 CLS 的语言的优势，不需要纠结于底层代码。以前我做的是直接基于 SDL 的，文本&amp;视频先不说，单是对象生命周期的控制（以及 STL！）就很令人不好了。自从换了 MonoGame，腰不疼了，腿不酸了，吃嘛嘛香！ 担心效率损失？嗯，确实会有一点，不过至少现在没明显缺陷，而且我也会尽量将其做好。例如现在的演示中，主界面背景就是 Strawberry Nauts（不要问我为什么又拿这个游戏开刀）的 OPMV 文件（视频），在我这渣本上照样能跑出 36 fps，资源占用也与 MPC-HC 播放同一个视频时相当，还别提视频上还有一个动态组件（用作简单特效演示）在跑着……前两天就在手工优化这个，头疼死了……游戏主内容的画面，一般是 50~60 fps（XNA/MonoGame 固定刷新频率模式时的封顶刷新频率）。{2014-09-07 16:15 CPU 占用率正常在2%~8%，播放视频大约在20%。这个占用率相比直接用 C++ 从底层操作 DirectX 来说确实高了一些，不过还是在可以接受的范围内的。} 该引擎支持多字节字符集，目前绘制效果也与 KiriKiri 相当。 可扩展性。现在的演示是一个小小的 AVG 引擎，不过就像 KiriKiri 一样，其能力不止于此。完全可以继承一些基础类（也可以选择自己实现接口 = =）之后做 RPG/STG……据说《魔法使之夜》很华丽（我个人没看过），假设某一天做好了，可以移植来试试。实现插件系统之后就可以在引擎的基础上写插件，而不用修改本身的代码了；甚至做成 foobar2000 的结构（需要好好准备）……（这个方面推荐看一下 SharpDevelop 的代码。） Bugs &amp; 改进： 视频播放组件有少量内存泄露，还没查出来在哪里…… 文字绘制资源占用率稍微高了一点（满屏文字的话，帧率下降到30），不过可以再优化。 组件结构还有少量变动，我面向对象&amp;组件化是渣渣（多看书！）…… 另外，在已有的组件的基础上，今天写这个小小的 AVG 演示，连同简单脚本解析器一起，加起来也不超过一个小时……够快的…… 完成这个阶段的目标的时候，就可以考虑将整个引擎脚本化了。不过在此之前，我要去学编译原理……（对，还有之前的弹幕君的事……） 脚本处理，综合所用环境，可以考虑用 Roslyn（类 C#），用 Jurassic（类 JavaScript），或者基于 TypeScript。为了更好地使用工具，应该先将原理弄清楚…… Q&amp;A Q：为什么不用 KiriKiri？ A：我讨厌无类型语言！（←知道我在说谁吧）而且 KiriKiri 主程序用了许多 Windows API 导致无法移植到其他平台。W. Dee 正在做 KiriKiri 3（目标是跨平台），不过总觉得吧，我们可以自己实现一个这个……而且不管对于希望写小游戏的人还是游戏公司还是希望研究这个的人，C# 明显比 C++ 好理解多了对吧，开发效率也高一些……（而且 KiriKiri 缺少中文或英文注释！连文档都是日文的！叫我这种日文渣怎么扫啊！）至于 KAG，那是见仁见智的事情……高级制作肯定不止要用 KAG，至少要深入 TJS 吧……这一段看以后脚本化了怎么设计吧。 Q：为什么不用 PyGame/Ren’Py？ A：我讨厌无类型语言！（←知道我在说谁吧）而且 Ren’Py 是基于 PyGame 的，PyGame 是基于 SDL 的，对多字节字符（例如，中文）的支持很蛋疼……好吧即使不蛋疼但是写起程序就那类型问题还是很蛋疼…… Q：为什么不用其他的，例如 ALICESOFT 的，或者 ONScripter？ A：不！用！就！是！不！用！ 在最后，要感谢 MSTC 的成员。 我加入 MSTC 之后第一个参与的是 SpaceMoto（开发这个的同学我忘了你的名字，但是还是要吐槽你的拼写），一个用 XNA 开发的游戏。这个东西似乎没有流传到外面。（上一年大神开发的类似性质的 Ocean Scream 可是作为编程竞赛的平台的。后来微软策略改了，SpaceMoto 后面也没听到什么消息。）不过呢，其实主要是我和另外几位（另外几位是大神）在讨论设计之类的问题，不过后来我也没怎么参与了，这位同学一个人将 SpaceMoto 写了下来…… 然后大二这一年，我在 MSTC 中非常非常不活跃，仅仅是负责了第一次招新……我都怀疑自己能否有能耐和那些大神们坐在一起选新人…… 不管怎么样，Ocean Scream 的源代码我还保存了一份。一年前我看的时候，总是搞不清游戏的运行机制。当时思维主要还在 VB6 的阶段，VB .NET 也只是简单应用；代码里各种东西觉得乱七八糟的，看不懂。一年之后，我终于有足够的能力做 MonoGame 的开发了，能读懂为什么要这么写代码了，能做一点应用了。 说实话，我不知道这一年来我在技术方面积累了什么，好像没什么吧，但是这种感觉真的很神奇…… 将我领进门的 MSTC 的成员们，感谢你们！特别是6系和21系的几位大牛。（在花园里点名表扬好么？好的话就点名了吧……） （为什么弄得有点像“师父在天之灵”的样子……诶诶我不是这个意思……） PS. 因为是无类型/弱类型语言，而同时被我讨厌的还有 MATLAB、BASIC（不是 VB）和 JavaScript。 PPS. 人家 W. Dee 早我14年做出一个应用广泛的引擎，作为后辈，追是不容易的，但是还得有人有这个志向吧。 PPPS. 看演示的同学表示演示内容很蛋疼。 PPPPS. 有人会说：“你做了引擎，没有好内容，照样没有好游戏。”没错，所以要做成品游戏，还得找美工&amp;音乐。 PPPPPS. @紫晓暮雾 关于之前提到的那个制作类似手绘2D效果的玩意儿，这个假期看了一些动画设计理论的书，表示我原来提出的，我还没有能力实现。就是说，以我计划能达到的技术水平，做出来的东西还无法达到设计师需要的水准。所以暂时搁置吧。但是还是要考虑的，不留 loose end。（← General Sheperd） PPPPPPS. 如果你们在想我是6系或者21系的，那就错了。 *2014-09-07 13:13 加入 2014-09-07 12:50 （此内容针对 AVG） 在脚本指令里多加一条，游戏页面中加入一个图像控件，一个简单的立绘系统就完成啦~由于每个元素都可以应用特效，所以拓展是非常方便的~ 2014-09-08 （因花园暂时关闭而未发上来） 更改了字体渲染后端。现在可以脱离 System.Drawing 运行。（不过附加问题是排版上有时有 3 px 左右的偏离，以及字形的控制要自己写……好吧我得看看文档……） 另外一个重大改进是，解决了锯齿&amp;字体颜色问题。这里给可能会遇到该问题的后人留解决关键吧：Microsoft.Xna.Framework.Color 的颜色格式其实是自乘（premultiplied）的。相关信息见链接。怪不得 PixelFormat/SurfaceFormat 里还有 PARGB（就是 Premultiplied ARGB 啦）的枚举值…… 2014-09-09 修复了一个透明度bug。此外，AVG 子系统开始制作。 2014-09-11 * Public demo 有希望了……不过马上就是国赛，然后立即开始上课，体力可能会不济，时间推迟一些…… 嗯，附加一句，以现在的框架，写起来就和写 WinForm 程序一样。 2014-09-12 凌晨 (00:15) 给字体布局写了一个解决方案，多次测试暂时没发现问题。因为所用的东西和 TrueType 的文档有些地方不一样（或者是我的理解问题），所以还无法验证该方案是否真的没问题。 另外 MonoGame 的最小化-恢复问题真的要命啊……还没有一个好的方法解决这个问题…… 今天早上就要开始国赛了我是不是在作死…… 2014-09-12 凌晨 (02:40) 睡觉之前想还是解决一下窗口大小的问题吧……结果这么下去就继续作大死了。 刚刚解决（在 Windows 平台下，其余未测试）。结果表明不是 MonoGame 的问题，而是我原来处理方式有误。 上社区&amp;调试了半天，发现最小化时会发送一次 ClientBounds = Rectangle.Empty 的消息。然后对其进行响应，保存并恢复状态啥的……两个多小时就这么过去了。 附加的提示：建议开启 IsFixedTimeStep，这样 XNA/MonoGame 会自动帮你处理刷新速率问题。如果设置为 False 的话，在窗口大小为零时由于 Draw() 立即返回，导致 Update() 被几乎是死循环式地调用。 另外，如果在最小化（此时位置为 (-32000, -32000)，大小为 (0, 0)）时，如果不按照默认处理办法（直接按照新窗口大小为0进行自动调整），而将缓冲区大小强制设定为一个非零大小的值（例如 (160, 90)）并绘制，会出现一个 CPU 占用率也不高但是所有操作都变得非常缓慢的问题，不知道是什么造成的。在这里记录下来。所以我才写了一段很别扭的代码用来检测和避免各种恶心的情况。找原因和解决，这两步都花了很长时间…… 看社区里人们遇到的问题，例如早期 OpenTK v1.0 的 (1, 1) 问题（导致无法最小化；在 OpenTK v1.1 中修复为 (0, 0)，就是现在的样子），会手工解决的人不多，所以哀鸿遍野，感觉我用的还是经过多次改进的东西，算轻松了…… 看来是真作死了。 2014-09-12 凌晨 (03:57) 本来以为好了，谁知道在失焦和最小化的时候还是有卡顿的现象……于是琢磨了一个小时……现在算是可以了，但是代码里一堆“// HACK:”…… 2014-09-23 开学之后果然很多事情就出现了。今天脚本系统（原型）才初步测试完毕……不过目前已经隐约有游戏的影子了…… 2014-09-26 凌晨 (01:44) 卡顿的问题还没解决，只好限制重绘时机了。另外，有时居然发生音频值错误，而且根据调试结果，是多次多点偶然的…… 一条线制作完成。嗯细节么……这是一个 technical preview 而已，所以八分相像即可。另外，还是拿SN开刀 2014-10-01 凌晨 找了第一只小白鼠试验运行了一下。这位小白鼠今天早上还要出队爬山，感谢啊感谢。被所采用的组件坑了不少。 先记下来吧。VCRT12（某个蛋疼的家伙居然拿 VS2013 来编译，在小白鼠的机子上直接就初始化失败了，幸亏我还是有点经验，去查看了导入表）/OpenAL，绝对绝对不能缺。 2014-10-10 更新了所有的集合操作逻辑，妈妈再也不用担心迭代器无效啦~（当然，也有限制，例如更新时机需要掐准。）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"MonoGame 3.2 下，截屏与 Texture2D 的保存","slug":"zh/2014-09-04-Taking-Screenshots-and-Saving-under-MonoGame-3p2","date":"2014-09-04T05:47:00.000Z","updated":"2020-03-30T22:34:35.391Z","comments":true,"path":"categories/Tech/Coding/zh/2014-09-04-Taking-Screenshots-and-Saving-under-MonoGame-3p2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-09-04-Taking-Screenshots-and-Saving-under-MonoGame-3p2/","excerpt":"博客园地址","text":"博客园地址 10月20日注：后来发现了这篇博文（英文），XNA 中的 Color 实际上是与 Alpha 值自左乘（premultiplied）的，这也解释了直接用 0xARGB 转译而颜色异常的原因。 注意，由于采用的是 MonoGame 3.2，因此方法与 XNA 4.0 不完全相同。 目标是将当前 GraphicsDevice 的内容保存为一个 Texture2D，同时还要能输出至文件。 截屏，在 XNA 下早就有人做了，例如这个：XNA4.0 保存屏幕截图方法[1]。 同时，针对 Texture2D.SaveAsPng()（XNA 下），也有人早就发现了其内存泄露问题，并写出了自己的解决方案：Texture2d.SaveAsPng() Memory Leak[2]。 不过 MonoGame 在 Windows 平台下是不支持 Texture2D.SaveAsPng() 和 Texture2D.SaveAsJpeg() 的，所以不管别人内存泄露啥的，这个保存方法还是要自己实现。（请参考 MonoGame 的代码；有相关外文帖子，不过地址我忘记了。） 其实呢，是我想偷懒，毕竟保存到 Texture2D 后还要写一段代码让其显示出来、消失、再进入原主循环，太麻烦；而且别人的代码还未必可行，先保存为文件看看结果如何。但是保存的时候就出问题了…… 链接[2]中有保存的实现，不过那是针对 XNA 的，我在 MonoGame 上运行时出现了颜色错误。也就是说，到目前为止，至少还没有 MonoGame 开发者公开一个成功的保存方案。（当然，像 FEZ 那样的 Indie Game，写了也不会放在网上，对吧。） 其中最值得注意的是像素格式。GDI+ 是 0xARGB，但是 MonoGame 呢？（这里 MonoGame 可能没有遵循 XNA 的规范？）这个我不知道。之前几次用的都是 SurfaceFormat.Color，微软文档上说这是一个 RGB 颜色带 Alpha 通道，不过顺序未指明（从后面看来，应该是 ARGB）。不过 MonoGame 3.2 的 Windows（不是 WindowsGL）模板用的是 SharpDX，DirectX 这里定义的似乎是 A8R8G8B8。直接保存，颜色错误。对比同一个像素发现有这样的事情：0xff3dab0d（正确）→0xffd3abd0（直接保存），因此做这样的处理，还是失败。最后这个成功的结果应该说还是偶然吧。 2014-09-05 02:52 记录：在调试一个视频的时候，发现 SurfaceFormat.Color 对应 ffmpeg 的 PixelFormat 是 PIX_FMT_RGBA，就是说是实际上排列是 0xABGR（内存中）……抱歉我没从图像中看出来，对颜色不敏感哈…… 这里就不展示错误的效果了，我附上了复现错误的注释，有兴趣的人可以自己试试。 下面就是代码。请预先添加两个引用： using System.Drawing.Imaging; using System.Runtime.InteropServices; 创建一个 RenderTarget2D 对象（继承自 Texture2D）保存截屏内容： public Texture2D TakeScreenshot() { int w, h; w = GraphicsDevice.PresentationParameters.BackBufferWidth; h = GraphicsDevice.PresentationParameters.BackBufferHeight; RenderTarget2D screenshot; // 注意格式一定要是 SurfaceFormat.Bgra32，与 GDI+ 统一。默认的 SurfaceFormat.Color 会导致颜色错误。 screenshot = new RenderTarget2D(GraphicsDevice, w, h, false, SurfaceFormat.Bgra32, DepthFormat.None); GraphicsDevice.SetRenderTarget(screenshot); Draw(_lastUpdatedGameTime != null ? _lastUpdatedGameTime : new GameTime()); GraphicsDevice.Present(); GraphicsDevice.SetRenderTarget(null); return screenshot; } 然后是对 Texture2D 的扩展（框架来自链接[2]）： public static void Save(this Texture2D texture, ImageFormat imageFormat, Stream stream) { var width = texture.Width; var height = texture.Height; using (Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb)) { IntPtr safePtr; BitmapData bitmapData; System.Drawing.Rectangle rect = new System.Drawing.Rectangle(0, 0, width, height); // 这里用 int[width * height] 而不用原文的 byte[4 * width * height]，否则图像大小异常 int[] textureData = new int[width * height]; texture.GetData(textureData); bitmapData = bitmap.LockBits(rect, ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb); safePtr = bitmapData.Scan0; Marshal.Copy(textureData, 0, safePtr, textureData.Length); bitmap.UnlockBits(bitmapData); bitmap.Save(stream, imageFormat); textureData = null; } GC.Collect(); } 最后是调用： void mainButton4_MouseClick(object sender, MouseEventArgs e) { var screenshot = RootControlContainer.TakeScreenshot(); if (screenshot != null) { // System.Drawing.Bitmap.Save() 方法的文件名必须是绝对路径 // 而在 MonoGame 下难以获取绝对路径，因此若要保存至相对路径，请使用 System.IO.FileStream using (var fs = new System.IO.FileStream(@&quot;screenshot.png&quot;, System.IO.FileMode.OpenOrCreate)) { screenshot.Save(System.Drawing.Imaging.ImageFormat.Png, fs); } screenshot.Dispose(); } }","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"博客园记录","slug":"博客园记录","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AE%B0%E5%BD%95/"},{"name":"MonoGame","slug":"MonoGame","permalink":"https://blog.mottomo.moe/tags/MonoGame/"}]},{"title":"MSIL Hello World","slug":"zh/2014-11-09-MSIL-Hello-World","date":"2014-09-04T05:47:00.000Z","updated":"2020-03-30T22:34:35.393Z","comments":true,"path":"categories/Tech/Coding/zh/2014-11-09-MSIL-Hello-World/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-11-09-MSIL-Hello-World/","excerpt":"博客园地址","text":"博客园地址 最近由于需要，开始阅读 MSIL 方面的东西。我读的是《.NET 探秘——MSIL 权威指南》（《Expert .NET 2.0 IL Assembler》中译版）。感觉没什么好说的，毕竟只要对 .NET 及其后面的东西了解一些，然后当做汇编来看，就好了。剩下的就是实践。 如书上所言，前面已经有人做出了这项研究了，如 Anders Liu、装配脑袋、Flier Lu。前辈们都是老手了，我也不好说什么，毕竟我刚刚入门。 这里就贴出昨晚写的一个 HelloWorld 程序吧。读了4天的收获。为了方便没学过 MSIL 的同志们，在上面都附上了实现同样功能的 C# 代码。 嗯，高级的东西还不敢说，要再仔细看，多练习才行啊。 .assembly extern mscorlib { auto } .assembly MyIlApp { } .module MyIlApp.exe .namespace MyIlApp { // public struct VC .class public value sealed auto VC { // public int val_int32; .field public int32 val_int32 // public string val_string; .field public string val_string } // public sealed class MainClass .class public sealed auto ansi MainClass { // public static int _val; .field public static int32 _val // public static void check(int argument1) .method public static void check(int32) cil managed { // string temp; .locals init ([0]string temp) // if (MyIlApp.MainClass._val == argument1) // { // System.Console.WriteLine(&quot;The value equals to the argument.&quot;); // } // else // { // System.Console.WriteLine(&quot;The value does not equal to the argument.&quot;); // } ldsfld int32 MyIlApp.MainClass::_val ldarg.0 beq TrueEqual ldstr &quot;The value does not equal to the argument.&quot; call void [mscorlib]System.Console::WriteLine(string) br ThisIsEnd TrueEqual: ldstr &quot;The value equals to the argument.&quot; call void [mscorlib]System.Console::WriteLine(string) // temp = argument1.ToString(); // 注意这里用 call 而不是 callvirt，因为 argument1 是 int32 类型，未装箱的时候没有V表 ThisIsEnd: ldarga.s 0 call instance string [mscorlib]System.Int32::ToString() stloc.0 // System.Console.Write(&quot;The real value is:&quot;); ldstr &quot;The real value is: &quot; call void [mscorlib]System.Console::Write(string) // System.Console.WriteLine(temp); ldloc.0 call void [mscorlib]System.Console::WriteLine(string) // return; ret } // public static void Main() .method public static void Main() cil managed { // .entrypoint 伪指令表示是程序入口点 .entrypoint /* Test Case 1 */ // string input; // int v; .locals init ([0] string input, [1] int32 v) // System.Console.WriteLine(&quot;Hi. Please input a string:&quot;); ldstr &quot;Hi. Please input a string:&quot; call void [mscorlib]System.Console::WriteLine(string) // input = System.Console.ReadLine(); call string [mscorlib]System.Console::ReadLine() stloc.0 // System.Console.WriteLine(input); ldloc.0 call void [mscorlib]System.Console::WriteLine(string) // v = System.Int32.Parse(input); ldloc.0 call int32 [mscorlib]System.Int32::Parse(string) stloc.1 // MyIlApp.MainClass._val = 9000; ldc.i4 9000 stsfld int32 MyIlApp.MainClass::_val // System.Console.WriteLine(MyIlApp.MainClass._val.ToString()); ldsflda int32 MyIlApp.MainClass::_val call instance string [mscorlib]System.Int32::ToString() call void [mscorlib]System.Console::WriteLine(string) // MyIlApp.MainClass.check(v); ldloc.1 call void [MyIlApp]MyIlApp.MainClass::check(int32) /* Test Case 2 */ // VC vc1; .locals init ([2] valuetype [MyIlApp]MyIlApp.VC vc1) // vc1.val_string = &quot;Test string of VC&quot;; ldloca.s 2 ldstr &quot;Test string of VC&quot; stfld string MyIlApp.VC::val_string // vc1.val_int32 = 8; ldloca.s 2 ldc.i4.8 stfld int32 MyIlApp.VC::val_int32 // System.Console.WriteLine(vc1.val_string); ldloca.s 2 ldfld string MyIlApp.VC::val_string call void [mscorlib]System.Console::WriteLine(string) // System.Console.WriteLine(vc1.val_int32.ToString()); // 《Expert .NET 2.0 IL Assembler》上说 ldflda “不能使用值类型的实例，也不能获取指向值类型实例的对象引用或指针”，有误。为了实现类似 a.X = 100（a 为 System.Drawing.Point 类型）这样的调用，需要用到 call 指令，也就需要用到 ldflda 而不是 ldfld；不过后者可以用在不访问实例函数/字段的情况下 ldloca.s 2 ldflda int32 MyIlApp.VC::val_int32 call instance string [mscorlib]System.Int32::ToString() call void [mscorlib]System.Console::WriteLine(string) // return; ret } } }","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"博客园记录","slug":"博客园记录","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AE%B0%E5%BD%95/"},{"name":"MSIL","slug":"MSIL","permalink":"https://blog.mottomo.moe/tags/MSIL/"}]},{"title":"路易兹刷屏成功！","slug":"zh/2014-08-21-Louise-Took-Over-the-Screen","date":"2014-08-21T14:17:00.000Z","updated":"2020-03-30T22:34:35.391Z","comments":true,"path":"categories/Misc/Records/zh/2014-08-21-Louise-Took-Over-the-Screen/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-08-21-Louise-Took-Over-the-Screen/","excerpt":"","text":"花园地址 鼓掌！ 2014-08-21 22:13 留念 This was a triumph I’m making a note here: HUGE SUCCESS It’s hard to overstate my satisfaction","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"弹幕君-BiliBili高级弹幕语言编辑器","slug":"zh/2014-08-17-Announcing-DanmakuKun","date":"2014-08-17T04:13:00.000Z","updated":"2020-03-30T22:34:35.391Z","comments":true,"path":"categories/Misc/Records/zh/2014-08-17-Announcing-DanmakuKun/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-08-17-Announcing-DanmakuKun/","excerpt":"","text":"花园地址 DanmakuKun_Debug_01a_alpha.rar 需要 Microsoft .NET Framework 4。 这是什么？ 简单说，就是写B站高级弹幕用的。如果是零基础的同学……这个…… 当然，如果要发高级弹幕，必须要有的账号&amp;硬币&amp;权限（本人没有→_→）。以后可能可以做一个interop的程序，在本地也能测试弹幕。 当然由于我也没条件测试高级弹幕，所以不知道对于那些直接用记事本/emacs/UE/Npp的大触来说这个如何……（说白了还是请人家做小白鼠……） 附带了一段B站上的 GalGame 弹幕代码（gal.js），可以用这个做实验。 功能？ 主要功能为自动完成。当然由于不是基于语法引擎的（如果将来有机会，应该会改进这个），而是基于正则的，所以其实相比 VS7+ 是非常非常渣的，不过能用233 有自动完成&amp;参数提示的功能。若是结构字段提示，请输入“@”。 另外，由于无法识别是否该停止自动完成，因此在不需要（例如编辑字符串，需要输入“.”）的时候请手动关闭（见菜单）。 现在的文档不是很全，不过至少B站的文档是都转下来了（这编辑量……）。 可以编辑 Resources 文件夹下的以下文件补充信息： comp-classes：内置类名称 comp-funcs_props：对象类型&amp;属性&amp;函数 comp-objfields：新建对象时的字段（参考：JSON） comp-snippets：代码片段 insights：函数信息 本人用 WPF 的第一个程序，数据驱动做得不好（思想还停留在 WinForms 的时代 = =），请原谅。 然后呢，里面有些功能未开放： 打印 查找&amp;替换&amp;转到 试验运行（将来实现interop之后再开放） 右键菜单 有些功能处于试验中： 代码缩进（最终目标是代码格式化） 静态自动完成（= =） 自动字段提示（现在要输入“@”） 自动完成状态控制（现在要手动 = =） 有些功能作为预览（未整合）： 语法树 还有什么？ Q:为什么不是以 Eclipse/VS/jedit 的插件形式做的？自己实现这么多东西不麻烦么？ A:不是不熟嘛……练习嘛……（好像又重复发明轮子了？） 请各位菊苣不要喷啊……本人水平有限……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"7月番","slug":"zh/2014-08-11-Animes-of-Summer-2014","date":"2014-08-10T17:21:00.000Z","updated":"2020-03-30T22:34:35.390Z","comments":true,"path":"categories/Misc/Records/zh/2014-08-11-Animes-of-Summer-2014/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-08-11-Animes-of-Summer-2014/","excerpt":"","text":"花园地址 按：还是那么青涩。 7月番快一半了，觉得还是吐槽一下吧。 本人是看TVA而未看原作（若有）的，非核心层成员，因此可能会有偏颇。换言之，这张表带有很强的主观意见。 这里只列出了我至少看过一话的作品。 刀剑神域II 看完了第一季就觉得，自从SAO结束之后就没什么好看的。我对诗乃不感兴趣（好像除初春外列表里就没别短发妹子），这一季除了我百吐不厌的光剑，就只剩梶浦由纪的配乐了——不过这一季好像功力又下降了？看着GGO拖12话。 （OP的空耳……在B站开始整顿之前，是充斥着“马云我XXX”的，23333333333333333333333） 魔法科高中的劣等生 是4月的。现在看着龙傲天使用反科学装13真是乐趣。所以这番必须要配合弹幕看，要不味同嚼蜡。哦其实我现在加入了お兄様计数党，即将加入bibi计数党。 金田一少年记事簿R 也是4月的。我也不知道为什么还在看……也许只是对年代稍微久一点的画风更感兴趣？ Aldonoah Zero 虚渊玄+泽野弘之的超级享受啊。我的评价是本季度最佳。虽然脸有点崩，不过掩盖不了剧本的光彩。配乐就不多说了。继拔剑神曲之后，降落神曲（核爆神曲）要诞生了…… 等三话定律的，请在第三话ED后得到满足。 生存游戏社 这个……官方吐槽得我们观众要反吐槽了，呵呵。本季度第三吧。女主的头有点奇怪。前几话的小故事都还不错——就是与“生存游戏”（用BB弹互撸）的主题…… 最精彩的还是第一话吧，毕竟是与主题最相关的，而且旁白大叔的乱入也是最充分的。不知道后劲如何。 斩！赤红之瞳 我主动去百科了。好吧，从明天（2014-08-11）开始，将要虐了。其实第一话就十分高能，附加颜艺，出于最小精神污染的考虑还是少看一点为好…… 角色的塑造还可以。可怜孤睾的战士。 月刊少女野崎君 漫画作者吐槽漫画作者的作品。野崎的生活为少女漫服务，就像爱徒的生活为胖次漫服务一样。可能是由于4月就有类似的TVA（附带钉宫），所以对这个没太大感觉。（08-11 11:28 这感觉应该是萌娘少了多了萌汉子的缘故……而且这论质量这番强于《漫画家与助手们》。） 还是吐槽一下女主脸的纵横比不对好了。 人生相谈 对不起，没认真看……没法认真看，因为太乱了。 搞姫日常 看了一话，还是觉得对可爱的男孩子无法有兴趣…… Re:滨虎 虽然血浆多了一些，不过“大布局”类的剧情给我的印象还是不错的。本番有种“小型美剧”的感觉。 最好看的，其实是主角与相当的反派——“一枚硬币的两面”——相斗争，而不是开挂/后宫的主角拿着神剑/光剑虐渣渣。 精灵使的剑舞 第一话前半部分我看了好几次，以确认自己没有看漏什么剧情。最后得出结论，这开头比我（与人）说话的跳跃性还强，而且缺乏逻辑。 设定上就与零之使魔神似，海报与 Infinite Stratos 神似。五河琴里&amp;夜刀神十香，I-401，古手川唯，塞西莉亚&amp;织斑一夏，就组成了这个剧的主角团。嗯，不仅外貌，性格与身份都（几乎）一样。 然后就看着迟钝的男主被疼♂爱。 其实主要是真爱剧有夏娜，后宫剧有零使，再看其他的我已觉无味。 花舞少女 OP着实让我觉的惊艳了一下，还让我专门查了一下“yosakoi”（よさこい）是什么东西。从第二话开始觉得，这是五人版的《K-ON!》啊……然后就没心情了。对不起我将其和摇曳百合对比了一下。（08-12 21:55 不，比这个更严重……赤裸裸的占有欲啊……） 魔法少女☆伊莉雅2wei! 小学生x百合真是太棒了！夫人我喜欢你啊！ 是的，除了以上两条，阴谋什么的我才不管…… 修业魔女璐璐萌 这个……难以理解，风格也与1月的魔女的使命类似，不过这次男主角可就只是将女主作为魔法发生器使用而已。←还未必想用 向山进发 除了看百合听声优，其他好像也没啥……相关的技术请自行阅读相应刊物。 白银的意志 可惜启动钥匙是短发。另外，时宗啊，请看隔壁伊奈帆训练机疯狂吊打神机。不要总是犯二，如果不是你身边有老手在，早就不知道挂了多少次了。到了第4话实在无法忍受其中二弃了。 东京喰种 实在不行，看着就要吐了，不知道为什么这么多人喜欢。 日本国有铁路公安队 涉及到具体职业的类型（编辑部的故事？233）不怎么喜欢。 普通女高中生要做当地偶像 这个长长的而且无法上口的标题是怎么回事？！而且看了第一话之后，再次引发了我对偶像动画的不满。 Psycho-Pass 新编集版 已经看过了，而且感觉新编集版没有原来那么友善…… 东京残响 我不喜欢被策划了啪啪啪的家伙挟持啊！（08-11 11:28 再看看。） （08-15）嗯，也像追美剧一样，不过比《滨虎》好一点。如果能把里面的女性角色去掉（一个渣渣，一个心理hentai）就更好了。 真·Strange+ 存在本身就值得吐槽。 女神异闻录4 黄金版 一看就像是游戏的标题，查了之后还真是游戏……游戏改编的动画呢，玩家的操作变成了角色自己的动作，这种失落感可想而知。 黑执事 马戏团篇 这酸爽……我是不能接受了。 JoJo的奇妙冒险 星尘斗士 还是4月的。果然是年番，“阿拉伯胖子”都不放过……欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉 三坪房间的侵略者 大沼心啊！想想笨测和C3，路人就是面容最祥和的存在。画面这次正常了一点，没有用彩色斑点的同时将人脸砍一半了。 同样值得一提的还是这个番的展开速度，看着看着我就有种被拉住了脖子的感觉。 东京ESP 也是很精彩的。本季度第二。眼睛有点奇怪，不过比M3黑钢好多了。类似X战警的设定也挺不错的，剧情节奏把握很好，就是会突然发现进度条挂了…… 其他的没看过，一般而言是看了标题，不对劲，就不看了。 真不对劲的有 Dramatical Murder 和 Free!。（不过比不上标题看似正常的《世界第一初恋》——我编索引的时候好奇搜索了一下，然后就被精神污染了。） 本季度的OP/ED/BGM 刀剑神域II Startear（ED）歌曲本身不特别，但是蜡笔风格画面与剧情的反差，以及蓝色的使用，感觉不错。 Aldnoah Zero 质量真心高。Heavenly Blue（OP）和 aLIEz（ED2）都很不错，尤其是后者。 生存游戏社 ぴてぃぱてぃサバイバード（ED），一群人唱歌技巧不怎么样，不过配上画面还是很萌的。 月刊少女野崎君 君じゃなきゃダメみたい（OP）蓝调风十足。ウラオモテ・フォーチュン（ED）含有电音，不过还是挺喜欢的，配上画面美如画。（有谁想加入否定词计数党的？） Re:滨虎 千の翼（OP）与剧情的切合程度很好，毕竟是专门为了这个写的。电吉他将气氛带动起来了。 精灵使的剑舞 精霊剣舞祭（ED）风笛的声音我是很喜欢的…… 花舞少女 花ハ踊レヤいろはにほ（OP）、花雪（ED）两首是我认为的本季度的最佳歌曲。 白银的意志 Tough Intention（OP）曲子搭配画面（如果不计里面坐着的人的话），还是不错的。 三坪房间的侵略者 恋はみるくてぃー（ED）曲子本身就不错，画面翻转的格子点缀感觉莫名地好。 2014-08-15 + 东京残响 虽说OP和ED给我的印象都不好，不过BGM在一些关键点上是非常不错的。 其实还有些是偏流行风的（如斩！赤红之瞳的ED こんな世界、知りたくなかった。），这些普通的就不提了。 PS. 本来想做 aLIEz 的坷垃化的，不过为了保险起见搜索了一下，找到了这个作品： http://www.bilibili.com/video/av1394449 后来找到了这个，颠覆了我对金坷垃故事的认知： http://www.bilibili.com/video/av1377356 （真·神曲） 于是就不想再做了。 PPS. 刚刚发现网上也有人在做这个哪！ http://tieba.baidu.com/p/3186968675 和我的口味不是和一致就是了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"mciSendString 的两个小坑","slug":"zh/2014-07-27-Pitfalls-of-mciSendString","date":"2014-07-26T20:51:00.000Z","updated":"2020-03-30T22:34:35.390Z","comments":true,"path":"categories/Tech/Coding/zh/2014-07-27-Pitfalls-of-mciSendString/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-07-27-Pitfalls-of-mciSendString/","excerpt":"博客园地址","text":"博客园地址 刚刚修正了自己用的小闹钟的代码。 坑1：REPEAT 选项的作用范围 原来用得好好的，之后选择 .wav 文件，居然不出声音了…… 诶，MCI 肯定支持 .wav 的啊…… 仔细想想，我以前都是选 .mp3 作为闹铃，和这个有关系吗？ 查看源代码。 strSend = &quot;PLAY &quot; &amp; STRING_SOUND_ALIAS &amp; &quot; REPEAT&quot; Call mciSendString(strSend, rbuf, 0, 0) 为了将我从睡梦中闹醒（一般来说我睡得很死的……），我选用了 REPEAT 选项来循环播放。 嗯，有。记得在哪里读到过，PLAY 指令的 REPEAT 选项只能作用于 MPEGVideo 类型的文件。（时间也这么晚了， 我想记录完直接睡觉，就不找引用来源了。） 那就很简单，打开的时候作为 MPEGVideo 打开就好了。 strSend = &quot;OPEN &quot; &amp; Chr$(34) &amp; FileName &amp; Chr$(34) &amp; &quot; ALIAS &quot; &amp; STRING_SOUND_ALIAS &amp; &quot; TYPE MPEGVIDEO&quot; Call mciSendString(strSend, rbuf, 0, 0) 坑2：文件名长度 应该好了吧……来，试一下。 D:\\Music\\Themes\\Anison Piano ~marasy animation songs cover on piano~ marasy\\marasy - Anison Piano ~marasy animation songs cover on piano~.wav 嗯？没有特殊字符啊，为什么还是无法播放呢？（我没写调试输出，所以如果看成一个黑盒的话，我看到的结果只有无法播放。）总长度也明显小于 MAX_PATH，文件夹名称和文件名称长度也正常。 去看 mciSendString() 的返回字符串太麻烦了，推理吧。 你看，MCI 是一个历史久远的东西，那么……历史久远！历史久远的东西，在这种情况下能造成影响的，很大的可能性是8.3文件名（短文件名）。 那也好办。Windows API，GetShortPathName()，不要重复发明轮子。 strShortFilename = String$(MAX_PATH, vbNullChar) Call GetShortPathName(FileName, strShortFilename, MAX_PATH) strShortFilename = Strip(strShortFilename) strSend = &quot;OPEN &quot; &amp; Chr$(34) &amp; strShortFilename &amp; Chr$(34) &amp; &quot; ALIAS &quot; &amp; STRING_SOUND_ALIAS &amp; &quot; TYPE MPEGVIDEO&quot; Call mciSendString(strSend, rbuf, 0, 0) （注意，上面的代码还有一个小坑。如果不进行字符串“修剪”去掉冗余的 vbNullChar 的话，也是无法播放的。不过我觉得这没必要单独提出来，就放在这括号里了。） 去睡觉 至少刚刚用了几个sample去测试，都通过了。今早应该能醒来吧……设置闹钟然后睡觉吧。 这篇文章就当是备忘录好了……看官别抱太大希望…… 最后补充说明，MCI 其实是调用相应的已注册的解码器来工作的，所以其实如果安装了相应的解码器，就能播放相应格式的音频文件。当然，raw PCM 和 waveform 肯定要用 native 的 API 直接解决对不对……如果微软那群人不这么想我也没办法……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"博客园记录","slug":"博客园记录","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AE%B0%E5%BD%95/"},{"name":"MCI","slug":"MCI","permalink":"https://blog.mottomo.moe/tags/MCI/"},{"name":"Visual Basic","slug":"Visual-Basic","permalink":"https://blog.mottomo.moe/tags/Visual-Basic/"}]},{"title":"发布动漫资源RSS阅读器","slug":"zh/2014-07-08-Announcing-Anime-RSS-Reader","date":"2014-07-08T09:36:00.000Z","updated":"2020-03-30T22:34:35.390Z","comments":true,"path":"categories/Misc/Records/zh/2014-07-08-Announcing-Anime-RSS-Reader/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-07-08-Announcing-Anime-RSS-Reader/","excerpt":"","text":"花园地址 RssReaderForAnime.rar RssReaderForAnime_Release.rar 第一个压缩包含源代码&amp;编译结果，第二个压缩包仅含可执行文件&amp;配置文件。 需要 Microsoft .NET Framework 2.0 作为运行环境。 简介： 订阅资源站的 RSS Feed 以获取最新的种子列表。 未来花园也有自己的 RSS Feed，见用户控制面板。 注意这个程序的工作原理和 AMG 不同，这个程序相当于小型 RSS Feed 阅读器。由于 RSS 自身的特性，并不能像抓取网页那样自由（例如浏览种子历史记录），而只能收到推送的信息；但同时，可定制性、可扩展性更强。这个程序一般用于追资源站的新种上。要获取更全的信息，可以见 AMG：http://buaabt.cn/showtopic-352936.aspx，不过编写起来麻烦一些。 另外，明天就要搬到本部去了，在那里不知道网络环境如何；如果糟糕的话……是不是难以上漫版了呢…… 主界面。按钮依次为：订阅 RSS Feed、显示 RSS Feed 资料页面、打开目标页面、复制链接、打开链接、RSS Feed 源管理、关于。 订阅 RSS Feed 就不用说了吧。在列表中选择一个 RSS Feed 源，按下即可。请保证有较良好的网络环境。 显示 RSS Feed 资料页面：外网上的发布组在发布种子时，其资料页面如图4，是可以浏览的。 打开目标页面：也不用多说了吧。打开的是列表中“页面”一栏所显示的地址。如果订阅的是未来花园的 RSS Feed，请使用该按钮打开链接。 复制链接：复制“链接”一栏的地址。 打开链接：打开“链接”一栏的地址。 RSS Feed 源管理：也不用多说了吧。 关于：更不用说了。 在这里管理 RSS Feed 源。 列表右端。 RSS Feed 资料页面（而不是目标页面）。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"脑洞大开","slug":"zh/2014-07-05-Brain-Holes","date":"2014-07-05T10:31:00.000Z","updated":"2020-03-30T22:34:35.390Z","comments":true,"path":"categories/Misc/Records/zh/2014-07-05-Brain-Holes/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-07-05-Brain-Holes/","excerpt":"","text":"花园地址 按：希望花园能一直保留数据。我现在看下面的评论还能想起当年相互逗乐的时光。另外，现在我相对理性了一些，不过思考的是“模式的产生与转变为某模式的方法”。 脑洞大开。 已经不能接受三次元的女孩子了。 敬告一些动机不良的人：我是直的。 走在路上见到各种女生，面部总是有缺陷。 或者直接分析其头骨结构，总有不完美的地方。 嗯，还是二次元生态系统丰富&amp;健康。 就像神大人所看到的那样。 神大人说：“现实就是一个最糟糕的游戏。” 你倒是动动脑子啊！在二次元吐槽“现实”？ 在地球上存在的攻略狂魔会被称为花花公子。 而且也没有人保证每次满分（♂=0，♀=0），特别是使用人类OCR的方法考满分的家伙这真是作弊。还有你考理科试试！ 也没有人叼着面包冲过街角。 没有那种幼驯染+妹妹+姐姐+班长+千金+学生会长+保健员+暗恋许久+成绩运动万能（不过并不是说同一个人要同时拥有所有特性）的存在。神大人看看你的身边吧。 人类也没法做出自然的颜艺。 肢体也不能变形。 摔了会死。 没有从天而降（对，就是字面上的意思）的妹子。 而且与人类打交道要实时计算与预测其反应。 和二次元的妹子说话会得到&gt;ω&lt;，和三次元的妹子说话你会得到人类的反应。Holy s***. 考马原之前我见了卡桑様。不知为何她现在要我找GF，标准如何如何。问题是我本来就不怎么想——而且为什么老一辈要关心这个哪。 我说：“妈，以后再说这些吧。” 心里想：不知道带抱枕回去会得到什么反应。（我的处境与桐乃类似啊。） 我有脑洞我自豪。 2015-08-07: 转录的时候又看到了7楼的图：","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"寻找对动漫制作与开发有兴趣的同学——做个项目吧","slug":"zh/2014-06-16-Find-Parters-Interested-in-2D-Style-Animation","date":"2014-06-16T10:50:00.000Z","updated":"2020-03-30T22:34:35.390Z","comments":true,"path":"categories/Misc/Records/zh/2014-06-16-Find-Parters-Interested-in-2D-Style-Animation/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-06-16-Find-Parters-Interested-in-2D-Style-Animation/","excerpt":"","text":"花园地址 按：图样图森破。 原标题：寻找对动漫制作&amp;开发有兴趣的同学——做个项目吧，因为“&amp;”字符无法被百度sitemap插件处理写入 XML，所以改动了标题。 暑假要开始了。 我在某帖子里读到过日本动漫产业的工作原理。我的理解是，原画+分镜+补间动画。没错吧？5#：分镜→原画→补间 于是我就有个想法，与其让人完成大量的补间工作，不如让计算机来完成。或者，通过如3D动画制作的流程，让计算机自动渲染对应的“2D”画面。 当然，如果是普通的3D渲染工具，强调真实感，市面上是有很多的，这一块也发展到了很高的境界了。但是对于动漫——只要不是纯萝卜——大多数人应该还是希望是那种手绘的风格吧。 不幸的是，这个想法有人已经做出来了。我所知道的，有 RWBY、苍蓝钢铁的琶音和希德尼娅的骑士等3部作品，是使用3D渲染的。这三部作品中，最成熟的应该属苍蓝钢铁。说实话，这已经很接近我希望达到的程度了，很多场景都像是人画的。 不过即使有人做了，我们也可以做出更好的。 三部作品的截图如下（后两者，我选了比较接近我的意图的画面），注意这三张图片都是完全的渲染结果，而不是人的绘制结果： 这是可以超越的吧。 总结：我想在未来的一年或者两年内，做出一个渲染引擎，达到渲染得到的画面“像人画的”的目标。 先以苍蓝钢铁为目标吧，应该还有超过它的余地。 流程：建模-贴图-动作/表情-场景-渲染。 最重要的是渲染这一步。 我说一些我对可能会碰到的问题的解决方案吧。 人的脸，传统的方法是渲染整个面部的皮肤，使其有材质感；但如果用类似等高线的方法区分颜色区域，应该能做出普通画风的画面吧。 另外表情，可以参考肌肉运动（就像 Valve 的面部引擎一样）——但是为什么要这么复杂，眼睛、嘴巴和其组合是有一定的范式的，可以套用这些范式，然后直接使用控制点+覆盖在表面即可。 头发和衣服的动态渲染呢……是个问题。本来想采用 Havok Cloth 的（注意，这是商业软件），不过觉得应该没必要真实到一丝一缕。现在还没有一个比较好的解决方案。 建模的配合……应该很多人会选用 3ds Max 或者 Maya 或者 SoftImage 的，这些都是商业闭源的建模软件，处理这种模型可能有点困难吧，要了解实现细节的话。也许我们可以专门做一个简易建模的软件，毕竟动漫的人物结构没有那么复杂，不过这时间就很长了吧。 可以考虑用 SVG 作为渲染中介，不仅对画师、程序猿都友善，而且基于文本、可以缩放（好好领悟）。我见到的一个很好的例子是下图。SVG 简介和图片的原文档见帖子最后。 （想象一下，这是由数值描述出来的。） 代码方面，开源吧。GitHub 托管是个不错的选择。 可以考虑基于 Unity，因为其脚本与 C# 很像，便于快速开发，跨平台。 或者先做出 Blender 的插件，并试着“还原”一段动画。 团队需要： 擅长绘制漫画的人 熟悉动漫产业的人 程序猿 有人物建模经验的人 有画面感（懂得光影配合）的人 团队粘合剂&lt;/span&gt; 最后对程序猿（我算是一个吧）： 先不要纠结在过于细节的问题上，例如选择什么语言上的。第一阶段，能运行就是胜利。 漫版人才济济，我希望大家能对我的想法提出意见，或者创建一个团队。谢谢！或者谁身边有此意向的也可以拉来入伙…… 鉴于之前加入过一个模组制作组，在开工没多久就成了一盘散沙，所以如果这个想法能开始实现，我们最好还是需要一个明确的路线图。 附： SVG 简介。SVG（Scalable Vector Graphics）是基于 XML 的描述型矢量图形。简单说，里面的所有元素都是几何元素，整幅画面就是元素的聚集——这与位图的死板很不一样。我们有时会见到有人“拿 Excel 画人物”，那其实是贝塞尔曲线的应用而已。相关软件有 Illustrator、Inkscape 等。 Mahuri.svg（IE、Chrome、Firefox、Safari 等浏览器较新的版本可以浏览渲染的图像。可以用记事本打开查看其内容。） Mahuri.svg SVG 1.1 规范（程序猿用） REC-SVG11-20110816.part1.rar REC-SVG11-20110816.part2.rar REC-SVG11-20110816.part3.rar PS. 我只是渣渣，不接受膝盖 最后，大家要理性地乐观~","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"发布 Anime Magnet Gripper","slug":"zh/2014-06-09-Announcing-Anime-Magnet-Gripper","date":"2014-06-09T09:25:00.000Z","updated":"2020-03-30T22:34:35.389Z","comments":true,"path":"categories/Misc/Records/zh/2014-06-09-Announcing-Anime-Magnet-Gripper/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-06-09-Announcing-Anime-Magnet-Gripper/","excerpt":"","text":"花园地址 按：应为 Grabber，写成了 Gripper（似乎是被状态栏的那个 grip 影响了）。 嗯临近期末考试了，顺手写了一个小程序。方便各位上传者。这种性质，就不发到软件区了。 看一看都知道是做什么的对吧。 需要 .NET Framework 2.0 作为运行环境。 需要 Microsoft HTML Object Library（Windows XP 和以上应该都附带的）。 本着开源的精神，该软件代码处于公共域。 文件夹内包含工程、源代码和编译结果。想直接运行的同学请至 AnimeMagnetGripper/bin/Release 下找到 AMG.exe。 小程序，不过是 MSHTML 的应用而已。附带说一句，COM Interop 在 CLR 下使用，组件释放很成问题。←求教，我强制用 GC 做回收好像还不行 开发语言是 Visual Basic .NET。为什么不用 C#？其实也可以，不过我本身就是从 VB（不是 VB .NET）入门的，RAD 的时候用老本行更亲切一些。 其实最终极的做法应该是搭建一个脚本引擎，根据自定义脚本去抓取。不过比较花时间，特别是遇到一些坑爹的网站的时候。所以我举了KTXP和动漫花园作为例子。（另一个原因是，我不知道/无权进入其他的资源站。） 啊那个“关于”里的 First release date: Jun. 08, 2014 就不要管了，因为是昨晚写完的，不过没发……现在也不想改了…… 还有，使用的是 WebClient，页面下载可能不稳定。可以多次[取消]-[连接到]。 功能： 抓取资源网站上发布的资源信息，特别是磁力链接。 现在已经支持的网站： 极影BT（文件发布时间、文件说明、文件大小、磁力链接、种子文件地址）←实际上稍微改造还可以得到发布者，不过我没写 动漫花园（文件发布时间、文件说明、文件大小、磁力链接）←实际上稍微改造还可以得到发布者，不过我没写 其他的网站可以按照程序中的两个网站的抓取例子写分析的代码。反正源代码都给出了。 短时间内不打算更新，还是先忙期末的事情吧。 AnimeMagnetGripper.rar","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"我眼中的四月番","slug":"zh/2014-06-03-Animes-of-Spring-2014","date":"2014-06-03T03:39:00.000Z","updated":"2020-03-30T22:34:35.389Z","comments":true,"path":"categories/Misc/Records/zh/2014-06-03-Animes-of-Spring-2014/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-06-03-Animes-of-Spring-2014/","excerpt":"","text":"花园地址 按：现在看到这些评论，想想当年的自己简直是不知天高地厚。 这里只列举花园上能找到的一些TVA。 海贼王：从来不看 龙珠改：从来不看 金田一少年之事件簿：就当看柯南了吧，不过剧情也是神奇地展开的，不知前因后果，将就吧 （不）健全机斗士：重度卖肉+无脑，弃 星刻的龙骑士：开始还正常一点，然后越来越卖肉（本季最多触手play获奖者）+无脑，从05之后弃 魔法科高中的劣等生：剧情略平淡（实在不如魔禁），外加龙傲天，将就吧 尽管如此世界依然美丽：“少女漫”再贴切不过了……搞笑倒是有很多…… 目隐都市的演绎者：超现实主义，弃，虽然 Ene 曾经让故事有趣了一下话说自然之敌p的音乐感觉和神主出发点很像，不过节奏太快我受不了。同人化之后还可以。 地球队长：对传统萝卜无爱，弃 上课小动作：等合集吧，这种神奇的东西还是不适合每周追的 LoveLive! 2nd：呵呵 一周的朋友：高中生情感模式，弃 极黑的布伦希尔德：虽然妹子被虐得惨了一点，不过还是挺有意思的，追 如果折断她的旗：一开始还以为只是不断收后宫的（看看OP，一话一个差不多），从（好像）05开始引入了平行世界，剧情啊权术啊乱七八糟，不知道想表达什么，日常搞笑氛围减弱了，弃 竣太和 No. 0 快去天文台！对，都是逢坂良太+种田梨沙 破刃之剑：读了简介之后不想看 漫画家与助手们：不如妄想学生会，看了2话之后弃 M3~其为黑钢~：这种画风是怎么回事！眼睛有一个正常的吗！再配上黑暗的剧情，从03开始弃 魔法少女大战：低龄化……看着玩吧…… 漆黑的子弹：还是不错的（虽然提前知道了许多萝莉的悲惨下场），追 Soul Eater NOT!：虽然CV是我知道的几个，不过剧情……作为轻松化的外传做得还可以吧，不过没兴趣了 火影忍者：从来不看 No Game No Life：个人认为的本季最佳TVA（尽管做大死），追 棺姬嘉依卡：刚看的时候突然觉得画风像奈亚子，后来剧情展开混乱+颜色略奇怪，准备弃 剑灵：滚 我们大家的河合庄：过于无厘头+封闭，弃 恶魔之谜：要看百合的去看天才百合少女吧，这个剧无非就是每一话干掉一个对手而已，单调乏味，弃 选择感染者WIXOSS：虽然是硬广告，不过剧情还是不错的，Selector 之间的心理、战术（虽然我没玩过 = =）表现得不错，追 犬神同学和猫山同学：强烈百合，无剧情，弃 爱丝卡&amp;罗吉的炼金工房~黄昏天空之炼金术士~：小学时看了空之轨迹的攻略之后就不喜欢RPG了，当日常番吧 请问您今天要来点兔子吗？：最大的作用是放松心情，真的放松心情（看了之后大脑暂时丧失正常功能，避免被烧坏，请在看了希德尼亚的骑士之后使用）……追 乒乓：燃！不过光看着真没意思，这也是我不看黑子的篮球的原因 龙娘七七七埋藏的宝藏：动作戏有，智商没有，关系混乱，设定还行，将就吧 希德尼亚的骑士：这种风格，以前读科幻小说的时候就想象过，非常不错（除了部分描写会令人不安），追 名侦探柯南：不看TVA 虫师 续章：应该是温暖人心的一类（类似夏目友人帐）吧，先不看 Fairy Tail 2014：从来不看 JoJo的奇妙冒险·星尘斗士：嗯不错，不过儿童不宜观看，追 当初知道JoJo只是因为俺修罗的不穿真凉开口就是JoJo梗，被逼疯了，就去刷了。 Date A Live II：这个就不说什么了，虽然价值不大，但是可以娱乐身心吧，追 本季度比较喜欢/有用的OP/ED OP 健全机斗士：非常非常非常燃，和JoJo混搭感觉应该不错（不过歌词内容不知道是怎么通过审查的） 极黑的布伦希尔德：少见的我能喜欢的混音作品 漆黑的子弹：fripSide，不说什么了 No Game No Life：前奏很有张力 请问您今天要来点兔子吗？：奇怪的旋律，刚好可以用来恶搞其他一些作品 希德尼亚的骑士：冲击感的音乐，不错 Date A Live II：这个也不说什么了，质量有保证 ED 尽管如此世界依然美丽：符合标准流行音乐的规范吧，有点好听的说…… 极黑的布伦希尔德：确实不错，剧情与歌曲旋律之间的反差更让人感到歌曲的美妙 漫画家与助手们：应该是几个和弦用好了吧，个人比较喜欢 漆黑的子弹：配上画面之后苍凉+寂寞感直线上升！ 犬神同学和猫山同学：略洗脑，可以用来恶搞 JoJo的奇妙冒险·星尘斗士：神奇的ED啊，配JoJo的风格，果然入味 Date A Live II：这个也不说什么了，质量有保证 其他配乐 魔法科高中的劣等生：开打的时候电子音乐应用得当 No Game No Life：同上 Date A Live II：至少大量前作的配乐还是有水准的 上个学期期末看了《机巧少女不会受伤》（《真·超元气三姐妹》，或者我更愿意称之为的，《我的自动玩偶不可能坏掉》）之后入坑，新人新人，请多见谅。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"},{"name":"未来花园回忆","slug":"未来花园回忆","permalink":"https://blog.mottomo.moe/tags/%E6%9C%AA%E6%9D%A5%E8%8A%B1%E5%9B%AD%E5%9B%9E%E5%BF%86/"}]},{"title":"virtual 修饰符与继承对析构函数的影响（C++）","slug":"zh/2014-05-08-Destructors-of-C-Plus-Plus","date":"2014-05-08T09:30:00.000Z","updated":"2020-07-26T13:47:56.837Z","comments":true,"path":"categories/Tech/Coding/zh/2014-05-08-Destructors-of-C-Plus-Plus/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-05-08-Destructors-of-C-Plus-Plus/","excerpt":"博客园地址","text":"博客园地址 以前，知道了虚函数表的低效性之后，一直尽量避免使用之。所以，在最近的工程中，所有的析构函数都不是虚函数。 今天趁着还书的机会到图书馆，还书之后在 TP 分类下闲逛，偶然读到一本游戏编程书，里面说建议将存在派生的类的析构函数都设置为 virtual。例如 ParentClass 和 ChildClass（派生自 ParentClass），如果 ParentClass 的 ~ParentClass() 不是 virtual 的话，以下代码会产生潜在的问题： ParentClass *pClass = new ChildClass(); delete pClass; 有什么问题呢？~ChildClass() 此时不会被调用。 于是想起来，赶快回来改代码！ 我觉得其实析构函数也遵循 virtual 修饰的规则嘛。之前的例子，delete 的时候其实调用的是 ~ParentClass()，因为该函数不是虚函数；而如果是 virtual ~ParentClass() 的话，~ParentClass() 实际上是在虚函数表里的，因此会调用覆盖（override）之的 ~ChildClass()。 实际情况是否是这样的呢？我写了一个小小的示例，展示析构函数修饰符的影响。其中，后缀“v”表示析构函数是虚函数。 #include &lt;stdio.h&gt; class P { public: P() {} ~P() { printf(&quot;P destruction\\n&quot;); } }; class Pv { public: Pv() {} virtual ~Pv() { printf(&quot;Pv destruction\\n&quot;); } }; class CP : public P { public: CP() {} ~CP() { printf(&quot;CP destruction\\n&quot;); } }; class CPv : public Pv { public: CPv() {} ~CPv() { printf(&quot;CPv destruction\\n&quot;); } }; class CvP : public P { public: CvP() {} virtual ~CvP() { printf(&quot;CvP destruction\\n&quot;); } }; class CvPv : public Pv { public: CvPv() {} virtual ~CvPv() { printf(&quot;CvPv destruction\\n&quot;); } }; int main(int argc, char *argv[]) { P *p = new P(); Pv *pv = new Pv(); P *pc = new CP(); //P *pcv = new CvP(); // 析构时崩溃 Pv *pvc = new CPv(); Pv *pvcv = new CvPv(); CP *cp = new CP(); CPv *cpv = new CPv(); CvP *cvp = new CvP(); CvPv *cvpv = new CvPv(); printf(&quot;-----------------------------\\n&quot;); delete p; printf(&quot;-----------------------------\\n&quot;); delete pv; printf(&quot;-----------------------------\\n&quot;); delete pc; printf(&quot;-----------------------------\\n&quot;); //delete pcv; // 父类析构调用没问题，然后崩溃 printf(&quot;-----------------------------\\n&quot;); delete pvc; printf(&quot;-----------------------------\\n&quot;); delete pvcv; printf(&quot;-----------------------------\\n&quot;); delete cp; printf(&quot;-----------------------------\\n&quot;); delete cpv; printf(&quot;-----------------------------\\n&quot;); delete cvp; printf(&quot;-----------------------------\\n&quot;); delete cvpv; printf(&quot;-----------------------------\\n&quot;); return 0; } 其中删除静态类型为 P * 动态类型为 CvP * 的 pcv 时会崩溃。 其余结果如下： ----------------------------- P destruction ----------------------------- Pv destruction ----------------------------- P destruction ----------------------------- ----------------------------- CPv destruction Pv destruction ----------------------------- CvPv destruction Pv destruction ----------------------------- CP destruction P destruction ----------------------------- CPv destruction Pv destruction ----------------------------- CvP destruction P destruction ----------------------------- CvPv destruction Pv destruction ----------------------------- 可见，我的想法不是完全正确的。 总结一下，在10种使用方式中，有两种是不好的： 父类析构函数非虚函数，子类析构函数是虚函数，使用父类作为静态类型的析构（崩溃）； 父类析构函数非虚函数，子类析构函数非虚函数，使用父类作为静态类型的析构（跳过了子类的析构函数）。 其余情况下，只要父类的析构函数是虚函数，就不需要关心指针的静态类型；统一指针的静态类型和动态类型（显式让运行时调用子类的析构函数）也可以避免意外。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"博客园记录","slug":"博客园记录","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AE%B0%E5%BD%95/"},{"name":"CPlusPlus","slug":"CPlusPlus","permalink":"https://blog.mottomo.moe/tags/CPlusPlus/"},{"name":"析构函数","slug":"析构函数","permalink":"https://blog.mottomo.moe/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"}]},{"title":"无题","slug":"zh/2014-04-19-No-Title","date":"2014-04-19T10:42:00.000Z","updated":"2020-03-30T22:34:35.389Z","comments":true,"path":"categories/Misc/Records/zh/2014-04-19-No-Title/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-04-19-No-Title/","excerpt":"我。","text":"我。 我在周围人的眼里，是什么样子的？ 知道得好多啊。 程序猿。 大神。 乖孩子。 我的梦想是什么？ 写代码、做架构、作曲、画漫画、写小说（虽然写出来会很囧）、做二次元视频、配音、拍摄和剪辑电影、设计各种东西。 超好玩的，你有什么意见吗！ 专业？ 机械工程。 为什么？ 黄老师说：以你现在的水平，完全不用去学计算机；兴趣这东西，即使不上课，也会自己学习的，还不如去选一些其他方面的内容。 如果从应用的角度来考虑，很好啊，软硬兼施。但是，我并不喜欢这个专业，我只能尽量让自己坚持。 现在的情况是什么？ 科学史：自我评价，及格。 代码、架构：完全业余，根本没有学习过什么。现在的东西完全是推断出来的，没有自己的东西。（@zalazan ！我弱爆了！我弱爆了！我弱爆了！我还在纠结于第四代、顺序执行语言！） 作曲：仅有的乐理知识还是四年级钢琴考级时的（没错我还记得）。和声学门外汉。 画漫画：形态有一点，没有神采，还有奇怪的线条。 写小说：我才想不出那些毫无理性的东西呢。 做二次元视频：现在的机子可以用作低端配置极限测试了。而且，今年春天才入坑，没有足够的积累。 配音：有人在看着的时候就没法说好。（换一种说法，没人的时候自己YY的效果反而不错。） 拍摄：曾经。现在请给我器材。 剪辑：还不错。 设计：红点应该是几十万年后的事情了吧。 现实中的失败者。 我是这么认为的。 空白至少还能 4v1200。 桐乃至少还是人参淫家。 最后也许我会去一个文科？ 不知道。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"让 OpenAL 也支持 S16 Planar（辅以 FFmpeg）","slug":"zh/2014-04-05-Add-S16-Planar-Support-for-OpenAL","date":"2014-04-05T09:01:00.000Z","updated":"2020-03-30T22:34:35.388Z","comments":true,"path":"categories/Tech/Coding/zh/2014-04-05-Add-S16-Planar-Support-for-OpenAL/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-04-05-Add-S16-Planar-Support-for-OpenAL/","excerpt":"博客园地址","text":"博客园地址 正在制作某物品，现在做到音频部分了。 原本要采用 SDL2_mixer 的，不过实验结果表明其失真非常严重，还带有大量的电噪声。不知道是不是我打开的方式不对…… 一气之下去看 OpenAL，结果吃了闭门羹（维护中，只有 mailing list 和 specification）。转投 FMOD，不过又考虑到其授权方式，还是放弃了。最终回到 OpenAL。使用的是 OpenAL-Soft。 OpenAL 呢，好的方面是开源+授权，坏的方面……呃，至少在刚刚的测试中，代码维护甚至没有 SDL 好。直接编译 .c 示例失败，耍小聪明改成 .cpp 拿去编译才成功。 在接下来的代码中，需要用到 OpenAL-Soft（1.15.1）和 FFmpeg。 看 OpenAL-Soft 自带的示例 alstream.c。为了方便起见，接下来的 C 源代码文件全部改成 C++ 源代码文件去……同时不要忘了在 FFmpeg 的头文件上下加 extern “C”！（为什么他们不考虑这一点？） 好，编译示例，运行。（注意，各种 dependencies 这里就不提了。）随便选择一个含有音频的、可以被 FFmpeg 解码的文件。 不对啊！很有可能出现以下错误信息： Opened “OpenAL Soft” AL_SOFT_buffer_samples supported! Unsupported ffmpeg sample format: s16p Error getting audio info for 01.mpg Done. 这是……怎么回事？经过测试，SDL_mixer 可以播放同一个文件，不过正如之前所说的，失真&amp;噪声。看其采样格式：S16P（Signed 16-bit, Planar←平面？）。再看源代码，S16（Signed 16-bit）是支持的。（当然，如果强制将那几个 if 修改一下的话，你会听到神奇的东西……）S16 和 S16P 的不同点是在于数据的排列方式，前者是相邻连续排列，后者是分离排列。但是现在有相当多的音频文件采用 planar 的方案，不仅是 S16，U8、S32、F32、F64 都有对应的 planar 方式。现在，目标就是：让这个示例支持 planar。 思路很简单。我的上一篇随笔中，有一个 AudioResampling() 函数，这里直接拿来用吧！（秉持拿来主义！鲁迅先生不谢。） 接下来就是好戏了。 又试验了一下，播放 U8/Mono 的时候出现崩溃，不知道原因。调试的时候内存是越界的。 先是添加对 libswresample 和 libavutil（要用到 opt_* 函数）的包含（别忘了添加对应的库）： #ifdef __cplusplus extern &quot;C&quot; { #endif #include &quot;libavutil/opt.h&quot; #include &quot;libswresample/swresample.h&quot; #ifdef __cplusplus } #endif 然后是修改 MyStream 的定义： struct MyStream { AVCodecContext *CodecCtx; int StreamIdx; struct PacketList *Packets; AVFrame *Frame; // FrameData 没什么用了，不过为了保持代码结构，还是保留下来，其作用由 FrameBuffer 代替 const uint8_t *FrameData; const uint8_t FrameBuffer[FRAME_BUFFER_SIZE]; size_t FrameDataSize; FilePtr parent; }; 可以先定义一下 FRAME_BUFFER_SIZE： // MP3 每一帧的大小是4608，所以如果设定成4096（一般音频可以播放）的话会造成溢出、崩溃 #define FRAME_BUFFER_SIZE (4800) 直接插入 AudioResampling() 函数（如果对这错误的时态感到别扭，改一下就好了），添加重采样支持： static int AudioResampling(AVCodecContext * audio_dec_ctx, AVFrame * pAudioDecodeFrame, int out_sample_fmt, int out_channels, int out_sample_rate, uint8_t* out_buf) { SwrContext * swr_ctx = NULL; int data_size = 0; int ret = 0; int64_t src_ch_layout = audio_dec_ctx-&gt;channel_layout; int64_t dst_ch_layout = AV_CH_LAYOUT_STEREO; int dst_nb_channels = 0; int dst_linesize = 0; int src_nb_samples = 0; int dst_nb_samples = 0; int max_dst_nb_samples = 0; uint8_t **dst_data = NULL; int resampled_data_size = 0; swr_ctx = swr_alloc(); if (!swr_ctx) { printf(&quot;swr_alloc error \\n&quot;); return -1; } src_ch_layout = (audio_dec_ctx-&gt;channels == av_get_channel_layout_nb_channels(audio_dec_ctx-&gt;channel_layout)) ? audio_dec_ctx-&gt;channel_layout : av_get_default_channel_layout(audio_dec_ctx-&gt;channels); if (out_channels == 1) { dst_ch_layout = AV_CH_LAYOUT_MONO; //printf(&quot;dst_ch_layout: AV_CH_LAYOUT_MONO\\n&quot;); } else if (out_channels == 2) { dst_ch_layout = AV_CH_LAYOUT_STEREO; //printf(&quot;dst_ch_layout: AV_CH_LAYOUT_STEREO\\n&quot;); } else { dst_ch_layout = AV_CH_LAYOUT_SURROUND; //printf(&quot;dst_ch_layout: AV_CH_LAYOUT_SURROUND\\n&quot;); } if (src_ch_layout &lt;= 0) { printf(&quot;src_ch_layout error \\n&quot;); return -1; } src_nb_samples = pAudioDecodeFrame-&gt;nb_samples; if (src_nb_samples &lt;= 0) { printf(&quot;src_nb_samples error \\n&quot;); return -1; } av_opt_set_int(swr_ctx, &quot;in_channel_layout&quot;, src_ch_layout, 0); av_opt_set_int(swr_ctx, &quot;in_sample_rate&quot;, audio_dec_ctx-&gt;sample_rate, 0); av_opt_set_sample_fmt(swr_ctx, &quot;in_sample_fmt&quot;, audio_dec_ctx-&gt;sample_fmt, 0); av_opt_set_int(swr_ctx, &quot;out_channel_layout&quot;, dst_ch_layout, 0); av_opt_set_int(swr_ctx, &quot;out_sample_rate&quot;, out_sample_rate, 0); av_opt_set_sample_fmt(swr_ctx, &quot;out_sample_fmt&quot;, (AVSampleFormat)out_sample_fmt, 0); if ((ret = swr_init(swr_ctx)) &lt; 0) { printf(&quot;Failed to initialize the resampling context\\n&quot;); return -1; } max_dst_nb_samples = dst_nb_samples = av_rescale_rnd(src_nb_samples, out_sample_rate, audio_dec_ctx-&gt;sample_rate, AV_ROUND_UP); if (max_dst_nb_samples &lt;= 0) { printf(&quot;av_rescale_rnd error \\n&quot;); return -1; } dst_nb_channels = av_get_channel_layout_nb_channels(dst_ch_layout); ret = av_samples_alloc_array_and_samples(&amp;dst_data, &amp;dst_linesize, dst_nb_channels, dst_nb_samples, (AVSampleFormat)out_sample_fmt, 0); if (ret &lt; 0) { printf(&quot;av_samples_alloc_array_and_samples error \\n&quot;); return -1; } dst_nb_samples = av_rescale_rnd(swr_get_delay(swr_ctx, audio_dec_ctx-&gt;sample_rate) + src_nb_samples, out_sample_rate, audio_dec_ctx-&gt;sample_rate, AV_ROUND_UP); if (dst_nb_samples &lt;= 0) { printf(&quot;av_rescale_rnd error \\n&quot;); return -1; } if (dst_nb_samples &gt; max_dst_nb_samples) { av_free(dst_data[0]); ret = av_samples_alloc(dst_data, &amp;dst_linesize, dst_nb_channels, dst_nb_samples, (AVSampleFormat)out_sample_fmt, 1); max_dst_nb_samples = dst_nb_samples; } if (swr_ctx) { ret = swr_convert(swr_ctx, dst_data, dst_nb_samples, (const uint8_t **)pAudioDecodeFrame-&gt;data, pAudioDecodeFrame-&gt;nb_samples); if (ret &lt; 0) { printf(&quot;swr_convert error \\n&quot;); return -1; } resampled_data_size = av_samples_get_buffer_size(&amp;dst_linesize, dst_nb_channels, ret, (AVSampleFormat)out_sample_fmt, 1); if (resampled_data_size &lt; 0) { printf(&quot;av_samples_get_buffer_size error \\n&quot;); return -1; } } else { printf(&quot;swr_ctx null error \\n&quot;); return -1; } memcpy(out_buf, dst_data[0], resampled_data_size); if (dst_data) { av_freep(&amp;dst_data[0]); } av_freep(&amp;dst_data); dst_data = NULL; if (swr_ctx) { swr_free(&amp;swr_ctx); } return resampled_data_size; } 修改 getAVAudioData() 函数： uint8_t *getAVAudioData(StreamPtr stream, size_t *length) { int got_frame; int len; if(length) *length = 0; if(!stream || stream-&gt;CodecCtx-&gt;codec_type != AVMEDIA_TYPE_AUDIO) return NULL; next_packet: if(!stream-&gt;Packets &amp;&amp; !getNextPacket(stream-&gt;parent, stream-&gt;StreamIdx)) return NULL; /* Decode some data, and check for errors */ avcodec_get_frame_defaults(stream-&gt;Frame); while((len=avcodec_decode_audio4(stream-&gt;CodecCtx, stream-&gt;Frame, &amp;got_frame, &amp;stream-&gt;Packets-&gt;pkt)) &lt; 0) { struct PacketList *self; /* Error? Drop it and try the next, I guess... */ self = stream-&gt;Packets; stream-&gt;Packets = self-&gt;next; av_free_packet(&amp;self-&gt;pkt); av_free(self); if(!stream-&gt;Packets) goto next_packet; } if(len &lt; stream-&gt;Packets-&gt;pkt.size) { /* Move the unread data to the front and clear the end bits */ int remaining = stream-&gt;Packets-&gt;pkt.size - len; memmove(stream-&gt;Packets-&gt;pkt.data, &amp;stream-&gt;Packets-&gt;pkt.data[len], remaining); memset(&amp;stream-&gt;Packets-&gt;pkt.data[remaining], 0, stream-&gt;Packets-&gt;pkt.size - remaining); stream-&gt;Packets-&gt;pkt.size -= len; } else { struct PacketList *self; self = stream-&gt;Packets; stream-&gt;Packets = self-&gt;next; av_free_packet(&amp;self-&gt;pkt); av_free(self); } if(!got_frame || stream-&gt;Frame-&gt;nb_samples == 0) goto next_packet; // 在这里插入重新采样代码 *length = AudioResampling(stream-&gt;CodecCtx, stream-&gt;Frame, AV_SAMPLE_FMT_S16, stream-&gt;Frame-&gt;channels, stream-&gt;Frame-&gt;sample_rate, const_cast&lt;uint8_t *&gt;(stream-&gt;FrameBuffer)); /* Set the output buffer size */ /* *length = av_samples_get_buffer_size(NULL, stream-&gt;CodecCtx-&gt;channels, stream-&gt;Frame-&gt;nb_samples, stream-&gt;CodecCtx-&gt;sample_fmt, 1); return stream-&gt;Frame-&gt;data[0]; */ return const_cast&lt;uint8_t *&gt;(stream-&gt;FrameBuffer); } 最后是 getAVAudioInfo() 函数，我们要让它允许 planar 音频输入： int getAVAudioInfo(StreamPtr stream, ALuint *rate, ALenum *channels, ALenum *type) { if(!stream || stream-&gt;CodecCtx-&gt;codec_type != AVMEDIA_TYPE_AUDIO) return 1; /* Get the sample type for OpenAL given the format detected by ffmpeg. */ if(stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_U8 || stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_U8P) *type = AL_UNSIGNED_BYTE_SOFT; else if (stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S16 || stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S16P) *type = AL_SHORT_SOFT; else if(stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S32 || stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S32P) *type = AL_INT_SOFT; else if(stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_FLT || stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_FLTP) *type = AL_FLOAT_SOFT; else if(stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_DBL || stream-&gt;CodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_DBLP) *type = AL_DOUBLE_SOFT; else { fprintf(stderr, &quot;Unsupported ffmpeg sample format: %s\\n&quot;, av_get_sample_fmt_name(stream-&gt;CodecCtx-&gt;sample_fmt)); return 1; } /* Get the OpenAL channel configuration using the channel layout detected * by ffmpeg. NOTE: some file types may not specify a channel layout. In * that case, one must be guessed based on the channel count. */ if(stream-&gt;CodecCtx-&gt;channel_layout == AV_CH_LAYOUT_MONO) *channels = AL_MONO_SOFT; else if(stream-&gt;CodecCtx-&gt;channel_layout == AV_CH_LAYOUT_STEREO) *channels = AL_STEREO_SOFT; else if(stream-&gt;CodecCtx-&gt;channel_layout == AV_CH_LAYOUT_QUAD) *channels = AL_QUAD_SOFT; else if(stream-&gt;CodecCtx-&gt;channel_layout == AV_CH_LAYOUT_5POINT1_BACK) *channels = AL_5POINT1_SOFT; else if(stream-&gt;CodecCtx-&gt;channel_layout == AV_CH_LAYOUT_7POINT1) *channels = AL_7POINT1_SOFT; else if(stream-&gt;CodecCtx-&gt;channel_layout == 0) { /* Unknown channel layout. Try to guess. */ if(stream-&gt;CodecCtx-&gt;channels == 1) *channels = AL_MONO_SOFT; else if(stream-&gt;CodecCtx-&gt;channels == 2) *channels = AL_STEREO_SOFT; else { fprintf(stderr, &quot;Unsupported ffmpeg raw channel count: %d\\n&quot;, stream-&gt;CodecCtx-&gt;channels); return 1; } } else { char str[1024]; av_get_channel_layout_string(str, sizeof(str), stream-&gt;CodecCtx-&gt;channels, stream-&gt;CodecCtx-&gt;channel_layout); fprintf(stderr, &quot;Unsupported ffmpeg channel layout: %s\\n&quot;, str); return 1; } *rate = stream-&gt;CodecCtx-&gt;sample_rate; return 0; } 嗯，基本上就可以了。现在播放的话，对应的 planar 是不会显示出来的，因为显示调用的是 alhelpers.cpp 的 GetFormat()，而它是按照 OpenAL 的格式输出的。 不过这不影响播放嘛。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"博客园记录","slug":"博客园记录","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AE%B0%E5%BD%95/"},{"name":"SDL2","slug":"SDL2","permalink":"https://blog.mottomo.moe/tags/SDL2/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://blog.mottomo.moe/tags/FFmpeg/"},{"name":"OpenAL","slug":"OpenAL","permalink":"https://blog.mottomo.moe/tags/OpenAL/"}]},{"title":"博客园第一篇——SDL2+FFmpeg 制作简单播放器与同步","slug":"zh/2014-04-03-Using-SDL2-and-FFmpeg-to-Build-A-Simple-Player-and-Synchornization","date":"2014-04-03T08:54:00.000Z","updated":"2020-03-30T22:34:35.388Z","comments":true,"path":"categories/Tech/Coding/zh/2014-04-03-Using-SDL2-and-FFmpeg-to-Build-A-Simple-Player-and-Synchornization/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2014-04-03-Using-SDL2-and-FFmpeg-to-Build-A-Simple-Player-and-Synchornization/","excerpt":"博客园地址 原标题：博客园第一篇——SDL2+FFmpeg 制作简单播放器&amp;同步，因为“&amp;”字符无法被百度sitemap插件处理写入 XML，所以改动了标题。","text":"博客园地址 原标题：博客园第一篇——SDL2+FFmpeg 制作简单播放器&amp;同步，因为“&amp;”字符无法被百度sitemap插件处理写入 XML，所以改动了标题。 SDL 2.0.3; FFmpeg 20140402 shared; 部分来自 http://blog.csdn.net/jiqiujia/article/details/22449131 的第二个例子，修正了一些问题。 原来的代码在第555行，SDL_Delay(50) 应该替换为 av_free_packet(&amp;packet)，这样既解决了迟滞问题还解决了一个坑爹的内存泄露问题。（我才不会告诉你我播放一个稍微大点的视频在8秒之后 2 GB 内存就被吃掉了呢！） https://github.com/phamquy/FFmpeg-tutorial-samples/blob/master/tutorial06.c 也有一些帮助。 功能： 简单播放器； 音频重采样，大部分视频的音频部分都播放正常（也有少部分仍不正常的）； 简单的同步。当前以音频流为基准，对于比较小（&lt;120 MB）的 .mpg/.flv 文件还正常，其他的有各种问题，包括视频仍然过快，或者严重丢帧（建议打开控制台自己看）。 下面上代码。部分地方有注释。 #define _CRT_SECURE_NO_WARNINGS extern &quot;C&quot; { #include &quot;libavutil/opt.h&quot; #include &quot;libavcodec/avcodec.h&quot; #include &quot;libavformat/avformat.h&quot; #include &quot;libswscale/swscale.h&quot; #include &quot;libswresample/swresample.h&quot; } #include &quot;SDL.h&quot; #include &quot;SDL_image.h&quot; #include &quot;SDL_thread.h&quot; #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; #pragma warning(disable: 4996) #pragma comment(lib,&quot;avutil.lib&quot;) #pragma comment(lib,&quot;avcodec.lib&quot;) #pragma comment(lib,&quot;avformat.lib&quot;) #pragma comment(lib,&quot;swscale.lib&quot;) #pragma comment(lib,&quot;swresample.lib&quot;) #pragma comment(lib,&quot;sdl2.lib&quot;) #define SDL_AUDIO_BUFFER_SIZE (1152) #define AVCODEC_MAX_AUDIO_FRAME_SIZE (192000) #if (defined main &amp;&amp; defined __MINGW__) #undef main #endif static Uint8 *audio_chunk; static Uint32 audio_len; static Uint8 *audio_pos; static int64_t audio_pts = 0; static int64_t audio_dts = 0; static int64_t video_pts = 0; static int64_t video_dts = 0; static AVFrame *g_pFrameYUV; SDL_Thread *g_pVideoThread; SDL_mutex *g_pVideoMutex; static int quit = 0; static int video_quit = 0; typedef struct video_thread_params { SwsContext *sws_context; SDL_Texture *texture; SDL_Renderer *renderer; AVCodecContext *vid_codec_context; SDL_mutex *video_mutex; } video_thread_params; int video_thread_proc(void *data); void fill_audio(void *udata, Uint8 *stream, int len){ if (audio_len == 0) return; len = (len &gt; audio_len ? audio_len : len); SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME); audio_pos += len; audio_len -= len; } int AudioResampling(AVCodecContext * audio_dec_ctx, AVFrame * pAudioDecodeFrame, int out_sample_fmt, int out_channels, int out_sample_rate, uint8_t* out_buf) { SwrContext * swr_ctx = NULL; int data_size = 0; int ret = 0; int64_t src_ch_layout = audio_dec_ctx-&gt;channel_layout; int64_t dst_ch_layout = AV_CH_LAYOUT_STEREO; int dst_nb_channels = 0; int dst_linesize = 0; int src_nb_samples = 0; int dst_nb_samples = 0; int max_dst_nb_samples = 0; uint8_t **dst_data = NULL; int resampled_data_size = 0; swr_ctx = swr_alloc(); if (!swr_ctx) { printf(&quot;swr_alloc error \\n&quot;); return -1; } src_ch_layout = (audio_dec_ctx-&gt;channels == av_get_channel_layout_nb_channels(audio_dec_ctx-&gt;channel_layout)) ? audio_dec_ctx-&gt;channel_layout : av_get_default_channel_layout(audio_dec_ctx-&gt;channels); if (out_channels == 1) { dst_ch_layout = AV_CH_LAYOUT_MONO; //printf(&quot;dst_ch_layout: AV_CH_LAYOUT_MONO\\n&quot;); } else if (out_channels == 2) { dst_ch_layout = AV_CH_LAYOUT_STEREO; //printf(&quot;dst_ch_layout: AV_CH_LAYOUT_STEREO\\n&quot;); } else { dst_ch_layout = AV_CH_LAYOUT_SURROUND; //printf(&quot;dst_ch_layout: AV_CH_LAYOUT_SURROUND\\n&quot;); } if (src_ch_layout &lt;= 0) { printf(&quot;src_ch_layout error \\n&quot;); return -1; } src_nb_samples = pAudioDecodeFrame-&gt;nb_samples; if (src_nb_samples &lt;= 0) { printf(&quot;src_nb_samples error \\n&quot;); return -1; } av_opt_set_int(swr_ctx, &quot;in_channel_layout&quot;, src_ch_layout, 0); av_opt_set_int(swr_ctx, &quot;in_sample_rate&quot;, audio_dec_ctx-&gt;sample_rate, 0); av_opt_set_sample_fmt(swr_ctx, &quot;in_sample_fmt&quot;, audio_dec_ctx-&gt;sample_fmt, 0); av_opt_set_int(swr_ctx, &quot;out_channel_layout&quot;, dst_ch_layout, 0); av_opt_set_int(swr_ctx, &quot;out_sample_rate&quot;, out_sample_rate, 0); av_opt_set_sample_fmt(swr_ctx, &quot;out_sample_fmt&quot;, (AVSampleFormat)out_sample_fmt, 0); if ((ret = swr_init(swr_ctx)) &lt; 0) { printf(&quot;Failed to initialize the resampling context\\n&quot;); return -1; } max_dst_nb_samples = dst_nb_samples = av_rescale_rnd(src_nb_samples, out_sample_rate, audio_dec_ctx-&gt;sample_rate, AV_ROUND_UP); if (max_dst_nb_samples &lt;= 0) { printf(&quot;av_rescale_rnd error \\n&quot;); return -1; } dst_nb_channels = av_get_channel_layout_nb_channels(dst_ch_layout); ret = av_samples_alloc_array_and_samples(&amp;dst_data, &amp;dst_linesize, dst_nb_channels, dst_nb_samples, (AVSampleFormat)out_sample_fmt, 0); if (ret &lt; 0) { printf(&quot;av_samples_alloc_array_and_samples error \\n&quot;); return -1; } dst_nb_samples = av_rescale_rnd(swr_get_delay(swr_ctx, audio_dec_ctx-&gt;sample_rate) + src_nb_samples, out_sample_rate, audio_dec_ctx-&gt;sample_rate, AV_ROUND_UP); if (dst_nb_samples &lt;= 0) { printf(&quot;av_rescale_rnd error \\n&quot;); return -1; } if (dst_nb_samples &gt; max_dst_nb_samples) { av_free(dst_data[0]); ret = av_samples_alloc(dst_data, &amp;dst_linesize, dst_nb_channels, dst_nb_samples, (AVSampleFormat)out_sample_fmt, 1); max_dst_nb_samples = dst_nb_samples; } if (swr_ctx) { ret = swr_convert(swr_ctx, dst_data, dst_nb_samples, (const uint8_t **)pAudioDecodeFrame-&gt;data, pAudioDecodeFrame-&gt;nb_samples); if (ret &lt; 0) { printf(&quot;swr_convert error \\n&quot;); return -1; } resampled_data_size = av_samples_get_buffer_size(&amp;dst_linesize, dst_nb_channels, ret, (AVSampleFormat)out_sample_fmt, 1); if (resampled_data_size &lt; 0) { printf(&quot;av_samples_get_buffer_size error \\n&quot;); return -1; } } else { printf(&quot;swr_ctx null error \\n&quot;); return -1; } memcpy(out_buf, dst_data[0], resampled_data_size); if (dst_data) { av_freep(&amp;dst_data[0]); } av_freep(&amp;dst_data); dst_data = NULL; if (swr_ctx) { swr_free(&amp;swr_ctx); } return resampled_data_size; } //创建一个全局的结构体变量以便于我们从文件中得到的声音包有地方存 //放同时也保证SDL中的声音回调函数audio_callback 能从这个地方得到声音数据 typedef struct PacketQueue{ AVPacketList *first_pkt, *last_pkt; int nb_packets; int size; SDL_mutex *mutex;//因为SDL 是在一个独立的线程中来进行音频处理的。如果我们没有正确的锁定这个队列，我们有可能把数据搞乱。 SDL_cond *cond; }PacketQueue; PacketQueue audioq; PacketQueue videoq; queue&lt;AVFrame *&gt; frameq; void packet_queue_init(PacketQueue *pq){ memset(pq, 0, sizeof(PacketQueue)); pq-&gt;mutex = SDL_CreateMutex(); pq-&gt;cond = SDL_CreateCond(); } int packet_queue_put(PacketQueue *q, AVPacket *pkt){ AVPacketList *pkt1; /*( if (av_dup_packet(pkt) &lt; 0){ printf(&quot;error&quot;); return -1; } */ pkt1 = (AVPacketList*)av_malloc(sizeof(AVPacketList)); if (!pkt1){ printf(&quot;error&quot;); return -1; } av_copy_packet(&amp;pkt1-&gt;pkt, pkt); av_free_packet(pkt); pkt1-&gt;next = NULL; //函数SDL_LockMutex()锁定队列的互斥量以便于我们向队列中添加东西，然后函 //数SDL_CondSignal()通过我们的条件变量为一个接 收函数（如果它在等待）发 //出一个信号来告诉它现在已经有数据了，接着就会解锁互斥量并让队列可以自由 //访问。 SDL_LockMutex(q-&gt;mutex); if (!q-&gt;last_pkt)//队列为空 q-&gt;first_pkt = pkt1; else//队列不为空 q-&gt;last_pkt-&gt;next = pkt1; q-&gt;last_pkt = pkt1; q-&gt;nb_packets++; q-&gt;size += pkt1-&gt;pkt.size; SDL_CondSignal(q-&gt;cond); SDL_UnlockMutex(q-&gt;mutex); return 0; } int decode_interrupt_cb(void){ return quit; } static int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block){ AVPacketList *pkt1; int ret; SDL_LockMutex(q-&gt;mutex); for (;;){ if (quit){ ret = -1; break; } pkt1 = q-&gt;first_pkt; if (pkt1){ q-&gt;first_pkt = pkt1-&gt;next; if (!q-&gt;first_pkt) q-&gt;last_pkt = NULL; q-&gt;nb_packets--; q-&gt;size -= pkt1-&gt;pkt.size; //*pkt = pkt1-&gt;pkt; av_copy_packet(pkt, &amp;pkt1-&gt;pkt); av_free_packet(&amp;pkt1-&gt;pkt); av_free(pkt1); ret = 1; break; } else if (!block){ ret = 0; break; } else{ SDL_CondWait(q-&gt;cond, q-&gt;mutex); } } SDL_UnlockMutex(q-&gt;mutex); return ret; } int audio_decode_frame(AVCodecContext *aCodecCtx, uint8_t *audio_buf, int buf_size){ static AVPacket pkt; static uint8_t *audio_pkt_data = NULL; static int audio_pkt_size = 0; int len1, data_size, ret = 0; static AVFrame *pFrame; pFrame = av_frame_alloc(); /*if (packet_queue_get(&amp;audioq, &amp;pkt, 1) &lt; 0){//从这里开始，取得main线程放入队列的包 printf(&quot;error, can&#39;t get packet from the queue&quot;); return -1; } len1 = avcodec_decode_audio4(aCodecCtx, pFrame, &amp;ret, &amp;pkt); if (len1 &lt; 0) return -1; return AudioResampling(aCodecCtx, pFrame, AV_SAMPLE_FMT_S16, 2, 44100, audio_buf);*/ for (;;){ while (audio_pkt_size &gt; 0){ data_size = buf_size; len1 = avcodec_decode_audio4(aCodecCtx, pFrame, &amp;ret, &amp;pkt); //len1 = avcodec_decode_audio3(aCodecCtx, (int16_t *)audio_buf, // &amp;data_size, &amp;pkt); if (len1 &lt; 0){//if error, skip frame printf(&quot;error\\n&quot;); audio_pkt_size = 0; break; } data_size = AudioResampling(aCodecCtx, pFrame, AV_SAMPLE_FMT_S16, 2, 44100, audio_buf); audio_pkt_data += len1; audio_pkt_size -= len1; if (data_size &lt;= 0)//No data yet, get more frames continue; return data_size; } //if (pkt.data) av_free_packet(&amp;pkt); if (quit) return -1; if (packet_queue_get(&amp;audioq, &amp;pkt, 1) &lt; 0){//从这里开始，取得main线程放入队列的包 printf(&quot;error, can&#39;t get packet from the queue&quot;); return -1; } //SDL_LockMutex(g_pVideoMutex); audio_pts = pkt.pts; audio_dts = pkt.dts; //SDL_UnlockMutex(g_pVideoMutex); audio_pkt_data = pkt.data; audio_pkt_size = pkt.size; } } //声音回调函数 //userdata是输入，stream是输出，len是输入，len的值一般为4096（调试中发现的）， //audio_callback函数的功能是调用audio_decode_frame函数，把解码后数据块audio_buf追加在stream的后面， //通过SDL库对audio_callback的不断调用，不断解码数据，然后放到stream的末尾， //SDL库认为stream中数据够播放一帧音频了，就播放它, //第三个参数len是向stream中写数据的内存分配尺度，是分配给audio_callback函数写入缓存大小。 void audio_callback(void *userdata, Uint8 *stream, int len){ //SDL_memset(stream, 0, len); AVCodecContext *aCodecCtx = (AVCodecContext*)userdata; int len1, audio_size; //audio_buf 的大小为 1.5 倍的声音帧的大 小以便于有一个比较好的缓冲 static uint8_t audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * 3) / 2]; static unsigned int audio_buf_size = 0; static unsigned int audio_buf_index = 0; while (len &gt; 0){ if (audio_buf_index &gt;= audio_buf_size){//already send all our data, get more audio_size = audio_decode_frame(aCodecCtx, audio_buf, sizeof(audio_buf)); if (audio_size &lt; 0){//error, output silence printf(&quot;error, output silence\\n&quot;); audio_buf_size = SDL_AUDIO_BUFFER_SIZE; memset(audio_buf, 0, audio_buf_size); } else audio_buf_size = audio_size; audio_buf_index = 0; } len1 = audio_buf_size - audio_buf_index; if (len1&gt;len){ len1 = len; } memcpy(stream, (uint8_t *)audio_buf + audio_buf_index, len1); len -= len1; stream += len1; audio_buf_index += len1; } } // 视频流处理线程 // 这里对齐是以音频流为准的 // 所以如果音频流（相对于视频流）过于稀疏的话，就会失去作用，效果不好 int video_thread_proc(void *data) { video_thread_params *params = (video_thread_params *)data; AVFrame *pFrame = NULL; AVFrame *pNextFrame = NULL; AVPacket packet = {0}; AVPacket nextpacket; // 注意，以下代码比较的都是 DTS（解压缩时间戳）而不是 PTS（显示时间戳）！！！ // 实际视频显示是以 PTS 为准的，但是 PTS 大多没有规律（只要是在解压之后就好），难以处理 // 所幸在相当一部分视频中 DTS 与 PTS 相差较小，所以这里就用 DTS 了 while (!video_quit) { while (!frameq.empty()) { if (pFrame == NULL) { SDL_LockMutex(params-&gt;video_mutex); // 这里采用了“连续读取”的方法，也即如果下一帧的 DTS 小于当前基准（目前采用音频流），则循环直至找到第一个 DTS 比基准大的 // 然后播放小于基准而且离基准最近的帧，并缓存下一帧 // 由于处理时间较长，而且使用了互斥体（看，音频部分也用到了），所以可能有极少数的音频帧有异常（噪声啊之类的） // 当然也可以将这一段注释掉，采用 pFrame = frameq.count(); frameq.pop();，同时解除 if (packet_queue_get()) 的注释（和下面的一对大括号） // 但是无跳过的方法会导致视频严重滞后 if (pNextFrame != NULL) { pFrame = pNextFrame; SDL_memcpy(&amp;packet, &amp;nextpacket, sizeof(AVPacket)); pNextFrame = NULL; } else { pFrame = frameq.front(); frameq.pop(); } while (!frameq.empty()) { pNextFrame = frameq.front(); frameq.pop(); packet_queue_get(&amp;videoq, &amp;nextpacket, 1); if (nextpacket.dts &lt;= audio_dts) { av_free_packet(&amp;packet); av_frame_free(&amp;pFrame); SDL_memcpy(&amp;packet, &amp;nextpacket, sizeof(AVPacket)); pFrame = pNextFrame; pNextFrame = NULL; } else { break; } } //pFrame = frameq.front(); //frameq.pop(); //cout &lt;&lt; &quot;vdts: &quot; &lt;&lt; packet.dts &lt;&lt; &quot; adts: &quot; &lt;&lt; audio_dts &lt;&lt; endl; //if (packet_queue_get(&amp;videoq, &amp;packet, 1) &gt;= 0) //{ sws_scale(params-&gt;sws_context, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, params-&gt;vid_codec_context-&gt;height, g_pFrameYUV-&gt;data, g_pFrameYUV-&gt;linesize); SDL_UpdateYUVTexture(params-&gt;texture, NULL, g_pFrameYUV-&gt;data[0], g_pFrameYUV-&gt;linesize[0], g_pFrameYUV-&gt;data[1], g_pFrameYUV-&gt;linesize[1], g_pFrameYUV-&gt;data[2], g_pFrameYUV-&gt;linesize[2]); //SDL_RenderClear(params-&gt;renderer); SDL_RenderCopy(params-&gt;renderer, params-&gt;texture, NULL, NULL); SDL_RenderPresent(params-&gt;renderer); // 可以使用 av_frame_clone() + 队列 实现“远程”dts 读取 //if (params-&gt;vid_codec_context-&gt;refcounted_frames) //{ // av_frame_unref(pFrame); //} //} //cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; //cout &lt;&lt; &quot;vidpts: &quot; &lt;&lt; packet.pts &lt;&lt; &quot; audpts: &quot; &lt;&lt; audio_pts &lt;&lt; endl; //cout &lt;&lt; &quot;viddts: &quot; &lt;&lt; packet.dts &lt;&lt; &quot; auddts: &quot; &lt;&lt; audio_dts &lt;&lt; endl; SDL_UnlockMutex(params-&gt;video_mutex); } else { //cout &lt;&lt; &quot;vdts: &quot; &lt;&lt; packet.dts &lt;&lt; &quot; adts: &quot; &lt;&lt; audio_dts &lt;&lt; endl; // 如果当前帧应该用被缓存的帧，那就用，不要重新读取了 sws_scale(params-&gt;sws_context, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, params-&gt;vid_codec_context-&gt;height, g_pFrameYUV-&gt;data, g_pFrameYUV-&gt;linesize); SDL_UpdateYUVTexture(params-&gt;texture, NULL, g_pFrameYUV-&gt;data[0], g_pFrameYUV-&gt;linesize[0], g_pFrameYUV-&gt;data[1], g_pFrameYUV-&gt;linesize[1], g_pFrameYUV-&gt;data[2], g_pFrameYUV-&gt;linesize[2]); //SDL_RenderClear(params-&gt;renderer); SDL_RenderCopy(params-&gt;renderer, params-&gt;texture, NULL, NULL); SDL_RenderPresent(params-&gt;renderer); // 可以使用 av_frame_clone() + 队列 实现“远程”dts 读取 if (params-&gt;vid_codec_context-&gt;refcounted_frames) { av_frame_unref(pFrame); } // 如果该帧是在音频帧之前的，那就销毁它，和数据包 if (packet.dts &lt;= audio_dts) { av_frame_free(&amp;pFrame); av_free_packet(&amp;packet); pFrame = NULL; } } } } return 0; } int main(int argc, char *argv[]) { av_register_all(); //注册了所有的文件格式和编解码的库，它们将被自动的使用在被打开的合适格式的文件上 AVFormatContext *pFormatCtx; pFormatCtx = avformat_alloc_context(); if (argc &lt; 2) return 0; //Open an input stream and read the header if (avformat_open_input(&amp;pFormatCtx, argv[1], NULL, NULL) != 0){ printf(&quot;Can&#39;t open the file\\n&quot;); return -1; } //Retrieve stream information if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0){ printf(&quot;Couldn&#39;t find stream information.\\n&quot;); return -1; } //output file information cout &lt;&lt; &quot;文件信息----------------------------------&quot; &lt;&lt; endl; av_dump_format(pFormatCtx, 0, argv[1], 0); cout &lt;&lt; &quot;--------------------------------------------&quot; &lt;&lt; endl; int i, videoIndex, audioIndex; //Find the first video stream videoIndex = -1; audioIndex = -1; for (i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++){//视音频流的个数 if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; videoIndex &lt; 0){ videoIndex = i; } if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; audioIndex &lt; 0) audioIndex = i; } if (videoIndex == -1) return -1; if (audioIndex == -1) return -1; AVCodecContext *pCodecCtx, *paCodecCtx; AVCodec *pCodec, *paCodec; //Get a pointer to the codec context for the video stream //流中关于编解码器的信息就是被我们叫做&quot;codec context&quot;（编解码器上下文） //的东西。这里面包含了流中所使用的关于编解码器的所有信 pCodecCtx = pFormatCtx-&gt;streams[videoIndex]-&gt;codec; // 帧引用：打开，见 AVFrame 的注释 pCodecCtx-&gt;refcounted_frames = 1; paCodecCtx = pFormatCtx-&gt;streams[audioIndex]-&gt;codec; //Find the decoder for the video stream pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); paCodec = avcodec_find_decoder(paCodecCtx-&gt;codec_id); if (pCodec == NULL || paCodecCtx == NULL){ printf(&quot;Unsupported codec!\\n&quot;); return -1; } //Open codec if (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; 0){ printf(&quot;Could not open video codec.\\n&quot;); return -1; } if (avcodec_open2(paCodecCtx, paCodec, NULL) &lt; 0){ printf(&quot;Could not open audio codec.\\n&quot;); return -1; } //--------------------------------------------------------// printf(&quot;比特率 %3d\\n&quot;, pFormatCtx-&gt;bit_rate); printf(&quot;解码器名称 %s\\n&quot;, paCodecCtx-&gt;codec-&gt;long_name); printf(&quot;time_base %d \\n&quot;, paCodecCtx-&gt;time_base); printf(&quot;声道数 %d \\n&quot;, paCodecCtx-&gt;channels); printf(&quot;sample per second %d \\n&quot;, paCodecCtx-&gt;sample_rate); //--------------------------------------------------------// //allocate video frame and set its fileds to default value AVFrame *pFrame; //AVFrame *pFrameYUV; pFrame = av_frame_alloc(); g_pFrameYUV = av_frame_alloc(); //即使我们申请了一帧的内存，当转换的时候，我们仍然需要一个地方来放置原始 //的数据。我们使用avpicture_get_size 来获得我们需要的大小， 然后手工申请 //内存空间： uint8_t *out_buffer; int numBytes; numBytes = avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //av_malloc 是ffmpeg 的malloc，用来实现一个简单的malloc 的包装，这样来保 //证内存地址是对齐的（4 字节对齐或者2 字节对齐）。它并不能保 护你不被内 //存泄漏，重复释放或者其它malloc 的问题所困扰。 out_buffer = (uint8_t *)av_malloc(numBytes*sizeof(uint8_t)); //Assign appropriate parts of buffer to image planes in pFrameYUV //Note that pFrameYUV is an AVFrame, but AVFrame is a superset of AVPicture avpicture_fill((AVPicture*)g_pFrameYUV, out_buffer, PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //----------------SDL--------------------------------------// if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)){ printf(&quot;Could not initialize SDL -%s\\n&quot;, SDL_GetError()); exit(1); } //先设置声音的选项：采样率，声音通道数和其它的参 数，然后我们 //设置一个回调函数和一些用户数据userdata。当开始播放音频的时候，SDL 将不 //断地调用这个回调函数并且要求它来向声音缓冲填入一个特定的数量的字节。 //当我们把这些信息放到SDL_AudioSpec 结构体中后，我们调用函数 //SDL_OpenAudio()就会打开声音设备并且给我们送 回另外一个AudioSpec 结构 //体。这个结构体是我们实际上用到的－－因为我们不能保证得到我们所要求的。 SDL_AudioSpec wanted_spec; wanted_spec.freq = paCodecCtx-&gt;sample_rate; wanted_spec.format = AUDIO_S16SYS; wanted_spec.channels = paCodecCtx-&gt;channels; //声音的通道数 wanted_spec.silence = 0; //用来表示静音的值 wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE; //声音缓冲区的大小 wanted_spec.callback = audio_callback; wanted_spec.userdata = paCodecCtx; if (SDL_OpenAudio(&amp;wanted_spec, NULL) &lt; 0){ printf(&quot;SDL_OpenAudio error: %s\\n&quot;, SDL_GetError()); return -1; } packet_queue_init(&amp;audioq); packet_queue_init(&amp;videoq); SDL_PauseAudio(0); SDL_Window *window = nullptr; window = SDL_CreateWindow(&quot;MPlayer&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, pCodecCtx-&gt;width, pCodecCtx-&gt;height, SDL_WINDOW_SHOWN); if (!window){ cout &lt;&lt; SDL_GetError() &lt;&lt; endl; return 1; } SDL_Renderer *ren = nullptr; ren = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC); if (ren == nullptr){ cout &lt;&lt; SDL_GetError() &lt;&lt; endl; return -1; } SDL_Texture *texture = nullptr; texture = SDL_CreateTexture(ren, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //*************************************************************// //通过读取包来读取整个视频流，然后把它解码成帧，最后转换格式并且保存 int frameFinished; //int psize = pCodecCtx-&gt;width * pCodecCtx-&gt;height; AVPacket packet; av_new_packet(&amp;packet, numBytes); i = 0; int ret; static struct SwsContext *img_convert_ctx; img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); SDL_Event ev; video_thread_params vtp; vtp.renderer = ren; vtp.texture = texture; vtp.sws_context = img_convert_ctx; vtp.vid_codec_context = pCodecCtx; vtp.video_mutex = SDL_CreateMutex(); g_pVideoMutex = vtp.video_mutex; g_pVideoThread = SDL_CreateThread(video_thread_proc, &quot;video_thread&quot;, &amp;vtp); double v_a_ratio; // 视频帧数/音频帧数 int frame_queue_size; //Read the next frame of a stream while ((!quit) &amp;&amp; (av_read_frame(pFormatCtx, &amp;packet) &gt;= 0 || (!frameq.empty()))) { //Is this a packet from the video stream? if (packet.stream_index == videoIndex) { //decode video frame of size packet.size from packet.data into picture ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet); //Did we get a video frame? if (ret &gt;= 0) { //Convert the image from its native format to YUV if (frameFinished) { /* sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, g_pFrameYUV-&gt;data, g_pFrameYUV-&gt;linesize); SDL_UpdateYUVTexture(texture, NULL, g_pFrameYUV-&gt;data[0], g_pFrameYUV-&gt;linesize[0], g_pFrameYUV-&gt;data[1], g_pFrameYUV-&gt;linesize[1], g_pFrameYUV-&gt;data[2], g_pFrameYUV-&gt;linesize[2]); AVFrame *pNewFrame = av_frame_clone(pFrame); frameq.push(pNewFrame); packet_queue_put(&amp;videoq, &amp;packet); SDL_RenderClear(ren); SDL_RenderCopy(ren, texture, NULL, NULL); SDL_RenderPresent(ren); // 可以使用 av_frame_clone() + 队列 实现远程 dts 读取 if (pCodecCtx-&gt;refcounted_frames) { av_frame_unref(pFrame); } cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt;&lt;&quot; &lt;&lt; endl; cout &lt;&lt; &quot;vpts: &quot; &lt;&lt; packet.pts &lt;&lt; &quot;, apts: &quot; &lt;&lt; audio_pts &lt;&lt; endl; cout &lt;&lt; &quot;vdts: &quot; &lt;&lt; packet.dts &lt;&lt; &quot;, adts: &quot; &lt;&lt; audio_dts &lt;&lt; endl; */ // 用互斥体保持同步，将包送入队列，让另外的线程自己处理 SDL_LockMutex(vtp.video_mutex); packet_queue_put(&amp;videoq, &amp;packet); AVFrame *pNewFrame = av_frame_clone(pFrame); frameq.push(pNewFrame); //cout &lt;&lt; &quot;Pushing vpacket.&quot; &lt;&lt; endl; SDL_UnlockMutex(vtp.video_mutex); } // 注意这里也必须要 free packet，否则会导致严重内存泄露 // 我修改了 packet_queue_put() 函数，它会复制 packet，所以可以放心释放上 av_free_packet(&amp;packet); } else{ av_free_packet(&amp;packet); cout &lt;&lt; &quot;decode error&quot; &lt;&lt; endl; return -1; } } else if (packet.stream_index == audioIndex){ //packet_queue_put(&amp;audioq, &amp;packet); /*ret = avcodec_decode_audio4(paCodecCtx, pFrame, &amp;frameFinished, &amp;packet); cout &lt;&lt; pFrame-&gt;format &lt;&lt; endl; if (ret &lt; 0){ printf(&quot;Error in decoding audio frame\\n&quot;); exit(0); } if (frameFinished){ printf(&quot;pts %5d\\n&quot;, packet.pts); printf(&quot;dts %5d\\n&quot;, packet.dts); printf(&quot;packet_size %5d\\n&quot;, packet.size); } audio_chunk = (Uint8*)pFrame-&gt;data[0]; audio_len = pFrame-&gt;linesize[0]; audio_pos = audio_chunk; //SDL_PauseAudio(0); while (audio_len&gt;0) SDL_Delay(1);*/ packet_queue_put(&amp;audioq, &amp;packet); } else { av_free_packet(&amp;packet); } process_sdl_events: if (SDL_PollEvent(&amp;ev)) { switch (ev.type){ case SDL_QUIT: { quit = 1; video_quit = 1; SDL_Quit(); goto exit_line; break; } case SDL_KEYDOWN: if (ev.key.keysym.scancode == SDL_SCANCODE_ESCAPE) { quit = 1; video_quit = 1; SDL_Quit(); goto exit_line; break; } default: break; } } //cout &lt;&lt; &quot;vframes: &quot; &lt;&lt; pCodecCtx-&gt;frame_number &lt;&lt; &quot; aframes: &quot; &lt;&lt; paCodecCtx-&gt;frame_number &lt;&lt; endl; // 设置一个缓冲区大小，如果超过此大小则暂停处理（视频和音频）帧 // 这里采用限制 frameq 的大小的方法 // 如果采用以下的动态代码，有可能导致结尾“崩坏”，囧 /* if (paCodecCtx-&gt;frame_number == 0) { v_a_ratio = 300; // 一个很大的值，基本上能保证所有视频都能解码 } else { v_a_ratio = pCodecCtx-&gt;frame_number / (double)paCodecCtx-&gt;frame_number; if (v_a_ratio &lt; 10.0) v_a_ratio = 10.0; } frame_queue_size = (int)v_a_ratio * 2; if (frameq.size() &gt; frame_queue_size) goto process_sdl_events; */ if (frameq.size() &gt; 50) goto process_sdl_events; } exit_line: SDL_DestroyMutex(vtp.video_mutex); SDL_DestroyTexture(texture); av_frame_free(&amp;pFrame); av_frame_free(&amp;g_pFrameYUV); avcodec_close(pCodecCtx); avformat_close_input(&amp;pFormatCtx); return 0; }","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"博客园记录","slug":"博客园记录","permalink":"https://blog.mottomo.moe/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AE%B0%E5%BD%95/"},{"name":"SDL2","slug":"SDL2","permalink":"https://blog.mottomo.moe/tags/SDL2/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://blog.mottomo.moe/tags/FFmpeg/"}]},{"title":"Thu Apr 03 2014 00:00:00 GMT+0800 (中国标准时间)","slug":"zh/2014-04-03-Records-on-04-03","date":"2014-04-03T08:19:00.000Z","updated":"2020-03-30T22:34:35.388Z","comments":true,"path":"categories/Misc/Records/zh/2014-04-03-Records-on-04-03/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-04-03-Records-on-04-03/","excerpt":"","text":"以后代码方面的东西我会发布到博客园上，而不再是百度空间了。百度空间的字数限制很糟糕啊，而且它的定位不是技术博客，而是社交病毒（类似 MySpace）。也许有些杂乱的东西会放到这里。 博客园地址：http://www.cnblogs.com/GridScience/","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Microsoft Visual Studio 2013，还是不能令人满意","slug":"zh/2014-02-25-Visual-Studio-2013-Not-So-Perfect","date":"2014-02-24T16:11:00.000Z","updated":"2020-03-30T22:34:35.388Z","comments":true,"path":"categories/Misc/Records/zh/2014-02-25-Visual-Studio-2013-Not-So-Perfect/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2014-02-25-Visual-Studio-2013-Not-So-Perfect/","excerpt":"","text":"目前为止，微软方面最好用的开发工具就是 Visual Studio 2012 了。 VS 2013 取消或弱化了两个我常用的功能（C/C++ 方面）：枚举成员自动提示值，以及自动错误检测。 前者是，将鼠标移动到枚举的其中一个值上，IntelliSense 会告诉你这个值的数值，例如“enum type::ident = 24”。如果一个枚举有数十个值，而且是自动递增的，那么就不用去数了……但是现在只有一个冷冰冰的“int ident”（依继承的不同，类型会不同）。 后者是，例如吧，把一个文件中的被引用的函数名改动一下，那么当前文档和所有关联着的打开的文档都会有 IntelliSense 的错误提示（下面有红色波浪线）。现在？IntelliSense 只是简单地假设被调用的函数具有 int 的返回值……然后编译的时候才告诉你“Unresolved symbol”。这和早期的 C/C++ IDE 有什么不一样吗！ 虽然说 VS 2013 的速度是提上去了，估计就是这些导致的吧。毕竟不是所有人都是 industrious developer，也有人想偷懒……就像我。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"2013年11月19日-记录","slug":"zh/2013-11-19-Records-on-11-19","date":"2013-11-19T13:15:00.000Z","updated":"2020-03-30T22:34:35.387Z","comments":true,"path":"categories/Misc/Records/zh/2013-11-19-Records-on-11-19/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-11-19-Records-on-11-19/","excerpt":"","text":"今天的合唱比赛，我没能带领大家得第一名……实在是无法释怀……哦是的我是有完美主义倾向。 他们真的挺认真的，三星期，可惜没有一张奖状证明他们曾经努力过。也许世界就是这么不公平吧，但是也许这个世界会更温柔一些……不知道。 附：Sibelius 7.1.x 出现“未指定的错误 {1}”（Unspecified error (1)）的解决方法。 其实 Avid 的官网上有。在 Windows 上，删除 %ProgramData%\\Avid\\Licenses\\Sibelius，重启 Sibelius。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"我们月亮上见 - To the Moon（去月球）","slug":"zh/2013-08-28-To-the-Moon","date":"2013-08-27T19:30:00.000Z","updated":"2020-03-30T22:34:35.386Z","comments":true,"path":"categories/Misc/Records/zh/2013-08-28-To-the-Moon/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-08-28-To-the-Moon/","excerpt":"","text":"（背景音乐：For River (Johnny’s Version) - Kan Gao，直接从游戏目录中提取） 关键词：Asperger Syndrome（艾斯伯格综合征） 推荐给：希望找到感动的人 （请注意，以下内容含有大量剧透成分！） 8月22日夜到8月23日凌晨，4个小时，To the Moon（去月球）通关。说是“通关”，其实不过是玩了一遍游戏而已，这游戏实际上就是一部“伪装成RPG的小说”。通关之后，我就给它打了10分的满分。有人说这剧情做作，我不那么觉得。文似看山不喜平，而且这更像是一个真实的对类自闭症患者的心灵的描写。 我是怎么知道这款游戏的呢？在非快餐游戏吧里见到了对这款游戏的推荐，上网一搜索发现原声音乐还不错（现在的评价是是非常好），于是先把原声音乐下载了下来，然后去支教。回来之后因为东方project的影响想做一个AVG引擎，觉得不见见这游戏的真身真可惜，就找了一下，通关。 我玩的是圆桌汉化组的汉化版，所以我还没见识过原版的游戏（当然，可以在 Steam 上购买到，不过我没银子），所以之后的叙述中，是以汉化版为基础的。（我个人推荐去玩原版，毕竟如果不是那一句“听到我的名字就想上厕所”我绝对猜不出“瑞娃”是什么英文名，而且原文也不难懂。）Kan Gao 的团队出品的游戏都是高水准的吗？我等着 To the Moon episode 2 出来，或许应该先去看看 A Bird’s Story。 这是一个通关之后还让人回味良久的游戏。今天看到《Everything’s All Right》的歌词，再次被感动（那是两个人的真实写照啊！）；又查了艾斯伯格综合征，才对 River 有了更深的了解。 我就主要讲讲游戏里面的几个人物吧。 1、Dr. Neil Watts &amp; Dr. Eva Rosalene（尼尔·沃兹博士和伊娃·罗萨琳博士）（我选的是 Dr. Rosalene 线，不过看起来选哪一条，只有轻微的差别，例如谁去在舞台上向大家宣讲“NASA 的登月计划”。但也有些大事件可能会与选 Dr. Watts 线不同，例如谁去移除 River，不过从图像上看来都是 Dr. Rosalene。这个等我玩了另一条线再更新吧。） 欢喜冤家。看起来 Dr. Watts 有些喜欢 Dr. Rosalene（黑白配 = =），最后看起飞的时候那牵手的动作，呵呵。游戏中表现得比较多的是 Dr. Watts，最大的未解之谜在他身上萦绕：他为什么需要止痛药？从游戏中的表现看来，Dr. Watts 是一个冒失鬼，但是是一个感性的人，与 Dr. Rosalene 比起来就像是一个小孩子（Alfred Ashford 和 Alexia Ashford？）；相比之下，Dr. Rosalene 多了一份成熟，多了一份理智，特别是到了中后期的那个时间点上，那种绝对冷静——或者到了冷酷、疯狂的地步了吧。两人总是说“为了公司”怎样怎样（直到后面都还有“按照协议”和“按照人性”的争执），但最后的结果是双赢，这还是挺让人欣慰的。 2、Johnny Wyles &amp; Joey Wyles（约翰尼·怀尔斯和乔伊·怀尔斯）Johnny 是男主角，兄弟 Joey 在其早年因为一次意外而身亡。这次事件的带来的严重后果是 Johnny 开始服用β受体阻滞剂（β-blockers）。这导致他的记忆被破坏，从而忘记了许多东西，包括与 Joey 和 River 的所有记忆（所以 River 才一直在提醒他，想让他回忆起他们在游乐场的第一次见面）。可是，这记忆，人性的一部分，怎么可能会被那无情的化学制剂抹杀呢？Johnny 心中一直保留着“去月球”的记忆，虽然他已经忘记了与 River 的初次相遇，虽然他一直不知道为什么他会这么想。最后他修改了早年记忆之后，和从新记忆里诞生的 River 携手搭乘航天飞机前往月球。记忆改变了，她虽然在早年消失了，但最后，奇迹般地，他们又见面了，而且也有了与现实中相近但完美的生活。从中可以看出 River 对他的影响多大，以及他与 River 感情的深厚。（人性的美好可以抵抗任何恶力量，即使记忆消失了……我希望如果我某一天了也失忆了，最美好的东西还是会留存下来。我希望所有我爱的人，即使我的意识被抹去了，潜意识里的所有人还是有美好的结局。） Johnny 幸福吗？有爱着自己的妻子、有好哥们儿，却让母亲头痛（因为看到就想起死去的 Joey，因此经常叫错名字），而且失去了记忆（尽管保留这那约定的残影）。谁知道呢？ 3、River E. Wyles（音译“瑞娃”太蛋疼了，直接以 River 称之，和 Serenity 也即《冲出宁静号》的女主角名相同）（在本段中提到的艾斯伯格综合征，是一种类自闭症，与自闭症不完全一样。详情请咨询相关专业人士。） River 是一个特殊的孩子。在玩 To the Moon 之前我对游戏的剧情并不知晓，但是第三章的“总有一天，我会成为他们中的一员”，在刹那间让一个短语闪现在我的脑海中：星星的孩子（儿童自闭症患者）。再次回味游戏，原来我想的是正确的。是的，River 也是一颗星星，而且一直是那么耀眼，从来就没有落于凡尘。如果对艾斯伯格综合征有一点点了解的话，在游戏过程中我应该就会看出端倪。River 静静地看书，被叫起来回答问题时一口气就是一长串话，一直折纸兔子，一直对那只鸭嘴兽不离不弃，以及那句“我们同时在同一间屋子里看电影，那不就是在一起了吗”（我很欣赏这句话，因为我从小都是这么想的，现在还是）。 是自闭症吗？但是 River 在一些时候又显得那么正常，她上学了，结婚了，会和人说话。但是我玩的时候对艾斯伯格综合征不了解，错过了她一生都在说的话——“你还记得那天晚上我们看星星吗”？她能和人说话，但是不能表达一些情感，所以只能用折纸（这也可以缓解她内心的不安，见百科）和守望灯塔（她在结婚前夜提议称之为 Anya）的行为在不断述说着。我玩的时候一直不理解，为什么 River 不要治病（可能是癌症吧），就为了建好那房子？其实，她是希望每天见到那灯塔，因为她在一些事情上和人无法交流（所以她也认为，星星们像灯塔，都在尽力向他人表达自己却没能被听见），有“同病相怜”之感。 可怜的 River 啊，苦苦地等待；可怜的 Johnny 啊，一生都没能理解。River 是不幸的，又是幸运的。River患上了艾斯伯格综合征，这在普通人眼里是十分不幸的，她也认为是不幸的（因为有时无法表达自己的想法）。她等待了一生，就在等待 Johnny 回忆起那个晚上，可是未能如愿，只是因为那可恶的β受体阻滞剂。但是因果之事，微妙玄通，深不可识——就最后的结果看来，她与Johnny 的相遇在一定程度上造成了 Joey 的死亡（因为改变之后，Johnny 遵守之前的诺言，努力读书以期去月球，所以没出门和 Joey 玩，Joey 就没有被撞），而 Joey 的死亡间接抹去了 Johnny 的早年记忆。唉，造化弄人啊。碰上一个爱自己的丈夫，也算是幸运了吧，可惜Johnny 爱的是 River 身上的“特殊”（为此 Nicolas 表示崩溃），尽管后半辈子中 Johnny 也爱着 River，但是“特殊”在哪里，他却一辈子都没能想起来或者领悟到。现实中的 River 含恨而终，但新的 River 如愿了，总有那么一点可惜的结局。 其实我对 River 的经历突然有了那么深刻的体会，是因为我支教时遇上的一件事情。如果不是这件事，或许 To the Moon 的真实性就被我忽略了。 （声明：为了遵守保密协议，在本文里不会出现真实姓名。我对其描述只是基于我所见到的情况，做出的结论是我的结论，不是医学上的结论。） 那是一个男孩，可能有人格分裂症（以下我对表现形态都以“人格”称之，不过未必准确）。在所有人面前，他表现出（或尽量表现出）的都是普通人格，就是非常善良的人格。他的第二人格是充满着复仇欲望的，但是“复仇”的定义是对“欺负过主人（主人格）的人”展开报复，所以还算是一个“好人格”。其他所有人都以为只是普通的爆发、耐受力弱（他们甚至以此来取笑他或者规劝他），或者精神不稳定，但是他亲自和我说了他们“不是同一个人”，而且只有我一个人知道真实的情况。我的观察也得出这个结论，两个人格从认知水平到语音语调到感官感知，都有着明显的不同。他总是想压抑住第二人格，认为他是疯子、是恶魔，于是第二人格也在不断反抗（虽然第二人格一直尊崇主人格为“主人”，但是还是很想“出来透气”）。我建议他把他当成朋友，好好谈谈——或许这就是我同时获得两个人格的信任的重要原因吧，我很感激他们。他爆发时伤的人、他的两个人格其实都很痛苦，但是其他所有人都认为只有第一个才受到了伤害。其实，压抑着第二人格的他，和被“关在笼子里”的第二人格，何尝不痛苦呢？要提尊重人，请同时尊重他们所有人。 River 就像这个男孩子，她在普通人看来是特殊得有点令人厌烦的，可是有谁去进入过她的内心世界呢？如果碰到她，请珍惜、保护她。 4、Isabell（伊莎贝尔）Isabell 是 River 的妹妹，同样患有艾斯伯格综合征，只不过在早年被诊断出来之后学会了“像一个正常人一样”活动。因此她后来也对 Johnny 说过，她这么活，活得很累。这就像一颗有瑕疵的蓝宝石，想把瑕疵去除掉，却也损伤了自己。她和 River 相比，就像被强迫飞行的小鸟和笼中的小鸟，压抑自己和无法表达自己，都有深深的遗憾。 5、Nicolas（尼古拉斯）作为 Johnny 的死党，Nicolas 像 Isabell 一直伴随他。（后来是不是在 Johnny 建房子的时候就已经去世了？那时只剩下 Isabell 了。）从鼓励他追 River，到娶 Isabell 为妻就为了让 Johnny 知道 River 也可以像她妹妹一样变得“正常”，他也是一个对 Johnny 的生命线影响很大的人。新的记忆中 Nicolas 依然那么重要，至少他和 Joey 填补了 River 离开之后的空白。 6、Lily, Tommy &amp; Sarah（莉莉、汤米和莎拉）Lily 是照顾 Johnny 的人（原文caretaker直译为“保姆”，但想想都觉得奇怪），Tommy和 Sarah 是她的孩子。他们最大的乐趣是到处跑，以及——弹钢琴，而且居然为此要抢位置。Lily 是尽职尽责的。 7、Doctor（酱油医生）呃……这个嘛，这个医生就是打酱油的…… 游戏流程充满真情，也有恶搞和惊吓。这就是老美，如果是小日本那就是各种乱X与不合逻辑。 恶搞么，看看 Dr. Watts 和 Dr. Rosalene 各种劝主角去月球（在他们不知道原因之前）就知道了，各种无厘头方法都用上了。另外作为一款伪RPG（是用 RPG Maker XP 做的），里面居然还有伪战斗情节（和一只松鼠的，没有实际打起来），但是那突如其来的战斗配乐和出招表倒是令我吃惊不小。 在 Dr. Rosalene 宣称要“去除 River 这个因素”的时候，我真的被吓着了。这个女人居然为了强制遵守合同而消灭 River（因为只有 River 不在了，Johnny 才会想起小时候的约定，去月球，从而达成原来的愿望，也使得两个博士履行合同条款），而且剥夺了 Dr. Watts 的控制权！到后来，不仅设下重重机关，还植入僵尸去阻止 Dr. Watts 拯救 River，即使 Dr. Watts 都说了“我们都知道了 Johnny 不去月球比去月球好”。这时候，阴森的音乐、激烈的剧情变化和环境变化，让我吓了一跳，全神贯注地操作 Dr. Watts 去找寻 River（毕竟我还是玩多了FPS游戏，这点快速反应还是有的），念叨着“River 你不能死”。到后来，发现是虚惊一场，Dr. Rosalene 实际上只是让一些“记忆人”把 River 带到其他的地方从而实现对 Johnny 记忆轨迹的修改，我才舒了口气。 真情这一点就不用多说了，不过需要你全心地投入这个游戏的故事中（我是一口气玩下来的）。在 River 消失之后，伴随着《Everything’s All Right》（即使当时我没有把歌词听全，知道全部歌词之后我更感动了），曾经熟悉的一切，有 River 参与的一切，都被 Joey 和 Nicolas 所取代，甚至被无名氏取代，虽然他们活出了与现实不一样的人生轨迹。愿望就要达成了，但这是幸福吗？我想到这个，痛痛快快地哭了一场。可是——出现了转机，现实中的爱情的力量让 River 回到了 Johnny 身边，而且这次是完美的幸福。喜极而泣。 最后，飞船在 Anya 的远处升空，带着 Johnny 和 River。明月在舷窗显露之际，心脏进行最后的搏动。River 伸出手，Johnny 握住了她的手，黑暗。 我觉得自己有轻微的社交障碍与强迫症（过度遵循规律）。虽然这让我得以摆脱污浊并看清真实，让我得以用写出的程序来表达自己内心的一些诉求，但是我总觉得和人们有隔阂，因为我会从他们行为的细节里看出许多东西。也许我只是过于敏感了。我也许也是一颗星星，我有时候会想。我可以写出这篇日志，不过我不会说出来，面子问题吧。 我有点希望自己也像 Johnny 那样找到一个像 River 一样“特殊”的人。我有些私心，因为我像 Johnny 一样，爱她的特殊，也爱她，只不过我会知道她为什么特殊。我希望能尽自己的力量，保护她，少让一个人受到伤害，因为至少还有我理解。我也知道这很累，我和那男孩子只谈了4个小时，就感觉精力几乎耗尽。我希望我和她也像 Johnny 和 River 一样，可以从小开始，相伴一生。不过现在看起来不大可能了，小时候的人都不知道去哪里了，或者已经落入大染缸而不再纯净。我也在等待，她的出现。 ——你明年还会来吗？ ——会的。 ——同一个时间，同一个地点？ ——同一个时间，同一个地点。 ——如果你忘记了我们的约定，或者走丢了，怎么办？ ——那我们就在月亮上见，好吗？ ——好！ 我们月亮上见。 最后来一个福利：网上找到的某蛋疼图片……一个好游戏瞬间就被黑成BL向了…… = =b （画中的是 Johnny 和 Nicolas，这对好基友）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"随便写写","slug":"zh/2013-07-09-Chip-Chap","date":"2013-07-09T05:21:00.000Z","updated":"2020-03-30T22:34:35.385Z","comments":true,"path":"categories/Misc/Records/zh/2013-07-09-Chip-Chap/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-07-09-Chip-Chap/","excerpt":"","text":"1、大前天才发现，C#居然支持指针（托管指针，在 unsafe 语句块中）！我之前一直认为符合 CLS 的都应该不再有指针了（C++/CLI 除外，其特性决定了指针是无法丢掉的）。有了指针，反编译 .NET 程序集更难，毕竟 C++/CLI 自然指针和托管指针混杂。 2、重看《鸭子侦探》，在《吉他难求》一集中，最后那鸭子被坏鸭撞倒在地上（于是坏鸭被抓住了），然后就像吃了某钙片一样——背不疼了瞌睡消失了等等等等。看来某药厂在十几年前就做好了宣传工作……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"The Stanley Parable","slug":"zh/2013-06-17-The-Stanley-Parable","date":"2013-06-17T14:45:00.000Z","updated":"2020-03-30T22:34:35.385Z","comments":true,"path":"categories/Misc/Records/zh/2013-06-17-The-Stanley-Parable/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-06-17-The-Stanley-Parable/","excerpt":"","text":"The Stanley Parable (http://www.moddb.com/mods/the-stanley-parable/) 在人格分析上有很大的价值！将来有时间我要为此写一篇文章。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"我的高考","slug":"zh/2013-06-09-My-College-Entrance-Examination","date":"2013-06-08T17:31:00.000Z","updated":"2020-03-30T22:34:35.385Z","comments":true,"path":"categories/Misc/Records/zh/2013-06-09-My-College-Entrance-Examination/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-06-09-My-College-Entrance-Examination/","excerpt":"","text":"今天突然想到，快高考了。作为已经在大学的学生，我看着下一届的学弟学妹们走上征途，感觉十分欣慰。不是幸灾乐祸，我只是很高兴又有人要经历磨砺，提高思想觉悟（嗯嗯，不是C2P的所谓“觉悟”哦）了。所以在此，我想把自己高考的经历写出来，以飨读者。 （题外话1：傲游哈哈中，什么叫做“还有100天大二的学姐就要打折了”？“小学妹上架”就算了，“学姐打折”是什么意思？！） （题外话2：@天秤的黑巧克力，感谢你在这一年问了我这么多问题。我自我感觉在纯学习这一块，我就是一渣渣，可能没帮上什么忙，这一点我很抱歉，不知道有没有耽误你什么。从下面可以看到，我脑子里飞的是各种各样的想法，而不是公式和题目解答，所以如果你未来进行纯粹为了心中所想去做的创新工作的话，或许我的建议更有益一些。加油哦~） 话说我原来是奥班化学组的，我们和其他班级不一样之处在于我们多一条路，那就是竞赛——我们班主要是被培训为竞赛精英的，而不像其他班（包括创新班）是“业余”搞竞赛的。应该说我对竞赛并不认真吧，所以在高二第一次参加全国高中化学联赛时我的知识积累并不好，运用得更不好，所以最后也只是省二而已（犀利哥高二就省一了）。也就是说，如果要通过竞赛保送（直接/保送生考试，或者有20分加分都好）这条路去好（中国）大学的话，必须要拼高三。高二，考完了水平考试之后，其余的科目也只是普通的期末考。暑假，我和一些同学去某坑钱培训班，预定8月2日晚上回来；而高三提前一个月上课，就是说8月1日已经开课了。于是，我的高三就在仓促之中开始了。 按理来说，高三的学子们最关心的应该是高考，但我们化学组的不是，因为9月中旬是联赛的初赛，我们还要拼这一次，才可以去准备高考（如果失败的话）。这一个多月，我们的化学课都是拉出去（就是到实验楼我们上课的地方啦）训练的，还顺便观摩了新一届高一和初一的军训。这段时间我还是没做什么，该做的题做一点（有些甚至几乎没做），额外的好像也没做什么，不同于一些很努力的、每天找各种初赛卷子做的组员们。其实，我也想不起来在空余的时间里我做了什么，很可能就是对着题发呆，也不问人。总之最后，我又是一个省二。 我相信，一分耕耘一分收获。但是我也感到命运对一些人还是不公平，或者是他们的命不好吧。这一次得一等奖的是林雁戈、吴广成和佘晓健，而刘佳和黄山应该是只差了一两分就可以了的。我不知道也不想知道我得分如何，说实话我也不喜欢这个竞赛。成绩公布的那一天，我们在我们上课的教室里谈论大家可能如何。这时钟老师进来了，一脸严肃——或者只是他的表情一贯如此——地告诉我们只有那三个人。黄山倒是不着急，他的底子很厚实，高考对他不是问题；苍思骏一向对竞赛都保持批判的态度，所以很平静；刘雨熙表现出略有失落的无所谓；梁颖怡情绪激动（按照她的性格，原本应该立即破口大骂），也显得“五内摧伤”；刘润菁没说话，但很明显不开心；吕源堃和刘佳这两个投入了很多、期望也很高（几乎将它当成唯一的路）的，当场就崩溃了（后者还被TDW劝了好久才不哭了）；我早就料到了这个结果，不过心里也不好受——但其实有什么呢，我又没付出什么。总之，整间房间充溢着悲伤的气氛，除了5.5个人（我算半个吧）。这个情景我太难忘记了，所以在这里要专门将其记录下来。（林雁戈和吴广成当时去问钟老师高二的考得如何，得知高二也有一个人得一等奖。佘晓健和黄山打闹，“佘贤湖”和“黄稣”叫个不停。至于龙宇驰，忽略就可以了，肯定跑到小卖部买可乐然后闲逛去了，他的智力一向如此。） 好了说了这么多，也只是说到九月份。九月份，我们回去（化学初赛结束）之前，刚刚考完第一次月考。所以我们化学组实际上是没有经历这次月考的。相关的卷子什么的，都只是拿回去看看而已。那么，九月到一月，这个时候我在干什么呢？ 第一，进行换同桌实验。具体的过程，请见日志《新的同桌》（http://hi.baidu.com/micstudio/item/ee2a493b638929c3382ffa6c）。总的来说，这次实验是一个失败，最重要的是，我和女同学的近距离交谈的技术并没有提升，到现在还是小学时的老样子。 第二，准备自主招生考试。当时我对高考并没有完全的信心，因为我的数学是一个绝对的弱项，所以我不敢保证哪天我就被数学拖后腿了。所以我需要找一种补偿的方法，而此时我已经不存在保送生考试或者加分的可能了，那么，剩下的就是自主招生考试了。虽说成功的概率也不大，但是还是大于零的，所以还是要试试。所以，我就开始看“高级”的物理和数学（因为当时我想，语文英语之类的，都是文科，临场发挥的成分很大，是无法用技巧取胜的，所以没有必要看；化学是老本行，也不用看）。可以说，这些还是有点用的，毕竟到了大学，才明白里面的一些道理（当然，物理组请忽略我的这番言论）。 第三就是各种常规的学习任务了。月考二、月考三，我略有进步；其中月考三到了年级前80——是的，对于优秀的学生来说这不算什么，但是我已经感到吃力了，因为我不是设计用来做这些的。（顺便说一下其他的数据，月考二是年级150左右，后来的一模和三模都是这样。）到了市统测的时候，数学考砸了，因为各种问题（具体是什么我忘了），才96，仅次于龙宇驰的低分，这是一个耻辱（也成为了陈润方和林雁戈在宿舍取笑我的一次事件）。一向是强项的英语，这次因为从完形填空的第一道题开始涂错了，后面的整体顺序向前移动了五位，所以也才70出头。（总分150。这次惨败让我震惊了，因此之后涂答题卡的时候我都会每5题检查一次题号以防出错。）至于四校联考，水平发挥一般，不好不坏，华附校内排名160左右。总之，在这个时候我实际上考试成绩就是这样不上不下的，而不像外人所想象的那样，奥班的家伙都是前100（所以我每次听我们班谁谁又进前50都不舒服）。宋老师这个时候还是对我有信心的，特别是月考三之后他觉得我可以向前50发起冲击，因为我只是“不认真”。我一直没有达到宋老师的期望，也许我就像贾宝玉一样不习惯“混账话”吧。常规的学习，我一直就没法让它进入心中，或者说像余欣彤那样全心全意（这个不准确，她当时还在忙物理竞赛的事情，但是后来得了一等奖之后仍然应该称为“全心全意”）地去看啊背啊算啊什么的。在我看来，这一阶段每天都是一样的，每次考试都是一样的，学来学去都是一样的东西——所谓“加深记忆”。 虽然学习是一成不变的，但是生活还是充满了光彩的。每天吃饭（午饭、晚饭）之后我都会去打三国杀。从这项游戏中可以看出，我的领悟力还是不算高的，经常被指出不合理的出牌。我们的宿舍生活除了三国杀就是相互拌嘴或者讨论，我记不起细节了，就像沙滩上的沙子，每一颗都是独特的，也是普通的。这时针对我的人身攻击也少了，毕竟在宿舍住了一年多，大家都熟悉了，有时通过嘲讽来回忆一下旧时光，也没什么。 一月了，放寒假了。在十二月的时候我已经为自主招生准备好了一切。我选择的是北约，最终压线获得港大和北航的面试资格。（考试结束之后基本上如我所料，但是物理居然考书上的原题我没想到——上考场之后把什么都忘，这玩意儿居然也是背书！）看来我的竞争力还是比较小，被港大的面试刷下来了。我本来是准备按网上所说的，取得对话主动权，但是实际操作和理论还是有差距的，我反而显得不那么出色了。至于港大的剑桥计划，只能说我没学高数，基础不好没注意到0到π/2上cos(x)和sin(x)的积分值相等，最后就是没声息了。北航的面试简单一些，五个人一组，让这五个人回答一个问题。我记得其中有个人的问题的一个小问是“‘航天之父’是谁”，那家伙居然说“杨利伟”！我抽到的题目是预测苹果未来的发展，这正是我擅长的，还在其中穿插了“自然人”和“社会人”的理论，我认为是这个给我加了分。面试前一天我来到北京，离开之前还吃了一顿烤鸭……回到家已经是星期一凌晨（星期日面试），第二天还得充满精神地去上课。 回来的时候下半学期已经开始了。下半学期最重要的就是三次模拟考试了。复习的过程依然枯燥，直到一模——我们被告知，一模是全市的模拟考试，也就是说一模可以反映你在市里的水平。而且，一模的难度是最接近于高考的难度的，略难。（毕竟，二模和三模都是学校内部的考试，是老师根据自己的经验出的题，总不能与市教委的相比。）一模，也只是一次考试，或许我已经麻木了吧。至于二模，那所谓的“安慰性”的考试，我也并不觉得有多少安慰，因为数学又惨烈了，108（好像是）。所以可以说，至此宋老师真的是对我灰心了，要求从原来的进前50和数学135+降低到了120左右不拖后腿就行了。但是到现在，我连120的信心都没有了，因为每张卷子都显得不一样（不知道其他同学怎么发现它们之间的共同点的，虽然我大概可以看出知识点，或者说，我没有很透彻地理解知识），而且经常会出现莫明其妙的错误（特别是计算错误，即使是通过标记关键字也没法完全消除）。其他的也是“恒定”的，好的还是好，坏的一直坏。语文也是弱势之一，因为在古诗鉴赏和阅读鉴赏（说的是“鉴赏”其实就是按模式答题）我完全不能接受那些“解题思路”，那些“得分点”。他们的基于“通过什么表达了什么”而高于其的那种模式，我无论是用理性还是感性都不得其要领。不过，生物还是略有进步的，最后可以每次到85+了（而不是月考一之后刚回来的周测的55）。 一般来说，一模是对前面所复习知识的一次总体检验，这次复习是“理顺”性质的。二模之前是“二次理顺”附带提高（生物老师最爱用的词是“查缺补漏”，而不是“查漏补缺”XD）；三模则是冲刺，不再有复习的功能——到这个时候了，基本上定型了，怎么再塑造呢？ 三模。三模的时候我已经不再担心什么，都已经大概知道自己的水平了。此时大考、模拟考之类的已经没有什么区别，唯一新鲜的东西就是大家都很清楚，这是最后一次校内的考试了。考完试后，老师们都进行“临终嘱咐”，有些老师提一下重要的知识点（如生物和化学）再说再见，有些就只是说“祝大家考好”之类的话；但是不管是哪一种，都让人有吃长休饭喝永别酒的感觉。我也说不清那是一种怎样的感情，老师们看着自己新一届的学生们上战场，为学校、为父母、为他们、为自己争光（不管是利益驱动的还是人性驱动的），却有些舍不得，即使之前教过许多届的学生，这些和那些并没有本质上的区别。这种情感很难形容，至少我的表达能力还不过关，但是我可以体会到。毕竟，人人都喜聚不喜散，三年（或者两年）的缘分，今朝分别…… 至于高考百日誓师，我们早就经历了。某个下午我们站在操场上，然后宣誓。细节我大多都忘却了。在我们高二的时候，在自习周，高三那一层是空的（全体学生搬到实验楼里自习去了）。当最后一个星期五，我们做太极拳的时候，我看见许许多多的前辈们，从实验楼里探出头，甚至上了实验楼顶层，拿手机拍照或摄像。（星期四的韵律操也是这样。）当我们做完操之后，他们一阵欢呼。我们心里都知道，每个参加过高考的人，都知道。这一眼，哪怕是留下一点点的高中的记忆，快乐的记忆，和许多人，看学弟学妹们在校园中生活的记忆，都是值得的；这一刻不会再来，高考完之后华附就只能成为“母校”，而不再是“学校”了。在我们进入实验楼之后，我们也曾探出头；只不过，我没有带记录设备，我只有看到的、听到的记忆，而没将其存档。太极拳的音乐一停，我们也像前辈们一样，欢呼鼓掌，不仅是为他们，为过去的生活，也是为我们自己。 在上一届学长上战场前几天的一个第三节课课间（我们的第三节课课间是20分钟，用来做操或看校电视台节目），我们在某一些人（似乎是余欣彤和李越，忘了）的组织下，上了状元桥，对着东教学楼（高三所在楼），高呼“附中必胜”（或者与此类似的口号）。当时下面，不仅是状元桥，聚清园也堆积着人。高三的楼层也是，许多人探头来看。到我们临走的时候，也收到了同样的祝福。 我的家离学校（我们学校是一个考场）很近，但是为了限制我的计算机使用我还是得住宿——不过住宿的经历也很有趣。在大家完全自由的时候（大概是3日，我不记得了），2302、2303的人曾经问我：“你在考试那几天是在家里还是在宿舍？”这个问题很难回答，我很想自在地过两天——我还是有点不喜欢在宿舍，原因归结起来还是我水平不够，感觉在一群做题总做对的同学面前抬不起头。于是我迟疑了，但是最后还是说我想在家里呆着。我记得，当时我还说如果在考试结束之后对答案怎么办，他们一致同意谁对答案就枪毙五分钟；但是我最后还是没留下来。我不知道最后那几天，和考试的那两天，他们在宿舍里是怎么过的，晚上睡觉的时候有没有讨论题目（不过RF一向是很遵守诺言的），保送生和非保送生在同一间屋子里各自的心情如何，莫深秋和刘雨熙有没有继续抽风，吕源堃是不是还处于神经质状态，黄山是不是依然挨个宿舍串人。我不知道，但现在我特别想知道。我想知道，如果我当时留在那里，而不是向私心屈服，那我高中和他们最后的日子会不会更好——我似乎只能用“好”这个字，找不到其他的描述了——或许用“记忆深刻”？不过略显中性了。我一直后悔我没有在最后的时间里陪伴他们，即使是作为渣渣被虐（当然，所谓虐都不具有敌意，而且也不经常发生）。 那一天终于到了。我记得《华附欢迎你》的歌词中，有“华附欢迎你，空调的温度特别低；高考有校服做战衣”这么一句。那一天，我们所有人都穿上了校服（顶着背后那花体“HUA SHI FU ZHONG”）。我们按每个班排好队，在实验楼大厅集合。然后，按照班级顺序一个个班走过状元桥。我记得当时我们班没有一个具体的领队，大家说走就走了，到了桥上大家大喊“高三一班，李越无敌”（我们班特有的口号，详情请见日志《华附高三(1)班众人小传》），李越又在装无知。大家笑着走过，似乎即将来临的考试只是一次小测验而不是决定人生走向的路口；或者，大家心里都知道，自己已经十拿九稳，不会错过这次机会，所以不会有任何忧伤。我当时喊了之后想流泪，为了进入考场之前的最后一次情感爆发。我们欢笑着过去，在其他一些小学校来考试的学生惊讶或者感动的目光中。在状元桥之前，老师们也来送别，每位老师都祝愿大家正常或超常发挥，面带微笑地。我们过去之后，其他班也过状元桥，但口号无非是“某班必胜”之类的，没有我们这样在诙谐中带着力量。每过一个班，喊一次口号，就响起一片掌声，在场的所有人的掌声。这时，不论是哪里的学生，哪个班的学生，已经不认为其他人是对手，而是衷心地希望所有人都能鲤鱼跃龙门。——惺惺相惜。这样的情感，没有勾心斗角的情感，只有经历了高考的人才会体会到。（龙宇驰？离队了。）喊了之后，大家在教学楼（东西南）下交谈，正如上战场之前相互鼓励一般。等到楼梯的封锁解除，大家就纷纷上楼就坐。此时我觉得，一切都回到了从前，回到了中考，回到了奥考，回到了各种竞赛。这种déjà vu，让我不再恐惧，即使知道自己就是和班里的人比也会败下阵来；我知道，这里是我生活了6年的地方，它给予我力量，我不再害怕，为了这6年我会绽放。 考试。4个科目（语文、数学、英语、理综；文科三科已经在高二的学业水平考试中考过了），2天。每一场结束之后我都觉得，只是又一次模拟考；到现在，我除了细心放心之外，还能做什么呢？小学数学老师（刘虹老师）曾经教导过，“我易人易，我不大意；我难人难，我不畏难”。横刀立马，进击劲敌。其实，准备了十个月，最后的一次考试，反而并没有什么特别的，除了这次的卷子是绝密而且结果出来之前是秘密以外。有人会爆发，有人会失足，那只是特殊现象，报纸将他们的事迹夸大了一些而已，大部分人是什么还是什么。卷子本身是索然无味的。话说华附空调的威力还真不错，“战衣”发挥作用了。 考试结束了。在这一刻，所有人都知道，命运已定。我们回到宿舍开始收东西。照常地进行期末清扫。已经三个期末做这件事了，这一次不一样，是最后一次。（我们没机会在木床上度过夜晚了……下一届的家伙们……）这次没有抽签，每个人想做什么就做什么，最后一刻了，没人会留下不好的痕迹。我还是留到了最后，算是对之前没在这里的补偿吧。 离别的那天我一早就醒了，只不过躺在床上没睁眼。我听见每个起来的人，都轻轻地将行李收拾好，轻轻地推开门，轻轻地走了，没有人说再见。就这样，一个一个。最后只剩下我和另一个室友。他没说话，看了我一眼，提着行李默默地离开了。我将房间打扫干净，走出门，将门锁上。那一刻，我的眼泪不禁流了下来。四年的时光，大家最后就是这么分开的…… 与此相似，我们走的时候，大多数人都是不打招呼的，打扫完自己的那一份，提着包，走了。当我每过十分钟看看三个寝室还有谁的时候，人总是在不断地消失。我不知道其他人是怎么想，我倒是属于感性一些的，对这种不告而别的行为还不大能接受。虽说我们班最终也不过集中到不超过8所大学，还多处于北京合肥浙江上海广州（中大的另一个校区其实在珠海）香港，但是我期待的拥抱之类的情感丰富一些的一直没发生，没人去做；知道大家不会相距很远也不至于这样吧！总之，最后我最后离开的时候我心里也不是滋味，我不愿意离开6年的所在；这一去就不会回头的呀！（我应该不会像Rose 梦回Titanic 那样回到这里吧……）我记得离开的时候是和林雁戈一起下楼，帮他拿行李，最后还是分开了——见到的最后一个同班同学。 最后无非是等分数出来，填报志愿而已。当时我还在北航、北理工和北邮之间犹豫了一下，最后选择的是北航。（劝告想投身于创意产业的人千万不要来，这里除了媒体专业，其他系会坑杀创新人才的，即使是所谓“工业设计”。）等到录取通知书到达的时候，一切就定了，该进入大学的轨道了。 附记： 1、我记得新闻上说有些考生考试结束之后十分激动，会把高中的教科书撕了，说是挣脱了高考的桎梏。撕书什么的，我没做过，我所有的教科书都保存在家里。至于“桎梏”，进入了错误的大学或者错误的专业更是桎梏，即使是一些“好专业”也是；以后的某些渣滓出风头的“竞赛”，更是。 2、关于选专业，黄秉刚老师启发了我。他说：“选择专业不一定要自己兴趣所在的。兴趣这事，你不去关注它，你自己也会去主动学。所以，（在专业阶段）还不如选一个接近自己兴趣的专业，学习一下，这样不仅多掌握了一项技能，还和你的兴趣有关。”我“沉迷于”计算机技术，因此他劝我不要选择计算机系，选择一个接近的，这样就不会在计算机这一个坑里淹死，至少可以留条活路。所以我现在选择的是机械工程——哎，我在想我为什么不选择创新类的专业，机械工程与我之前所认为的“机械结构理论”太不一样了，简直是让人脑子里都长出机械零件来…… 3、附中的生活，还有早操啊，冬季长跑啊，等等。这些，以后有时间我在记叙吧。 （5月22日开始写，6月9日完工。）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"技术宅的爱情：Lonely Lullaby","slug":"zh/2013-04-21-Lonely-Lullaby","date":"2013-04-21T05:37:00.000Z","updated":"2020-03-30T22:34:35.384Z","comments":true,"path":"categories/Misc/Records/zh/2013-04-21-Lonely-Lullaby/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-04-21-Lonely-Lullaby/","excerpt":"","text":"在最近的一次音乐搜索中，我找到了 Owl City 的 Lonely Lullaby。（天啊，居然是在2011年发行的，我居然不知道，还在等着 Adam 出更有趣的音乐呢！） 先附上歌词：（致英语不好的人：嗯……我不翻译了，反正不难懂。） Symphony of silver tearsSing to me and sooth the ring in my earsOvercast these gloomy nights wear onBut I’m holding fast‘Cause it’s darkest just before the dawn I sang my princess fast asleep‘Cause she was my dream come trueOh Annmarie, believe me, I loved you But now those lonely lullabiesJust dampen my tired eyesBecause I can’t forget you Because I can’t forget you I’ll dissolve when the rain pours inWhen the nightmares take meI will scream with the howling wind‘Cause it’s a bitter world and I’d rather dream Dizzy love turned a star lily pinkAnd hung above our lids too flushed to blinkBut icy blue froze the fairytale coldThough I treasured youAnd you sparkled with someone to hold I sang my princess fast asleep‘Cause she was my dream come trueOh Annmarie, believe me, I loved you But now those lonely lullabiesJust dampen my tired eyesBecause I can’t forget you Because I can’t forget you I’ll dissolve when the rain pours inWhen the nightmares take meI will scream with the howling wind‘Cause it’s a bitter world and I’d rather dream I’ll dissolve when the rain pours inWhen the nightmares take meI will scream with the howling wind‘Cause it’s a bitter world and I’d rather dream And I’d rather dream Annmarie, I’ll never forget youAnnmarie, I’ll never forget youAnnmarie, remember me?I’ll never forget youAnnmarie, remember me?I’ll never forget youAnnmarie, remember me?I’ll never forget you 这首歌——怎么说呢，洋溢着情感。需要知道的是，曲子中的“Ann Marie”是 Adam 的前女友。 看看 Adam 自己是怎么说的吧：（来源：http://fuckyeahowlcity.tumblr.com/post/7627610103/adam-young-opens-up-about-ann-marie，地址名称有点奇怪对么？） Ann Marie was, and certainly still is, such a beautiful person to me, and I’d never written such a personal song before, I knew I had to include her name in the lyrics because the song is truly what I wish I could say to her now that’s she’s gone. A lot of my songs are written purely from the imagination and some have no representation of my personal life, but “Lonely Lullaby” was the first song I wrote almost ENTIRELY about something as personal as a romantic relationship. Ann had blue eyes, her favorite flowers were pink star-lilies, and I used to literally sing her to sleep over the phone while she was home and I was on tour. The song is in fact so personal, it almost hurts to listen to it now that such a perfect relationship has come to an end. I wasn’t sure if I had something as “genuine and pure” inside of me but the song basically wrote itself and I’m proud of it. 没错，我觉得这是 Adam 写的最个人化的歌曲。之前，他的歌里洋溢着欢乐和动感。但是，这首歌完全不一样！按照我的话说，就是“情感波动幅度大”，而且显得很深沉，充满着爱意。嗯……我在想，Breanne Duren（Breanne Elizabeth Dürenberger）唱这首歌的时候不觉得什么么……即使作为 Adam 的好友（而不是女友XD）？最后那几句“Ann Marie, remember me”和“You”，就俩……不知道她总是唱别人的名字时在想什么。 言归正传。第一次听到这首歌（只是在专辑歌曲列表中试听）的时候，就被“I sang my princess fast asleep, ‘cause she was my dream come true”给震撼了。可能是歌词和曲调配合地太好了吧，我听到这一句的时候心中真是五味杂陈——毕竟有经历才会产生共鸣——这一句，Adam 唱得很平静，至少在全曲中显得相对平静，但是背后的滋味呢？然后，Adam 轻轻地呐喊（是的）：“Oh, Ann Marie, believe me, I loved you”，心声表露无遗。印证了前文：it’s darkest just before the dawn，为什么你就在这个时候放手了呢？可惜啊，Adam，你也没有料到这个，对吗？其他的一些，涉及到个人隐私，我也就不在此写出了。 接下来，只好唱着孤独的摇篮曲（在孤独中入睡），眼眶被泪水浸湿，因为就是无法释怀。昨日的欢乐和今日的孤单相映衬，显得 Adam 无奈而无力，虽然心中还是保持着那份期待，那份美好。从前给她哼的歌，现在只有自己听；这不但没能使他入睡，反倒让他更纠结了。我有时在被子里哭泣，其实我也不对谁，我也不怪谁，只是对自己的经历发感慨。我所追求的、我所找到的，曾经闪耀，而如今也离我远去。就像焰火的绽放和消逝，酝酿是漫长的，消逝之后就是永恒，只有绽放的那一刻才焕发光彩，但也只有那一刻。我也不知道未来如何。各种科学、技术，在头脑中盘旋，尝试着去分析、去解决，却也无法消解这份哀伤。但是我有什么办法呢？ 在雨中，在风中，心与环境已经融为一体。噩梦将我掠去，世界充满了悲伤（bitter，意思一下吧）。就像某篇微小说里说的，“只有在雨中，你才不会看到我流下眼泪”。同样地，在呼啸的风中呼喊，才不会让你发现我声音中的尝试这将这份心情留在风中，留在雨中，希望风雨可以将其带走，但还是没法忘却，它们已经深深地烙在脑海中。 从前，眩晕的爱情让 Star-lily 成了粉红色的（意即，Adam 觉得，因为他和 Ann 之间的爱情，他才会格外注意粉红色的 Star-lily。Adam 说 Ann 最喜欢的花是粉红色的 Star-lily，我不知道这是什么，估计是百合的一种吧），Adam 和 Ann 四目相对（还俏皮地眨眼 = =）；但是现在这个美好的童话冻结在冰蓝（就像那冰盖，古老的冰是淡蓝色的，很漂亮）之中。尽管 Adam 希望她停留在他手上，但是她还是像流星一般划过。曾经想过为一个人付出一生，但总是失望而归。一次又一次的伤害是会使人麻木的，所以才会出现负心人——一开始谁不是怀着真切的心呵护着对方呢？ 最后，五个“Ann Marie, I’ll never forget you”，让整首歌结束在低语中，其间穿插着“Remember me”这个问句。这个低语，不是呢喃，而是在分手之后对自己立下的誓言。Adam 似乎还沉浸在美好之中，絮絮念叨：“我不会忘了你的，我不会……”经历过恋爱的人都知道，如果是对方主动离开，那自己总是希望对方可以回头，此时一切都可以重来，就像没发生过什么一样。记住我吧，记住我吧。每一个为对方着想的人，心中总是希望对方会过得好；自己曾经出现在ta的生命中，对方是否记得自己已经不再重要。有一点点私心，还是愿意对方记得自己吧。或许某天在街上碰见，两人还能相视而笑，这就是圆满了吧。 谁又能将这个诺言贯彻一生呢？总有人可以的。祝 Adam 和 Ann 幸福！ 有人摆蜡烛，有人唱情歌——太俗了，是人都会。要是哪一天我碰见送手链的那位，我一定要对他眨眨眼：“有创意，有感情！”或者，一首完全自制的、优美的歌曲，或者，一段令人惊喜的代码——这便是技术宅的爱情。 Adam 做出了一个范例呢。 嗯……播放列表中下一首歌是 Long Long Way to Go 诶……以前在 K 的阶段我也在晚上一边听一边流泪呢……（我还记得嘉伟播这一首歌时说的话：在 HitFM 7周年之际，希望 HitFM 越走越好，毕竟前路漫漫啊。但是现在呢？已经不再是记忆中的 HitFM 了……）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"关于 Visual Studio 2010 SP1 的“此计算机状态不支持安装”","slug":"zh/2013-04-21-Visual-Studio-2010-SP1-Error","date":"2013-04-21T04:19:00.000Z","updated":"2020-03-30T22:34:35.385Z","comments":true,"path":"categories/Misc/Records/zh/2013-04-21-Visual-Studio-2010-SP1-Error/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-04-21-Visual-Studio-2010-SP1-Error/","excerpt":"","text":"这几天为了社团的一个项目，需要用到 XNA，我的首选语言自然是 VB .NET 啦。（附注：我用的是 VS 2012，而且修改了 XNA Game Studio 的 extesion.vsixmanifest 让 XGS 支持 VS 2012。文件在 $(VSDir)\\Common7\\IDE\\Extensions\\Microsoft\\XNA Game Studio 4.0 下。） 我先用 XNA（版本 4.0），默认不支持 VB .NET 的。于是费了好大劲从 C# 那边搬来 Content Project，未果，没有生效。大不了用 C# 呗，但是居然运行时出现“找不到支持 XNA Framework Hi-Def 配置的图形卡”错误，根本没法运行！相比之下，虽然 VB .NET 无法使用 Content Pipeline，但是至少可以通过 Texture2D.FromStream 来实现“默片”啊，还可以正常运行！ 算了算了，只好找 XNA 4.0 Refresh，这个版本添加了对 VB .NET 的支持。但是要命的是，它需要 VS 2010 SP1，而一年前我一个脑残的举动（手动在“程序与功能”里卸载 VS 2010 组件，结果到了一半时蓝屏了）使得 SP1 再也安装不上了（VS 2010 可以），显示“此计算机状态不支持安装”，而且居然没说为什么。我跑到 MSDN 上去问，某 MSFT 成员说把 Collect（Microsoft .NET 性能收集器）的数据给ta，但是最终也没得出什么结果……蛋疼。（嗯嗯……忘记截屏了。）今天再上网，努力搜，找到原因了（虽然我还没看错误报告）。VSTO！VSTO 没卸载干净，所以检查环境的时候就不能通过了。将 HKLM\\SOFTWARE\\Microsoft\\VSTO Designtime Setup\\10.0 下的所有子键删除就行了。安装成功~ 补充：Texture2D.FromStream。 对于不想用 XNA 4.0 Refresh 的苦逼 VB .NET 程序猿们，如果只涉及到图像的移动等等等等，可以使用 Texture2D.FromStream。方法是 Texture2D.FromStream(GraphicDevice, (New IO.StreamReader(FileName$)).BaseStream)。（简写了哈，只是表明调用结构。）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"邂逅","slug":"zh/2013-03-23-An-Encounter","date":"2013-03-23T03:57:00.000Z","updated":"2020-03-30T22:34:35.384Z","comments":true,"path":"categories/Misc/Records/zh/2013-03-23-An-Encounter/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-03-23-An-Encounter/","excerpt":"","text":"这是一次邂逅吗？我从未预见过，但是也挥之不去。 2月27日还是28日，我记不清楚了。那天，为了冯如杯的项目，我第二次（或第三次）去电子城买零件准备制作电路板。这一天的一个采购项目是开关（电容短路放电用）。 在二楼靠中间的一个铺位，玻璃柜子上一个（长宽远大于高的）盒子里放着各种开关。我要什么呢？我不清楚，只知道应该起的功能是，常开触点，无锁，要放在 2.54 mm 标准万能板上；长什么样子，不知道。（而且，各种开关和以前在书本上、电子积木或者学校的实验中看到的都不一样，有些甚至是四个脚而明显不是多刀多掷——最合理的猜测是，按下的时候四个触点之间会等电位，不过我居然没进行猜测。）所以我站着，用眼睛扫描各种开关，期望着可以凭直觉发现一个合适的。 这时我听到了一个纤细的声音：“你想要哪一个呢？”抬头一看，是一个长得很文静的一个女孩子，目测17岁到22岁之间；旁边应该是她妈妈的一个人在打电话（似乎在接单），所以没有打理柜台。抬头之后，我的脸刷地就红了（如果按照作文规范，讲求合理性的话，应该是我感觉的脸发烫）——她很好看，从刚才的语音中可以推断出她平时态度也不错——如果用一句流行语，那就是“她是我的菜”（糟糕，很粗野……）。她在看着我，我不敢对视；我知道在这种情形下，如果我看着她的眼睛，我可以读心，但是我自己的想法也会表露得很明显，因为一点防御都没开启，根本没料到有这种事发生。 我：“嗯……我只是需要一个开关……就是常开的，按下去之后才会接通的那种……”由于紧张（对啦！不仅是认为因为无法准确描述所需产品给人家带来麻烦了，就像一楼卖 USB 接线端子的那家伙那样，而且有其他因素 XD），我的声音显得有些轻而无力，停顿也非常长。 “常开的？”她估计没听过这种描述，显然感到和迷惑，在分析我想找的是什么东西。说这句话的时候，她的声音有点像我认识的一个女生……是谁呢？刘亦甦？我记不清了，但是那神情如同西施颦眉。 她只好向她妈妈求援，刚好此时她挂了电话。“我们有没有常开的开关？”“什么叫‘常开的’？”她走过来，“你看一下，这个是不是？你要什么？” “就是……一般不接通的……按下去才通，松手就不通的那种……”接下来她妈妈怎么到旁边的柜子（存货柜）那边去找的，我忘记了。我的描述确实给人家带来了很多麻烦，老板娘在柜子里翻来翻去的（这些小零件都是按包来装的）。 “哎呀，快点啦，人家要的……”她转向她妈妈，有点焦急地说，声音还是细细的。 老板娘找到了一包看起来合适的。“几个？”“五个，五个。”老板娘抓出五个，甩到桌面上。我一看，这些就像电源插头一样（只不过细一些），不是焊到电路板上的那种。 “我要把开关焊到电路板上，这些好像不行的……”（老板娘翻箱倒柜找到这个，听我这句话估计快崩溃了。） “电路板？”她听到了，声音中有点惊喜，应该是想起了什么。她在柜台上的盒子里找出一个开关：“这种是不是？” 她拿起一个，用拇指和食指夹着，手掌朝上，递过来。她的手乍一看是很光滑的，淡淡的粉红色；虽然在这种环境下工作，也不像我的一般粗糙（呵呵，我就是跑来跑去、各种辛劳的伪技工命，不过我也很享受高级创造的乐趣）。不过也只是“乍一看”，因为我没敢细致观察，或者拉住，这样也太没礼貌了吧；而且我还有承诺在身。我也是用拇指和食指，轻轻将她手中的开关夹起来，就是不太想碰到她的手，也许我潜意识中就抗拒这个吧。毕竟古人礼法中讲，一般情况下“男女授受不亲”嘛。（迄今为止，除了和小菲拥抱过一次，我和其他所有女孩子的皮肤接触仅限于手或手臂，而且总时间不超过40秒。）不过由于我的手抖了一下（所以金工实习的焊接部分才86 = =），我们的皮肤还是相碰了，短短的零点几秒，甚至没感受到温度。我触点般地将手向上收了一下，以确保不会再碰到。 这种感觉，就像是初三的经历。我坐在椅子上和其他同学谈笑，手放在课桌上。忽然，手臂上被轻触了两下。轻轻地。冰凉的手指。两下。0.4秒。这种感觉奇怪而舒适，我可以感受到其中的温柔。后来的事，就是我向右上抬头一看，刘亦甦，给一个老师传话让我过去。（另一个和她有关的经历是，初三第一学期期中还是期末考试，按奇偶分列，每一列9个人。我当时是18号，她14号，16号的余立能上厕所未归。第一科发卷的时候，我和她中间隔着一个临时的空位；我忘记是否是故意地，将头埋在手臂中。那一次，她拿卷子捅了捅我的手臂，我抬头，接过来。这是我和她仅有的几次交互，不超过四次吧，之一。后来余立能在发卷的时候一直在座位上，也就再也没有这种事情发生。） 就像那时。 我拿出万能板，将开关往上面插了一下，很合适。“是的，这个可以。” 不过这玩意儿有四个引脚，而不是抽象模型的两个啊！“这里四个引脚，哪两个是通的……”“我也不知道，回去拿万用表测一下不就好了嘛。”我的脸更红了（更烫了），唉，我一堂堂北航学生居然败在一个卖元器件的小女孩手里。 我将原来的开关放到桌面上，拨到一起，准备给钱。她挑出另外四个同类型的开关，从边上的圆柱形容器（类似于装茶叶的那种）里拿出一个小塑胶袋（装元器件的那种，表面平滑，未打开时呈片状的），帮我将这些小家伙装进去。她一边装一边问：“诶，你买这些做什么用呢？”我为了项目的安全性考虑（嗯，就是不想让其他人知道我在做什么东西；如果当时解释一下作用原理，不知道后面会发生什么哩），只是说，我要做一个电子制作。她从我的着装、表面年龄和举止应该看得出我很少来电子城这种地方。“啊，没想到你（们）还有这个兴趣爱好……”她一边说着，一边细心地装好，封口；封口之前，她将一张名片塞进塑胶袋中（自然是店铺的地址、联系方式等等）。我无话，一直低着头，目光钉在其他的元器件上，没有抬头看她的脸；或许，她也低着头吧，如果和我一样害羞的话。:-) “谢谢。”我付钱，双手接过塑胶袋，将其装入包中。在这个时候，我也没敢抬起头，我的脸在发烧。我微笑了吗？很可能，因为已经成为了一种习惯；如果有，也是低着头的，不过我相信如果她向前看的话，她会看见我微笑。 我还是低着头，转山，快步离开了这个店铺，没有说再见。或许那个“谢谢”就已经表达了一切吧，或许的或许她听出来了吧。这一切我无法验证。 后来在买电池的时候我在二楼转圈，看到了她的侧影，不过在她没发现我的时候我已经从另一条路绕过去了，就是不想再次看见她。 我唯一能确定的是，她的年龄看上去和我差不多。她曾经在中学或者是专科读书吗？她是哪里人？她以后会怎么样，读书或者一直就呆在一个一米见方的小铺位，做小本生意？也许她已经有追求者了，而且她在广州，而且她只是一个卖元器件的小女孩，我在北航。我不是鄙视她，更多的是一种同情，油然而生的。人在出生的时候已经是不公平的，有人就是在低下贫贱之家，而有些人就是嘴里含着金钥匙；后天的竞争，只要是与出身有关，那就都是不公平的——几乎所有——如果按普通人的视角来看。我更慨叹的是，她受到的影响已经不可逆转，所谓鲍鱼之肆即是如此；就算是我们怎么怎么的话（概率太小了，忽略），这个认知差太大了，要改变那是非常难的事情，虽然不是不可能。如果她生在一个稍微好一些的家庭（即使接受教育，其行为方式还是不能完全摆脱家庭背景的影响），从一开始就可以从一个好的眼睛中看见世界，那么我和她也许会走到一起——如果。既然如此，我只好选择离开，将这段记忆封存，希望她可以过得更好吧。毕竟，如果她坚守道德，不被这种不公平打败，将这一生过好，下一世会更好的。——因为，没有什么不公平，境由心生，福自我求。 我祝愿她在接下来的生命中焕发光彩，不枉此生，因为她给我带来了一份美好的记忆，这份能量成为了我的一部分。 过去曾是什么，未来会是什么，我都无法预知。我只知道，在我19岁之前，在某地，邂逅了一个女孩，而我们被几乎不可逾越的鸿沟所阻隔。或许将来我们还会相见，或者其他的什么，我不知道。上等的缘分是可遇而不可求的，我也不会去强求，就等待好了；如果它会到来，它总会到来的。 安。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"三月飞雪","slug":"zh/2013-03-23-Snow-Pouring-in-March","date":"2013-03-23T03:55:00.000Z","updated":"2020-03-30T22:34:35.384Z","comments":true,"path":"categories/Misc/Records/zh/2013-03-23-Snow-Pouring-in-March/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-03-23-Snow-Pouring-in-March/","excerpt":"","text":"今天，2013年3月20日，农历二月初九，北京居然下雪了！ 星期一听到新闻说星期二会下雪，还认为那不会怎么样，或者只是小雪或雨夹雪（星期二起床的时候外面就是这样的，盖着灌木的帆布上面有浅浅的白色，路面只剩下湿的痕迹）。 但是星期二晚上，雪下起来了。 九点多，我望向窗外，雪已经下起来了。那是怎么样的一场雪啊！就像去年冬天（第一场雪倒是雨夹雪），雪花从天而降，让人一看就知道，那是狂欢的雨点变成的雪花。再加上北风的吹拂（对，吹拂），雪花向着北边飘去，其间还伴随着上下的“颠簸”。在橘黄色的路灯光的映照下，那些雪花在空中划过的完美曲线都可以看得一清二楚。一片雪花飘到窗前，那真是一小片，晶莹而泛白，轻盈地荡漾着——但是，我一伸手，它就没了，只余下一丝清凉，和一滩再也普通不过的水而已。 雪花飘飘，不久柏油路就盖上了棉被。 第二天，早晨，太阳升起来了。这时的太阳，被朦胧的雪所遮挡，呈现出橘红色，可以用眼睛望着。阳光照在身上，空气不湿也不是很冷，这就是所谓“冬日的暖阳”了，阳光可以把从冰冷中拯救出来。更好看的是那天空，最靠近地平线的地方是乳白色的，向上走40°，乳白色和淡蓝色融合了。那种渐变的效果，我是很难调配出来，只有欣赏的份儿了。 这次还可以感觉到和上学期很大的不同，这次的雪非常厚（后来报道说北京最厚的有20厘米左右，我目测这里是大约15厘米）。一看就知道昨晚刮北风——一些路灯柱子或树干上，南边覆盖上了一层冰花，而北边则是秃头。这雪不仅厚，还很温柔，和风一样。树干上真的落满了雪，整根树枝都是白色的，像洒满了白糖一样，长胖了；但是这雪很完好地附着在树枝上面，就像穿上了棉衣，贴身的棉袄，一切。而这雪很忠实地反映了物体的形状——树枝，灌木丛，自行车，甚至（食堂二楼露台上的）卫星天线，尽显其柔美的特性。如果昨晚风凌厉一些，想必雪就都散了吧。 下楼的时候，又见到那些纯白的、可爱的雪了，就在没人践踏的地方，安静地躺着。就像见到久违的朋友，我对她会心一笑。 自然，我们又打雪仗了，这次的“库存”非常充足哟。 中午的时候出太阳了。我原本以为这中午的太阳会将雪摧残殆尽，不过令我没想到的是，下午还有一些雪在，有些表面还是白色的。 但是，为什么三月份（农历二月初九）还下雪呢？不知道。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"小品","slug":"小品","permalink":"https://blog.mottomo.moe/tags/%E5%B0%8F%E5%93%81/"}]},{"title":"偶思","slug":"zh/2013-03-21-Sudden-Thoughts","date":"2013-03-21T13:23:00.000Z","updated":"2020-03-30T22:34:35.384Z","comments":true,"path":"categories/Misc/Records/zh/2013-03-21-Sudden-Thoughts/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-03-21-Sudden-Thoughts/","excerpt":"","text":"男孩和女孩是一对双胞胎，从小到大，他们形影不离。或者说，他们的生命就是一体的。 可是，女孩太纯洁了。他们都深知，这个世界容不下她的心灵。 于是，女孩对男孩说：“你成为神吧。” 男孩夜以继日，终于走上神坛。 男孩成为了神，处处保护着女孩。女孩很开心，她知道，在他的保护之下，她很安全。 后来，男孩带着女孩走向了一个没有人可以去到的小岛。在那里，作为神的男孩倾听着世界，而女孩则彻底得到了解放。 但是——多么奇怪啊，那里只有他们。 ——“你不孤独吗？”人问。 ——“是的，或者不。”男孩说。女孩浅浅地笑着，没人可以看见。 他们永生。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"洗“枣”记（2013年3月20日）","slug":"zh/2013-03-20-Taking-the-Shower","date":"2013-03-20T04:52:00.000Z","updated":"2020-03-30T22:34:35.384Z","comments":true,"path":"categories/Misc/Records/zh/2013-03-20-Taking-the-Shower/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-03-20-Taking-the-Shower/","excerpt":"","text":"上个星期，靠近3号公寓楼的一棵树下的泥土池子开始冒热气。这热气，我一开始还以为是烟——谁在里面烧东西或者放了啥强氧化剂了，不久发现原来是热气。另外一个情况是，上星期澡堂热水的供应量下降了。结合这两个条件，澡堂的热水管子漏了。 既然坏了，那就要派人来修对吧。于是在星期五，楼管贴出了告示，说从3月16日（星期六）开始将关闭澡堂，重新开启的时间未知。我看到这消息之后当天晚上享受了一个不冷不热的澡，心想估计一个小破口就一天好了。可是后来的事实证明，我错了。 星期六，我去了校本部参加微电影分镜头的修订。当然，这就免不了挤两次地铁，以及在校内跑来跑去。晚上回到宿舍，这衣服的肮脏程度较平时要糟糕一些（我比较爱干净），不过我还是换了裤子，盖被子睡了。第一天不能洗澡，真是难熬啊！记得我高二的时候，是每天洗三次的，高三有所下降，也有每天两次。晚上我还是克制自己，算睡了一个安稳觉。星期天，在宿舍一天，为了让衣服不要更脏我还尽量避免下楼，一天只吃了一餐，方便面+压缩饼干。没错，当天晚上还是不能洗澡；而且我没看到任何人在坑边工作（其实他们是在下午做事）。行，凑合凑合吧。两天不洗澡，身上难受得像蚂蚁叮一样。 到了星期一，该上课了。上了一天课，还在食堂吃了一餐。最重要的是，下午上了一节体育课！还好，天气不热，没出多少汗。但是几天的“积淀”，让我弯脖子的时候有微微的粘滞感。好消息是，快到吃饭的时候，我听闻晚上可以洗澡了，不过是开放到十点，因为没有完全修好。我还高兴了一阵子：终于可以摆脱身上的污垢了。下了史纲课，我、范成和陈俊驰还兴冲冲地准备去跑步，刷十圈。刚到楼梯口，碰见黄晋国，我们得知了一个至关重要的消息：澡堂改为开放到八点。你妹！这是什么概念呢？史纲（第九、十节）下课时间是20:10。而我习惯晚上上完所有课之后再洗澡，所以下午就没去（下午某次出239Z的时候看到钟逸凡明显是洗完澡的样子，还想晚上就可以轻松一下了；晚上刷牙的时候再碰到他，我不由得说：“你看看你，真幸运啊！”）。总的结果是：没洗澡。 为了表示抗议（或者说为了不再弄脏床单），当天晚上我就睡在了椅子上。（来，让我解释一下这是怎么实现的。首先准备四张椅子，置于一条直线上，调整间距以适合躺下时身体的受力点位置，就可以躺下了。这一招我在军训的时候用过，不过那是中午；当然军训时我还有中午睡在一米长两边封闭的桌子上的经历。）这次，我放了一个枕头（上面有枕巾）。可惜没有被子，我只好找了这几天穿的一件衣服盖在上半身。这一夜过得非常艰苦（rough）。首先，椅子和床还是不一样，例如你可以将整条腿放在床上，感受着它均匀受力，而椅子不行，因为其中总有一段是空的，一点支撑都没有，所以身体实际上一直处于紧绷的状态。其次，椅子本来就窄，躺下之后手臂是不可能展开的了，晚上还要小心睡着的时候掉下去。还有，翻身很艰难，一是椅子窄，二是盖在身上的衣服要随着身体的翻动而移动，要不然就滑到地上了，所以每次翻身都是在清醒的情况下完成的。同时，我侧身睡的时候手臂必须得压在身下（在床上的话，侧向展开就好了），所以手指末端后来都冰凉冰凉的了（循环不畅），而且还酸麻。最重要的一点是，我忘了在群上的一条消息——星期二要下雪。当天晚上气温骤降，如果上有被子下有床垫那倒没事，但是我是在一个冰凉坚硬的椅子表面，罩着一件衣服睡的啊！所以每次夜里醒来（翻身或者被冻醒）的时候，我都能感受到那刺骨的冷气，感受到我的身体正在失温。不知道各位有没有这样的体验。我想，流浪汉也不过如此吧。 这么折腾了一晚上，我睡踏实了才怪。第二天，大物几乎睡了两节课，最后课堂测验的时候总算清醒过来了，还把一道简单的题做错了，还是极端弱智的错误。总之星期二上午就没好过。中午我发誓，澡堂一天不开放，我就一天不回到床上。当天的QQ签名，如果谁看见的话，是这样的：“这三天来，在沙河校区，你可以洗苹果，可以洗梨子，可以洗葡萄，可以洗西红柿——就是不能洗枣。” 下午下了语文课，路过路边两个大坑的时候我还责怪修管道的工人效率为何这么低。回到宿舍大堂，向右一看——“今天浴室开放时间：16:30-23:00，2013.3.19”。我将信将疑，问楼管大妈今天会不会还发生昨天的情况，得到的答案是不会。“修好了？”“是的，现在修好了，早点去洗吧。” 我还是有些担心，所以一回到宿舍，尽管九、十节还有选修课，我就立马准备东西去洗“枣”了。四天，整整四天！一卡通放入卡槽，打开水龙头，在这氤氲之中，我享受到了肉体的最高快感。这平凡的肉身，如何才能消受得起这美妙的感受。但是！别忘了，这是纯粹的感官愉悦，应当从精神层面对此进行进一步的挖掘。在那一刹那，所有的不净之物都离我远去，只余下我一个人徜徉在洁净之中，感受着心灵的洗涤。 一切都沉寂之后，我感到浑身轻松，就像玉石上的积灰被洗涤之后的那种清莹。顺带着，晚上也特别精神。没错，就这么短短几天，就一个“枣”就可以给我这么大的愉悦——毕竟，这种事情还是不常发生的嘛。 过了，也觉得那是一次难得的经历吧，毕竟之前知道肯定有些地方的孩子们条件艰苦，但是总觉得这种事情不会发生在自己身上。这次，就是一下马威啊！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"小品","slug":"小品","permalink":"https://blog.mottomo.moe/tags/%E5%B0%8F%E5%93%81/"}]},{"title":"驱动笔记之二：一个成功的驱动程序与应用程序通信的实例（命名管道方式）","slug":"zh/2013-02-14-Kernel-Pipe-Part-2","date":"2013-02-14T09:30:00.000Z","updated":"2020-03-30T22:34:35.384Z","comments":true,"path":"categories/Tech/Coding/zh/2013-02-14-Kernel-Pipe-Part-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2013-02-14-Kernel-Pipe-Part-2/","excerpt":"","text":"经过多次测试，一个笨拙的驱动程序和应用程序通信的实例终于完成了！我不会用 minifilter，所以就用了 named pipe 来解决。 代码如下： // --- MessageThread.h #include &quot;wdm.h&quot; void MessageWorkerEntry(IN PVOID); // --- MessageThread.cpp #include &quot;MessageThread.h&quot; #include &quot;KernelPipe.h&quot; extern KEVENT keMsg; void MessageWorkerEntry(IN PVOID pvContext) { HANDLE hPipe = NULL; NTSTATUS ns = STATUS_UNSUCCESSFUL; PWCHAR pwszPipeName = L&quot;\\\\??\\\\pipe\\\\HelloPipe&quot;; UNICODE_STRING uniPipeName={0}; OBJECT_ATTRIBUTES ObjAttr={0}; IO_STATUS_BLOCK IoStatus={0}; KdPrint((&quot;In MessageWorkerEntry.&quot;)); RtlInitUnicodeString(&amp;uniPipeName,pwszPipeName); InitializeObjectAttributes(&amp;ObjAttr,&amp;uniPipeName,OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,NULL,NULL); KdPrint((&quot;Pipe name: %wZ&quot;, uniPipeName)); ns = ZwCreateFile( &amp;hPipe, // File handle FILE_WRITE_DATA | SYNCHRONIZE, // Desired access &amp;ObjAttr, // Attributes &amp;IoStatus, // IO Status Block NULL, // Allocation size 0, // File attributes FILE_SHARE_READ | FILE_SHARE_WRITE, //File share FILE_OPEN, // Create disposition (must exist) //FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,// Create options FILE_SYNCHRONOUS_IO_NONALERT, NULL, // EA buffer 0 ); // EA size KdPrint((&quot;Open status: 0x%x&quot;, ns)); KdPrint((&quot;Pipe handle: %p&quot;, hPipe)); if (NT_SUCCESS(ns)) { ns = ZwSetNamedPipeState(hPipe, FILE_PIPE_MESSAGE_TYPE | FILE_PIPE_MESSAGE_MODE); KdPrint((&quot;ZwSetNamedPipeState status: 0x%x&quot;, ns)); } IO_STATUS_BLOCK isb; LARGE_INTEGER li; ns = STATUS_UNSUCCESSFUL; li.HighPart = -1; li.LowPart = FILE_WRITE_TO_END_OF_FILE; int i = 0; char ch[] = &quot;This is some sort of test message.&quot;; for ( i=0; i&lt;10; i++ ) { ns = ZwWriteFile(hPipe, NULL, NULL, NULL, &amp;isb, ch, (ULONG)strlen(ch), NULL, NULL); KdPrint((&quot;ZwWriteFile status: 0x%x&quot;, ns)); } KeSetEvent(&amp;keMsg, 0, 0); ZwClose(hPipe); PsTerminateSystemThread(STATUS_SUCCESS); } // --- KernelPipe.h #include &quot;wdm.h&quot; #include &quot;basetsd.h&quot; #include &quot;ntdef.h&quot; //#include &quot;ntifs.h&quot; #define FILE_PIPE_MESSAGE_MODE 0x00000001 #define FILE_PIPE_MESSAGE_TYPE 0x00000001 #define FILE_PIPE_QUEUE_OPERATION 0x00000000 #define FSCTL_PIPE_ASSIGN_EVENT CTL_CODE(FILE_DEVICE_NAMED_PIPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_DISCONNECT CTL_CODE(FILE_DEVICE_NAMED_PIPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_LISTEN CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_PEEK CTL_CODE(FILE_DEVICE_NAMED_PIPE, 3, METHOD_BUFFERED, FILE_READ_DATA) #define FSCTL_PIPE_QUERY_EVENT CTL_CODE(FILE_DEVICE_NAMED_PIPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_TRANSCEIVE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 5, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA) #define FSCTL_PIPE_WAIT CTL_CODE(FILE_DEVICE_NAMED_PIPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_IMPERSONATE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_SET_CLIENT_PROCESS CTL_CODE(FILE_DEVICE_NAMED_PIPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_QUERY_CLIENT_PROCESS CTL_CODE(FILE_DEVICE_NAMED_PIPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_GET_PIPE_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_SET_PIPE_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_GET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_SET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_GET_HANDLE_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_SET_HANDLE_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS) #define FSCTL_PIPE_FLUSH CTL_CODE(FILE_DEVICE_NAMED_PIPE, 16, METHOD_BUFFERED, FILE_WRITE_DATA) #pragma comment(lib,&quot;ntifs.lib&quot;) extern &quot;C&quot; __drv_maxIRQL(PASSIVE_LEVEL) NTSYSAPI NTSTATUS NTAPI ZwFsControlFile( __in HANDLE FileHandle, __in_opt HANDLE Event, __in_opt PIO_APC_ROUTINE ApcRoutine, __in_opt PVOID ApcContext, __out PIO_STATUS_BLOCK IoStatusBlock, __in ULONG FsControlCode, __in_bcount_opt(InputBufferLength) PVOID InputBuffer, __in ULONG InputBufferLength, __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer, __in ULONG OutputBufferLength ); /* extern &quot;C&quot; __kernel_entry NTSYSCALLAPI NTSTATUS NTAPI NtWriteFile ( __in HANDLE FileHandle, __in_opt HANDLE Event, __in_opt PIO_APC_ROUTINE ApcRoutine, __in_opt PVOID ApcContext, __out PIO_STATUS_BLOCK IoStatusBlock, __in_bcount(Length) PVOID Buffer, __in ULONG Length, __in_opt PLARGE_INTEGER ByteOffset, __in_opt PULONG Key ); */ #pragma pack(push,1) /* typedef unsigned long ULONG, ULONG32; typedef unsigned short USHORT; typedef unsigned char UINT8; */ typedef struct _WAIT_PIPE_PARAM { __int64 liTimeOutvalue; ULONG ulPipeNameLen; USHORT bUsTimeoutValue; } WAIT_PIPE_PARAM,*PWAIT_PIPE_PARAM; typedef struct _NAMED_PIPE_CREATE_PARAMETERS { ULONG32 NamedPipeType; ULONG32 ReadMode; ULONG32 CompletionMode; ULONG32 MaximumInstances; ULONG32 InboundQuota; ULONG32 OutboundQuota; LARGE_INTEGER DefaultTimeout; UINT8 TimeoutSpecified; UINT8 _PADDING0_[0x7]; } NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS; #pragma pack(pop) #define WAIT_FORVER (0x8000000000000000) #define PIPE_ACCESS_DUPLEX (3) NTSTATUS ZwCreateNamedPipeFile ( OUT PHANDLE phPipeHandle, IN ULONG ulDesiredAccess, IN POBJECT_ATTRIBUTES pObjAttr, OUT PIO_STATUS_BLOCK pIoStatus, IN ULONG ulShareAccess, IN ULONG ulCreateDisposition, IN ULONG ulCreateOptions, IN BOOLEAN bIsMsgType, IN BOOLEAN bIsMsgMode, IN BOOLEAN bIsNonBlocking, IN ULONG ulMaximumInstances, IN ULONG ulInBufSize, IN ULONG ulOutBufSize, IN PLARGE_INTEGER pliDefaultTimeout OPTIONAL ); NTSTATUS __stdcall ZwCreateNamedPipe(PWCHAR pwszPipeName, ULONG ulMaxInBufSize, ULONG ulMaxOutBufSize, ULONG ulMaxClientCount, PLARGE_INTEGER liTimeOut, PHANDLE phPipe); NTSTATUS __stdcall ZwConnectNamedPipe(HANDLE hPipe); NTSTATUS __stdcall ZwDisconnectNamedPipe(HANDLE hPipe); NTSTATUS __stdcall ZwSetNamedPipeState(HANDLE hPipe,ULONG ulMode); NTSTATUS __stdcall ZwWaitNamedPipe(PUNICODE_STRING puniPipeName,LARGE_INTEGER liTimeOut); // --- KernelPipe.cpp #include &quot;KernelPipe.h&quot; NTSTATUS ZwCreateNamedPipeFile ( OUT PHANDLE phPipeHandle, IN ULONG ulDesiredAccess, IN POBJECT_ATTRIBUTES pObjAttr, OUT PIO_STATUS_BLOCK pIoStatus, IN ULONG ulShareAccess, IN ULONG ulCreateDisposition, IN ULONG ulCreateOptions, IN BOOLEAN bIsMsgType, IN BOOLEAN bIsMsgMode, IN BOOLEAN bIsNonBlocking, IN ULONG ulMaximumInstances, IN ULONG ulInBufSize, IN ULONG ulOutBufSize, IN PLARGE_INTEGER pliDefaultTimeout OPTIONAL ) { NAMED_PIPE_CREATE_PARAMETERS NamedPipeParms={0}; NTSTATUS NtStatus={0}; __try { if ( pliDefaultTimeout ) { NamedPipeParms.TimeoutSpecified = TRUE; NamedPipeParms.DefaultTimeout.QuadPart = pliDefaultTimeout-&gt;QuadPart; } else { NamedPipeParms.TimeoutSpecified = FALSE; } NamedPipeParms.NamedPipeType = bIsMsgType; NamedPipeParms.ReadMode = bIsMsgMode; NamedPipeParms.CompletionMode = bIsNonBlocking; NamedPipeParms.MaximumInstances = ulMaximumInstances; NamedPipeParms.InboundQuota = ulInBufSize; NamedPipeParms.OutboundQuota = ulOutBufSize; NtStatus = IoCreateFile( phPipeHandle, ulDesiredAccess, pObjAttr, pIoStatus, NULL, 0, ulShareAccess, ulCreateDisposition, ulCreateOptions, NULL, 0, CreateFileTypeNamedPipe, &amp;NamedPipeParms, 0 ); return NtStatus; } __except (EXCEPTION_EXECUTE_HANDLER) { KdPrint ((&quot;ZwCreateNamedPipeFile: Exception occured.\\n&quot;)); return GetExceptionCode(); } } NTSTATUS __stdcall ZwCreateNamedPipe(PWCHAR pwszPipeName, ULONG ulMaxInBufSize, ULONG ulMaxOutBufSize, ULONG ulMaxClientCount, PLARGE_INTEGER pliTimeOut, PHANDLE phPipe) { NTSTATUS NtStatus=STATUS_SUCCESS; HANDLE hPipe=NULL; UNICODE_STRING uniPipeName={0}; //ANSI_STRING ansiPipeName = {0}; OBJECT_ATTRIBUTES ObjAttr={0}; IO_STATUS_BLOCK IoStatus={0}; RtlInitUnicodeString(&amp;uniPipeName,pwszPipeName); InitializeObjectAttributes(&amp;ObjAttr,&amp;uniPipeName,OBJ_CASE_INSENSITIVE,NULL,NULL); //RtlInitAnsiString(&amp;ansiPipeName, pszPipeName); //InitializeObjectAttributes(&amp;ObjAttr,(ULONG)&amp;ansiPipeName,OBJ_CASE_INSENSITIVE,NULL,NULL); KdPrint((&quot;Name in ZwCreateNamedPipe: %wZ&quot;, &amp;uniPipeName)); NtStatus=ZwCreateNamedPipeFile(&amp;hPipe, FILE_ANY_ACCESS, &amp;ObjAttr, &amp;IoStatus, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, PIPE_ACCESS_DUPLEX, FILE_PIPE_MESSAGE_TYPE, FILE_PIPE_MESSAGE_MODE, FILE_PIPE_QUEUE_OPERATION,//blocking mode ulMaxClientCount, ulMaxInBufSize, ulMaxOutBufSize, pliTimeOut); if (NT_SUCCESS(NtStatus)) { *phPipe=hPipe; } else { *phPipe=NULL; } return NtStatus; } NTSTATUS __stdcall ZwConnectNamedPipe(HANDLE hPipe) { NTSTATUS NtStatus=STATUS_SUCCESS; IO_STATUS_BLOCK IoStatus={0}; NtStatus=ZwFsControlFile(hPipe,NULL,NULL,NULL,&amp;IoStatus,FSCTL_PIPE_LISTEN,NULL,0,NULL,0); return NtStatus; } NTSTATUS __stdcall ZwDisconnectNamedPipe(HANDLE hPipe) { NTSTATUS NtStatus=STATUS_SUCCESS; IO_STATUS_BLOCK IoStatus={0}; NtStatus=ZwFsControlFile(hPipe,NULL,NULL,NULL,&amp;IoStatus,FSCTL_PIPE_DISCONNECT,NULL,0,NULL,0); return NtStatus; } NTSTATUS __stdcall ZwSetNamedPipeState(HANDLE hPipe,ULONG ulMode) { NTSTATUS NtStatus=STATUS_UNSUCCESSFUL; ULONG aBuf[2]={0}; IO_STATUS_BLOCK IoStatus={0}; do { if ((0xFFFFFFFC &amp; ulMode)==0) { break; } aBuf[0]=((ulMode&gt;&gt;1) &amp; 1); aBuf[1]=(ulMode &amp; 1); NtStatus=ZwSetInformationFile(hPipe, &amp;IoStatus, aBuf, sizeof(aBuf), FilePipeInformation); } while (FALSE); return NtStatus; } NTSTATUS __stdcall ZwWaitNamedPipe(PUNICODE_STRING puniPipeName,LARGE_INTEGER liTimeOut) { NTSTATUS NtStatus=STATUS_UNSUCCESSFUL; IO_STATUS_BLOCK IoStatus={0}; HANDLE hParent=NULL; OBJECT_ATTRIBUTES Oa={0}; WCHAR aTmpBuf[512]={0}; PWAIT_PIPE_PARAM pWaitPipeParam=(PWAIT_PIPE_PARAM)aTmpBuf; INT iShortNameOffset=wcslen(L&quot;\\\\\\\\.\\\\pipe\\\\&quot;)*sizeof(WCHAR); UNICODE_STRING uniPipeParentName={0}; do { if (!puniPipeName || puniPipeName-&gt;Length&lt;iShortNameOffset) { NtStatus=STATUS_OBJECT_NAME_NOT_FOUND; break; } RtlInitUnicodeString(&amp;uniPipeParentName,L&quot;\\\\DosDevices\\\\pipe\\\\&quot;); InitializeObjectAttributes(&amp;Oa,&amp;uniPipeParentName,OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,NULL,NULL); NtStatus=ZwOpenFile(&amp;hParent,0x100080,&amp;Oa,&amp;IoStatus,FILE_SHARE_WRITE | FILE_SHARE_READ,32); if (!NT_SUCCESS(NtStatus)) { break; } pWaitPipeParam-&gt;liTimeOutvalue=liTimeOut.QuadPart; pWaitPipeParam-&gt;bUsTimeoutValue=TRUE; *((USHORT*)(&amp;pWaitPipeParam-&gt;ulPipeNameLen))=puniPipeName-&gt;Length-iShortNameOffset; RtlCopyMemory((PVOID)((ULONG_PTR)pWaitPipeParam+sizeof(WAIT_PIPE_PARAM)),&amp;puniPipeName-&gt;Buffer[iShortNameOffset/sizeof(WCHAR)],pWaitPipeParam-&gt;ulPipeNameLen); NtStatus=ZwFsControlFile(hParent,NULL,NULL,NULL,&amp;IoStatus,FSCTL_PIPE_WAIT,&amp;pWaitPipeParam,14+pWaitPipeParam-&gt;ulPipeNameLen,NULL,0); } while (FALSE); if (hParent) { ZwClose(hParent); } return NtStatus; } 就可以了。 要点： 打开命名管道的时候要在 ObjAttr 中使用 OBJ_KERNEL_HANDLE，使其附加在系统进程（[System]）里。 ZwCreateFile 和 ZwWriteFile 必须处于同一个线程中。（我之前尝试用 PsCreateSystemThread 的 lpContext 来传递 hPipe，结果 ZwWriteFile 返回 STATUS_INVALID_HANDLE（此时的 hPipe 为2位~4位16进制码）。 服务器端代码如下（我保证只会有一个线程调用 ZwWriteFile，所以我没考虑同步的问题）： #include &quot;SnoopyTester.h&quot; int main() { HANDLE hPipe = NULL; BOOL fRead = FALSE; DWORD i = 0; DWORD dwBytesRead = 0; char buffer[100] = {0}; hPipe = CreateNamedPipe(&quot;\\\\\\\\.\\\\pipe\\\\HelloPipe&quot;, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_NOWAIT, 2, 100, 100, (DWORD)-1, NULL); if ((hPipe) &amp;&amp; (hPipe != INVALID_HANDLE_VALUE)) { for ( i = 0; i &lt;= MAXDWORD; i++ ) { fRead = ReadFile(hPipe, buffer, 100, &amp;dwBytesRead, NULL); if (fRead || dwBytesRead) { printf(&quot;Message received: %s\\n&quot;, buffer); memset(buffer, 0, 100); } } printf(&quot;Application ends.\\n&quot;); getchar(); return 0; } else { printf(&quot;Cannot create named pipe \\\\\\\\.\\\\pipe\\\\HelloPipe\\n&quot;); getchar(); return 0; } } 其中 SnoopyTester.h 包含了 stdio.h 和 windows.h。 运行结果如下：","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"驱动笔记之一：内核命名管道问题的解决","slug":"zh/2013-02-12-Kernel-Pipe","date":"2013-02-12T15:51:00.000Z","updated":"2020-03-30T22:34:35.382Z","comments":true,"path":"categories/Tech/Coding/zh/2013-02-12-Kernel-Pipe/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2013-02-12-Kernel-Pipe/","excerpt":"","text":"（老鸟们请不要笑话我……） 最近正在做一个驱动程序，需要用到内核与用户层通信。我是个驱动开发的新手，所以想回归最简单最传统的 Windows 编程模式，第一个反应就是：命名管道。所以不要问我为什么不用 minifilter 的通信机制，原因很简单——我不会。 内核管道的实现在这里：http://blog.csdn.net/skyseacsn/article/details/6962858 #pragma pack(push,1) typedef struct _WAIT_PIPE_PARAM { __int64 liTimeOutvalue; ULONG ulPipeNameLen; USHORT bUsTimeoutValue; } WAIT_PIPE_PARAM,*PWAIT_PIPE_PARAM; typedef struct _NAMED_PIPE_CREATE_PARAMETERS { ULONG32 NamedPipeType; ULONG32 ReadMode; ULONG32 CompletionMode; ULONG32 MaximumInstances; ULONG32 InboundQuota; ULONG32 OutboundQuota; LARGE_INTEGER DefaultTimeout; UINT8 TimeoutSpecified; UINT8 _PADDING0_[0x7]; } NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS; #pragma pack(pop) #define WAIT_FORVER (0x8000000000000000) #define PIPE_ACCESS_DUPLEX (3) NTSTATUS ZwCreateNamedPipeFile ( OUT PHANDLE phPipeHandle, IN ULONG ulDesiredAccess, IN POBJECT_ATTRIBUTES pObjAttr, OUT PIO_STATUS_BLOCK pIoStatus, IN ULONG ulShareAccess, IN ULONG ulCreateDisposition, IN ULONG ulCreateOptions, IN BOOLEAN bIsMsgType, IN BOOLEAN bIsMsgMode, IN BOOLEAN bIsNonBlocking, IN ULONG ulMaximumInstances, IN ULONG ulInBufSize, IN ULONG ulOutBufSize, IN PLARGE_INTEGER pliDefaultTimeout OPTIONAL ) { NAMED_PIPE_CREATE_PARAMETERS NamedPipeParms={0}; NTSTATUS NtStatus={0}; __try { if ( pliDefaultTimeout ) { NamedPipeParms.TimeoutSpecified = TRUE; NamedPipeParms.DefaultTimeout.QuadPart = pliDefaultTimeout-&gt;QuadPart; } else { NamedPipeParms.TimeoutSpecified = FALSE; } NamedPipeParms.NamedPipeType = bIsMsgType; NamedPipeParms.ReadMode = bIsMsgMode; NamedPipeParms.CompletionMode = bIsNonBlocking; NamedPipeParms.MaximumInstances = ulMaximumInstances; NamedPipeParms.InboundQuota = ulInBufSize; NamedPipeParms.OutboundQuota = ulOutBufSize; NtStatus = IoCreateFile( phPipeHandle, ulDesiredAccess, pObjAttr, pIoStatus, NULL, 0, ulShareAccess, ulCreateDisposition, ulCreateOptions, NULL, 0, CreateFileTypeNamedPipe, &amp;NamedPipeParms, 0 ); return NtStatus; } __except (EXCEPTION_EXECUTE_HANDLER) { KdPrint ((&quot;ZwCreateNamedPipeFile: Exception occured.\\n&quot;)); return GetExceptionCode(); } } NTSTATUS __stdcall ZwCreateNamedPipe(PWCHAR pwszPipeName, ULONG ulMaxInBufSize, ULONG ulMaxOutBufSize, ULONG ulMaxClientCount, LARGE_INTEGER liTimeOut, PHANDLE phPipe) { NTSTATUS NtStatus=STATUS_SUCCESS; HANDLE hPipe=NULL; UNICODE_STRING uniPipeName={0}; OBJECT_ATTRIBUTES ObjAttr={0}; IO_STATUS_BLOCK IoStatus={0}; RtlInitUnicodeString(&amp;uniPipeName,pwszPipeName); InitializeObjectAttributes(&amp;ObjAttr,&amp;uniPipeName,OBJ_CASE_INSENSITIVE,NULL,NULL); NtStatus=ZwCreateNamedPipeFile(&amp;hPipe, FILE_ANY_ACCESS, &amp;ObjAttr, &amp;IoStatus, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, PIPE_ACCESS_DUPLEX, FILE_PIPE_MESSAGE_TYPE, FILE_PIPE_MESSAGE_MODE, FILE_PIPE_QUEUE_OPERATION,//blocking mode ulMaxClientCount, ulMaxInBufSize, ulMaxOutBufSize, &amp;liTimeOut); if (NT_SUCCESS(NtStatus)) { *phPipe=hPipe; } else { *phPipe=NULL; } return NtStatus; } NTSTATUS __stdcall ZwConnectNamedPipe(HANDLE hPipe) { NTSTATUS NtStatus=STATUS_SUCCESS; IO_STATUS_BLOCK IoStatus={0}; NtStatus=ZwFsControlFile(hPipe,NULL,NULL,NULL,&amp;IoStatus,FSCTL_PIPE_LISTEN,NULL,0,NULL,0); return NtStatus; } NTSTATUS __stdcall ZwDisconnectNamedPipe(HANDLE hPipe) { NTSTATUS NtStatus=STATUS_SUCCESS; IO_STATUS_BLOCK IoStatus={0}; NtStatus=ZwFsControlFile(hPipe,NULL,NULL,NULL,&amp;IoStatus,FSCTL_PIPE_DISCONNECT,NULL,0,NULL,0); return NtStatus; } NTSTATUS __stdcall ZwSetNamedPipeState(HANDLE hPipe,ULONG ulMode) { NTSTATUS NtStatus=STATUS_UNSUCCESSFUL; ULONG aBuf[2]={0}; IO_STATUS_BLOCK IoStatus={0}; do { if ((0xFFFFFFFC &amp; ulMode)==0) { break; } aBuf[0]=((ulMode&gt;&gt;1) &amp; 1); aBuf[1]=(ulMode &amp; 1); NtStatus=ZwSetInformationFile(hPipe, &amp;IoStatus, aBuf, sizeof(aBuf), FilePipeInformation); } while (FALSE); return NtStatus; } NTSTATUS __stdcall ZwWaitNamedPipe(PUNICODE_STRING puniPipeName,LARGE_INTEGER liTimeOut) { NTSTATUS NtStatus=STATUS_UNSUCCESSFUL; IO_STATUS_BLOCK IoStatus={0}; HANDLE hParent=NULL; OBJECT_ATTRIBUTES Oa={0}; WCHAR aTmpBuf[512]={0}; PWAIT_PIPE_PARAM pWaitPipeParam=(PWAIT_PIPE_PARAM)aTmpBuf; INT iShortNameOffset=wcslen(L&quot;\\\\\\\\.\\\\pipe\\\\&quot;)*sizeof(WCHAR); UNICODE_STRING uniPipeParentName={0}; do { if (!puniPipeName || puniPipeName-&gt;Length&lt;iShortNameOffset) { NtStatus=STATUS_OBJECT_NAME_NOT_FOUND; break; } RtlInitUnicodeString(&amp;uniPipeParentName,L&quot;\\\\DosDevices\\\\pipe\\\\&quot;); InitializeObjectAttributes(&amp;Oa,&amp;uniPipeParentName,OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,NULL,NULL); NtStatus=ZwOpenFile(&amp;hParent,0x100080,&amp;Oa,&amp;IoStatus,FILE_SHARE_WRITE | FILE_SHARE_READ,32); if (!NT_SUCCESS(NtStatus)) { break; } pWaitPipeParam-&gt;liTimeOutvalue=liTimeOut.QuadPart; pWaitPipeParam-&gt;bUsTimeoutValue=TRUE; *((USHORT*)(&amp;pWaitPipeParam-&gt;ulPipeNameLen))=puniPipeName-&gt;Length-iShortNameOffset; RtlCopyMemory((PVOID)((ULONG_PTR)pWaitPipeParam+sizeof(WAIT_PIPE_PARAM)),&amp;puniPipeName-&gt;Buffer[iShortNameOffset/sizeof(WCHAR)],pWaitPipeParam-&gt;ulPipeNameLen); NtStatus=ZwFsControlFile(hParent,NULL,NULL,NULL,&amp;IoStatus,FSCTL_PIPE_WAIT,&amp;pWaitPipeParam,14+pWaitPipeParam-&gt;ulPipeNameLen,NULL,0); } while (FALSE); if (hParent) { ZwClose(hParent); } return NtStatus; } （吐槽一下百度空间的“插入代码”功能，总是出现神排版！） 引入了管道之后，我尝试创建管道，但是一直返回 0xc0000033（STATUS_OBJECT_NAME_INVALID）。我纳闷了，为什么呢？我查看了 KdPrint(&quot;zW&quot;)，使用的名称“\\.\\pipe\\hellopipe”确实被正确地转成了 Unicode 字符串啊！那么为什么系统总是说我的名称错了？ 我查遍了所有的资料，里面写的都是，本地命名管道（服务端只能采用这种格式）采用“\\.\\pipe\\pipename”的格式，远程管道可以采用“\\servername\\pipe\\pipename”的格式。那么为什么我的名称是不对的？后来我偶然找到了一个页面（http://us.generation-nt.com/answer/create-named-pipe-kernel-driver-help-27790252.html），里面讲述了原因。翻译如下： Thus whereas in user-mode format of pipe is , in kernel it is “\\??\\pipe\\pipename”. In addition, in kernel default security context is LocalSystem which is not allowed to access network. 所以尽管用户态的管道名称格式为“\\server\\pipe\\pipename”，在内核中其为“\\??\\pipe\\pipename”。而且，在内核中，默认安全上下文是 LocalSystem，该安全上下文不允许访问网络。 好了，知道原因，修改代码，调试，成功~","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Astraea's Caroline 2.1.0.5 已经发布","slug":"zh/2013-01-14-Astraeas-Caroline-2105-Announcement","date":"2013-01-14T03:52:00.000Z","updated":"2020-03-30T22:34:35.382Z","comments":true,"path":"categories/Misc/Records/zh/2013-01-14-Astraeas-Caroline-2105-Announcement/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-01-14-Astraeas-Caroline-2105-Announcement/","excerpt":"","text":"Astraea’s Caroline 通用游戏启动器 2.1.0.5 版本发布。这很可能是最终的版本，以后不再更新。 地址：http://pan.baidu.com/share/link?shareid=151557&amp;uk=3121145127 （该版本需要手动下载安装，不再提供自动更新功能） 更新至： Astraea’s Caroline 2.1.0.5 AcUpdate 1.1.0.13 AcAppIDUpdate 1.1.0.5 AcAppIDBrowse 1.0.0.4 修正 Windows XP 下有时会启用 DWM 设置的问题 修正“最近游戏”列表不会添加新项目的问题 修正一些界面 bug 稳定性增强 AppID 更新增加对 Windows 7 任务栏的支持 添加对 Windows 游戏的搜索支持（需要 Windows Vista 及以上） 添加选择性搜索功能 添加自定义配色方案功能 截图： 未使用主题时的外观 启用桌面合成之后的仿 Windows 8 Style 外观 修正后的菜单和工具栏 美化后的设置窗口 可选择多种配色方案 关于","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"},{"name":"发布","slug":"发布","permalink":"https://blog.mottomo.moe/tags/%E5%8F%91%E5%B8%83/"}]},{"title":"Serenity, impressive.","slug":"zh/2013-01-01-Serenity-Impressive","date":"2013-01-01T12:52:00.000Z","updated":"2020-03-30T22:34:35.382Z","comments":true,"path":"categories/Misc/Records/zh/2013-01-01-Serenity-Impressive/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2013-01-01-Serenity-Impressive/","excerpt":"","text":"People don’t like to be meddle with. We tell them what to do, what to think. Don’t run, don’t walk. We’re in their homes and in their heads and we haven’t the right. I am a leaf on the wind. Watch how I soar.","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Astraea's Caroline 还在继续更新","slug":"zh/2012-09-29-Astraeas-Caroline-Is-Still-Updating","date":"2012-09-29T08:03:00.000Z","updated":"2020-03-30T22:34:35.382Z","comments":true,"path":"categories/Misc/Records/zh/2012-09-29-Astraeas-Caroline-Is-Still-Updating/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-09-29-Astraeas-Caroline-Is-Still-Updating/","excerpt":"","text":"“关于”界面 在桌面组合开启时的样子 使用传统风格系统主题的样子 当前版本为 2.0.5.1。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"2012届高中毕业生自招亲历——自主招生是怎么救了我的命的","slug":"zh/2012-08-17-How-Independent-Recruitment-Saved-My-Life","date":"2012-08-17T13:44:00.000Z","updated":"2020-03-30T22:34:35.380Z","comments":true,"path":"categories/Misc/Records/zh/2012-08-17-How-Independent-Recruitment-Saved-My-Life/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-08-17-How-Independent-Recruitment-Saved-My-Life/","excerpt":"","text":"大家对自主招生不陌生吧。有的广告甚至宣称，自主招生考试、保送生考试和高考是进入高校的三大途径，我要狠狠地嘲笑这一点；而且不仅是我，有智慧的老师们都这么做。不过，自主招生确实救了我的命。接下来我会详细解析自招流程与其带来的好处。 先说第一点。自主招生的重要性很多时候被过分夸大了。可以说，保送生考试和高考是进入高校的“唯二”途径（走后门不算）。为什么？没错，有电视主播说其子自招跑到北大面试，北大看过之后当场拍板要了——但是大哥，这可是十亿分之一的概率。你每年见过几个人在自主招生阶段就被马上要走了？没有多少对吧，要不然各路媒体又要进行宣传轰炸了。所以，自主招生再怎么样都只是高考的助推器，如果你没料，自招再好而高考一塌糊涂也照样会落榜，因为自招只是降分录取，而不是加分（除非你过了高校在该省的录取线）！ 再说第二点。这里我要给大家介绍自招的流程了。 前言：带自主招生的高考录取制度和普通的高考的录取制度是不一样的，如果你不清楚这一点，请看完下面的东西之后再把最后一段好好看完。这样你才清楚自招的威力。 Step 0请先看好各个学校的自主招生制度！一般来说，在开始报名的时候各大高校网站上都会贴出来。请详细阅读，不要放过一个字，有疑问马上打电话问清楚。例如，这个降分是降大类的分还是系的分、允许报什么专业、平行志愿与非平行志愿的省份制度区别，等等。 Step 1挑选联盟，或者一些散兵游勇（如中大在广东的独立考试、复旦千分考。此部分个人决定，在此省略）。三大联盟：华约、北约和卓越，请大家根据自己的情况选择。三者之间的一些规则（如，选报学校的限制、笔试科目）不一样，请一定要看清楚。另外，有些年，例如2011-2012学年度，华约和北约是死掐在一天笔试的，所以也做好只能选其中一家的准备。卓越一般是不冲突的。我选择了北约，没有选择卓越（因为不想连续两个周末被占用……）。 [PS. 港大和其他学校不一样，会多一个剑桥联合招生计划（考试全英。面向未来的港大学生），以及入学计划（面向高考有志于选择港大的学生）。] Step 2最好在在准高三的暑假就开始准备自招，当然如果学得比较好可以晚一点开始。例如我是奥林匹克班（简单说就是搞竞赛的班）的，也有一些超前学习的东西了（化学），所以在奥赛培训结束之后（9月份中）才开始准备。买书不大有必要（除了物理和化学），因为即使是我一位同学每天刷题都没刷完。 Step 3准备完成（其实很难，一般就只能看一部分）之后，到了来年1月份到一个统一地点笔试。一般来说每个省都会设点，所以不用很紧张。（问题是，考点附近物价会飞涨，所以请各位家长提前做好准备。）试题网上都有。考试的科目如下： 北约—— a.语文语文不算难，不过要有一定的阅读积累，答题的时候也要有自己的心得；不过不要太注重这个，因为这毕竟是试题，是有标准答案的，所以还要委屈一下各位讨厌高考语文的人啦。 b.数学数学也不难，除了小题之外就是高考压轴题的轰炸啦~我们这一届可是对这个考试颇有微词的，因为之前只需要考7题（文科选前4道题，理科选后4道题）而这次题量加大到如此程度。不过说是压轴题，还是跟高考的难度设置有所类似的。要点是拿下小题和前面的大题，后面的如果有时间再慢慢做。（高考也是这样！我和一些同学的血泪总结……） c.英语这个……看个人造化了。我英语很好所以不用担心这个。我觉得这个难度和高考的没什么区别，都是可以刷题的。（我最后检查完剩下的时间用来睡觉了。） d.物理&amp;化学（两个科目同时考）这个嘛……我推荐没有化学联赛经历的人主攻物理，有化学联赛经历的人也主攻物理。（画外音：“废话！”）为什么？这两者考的都是竞赛内容，而二者之中物理显得更为容易一点。（如果有人没搞过化学竞赛，看自招的化学书不头大的，可以否认这一点。）而且我们这一届的物理考题，后两道大题根本就是从书上摘下来的！如果你看书了，背题了，绝对满分！（我考完回去之后捶胸顿足……）其他的，就要看各位的物理思维了。化学方面，考得太简单了（对于我们进行化学竞赛的人来说）！基本上就是相当于省初赛的一个子集。在这里告诉没有玩过化学竞赛的人，需要背记的东西很多，有时间还不如把你的高考生物提高了。 最终结果是，虽然其他三科不咋地（个人感觉），但是凭借着英语和化学的高分，我顺利杀入下一轮。 华约—— 考的是语英+数+文理（美其名曰人文科学+实验科学）。这个考试我没经历过，所以不好写。 Step 4面试是大型考试的必备环节。考完之后两个星期你就会收到面试的offer，同时可以看到你的成绩啦。然后就面试吧。我去的是港大和北航（北大的资料没用心准备，胡乱塞一通，结果材料评审就没过）。各大高校的面试地点不一样的，一般在其本部。（我很幸运，在北大进行港大的面试，在北航进行北航的面试，车程不远。如果我报四川大学我就惨了……）所以请大家规划好自己的行程。面试的话……就看自己的技巧了。如果说纯技巧也不对，你要有料，就是有自己的观点（同时不能和主旋律唱反调）。我记得在北航的时候我提出了“自然人”与“社会人”的观点（虽然不全是原创的），相信是这个给我加分了（我很担心能不能过，因为我不小心在要回收的问卷上写了答题草稿……）。总之，理科生要有文科积累，文科生要有理科思维，这样的人是高校最喜欢的。 Step 5如果你过关斩将赢得了所有战役的胜利，那么在4月份你就可以收到确认函了。主要内容是：你通过了我们的自主招生考试，现在给你优惠多少多少，要参加高考才有效，而且请注意我们的学校在你的志愿的位置，确认吗？一般来说这种信函要留3份：给高校、留在中学、自己备份。而且这张信函所有的陈述都要看清楚！如果你填错了，那么优惠就无效了。可以缓一缓，因为很多学校都要求填上高考分数，然后在放榜之后多少天之内寄回，所以时间不用赶的。 Step 6 高考并填志愿去吧。接下来对平行志愿和非平行志愿的省份进行讲解。a.平行志愿省份你们的选择很多，风险小，但是优惠幅度小。无论如何，也要看清楚确认函的内容，并且严格按照指示执行。关于志愿排位这一点我之后还会讲到。 b.非平行志愿省份你们也不用着急，虽然“一考定乾坤”的压力比平行志愿省份的压力要大很多，但是你们获得优惠幅度也会更大。所以请考虑清楚了，志愿填在什么位置。 Step 7最后，如果你发现（或者估计，如广东）你可以上线，就大胆报吧。最后的最后，就是一张录取通知书了。 最有趣的地方就在这里了。 有心的人从前面可以看出，我是广东的考生——没错，2012届，获得北航20分降分录取优惠的，全省只有3个，其中就有我。 然后，我的高考其实并不理想，628（这也不是秘密了），甚至比华工的好专业的分还要低。 但是我最终上了北航的机械工程系啊！这里是怎么来的？这就是自主招生的功劳了。 （但是，各位高考的学子们，不要过于依赖自招，要努力学习啊，因为要以高考为本，不要像我一样考砸了！上大学之后一样要继续努力的！） 广东今年实行的新政救了我的命。 去年，批次分布如下： 一本-二本A-二本B-…… 今年，批次分布如下： 自主招生-一本-二本A-二本B-…… 看到没有？多出来了一个“自主招生”批次，所有的自招院校会优先看这个批次的学生。 先讲一下普通的高考录取制度。（这是广东的制度，外省未必适用！） 广东实行平行志愿。所以，所有档案按照分数排好（具体排位请参见排位系统，这里有很详细的说明），一个一个入档。这就像信号灯对象（Semaphore，Windows 多线程编程里会用到的）一样，每个时候在机器里只有一份档案。 伪代码描述如下—— For Each s As Student In Examiners If s.AcceptableUniversities(1 To s.AcceptableUniversities.Count – 1).Full Then Continue For For Each u As University In s.AcceptableUniversities If s.TotalScores &gt;= u.AdmissionScore Then s.SendTo(u) s.Enrolled = True End If Next If Not s.Enrolled Then Continue For Next 然后让我们来假设数据。例如，今年有一本线上清华大学、北京大学和X大学在广东招生，人数分别为100、100和1000，广东考生一共1500人。 OK，机器开始读档。先取第1名的档案，看到她A组（A志愿组）第一志愿是清华大学。清华大学人满了吗？没有。那就送过去。于是现在三所大学分别剩余99、100、1000个名额。 第2名，以此类推，直到第100个都是选清华的，然后看第101个。结果他的A组第一志愿也是清华，对不起，人满了，看A组第二志愿。第二志愿北大，进了。第102个，A组第一志愿、第二志愿第三志愿都是清华，抱歉，他只能等到A组第一志愿不是空的人都投档完毕了他才能进入B组进行投档。也就是说，如果B组里他选了北大，他的分数也足够，但是由于北大在A组已经招满了，他还是进不去。（当然，如果涉及到专业，那就把三所大学设定成三个系就行了。简单说，就是递归。） 就是这样。旧的不去，新的不来，如此往复，而且严格遵照顺序。 然后再看自主招生批次的录取制度。 自主招生批次的考虑顺序是在其他所有批次之前的。那么，这时候怎么出成绩呢？毕竟正式的投档还没开始呢。这里就要涉及到一个预投档线的问题了。 预投档线在自主招生的录取时是很重要的参考依据，每个学校都有所不同。那么它是怎么计算出来的呢？ 伪代码描述如下—— Dim intEnrolledStudentCount As Integer = 0 For Each s As Student In Examiners If intEnrolledStudentCount &gt; CurrentUniversity.MaximumEnrollStudentCount Then Exit For If s.AcceptableUniversities.Contains(A) Then colPrecastScores.Add(s.TotalScores) Next Return colPrecastScores.MinimumValue 从第1名开始，如果该学生的第一志愿是该学校，则将这个学生的总分录入一个表中，直到这个表中的学生总数达到计划数的105%（不是100%，这就解释了为什么所有学校都说每年自主招生的录取人数不超过计划数的5%），然后取其中最低的分数作为预投档线。自然，有时预投档线可能偏高或者偏低，只要学校觉得不合适，就可以向教育部门申请调整录取情况（如，生源太好了，想多招收一些，就增加招生人数）以获得一份新的表，继续操作得到一个新的预投档线——第二预投档线。第二预投档线就是最终的结果，该学校一切自主招生的录取以它为准。这些操作都是不公开的，但是结果会被公布出来。之后，所有的优惠都是以它为准，如第二预投档线是660，甲获得降20分录取的优惠，那么考到640以上可以进去了（当然，这是不确定的）。今年北航在广东招收55个人（理科），按100%投档线计算录取线是649，而第二预投档线是是647，所以我压线进去了。这不得不说是含有侥幸成分——但是到了大学，不大可能再有侥幸，拼搏吧少年！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Sat Jul 28 2012 00:00:00 GMT+0800 (中国标准时间)","slug":"zh/2012-08-04-The-Last-Course","date":"2012-08-04T12:58:00.000Z","updated":"2020-03-30T22:34:35.379Z","comments":true,"path":"categories/Misc/Records/zh/2012-08-04-The-Last-Course/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-08-04-The-Last-Course/","excerpt":"","text":"最后一节课了。其实前一天我专门找到遇见科组调课，想把1班和2班的课表调换（原：遇见C1.4/C2.3 实验C1.3/C2.4，调换之后：遇见C1.3/C2.4 实验C1.4/C2.3）想取得最大的眼泪收效，结果到了上课那一天那些家伙居然没有更改课表！（事后证明，原课表的安排也不错。） 其中，3班在昨天上了最后一个课时的课，林文琪准备的是《回忆积木小屋》。不过据反映孩子们都没看懂，所以之后我们使用这个是有很大的风险的。 [C1] 1班的学生们说，最后一天上的是他们最喜欢的三节课（十天、实验、遇见）。其实在我们来之前，十天的家伙们已经成功把他们搞哭了。（后来我们把他们的眼泪榨干了 :-)，导致遇见的效果没有预期好~） 我对这节课的准备在两天前就开始了（如果算上选曲子，那要从公开课前一天开始）。我从曲库中选出各种离别时可以放的曲子，再根据1班的特点选出最好的一首——Nothing I’ve Ever Known，作为催泪弹。 那天另外两位倒是没我准备那么充分（因为前一天我一开始拒绝透露今天我要说的内容，而最终要透露要他们准备配合的时候又因为种种原因而没人有空听）。陈晓菲做了一个幻灯片，打励志牌；黎荣舜则什么都没有（而且如果我没带无线上网卡那他真的要干讲了）。然后大家各自讲了一下各自的思路，准备开始。 原本我预计是要用 Butterfly 的不同风格（对应《数码暴龙》的开场曲和第54集的离别曲）来引入。不过班主任没有意识到课已经开始了，也就没有去维持纪律，导致引入不成功，两首歌被浪费了。 一开始是黎荣舜，他趁着我带了无线上网卡的机会下载了《倔强》的 MV，然后一上来就是不痛不痒的寄语，结束之后放视频。自然——孩子们没有什么反应。 然后是陈晓菲。她准备的是 Jessica Cox 的事迹，以及《没有翅膀的鸟》。（顺带提一下，《苍蝇的一分钟生命》也很不错。）她延续了之前我们课堂的风格，就是提问竞猜来调动气氛，让大家猜 Jessica 能做什么——当然，孩子们惊叹于 Jessica 的精神。但是我总觉得，孩子们对主旨，就是要有坚强的意志，感受不充分。而《没有翅膀的鸟》则没有得到共鸣，孩子们毕竟还是太年轻，也没有体会过生命的残缺会带来什么。最后陈晓菲一段动情的演讲——主要是讲要再逆境中拼搏——收效也不算好。 我在开场之前受到《没有翅膀的鸟》的启发，想到高考前心理辅导的老师给我们放过一个叫《蜗牛》的 Flash 短片（插话：推荐！推荐！“我一步一步向上爬，等待着太阳来照着我的脸……”），坐在我身边的一位同学（男的）因为觉得他就像那只蜗牛，当时就哭了。我开场也没说什么，就打开了这个视频，简要地概括了一下蜗牛遇到的东西（怕他们看不出），并且说了我的同学哭过的历史。他们静静地看着（对比：鸟那个，由于画风过于卡通，而且音乐也不够好，所以小孩都问“他为什么这么做”，或者是在笑），唱到第二段旋律的时候已经开始有人（蚊子）在跟着唱。当视频结束之后，孩子们看到蜗牛最终爬上了树顶，发出了惊叹声。已经有几个感情把控不住的人（1男1女）开始落泪了。接下来是重头戏，精心编辑好的幻灯片，配合 Nothing I’ve Ever Known。唱歌的过程就不细说了，有视频，而且……我唱歌很渣。唱完之后不止两个人开始哭了。（我呢？嗯，虽然说处处的眼泪已经成为一种收藏，但是为了配合情景我还是得来一点~） 至此，效果已经达到了。（据孩子们的反映，他们觉得这一段歌曲是他们印象最深刻的。“梧桐树放了一首歌，我看到歌词与现在的情景很像，我禁不住哭了。”） 然后陈晓菲准备宣布下课。班主任真的不会当啊，听到“下课”就要下课，她们估计是等下课等不及了吧？好不容易把孩子们稳住，进行最后一个环节——这个环节我之前没有设计，到了快下课为了补偿那首绝顶好听的抒情版 Butterfly，我决定顶住压力放这首歌。放的时候让他们闭上眼睛用心听，我也跟着闭眼了。一首歌曲放完，又有人哭了。有些孩子直到歌曲放完之后20秒还没睁开眼睛，他们已经沉浸在这氛围之中了。我觉得这是最成功的。 [C2] 但是对于2班这个没有1班和我们那么熟，而且更为活泼的班级来说，就要换一种策略了。催泪弹不好使，得用欢快的结局。不过他们俩估计没意识到这一点。 黎荣舜上台，还想打悲情牌，于是在我放 Butterfly 的时候他让学生回忆这10天大家做了什么。不过还好——这次没放《倔强》了，看来他有学习能力。 陈晓菲则没变，还是 Jessica+鸟。（这次，孩子们有笑的了。） 没办法，一定要改。我一上台就问：“大家想要来抒情点的，就像刚才那样，还是来欢快点的？”答案不用说了吧。然后就是一堆火柴人动画，把之前在1班而没在2班放过（因为投影仪效果没1班好，而且之前没找到音频线）的动画都在2班放了一遍。在欢笑中（严重超时了），课堂结束了。 后记：这天中午我们可是叫了外卖哦~我们和2班的孩子们一起吃的~","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"上课日志（2012-07-22~2012-07-26）","slug":"zh/2012-08-04-Rest-of-Teaching-Records","date":"2012-08-04T12:53:00.000Z","updated":"2020-03-30T22:34:35.379Z","comments":true,"path":"categories/Misc/Records/zh/2012-08-04-Rest-of-Teaching-Records/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-08-04-Rest-of-Teaching-Records/","excerpt":"","text":"这些天的课都是正式的课，最后一节课我会单列出来。 7月22日我们上的是单极马达，关于这个玩意儿，有兴趣的人可以上网找一找，其实就是电池+导线+磁铁，然后一个左手定则就解决问题了。 其实这天也没什么好讲的了。一班和二班都有点乱，其中一班更糟糕一些。 讲解原理方面，当然不能给这些小孩讲左手定则，也不能过度地讲电生磁，而且很糟糕的是他们不会知道奥斯特的。那么……我就发掘已有器材，亲手试了奥斯特实验。别说，效果真的不错：一节五号电池，一根导线（例如，电视机的信号线，不过要求是绝缘层不能太厚）和一个指南针，就可以了。（普及一下，对于还没学过这个实验的朋友，导线平行于小磁针且在其斜上方不远处时效果最好。原因的话，课本里有。）看起来1班和2班的孩子们觉得这个演示实验很新奇嘛~当然，讲解为什么小磁针会偏转时还是花了很多功夫……因为还不能涉及“场”的概念。 4班（不是我们三人小组教的）觉得这节课很无聊，原理就更不想听了。就是啊，这节课是我们上的所有课里面最难上的（因为只要弯一下铜丝就可以了，还有现成的模板，纸塔什么的还至少有小组之间的创意比拼），因为气氛很难调动——这一点和后面（第8课时）的绳子挂物的纪律难以维持形成了很大的对比。 （插播：应该是这天中午吧。我们吃午饭后，回启明时，就在校门前的斜坡上，我被一个小萝莉缠住了。这家伙好像是5班、4班还是1班的，有点忘了，不过更可能是前两个。我们一群人当时正在有说有笑地走着，突然这小萝莉就从路边逼近到路中间，拦住我的路。为什么她不拦着别人呢？我不知道。然后发生了如下对话。“呃，我要过去。”“不行。”“为什么不行？”“你要帮我买一瓶汽水。”嗯，我认人的技术很糟糕，所以认不出这家伙是谁，所以也没法做出决定。“为什么要买汽水？”“不要汽水也可以，零食。”我跟你很熟吗？虽然可能熟，但是我还是不认识你啊……所以我只好绕路，但是我向右，她也向右，我向左她也向左，挡了我几次。最后估计她也有点不好意思了，还是让我走掉了。我的脸很可能又像熟透的大番茄了！某些组员调侃说：“哇，她看上你了哟！”“你居然连一个小妹妹也不放过！”“她长得还不错哦~”啊啊啊，谁叫我不善于和女生打交道……我又不像某些人那样是大情圣，怎么样都能哄人，而是一遇到意外的事情就会脸红，并且从来只会理睬(我喜欢的&amp;&amp;道德和法律允许的)人。） 不过，启明的男女生之间倒是隔阂很严重。如，女生拒绝与男生合作，如果有一个三人小组中有一女二男（或者一男二女），则这“一个”就会在一边干看着，没有外力就不参与。 7月23日，大坑爹。 本来呢，今天我们是不用上课的。按照原来的课表，我们23、24两天都不用上课的（23日上午“浩洋学社活动”，下午游园活动；24日我们实验科组没课）。后来，上午的活动取消了（由于对方效率低下），改为上公开课！接下来你就会看到我们是怎么在23日从没课到接到课的。 一开始，原定有3个科组上课：世界银行、经济（忘了具体内容）、生活中的选择。后来，上生活中的选择的科组的一个关键人物生病了来不了，于是课程安排的家伙们要物色一个代替他们的科组。我们作为启明最受欢迎的科组，首先接到了任务（这时是科组长接的），然后我们小组都知道了这件事。考虑到我们真的很需要休息（21日我们没课，但是去听了其他科组的课），科组长花了很大的劲儿才推辞掉这个“美差”。听科组长说，当时安排课程的家伙“头上的汗就下来了”（当然，如果有一个科组缺课，这个压力对其他科组来说是很大的）。然而，我们组的其他人（其实不包括我，我还在收电脑）“兴奋地冲下楼来，告诉安排课程的家伙说我们有十足的把握上好明天那节公开课”。然后，笑容就出现在了对方的脸上~其他人高兴，她也高兴啊……他们还不知道发生了什么…… 然后就是备课！我们因为这一乌龙，只剩下一个晚上的时间去备课了。艰苦的斗争。要上一节高质量的课，只有一个晚上的准备时间……（开始还预定一组化学实验的，后来下午我们还要开会，开完会我再跑到一德路那边的时候已经晚上八点多了，化学用品店都关门了。所以即使我强烈建议要玩火，就是七氧化二锰和乙醇的实验，各种化学实验最终还是没能进行。）我们就首次地采用了YY（语音软件）。 插入：我们原定进行鸡蛋实验（一连串用鸡蛋完成的实验），所以我才会跑去买化学试剂，因为主要目标是硫酸铜（当然还有自己要的七氧化二锰和乙醇啦）。后来由于种种原因，如怕孩子觉得浪费、会导致脏乱等等，我们取消了鸡蛋实验，而换成了后面说的实验组。 那晚的讨论非常热烈，之后在YY上再也没有这么热烈的群讨论了。 总之，备着备着，到最后我们确定了几个方案：用辊子运输石块（桌子+人）、纸桥（把后面的课调到前面了！）、表面张力+大气压强，以及纸飞机。其中后两个是备用方案，撑场用的。商议出这几个方案之后我们就暂停讨论了（一点多了），我直接下线了，所以不知道他们后来说了什么。 第二天也是很坑爹的！原本约定的是7:40到（8:40开始上课），结果我7:30到（还是为了赶时间，打的赶去的），在3楼（秘密基地）和4-5楼（教室）转悠了很久，还和2班的几个家伙打了一盘斗地主~但是直到8:40，到快要上课的时候都没见到一个人影。可知道，在这期间我可是电话轰炸了（谁叫你不接电话！）罗泽仑和陈晓菲，总计37（33+4）次，但是只有最后一次陈晓菲才接了电话，并且给出来了一个非常坑爹的信息：这群家伙在2楼为公开课排练！到我下去的时候他们已经接近排练完了，我一点忙都帮不上…… 他们排练的主题是法老和神要建一座金字塔，由此引发了一串问题。啊啊啊，我没任务，所以自觉地去录像去了。（现在看来这是很正确的。很有幸，录像记录到了一切。）在录像中你可以看到那天的各种坑爹表演：在教室里，在操场上。还有最后的坑爹时间，做实验不足而自由活动有余，所以拿来放视频（建桥的视频）了…… 到了公开课结束的时候，法老（文台，郑浩鸣）和神（罗泽仑）特别受孩子们的欢迎。（孩子们觊觎的应该是他们俩的两柄权杖吧？解释一下，权杖是PVC管，就是第一个实验的实验器材之一，以及网球、一次性塑料杯和绳子粘成的，看起来蛮不错的。）几个孩子都想要这权杖，权杖几经易手，最终被两个5班的女生拿了，而她们最喜欢的事情是拿着权杖，用网球或杯子对着人的胸口大喊：“神命令你死去！嗞嗞嗞……”大佬和文台都很配合，做倒下状。而我则拒绝倒下（哼，我才不吃你这一套），所以直到第二天她们都会追着我问“为什么你还不死”…… 中午出现餐具。林文琪同志（会骑自行车）与陈嘉怡同志（不会骑自行车）两位因为公开课上完了且非常成功而非常高兴，在校门口借了1班一位学生的自行车，然后林骑车，陈坐在后座上，从大斜坡上滑下去。（唉，当时我傻了，没有先分析该行为的危险性而做出风险评估。估计也是被公开课冲昏了脑子，也跟着大笑着跑了下去追车玩。）林文琪是下惯了这种坡，喜欢不减速而直接冲到坡底。到了离坡顶三分之一的地方，陈嘉怡对当前的速度感到恐惧，想让林文琪停车。（但是林文琪正在兴奋地尖叫诶，哪里注意过后座上的人怎么想。）然后，她选择了直接跳车。砰！陈嘉怡就摔倒地上了。当时擦破了左手的第一关节，左手臂和额头，感觉颅骨受到重击。（嗯，透露一下，她哭了。如果陈嘉怡同志想删掉这个描述可以跟我说。）然后……就是鲁迅先生说的，围观。学生、附近杂货店的小孩和一些大人都来围观。（纯粹看热闹的人应该被清除。）好不容易把他们赶走之后有几个好心的人来了：一个学生和一个大人拿来了创可贴，还有双氧水。当然，这种小伤，在这样的路面上跌倒，最好不要用创可贴，因为用了反而容易感染破伤风（学过高中生物的都应该能理解）；双氧水的话，会很疼，我们担心陈嘉怡受不了（哭上加哭……），也没用。过了几分钟，一个学生（6班，钟礼剑）留了下来。他说他知道附近的医院（我们要解决的主要是脑震荡的可能性，所以最好去医院），我们就跟他走了。 在前往医院（同和医院）的途中，钟礼剑和我聊了一路。主要内容是他以前曾经多次摔过手，其中4次骨折；而同和医院原来是一个治骨头的医生开的小诊所，后来他越来越有名，诊所也越来越大，后来发展成同和医院。这个医生成为师傅之后培养了一堆徒弟，而这些徒弟们则是目前医院骨科的中坚，不过他本人隔一天会来一次医院。废话不多说。到了医院，主要就是一系列医疗操作啦。等了一段时间之后，诊断，处理，开药，打针（包括试针）。（于是后来几天陈嘉怡都以伤口涂着一篇红药水的样貌出现。）钟礼剑一直陪着我们 下午游园会，我本来是第8组的（在2班），但是我们组因为经历了公开课和中午的事情，都很累了，所以没有参与游园的组织。不过我们还是去玩了一下。我本人玩了说颜色的游戏，光凭破纪录的得分就有12分了，不过我没打算计算积分。（不过最后的最后，我的记录在雄踞了30分钟之后被一个胖胖的女生以一个之差打破了……） 7月24日 因为台风来到广州，所以两个营区都停课了。到了晚上天气好的时候，我去购书中心买了点书。 7月25日 第一节是6班的课，忘了具体的情况。 下课之后还去串课……然后好像是第三节，我破坏课堂秩序，估计把新课堂小组的家伙气死了…… 这两节课，我因为没有对这节课的讲课预期，而且连续主讲了几天比较累，所以把讲课的任务交给另外两位了。 下午我们做的是绳子挂物的实验。（解释一下，就是把各种小东西挂在一根绳子上，挂上会有相应的加分，而用工具则会按扣分。）然后……黎荣舜同志编造了一个令人无语的情景，什么八路军要运物资抵达，反正一较真就不堪一击的那种。关于这个实验，我们老师做的最好成绩是扣70分挂起所有物资，用了一张A4纸和2个回形针。 下午是1班的课，气氛很活跃。不过由于快到结营了，所以纪律比较乱。1班的课没有什么好讲的。 虽然2班是在26日上的课，但是我还是要把它移到这里讲。 26日上午第一节，因为3班和4班同时上课，我们得去帮忙。这两个班的孩子们都很有创造力，有两个组做出了只扣60分就完成的方案，一个回形针和一张A4纸。（我们老师原本还要讲解最佳挂物的方式并且展示我们的方案的，结果现在都不敢了。）这些都有录像。 到了2班，我又把自己当做学生，他们俩讲解完规则之后，我直接和一组学生在那里玩了。他们试验了一些方案之后还是没有完成，而此时别的小组都已经挂完了所有物资（最好成绩也是扣60分）。原来他们的设计是把绳子挂物作为一个小组竞赛来进行的。既然赢不了，我就和他们一起挑战理论极限——扣30分解决问题。我们不断尝试（多亏有一个小孩指出了正确方案来说服同伴，因为我不好直接点明）。到了下课，课间都结束了，我们组还在继续——这又把新课堂的家伙们气死了，因为这一节是语文课，我们搞得小孩子过度兴奋……不过我们还是保留了进度。 第四节上课一开始我们继续尝试，用了大约5分钟，我们成功了！只扣30分！三根橡皮筋解决！当然3班和4班的人不服，因为他们的物资是有3个网球的（因为各个班级的时间问题，我们安排的物资数量是不尽相同的），而我们只有两个。但是由于设计上我们只能容纳两个网球的位置，无法加入第三个网球，所以之后加码的尝试失败了。 出现的神级方案：一根橡皮筋挂两个网球（3班），以及一个回形针夹着一张包着所有东西的A4纸（3班、4班）。有照片。 7月26日 倒数第二节课。由于之前一天我们对这节课的安排产生了分歧，故不同小组上课的内容不一样。5班、6班按照原定的计划上纸飞机的制作与原理讲解，3班、4班按照小孩子的要求（虽然最后他们讨厌这节课）上了厕所中的科学（囧！主要是马桶的连通器原理和电灯泡的拱形原理），我们则把公开课没用上的表面张力讲了一下。（呼~前一天我可是做了充足的准备的，包括翻译了一段 National Geography 的视频……） 先上的是2班，这堂课很正常。1班则在一开始谁也没有放成功（包括我们老师），导致了小小的混乱。其他的还好。 （附记：刚才是2012-08-04 19:00，女子赛艇项目最后一桨真的是决定胜负的关键！我拍着手大叫“银牌，不要拿铜牌”……最终中国的家伙们还是很争气~希腊的家伙们估计要气死了。） 附：小组安排 [启明] 吴桐、陈晓菲、黎荣舜 - C1/C2 陈文豪、林文琪、赖其祺 - C3/C4 罗泽仑、陈嘉怡（、郑浩鸣） - C5/C6 [春华] 吴鸣、林静、何绮祺 - C1/C2","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"记昨天晚上回家路上发生的有趣事情","slug":"zh/2012-08-01-Funny-Things-Happend-on-the-Way-Back-Home","date":"2012-08-01T08:54:00.000Z","updated":"2020-03-30T22:34:35.379Z","comments":true,"path":"categories/Misc/Records/zh/2012-08-01-Funny-Things-Happend-on-the-Way-Back-Home/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-08-01-Funny-Things-Happend-on-the-Way-Back-Home/","excerpt":"","text":"昨天看完电影（秘密，拒绝透露）回家，走到楼下的喜士多想买点东西。进门发现一下一个结账的是一个老外（这家伙买了一堆馒头和士力架）。 收款员：（显示器上显示金额为23.5元） 然后，这老外掏出一张10元和四张1元。高潮来了。此时他手中还有一张50元、一张10元和一张5元，只见他把5元递了过去！ 收款员估计被雷到了…… 这时我正试着直接用手去帮他指明该拿哪一张钱。 幸好收款员会说一点英语（我SB了，为什么我不直接说出来而要指……），直接用英语说：“Ten Yuan.”老外：“Ten Yuan? Oh, ten Yuan.”然后他把10元递了过去。 此时我正站在他的右后方（他斜对着收款机），估计也很尴尬，想看看周围有没有人发现这么囧的事情。他看到我盯着他和收款机，低头（他比我高）挤出一丝微笑（他应该知道我知道刚才发生了什么了，所以会觉得有点苦逼……）。作为回礼，我也得微笑……感觉有点像兔斯基的“无所谓”的 feel（没错，兔斯基一般情况下没有除了眼睛之外的五官，不过动作总是会给人一种 feel 的嘛）~ 然后这老外被找了五毛，右手提着馒头左手攥着（没错！大手！）士力架出门了…… 现在我能体会某些老外数学是怎么学的了！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"华师附中2012届高三(1)班众人小传 [18/57]","slug":"zh/2012-07-24-Members-Of-Class-One-Senior-Three","date":"2012-07-23T16:23:00.000Z","updated":"2015-01-23T08:19:00.000Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-24-Members-Of-Class-One-Senior-Three/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-24-Members-Of-Class-One-Senior-Three/","excerpt":"高三一班的同学们。 2016-05-25 附注：原地址在 http://hi.baidu.com/micstudio/item/d45f65e9dfa45f2b5a7cfb41。","text":"高三一班的同学们。 2016-05-25 附注：原地址在 http://hi.baidu.com/micstudio/item/d45f65e9dfa45f2b5a7cfb41。 CDA M M HF 蔡德安 CDA，别名“黑人”（因为……他就是黑，至少比普通人黑多了），是数学牛人，在高三进了数学集训队。 但同时，此人也非常地不守纪律~除了数学，打牌、足球、篮球、桌球等等，样样精通。宋老师曾经跑到操场，把他抓回教室……此外，在其他科，他只能说是马马虎虎，及格过一点。当然，这些并不影响他高超的数学水平，更不影响他与其他人的关系。 CSJ M C HF 苍思骏 CSJ听说是满族人（没考证过）。他一向比较严肃，下课了也不会出去溜达，而是在座位上做各种参考书或者继续看课本。 他的思维非常理性，甚至有点……批判力过强了。班级讨论一些有争议的社会现象时，就是他展现风采的时候了~他能用坚定的语气、严密的推理来告诉你，他的观点是有很强的依据的。 他的一个喜好是动漫（不是动画！）和游戏。美系、日系等等，他都会去了解。我和他聊游戏经常是这样的——我：“xxx不错，因为……”他：“xxx其实很久之前就已经……了，现在……”比如一说起《罪恶王冠》或者《寄生前夜》，他总会吧啦吧啦地说上不停，搞得我晕头转向。好吧，听着他讲话，我确实学到了很多东西，主要是动漫方面的前沿知识和一些历史。 他居然会在高三的时候还有时间在晚上九点半之后用电脑！但是说真的，他的成绩属于中等，中等的中间。 他说话的时候，怎么描述呢，就是那种程度比较浅的一惊一乍吧。说话力度、速度和音调的变化，让他说的话增彩了~ 另外，他中午一般不吃饭，如果吃也只是一包饼干或者方便面，不知道为什么。= =! 还有，建议不要听他唱歌，要不然你会“三月不知肉味”……因为你不断呕吐。 CCJ M P HF 陈昌嘉 CCJ主要被称作“禽兽”（因他在球场上冲撞非常暴力）、“有钱”（不用解释了吧）或者“Man X（为隐匿身份需要，不显示这个字）”（这个不知道怎么来的了）。 我们班用最多电子设备、最多电子设备可供使用的四个人中，他可以算是为首的那个。高三的时候，他经常带着iPhone、拴着耳机在教室里做题……（#少儿不宜#然后他的其中一位EX，或者他的同桌，就会观看）。特备是苹果——一些新潮的电子产品，他总会在第一时间买到。不知道这要有多有钱啊~ 他是电教员，应该算是班里计算机技术第二好的人了吧。（第一是谁？鄙人。）由于有电教员这个公开的职务作为招牌，每当老师遇到什么问题（主要是投影仪显示不了之类的）就会先叫：“电教员！”然后CCJ就屁颠屁颠地跑上讲台，解决问题……（呃，你是在黑化他吗？） 学习不错，典型的高富帅+成绩好，特招雌性人类的喜爱……戴着眼镜、斯斯文文、头发前伸的样子，估计很多雌性人类第一眼看过去就想把他推倒吧~（喂，对象反了？） #少儿不宜#关于他的私生活，我并不知道多少，比如周末带着什么跟谁聊天之类的，只知道……EX，至少是相互之间有过很强好感的，有多个。 CJL F P HF 陈景莉 某高官女儿！语文成绩优秀！有众多社会实践经验！非常（非常）外向！ 听到这些，你是不是想付998，把她抱回家？建议不要……不仅是因为你买不起，更是因为她太骚了。（警告：个人观点，切勿引申！） 每次作文都会因贴近生活、文笔优美而受到表扬，多次被称作“小清新”我承认，这些真的让人望尘莫及。如果要从感情路线下手写作文，她的作文可是全班第一的。 另外，由于某种特殊原因，她总是能收到各种社会活动的最新最真切的消息。然后就是滚雪球，参加更多的社会活动，积累更多的社会+经济资源……天啊，我们这些屌丝们，这些矮穷挫们，怎么活！（P.S. 看路计划也是这么进的么？） 另外，她也是新电子产品的拥趸之一，而且经常会去跟CCJ攀比（+各种小鸟依人）……唉，我们这些技术员们，没有这么好的装备，但是听那些只会求新产品的SB们讨论问题，能听到各种垃圾……深切鄙视。算了算了，资源不均，是社会常态。 最雷的是，她会不分对象地过度亲近。怎么讲？每次看到班里谁谁发生什么新奇的事情，或者带来什么新奇的东西，她就会凑过去说：“你（或者‘这个’）好……哦！”不，你们没见到，她说话时的表情与动作！举个栗子。（掉下一个桃子= =）在做班级的成人典礼画册时我把笔记本带到了教室。自然很多人都想看别人小时候的样子。你知道吗？当时我是操作员，坐在一张椅子上，她坐在旁边的椅子上（还是站在我旁边？），用手指着屏幕，还向我压过来……压过来……阿弥陀佛……老衲元阳未失，哪敢跟你们这种东西风流！ CJN M P NHF 陈俊能 CJN，又叫“JJX（同样和谐了）”，最出名的外号莫过于“叫兽”了。这是因为，他总是能在课堂上老师提问时冒出一些无厘头的话。（当然对于我这种追求正统课堂的人来说，那些是糟粕，所以我不建议老师对此行为表示赞赏。）他打篮球是一把好手~ 他来自哪里我忘了，反正是一个小镇。正因为如此，他才积累了小镇生活的许多经验（比如收稻子，在学农时派上了用场，使得大家纷纷跑去学习），而且非常了解他那一带农村的乡土人情，例如在我看来仍旧是一团乱麻的辈分……他植根于乡土，所以他一定不会走偏路。 识别特征是他那一头非常有型的头发…… CRF M P HF 陈润方 不是我夸张，CRF的额头真的非常大（程度接近我们的一个初中同学“博导”-HJD），而且头发一般形似麦当劳的标志“M”。一般人们认为， 额头大（天庭饱满）的人都会聪明，这一点在CRF身上得到了验证。（CRF：“放狗屁！”）没错，这也是他的一个重要特征——只认自己觉得对的事情。他不仅额头大，嗓门也大。他低声说话时也能旁人听得清楚，而当他要和人争论时，只需要凭极快的语速+大嗓门，就可以对对方进行火力压制，更别提他还有于无理中找理的超强能力。（只有同样能在没理中找出道理，还要有气场的人才能和他对抗，如LYG、DJC。）不同意一个人的观点的时候，他可以把话说得非常难听；不过这种直率的性格也未失其可爱之处。不过这种无理和无礼是暂时的，只有别人冒犯他（或者他故意侵犯别人）时才会展现。 比起语言上的压制，他更多是从智力上进行压制。作为物理组的中坚之一，CRF在物理和数学方面非常有天赋。值得一提的是，他不是死学的（后面其中一位是，不点名），而是真正的有兴趣、想深究，并将新知识融入原有体系中。如果体系之间对立，他就会去验证每一个，并鄙视不合理的。而且他很善于提问题，在理科科学上，或者在宿舍夜谈中（能把人噎死）。物理组的老师肯定尝过被他穷追猛打的滋味…… 之前我说他很聪明，如果你认为就是在物理和数学上，那就错了——他在语文上也颇有积累（学贯文理？）！他偏爱古风（非律诗），不过对之后的作品（到当代。这里面他最欣赏近代的作品）也有欣赏水准，经常会指出一句（或者说出一句），然后说：“啊，你看这个，写得多……”不仅是诗词，还有文章……（天，这个列举什么时候才到头啊……）因为有一些积累和独到的体会，所以他在语文课上会对一些作品发表自己的看法，而不在乎语文老师怎么看或者《大纲》要怎么解读（“我对这个倒是有不一样的理解，是……所以XXX是错的！”），甚至会当场驳斥老师。如果说CSJ在逻辑方面能把人撂倒的话，CRF就能在文学方面把人撂倒。（说实话，我倒是觉得他有梁实秋的风范……） 因为早早地就被保送了，所以他会在语文课上看古文书，或者近代大家的作品（我们这些要高考的苦逼们只有读课本和习题的份……）。甚至，他还会在数学课上刷题完成之后（当然又是抱着鄙视的态度）看他想念的文字——数学老师还恼过一次。（为了给我们营造良好的高考备考氛围，数学老师决定无论保送生还是非保送生都必须完成一本厚厚的《走向高考》。于是有：“你怎么在看这些？”“老师我做完了。”“做完了就接着往后做呗！”“^&amp;$^%*&amp;”） 作为一名物理组的学生，他肯定要学习比较高深的物理（当然还有数学）知识，包括现代物理。学了之后他就经常发牢骚，认为课本上的东西太陈旧，同学们应该扔掉课本，去领会现代物理的美……不过对于物理竞赛倒还是认真的，在高三上学期结束时，他清理物品，送给我一套他高一时用的物理竞赛书，我后来看了，上面有很认真的解答和批注。——嗯，是不是说明才高气盛呢？还是因为被保送了，在一模之后他开始变得有点伤感了——也许是骨子里的文人气质，总之他开始对高中、对同学表示各种怀念。斗嘴之类的事情少了很多，变多的是散播离别的情绪…… DJC M M NHF 杜稼淳 密友，外号“村长”。我的交际能力较弱，或者说，我习惯于将自己封闭在一个安全的圈子里；而他则四处交友（当然，与大多数人相互之间只是“我知道这家伙”的关系，他知道这一点），所以交际圈比较大，也很容易得到最新信息，然后选其中与我相关的告诉我。正因为这一点，他对我而言非常重要。（看下文之后，你就会觉得这样一个硬实力+软实力兼备的家伙，好大学不要真是可惜了。） 他在学习上比我有天赋，而且比我努力——例如生物，当我刷完《导与练》的时候，他已经刷了《导与练》+《备考指南》，选做了《五三》+《三二》（之后就会向我推荐一些好题，并指出哪些题很烂）。而且他擅长数学，这不是他一进班里就有的，而是真正的刷题刷出来的。再加上后来冲击省一等奖和明天小小科学家失败而被迫高考，他学得非常拼命，可以说兼有数学组中保送生的高水平和高考考生的细心耐心。不过不知是什么问题，他总是无法进入年级前十，每次都有莫明其妙的丢分（像我一样……）。不过从前期表现看来他是有冲击清北的实力的，可惜最后只去了浙大（但是对于这种强人来说，没有双学位怎么能行呢？所以……） （插话：为什么一定只要上这两所大学呢？每个人应该根据自己的兴趣或者未来要的专业来选学校，清北只是综合性的学校。例如，要通信就去北京邮电大学，信息安全就去西安电子科技大学，等等，“好学校”的标准是相应专业要强，而不一定是有多有名。） 但是，他可不是书呆子。科创、文艺，都搞，虽然结果都不算好（科创的结果是被坑的，与此相反的是CJL）。但是不要以为他真的就一无所成，我敢说，如果黑幕少一些，他的作品绝对是站前排的。至于唱歌……我不作评论。 有高EQ，他的沟通能力自然比较强。他知道在什么场合什么时间对什么人说什么话（我则要对此进行大量运算，如果周围都是熟人我就会表现得EQ超低，因为这个太费脑力了），自然能拉拢人，以及获得更好的资源——以人际关系为基础的资源。他表面上看起来很粗枝大叶，走起路来大开大合（晃身子、手臂，一边走路一边喝水瓶里的水），但是在处理人际关系时的细心是很少人能达到的。我的评价是，他是坚定的盟友，而且不会是背后捅刀子的人（虽然他会把此类想法向非常非常亲密的人说）。 DWC M M HF 杜文超 道袍，拂尘。作为班上文化与CRF相当的人（二者都喜欢研究中国传统文化），以及在占卜方面与WGC相当的人，DWC的功力可不是一般的高。他广泛地阅读了许多典籍（嗯，很多我叫不上名来），有时在说话的时候（伴随着捶腿）会微笑着蹦出几句话。不过，他得的储备究竟有多少，我拿不准；唯一能确定的是，非常多。同时，作为班上宗教理论界的领军人物（LZK同志只是喜欢愉快地戏说基督教的东西），他也研究了道教（主修）、佛教和基督教的一些内容。我倒有些相信，他在宗教中他汲取的不仅有信仰（这个，他没公开过），还有一种平和，以及一些宗教知识（用来纠正同学们和老师的错误看法）。可以说，他是班里心情和脾气最好的人，即使到后来他的化学暂时落后（最终还是很强悍的）的时候他还是在微笑着学习。另外，他真的从没有生气——这点上脾气也比较好的WYK有点缺憾。 HS M C HF 黄山 HS同学喜欢每天把早餐带到教室吃，就在早读结束的时候；他一边嚼着面包（嗉囊有多大！如果按照实际利用体积，可以和WLH持平了）一边拿着一盒牛奶一边和LY/SXJ（或者其他人）聊天或讨论题目。（插话：HS/LY/SXJ之间似乎有一种基友铁三角的联系……） HS的体育能力是众人皆知的，喜欢打羽毛球、踢足球，有时也去篮球场上爽一把。在长跑中，他的能力表现得尤其明显——所谓“钢铁般的耐力”，就是跑完之后气喘不强，还能从容地讨论数学题。爱运动，自然汗腺分泌旺盛。所以，在夏季，你经常可以看见HS的后背是湿的；更可怕的是，衣服湿了之后他只会翻出一件干衣服（并脱下原来的）套上。如果你细心看他的衣服，你会发现，他的一些衣服是泛黄的，有硬化的痕迹，那就是他的汗液导致的。（更可怕更可怕的是，他洗衣服的频率最高是两天一次，袜子是一周一次。不过高三后期频率有所提升。他的洗澡频率在高二下学期——请注意是夏天——达到了惊人的平均2天一次！所以如果你闻到了一股长时间存在的“妙不可言”的味道，那这多半是HS的杰作。） HS经常笑，甚至可以说是见到人就笑。当然，这种笑产生的原因不是他高兴，而是因为他有一种强大的气场（至少是他这么认为吧）。例如，在与SXJ“打情骂俏”时HS会大叫“SXH”（SXJ的某亲属），后面经常跟一个“呵呵”（用力地），脸上伴随着得意的笑容。另外，他在讲题或和人讨论题（不管他是居上风还是下风）的时候都会有“呵呵”出现。所以，HS是没有表现出情感上的笑的，他一直处于理性的状态。个人意见，HS找妹子不是难事（他身上总有一种彬彬有礼的学霸范儿），但是在生活中与之相处就麻烦了。 HHF F M HF 黄红枫 HHF是我最少接触的人之一（第一，没必要；第二，这些事还是越少碰上越好吧）。如果从星座的角度看，她是天秤座的代表，核心词是优雅。她的嗓音很特别，会令人怀疑是猫叫，声音小、柔和，但清晰。HHF在初中的时候就已经长得比较好看了，所以据说在初中就有某君追她；到了高中，又是一些关系，但是这些关系的证据从来没有被发现过，只有痕迹，所以我们其他人也只能说她“和某某某相互有好感”。（值得一提的是，在高三，她被分到ZYX旁边之后，两人的好感度不是一般地高，至少是可以察觉的。但这并不意味着她没有其他追求者。这些我了解得不多，对内幕也没有如DJC这样的消息中转站那么熟知。）其学习能力，作为一个考入了数学组的女生，是不容置疑的，在高三宋老师也称赞过她几次。 我们之间也没说过几次话，我也没观察过她，所以资料不多。 PS. 从成人礼上她提供的照片来看，她很喜欢自拍。虽然这不是什么罕见的事情，但是我们班其他女生都是很“朴实”的，也就是不怎么在意自己在社交网络上以照片形式出现的形象，最多也只是像ZXK那样写纯发泄无理性的日志。 HQS M M HF 黄秋实 HQS……怎么说好呢？从外表看，他是一个很可爱的人（因此被CDA等数学组闲得蛋疼的家伙们赠送外号“可爱Q”），但是他的思想其实挺成熟的——所以不要被骗了。例如他喜欢和CDA、CCJ和LHR等球迷讨论球队的战绩。他也是那种伪球迷，知道各个队的情况但是自己不去踢球（还别说，他还真的去过几次，不过就他略显矮胖的身材来说真的为难他了），这种感觉就像是你和一个十岁小孩在谈足球。而他又是比较随和的人，不像LHR那样锋芒毕露，这才是奇怪的根源。 HQS长着一个肉乎乎的脸，而他又实行“不抵抗”（其实也有抵抗，不过这种手臂的无力挥舞对正常人不构成威胁）策略，所以经常会被众人捏脸。不知道是不是捏多了的后果，他的脸是有点白的，脸颊一般是微微粉红的。大多数时候他都是笑着的（咧开嘴），至少不会生气——他从来没有真正生过气。他严肃和笑的时间界限并不是很明显，例如捏脸，有时他会笑，有时会嘟着嘴反抗。不过能确定的是，他在思考题目或者被人推翻假设的时候脸上的表情是专注的；而给别人讲题的时候，如果是面对面的，他就会讲一下抬头看一下对方然后再看纸，此时他的面容中有小孩子般的得意（他的眼睛不大，而且是在高度近视眼镜后面，但是他会瞪大眼睛看着你），也有关切（如果对方迟迟不能理解这就不好了）。从相学上分析，他的眉间距很宽，眉淡，因此是个没有心机的人。也就是说，他一直是这样，至少是看上去的，懵懵懂懂，但是只是因为他对生活不关心而已，所谓“如婴儿”（老子）。 不要因为他长着娃娃脸就小看了他的实力，他可是宋老师的骄傲——宋老师喜欢他甚于WLH、CDA等人，认为他才是天才和苦干的化身（WLH不是天才但是肯吃苦，CDA脑子灵但是喜欢往球场跑）。虽说他在生活中不拘小节（但是也能找到理解他的人），但是在数学方面他可是一点都不含糊。总而言之，HQS是非常精明的，只不过表现得像顽童一样。 HYY M P HF 黄宇阳 香蕉，而且是一根粗大的香蕉。HYY这个外号的来源，据说是初二的时候他和LZQ去正门对面的麦当劳吃饭，饭后在奶茶店买甜品的时候LZQ不知怎么（这个嘛，估计是选口味啥的）就提到了这个词并将其用于形容HYY而他高兴地接受了。这样，回来之后他就成了一根香蕉。一直到初二期末，当我们提到同音词（如“相交”，特别是上数学课，讲解析几何中直线与圆的位置关系）的时候，如果HYY也在场，我们自然心领神会——除了数学老师。HYY的体型，算得上庞大了。他在高三体检的时候是1米92，体重……我记得是过70（公斤）了。或许你认为他是一个胖子，其实他不是，你只需要把一个男篮队员压扁一点，把肌肉中脂肪的成分增多一点（至少看不见膝盖骨；这样他膝盖上的疤痕，缝针留下的，就看得很清楚了，就像一条肥肥的水蛭），就是他的样子了。从脸型上，他有点像王治郅，但是透出来的气质不像。他属于比较健谈的人，这种健谈的性质是他牵着对方的鼻子走，而不是跟你侃大山。或者这种描述不准确，是他选择的话题总是那么——没深度，如果是闲来无事听听也容易让人厌烦，但是如果想从他那里获取什么有用的信息，那纯粹是白费力。他擅长的是对已知的“趣闻”进行再包装（很容易辨别出来，特别是你知道原始信息的时候），然后讲给不知道的人听，对方就会认为他博闻强识、谈吐风趣。结果表明，这种方法对ZXK非常有用，以至于&amp;^&amp;!@^$@#&amp;#……（和谐一万字）他的人缘很好，估计就是这种“亲和力”带来的；试想，如果有人每次见到你的时候会跟你聊一下“有趣的”、你不知道的东西，或者“挑逗”你，你可能就会认为这个人挺好相处的了。（我不吃这一套，也无法证明为何这种方法对人类有效，还可能带来使役权等附加好处。）但是，他不得不令人佩服的是他对信息的接收能力很强。他和ZXK是在班上我见过的两个短期记忆最强的人，基本上一本高一政治书在一个下午+晚上刷完之后，第二天答题就可以85+（就是主要表述都可以记住，而且会见人说人话，见鬼说鬼话）。而且基本上所有科目都是这样，而且成绩属于中上偏上，在我们班。（这就是为什么后来我们似乎都看好HYY vs. ZXK，特别是两个人亲密接触的时候。两人有接近相同的天赋，相同的兴趣，相同的逻辑，与相同的思维深度；唯一的障碍是身高差距，30厘米。）作为一个CCJ的好友，对电子产品的了解是不可缺少的。班上使用iPhone的就3个人（不包括HS，他在高三后期获得物质奖励），CJL、CCJ和HYY。HYY的观点是，只买最新潮的，不管它有多贵，也不用知道其工作原理——会用App就够了。这样的特性使得一些雌性被他吸引（想想，高富帅啊），他游走于她们之间，给其中的所有人留下好感（主要方式是炫耀或出借他的电子产品，在别人用他的电子产品的时候站在旁边微笑着指导），但是程度是相近的。另一个吸引力必杀技是羽毛球，可以想象这么大一个家伙，在球场上奋力挥拍的情景——展现灵活性和智力，肯定会吸引一些雌性。ZXK、YXT和LZQ都经常和他打羽毛球（一般是ZXK、YXT、QH和他，然后分两组；LZQ在的时候也可能参与），但是就身高和/或力量来说，那三位显然太弱了…… 香蕉，而且是一根粗大的香蕉。 HYY这个关于水果（可以切么？）的外号的来历据传可以追溯到初二。初二某天，HYY与LZQ（一直到北京夏令营，他们还是这么频繁地接触）出去在学校正门对面吃M记（麦当劳），然后去旁边买了一些零食饮料什么的。不知为何LZQ就提起了“香蕉”，而HYY欣然接受。我忘了是当时QH等在场，还是回来之后LZQ还是这么称呼HYY，总之“香蕉”这一“雅号”就这么传开了。老师们自然不知内幕，例如数学老师，在讲到平面几何的元素的位置关系时，相交、相切、相离、包含等等必然是经常出现的。各位看官，发现亮点了吗？所以在“香蕉”刚刚传开的时候，级里的人听到同音的词就会会心一笑，甚至在数学课上忍不住笑出来。老师自然奇怪：几何元素有什么好笑的？后来，就像绝大多数绰号一样（也有少数被冲刷掉了，如“叉烧包”，这是另一个人的外号），人们都接受了这个绰号，不再笑了。（后来高中生物必修二的时候，“三倍体”作为香蕉的代称流行了一阵。） 香蕉，不对，HYY是社交高手。他身上有一种类似周星驰的地痞气；但是就如周星星，他也总是会使气氛活跃起来，从而吸引很多人。（年级里的女生几乎都认识他，而且关系还不错……）不要以为他是个花架子，他的学习能力也很强，短期记忆能力特别好，可以与ZXK相提并论。就是说，考试前刷三小时课本，第二天他准考85+。而且他还善于提问——这应该是积累的吧，黄爱国老师也挺欣赏他的。 如前文所说，粗大的香蕉。HYY的身高在高三体检时为192厘米，是我们班最高的。同时，他的体积还特别大，不是肥胖，是那种保镖少一点肌肉的样子，一张大脸上总是挂着似笑非笑的表情（不定时显露出邪恶的笑容）。他的头发如其个性，中等长度，但是都是向上长的，真的像青青的草，不垂下来的。他经常和QH、YXT、ZXK和LZQ等去羽毛球场爽一把，自然后三位都不是他的对手。 在生活方面，HYY和CCJ一样是高富帅。班里只有三个人用iPhone，HYY、CCJ和CJL。而且，新潮的电子产品，他总会和QH、ZXK等展示、讨论一阵。 LMY F P NHF 李梦瑶 LMY是非常安静的一个人。在人群中，如果她不说话，应该不会有人注意到她。她的眼睛总是很有神的，不管是在平时（面无表情），还是在和人讲话的时候（会盯着对方的眼睛），或者笑的时候（腼腆地）。她的语速比较慢，即使在紧急的时候也是这样，而且音调会出现红移和蓝移（紧张的时候波动频率加快）。她走路的时候，特别是上学放学的时候，背着书包，身体前倾，头轴线和地平面成约60°，而且每一步都迈得很稳，虽然速度比较慢，但是感觉很用心。总之，她的肢体动作总是比较慢的。她有理顺头发的习惯，中分头，中等长度的头发，也总是将头发捋一捋，使其保持一部分在肩膀前面，另一部分在肩膀后面，颇有完美主义者的风范。 在高一的时候，LMY就进入了M组旁听（因为自身是P组的），而且成绩不错。这说明了她智力超常（不像鄙人，后来狼狈地逃走了）。高三的时候她的成绩一直处于中上（高考时爆发了），数学成绩一直保持在125~145；宋老师每次都很看好她，她也没有辜负期望。（语文和英语都很好！）她的前额很开阔，就像CRF一样，以至于第一眼看上去觉得这比例就是不对。 虽然LMY比较安静，但她心里是很活泼的。她一直和YJ是同桌（两位英语牛人坐在一起），喜欢配合着（有时还要加上ZXK）开玩笑，例如戏弄“羞涩小男生”。她在我们班成名于高一的课本剧表演，我们选择的是《孔雀东南飞》。（该剧中，HS是焦仲卿，LMY是刘兰芝，WLH反串贾母，县官是谁我忘了，YXT和ZXK是俩酱油。该剧演出时的最大亮点在于WLH罕见的反串。）到了最后，刘兰芝“举身赴清池”，焦仲卿“自挂东南枝”，而最后的最后两人成了比翼鸟、连理枝；HS（这次是他唯一的“绯闻”；当然，HS同学到底想什么我们不知道）和LMY两人携手共立，俩酱油撒花，由此《孔》在我们班就成了青春偶像剧。= =b 到了高二元旦班会的时候，我忘记当时一部分男生合唱什么了，到中间LMY听不下去了，也冲上去和他们一起唱。HS一直唱得特别卖力，LMY上台之后也没有减退热情（但肯定注意到了）。其他男同胞们自动退后，用手臂给他们围了一颗心，其余的观众起哄。不知这珍贵的一幕是否被照相机所留存…… LY M M HF 李越 “初三（1）班，LY无敌！”“高一（1）班，LY无敌！”“高二（1）班，LY无敌！”“高三（1）班，LY无敌”！ 从初三（也可能是初二，待考）开始，LY同学就被冠以“无敌”的称号。从这个称号就可以看出，LY在初中的时候已经是学习上的超人了。其实，说李越有什么特别的，也没有什么，就是那种普通的人。 或者让我稍微具体地描述一下吧。如前文所说，LY喜欢和HS、SXJ没事小打小闹，不外乎“SXH”、“H稣”和“无敌Y”这三个关键词。LY和YXT一样，在下课之后会追着老师问问题，而且语调就让人觉得他有基础，但是不懂这个问题（这个我也模仿不出来），因此更容易获得关注。还有讨论数学题——其实根据观察，LY数学天赋比起其他一些数学组的人来说并不高，但是他很勤奋，即使苦练了上千道题才达到HQS水平的一半他也愿意继续钻研。 LY的英语和语文都很好。英语是标准的美音，而且很会演讲（高三时的青春旋律艺术节上，作为英语演讲大赛的第一名，他好好地展示了他的英语功底）。英文作文可以说是四平八稳的，词汇量很大，但是应该是高考所限吧。至于语文，因为LY很喜欢西藏也很喜欢去西藏，所以他的作文主题经常是关于西藏的美，以及人性、自然的纯洁肃穆的。 还有一点，LY的游泳水平很好，不过此时可以看到赘肉均匀地分布在腹部，却毫无违和感，这很有意思。 LKS M M HF 梁凯升 LKS，别名“L Man”，应该算是除了CDA之外的班上最黑的人了。现在想想，这种肤色应该被称为“巧克力色”吧，配上一头柔顺又不失硬朗的黑发，再加上面部的构造，那简直是个印度人（虽然应该不是，应该吧）。 LKS又高又瘦（所以会长时间被安排为HYY的同桌），而且是从四肢看上去就是那种“骨格精奇”的人。他一直充满活力，与人对话的时候总用谦虚的语气，说话的节奏也是一顿一顿的，在一个关键点处到达顶峰，短时间的空白后又着急速下降，就像过山车一样。 他的人缘挺好，数学能力也很强，至少是被宋老师点名称赞过的。我不怎么和他打交道，不过在他一直称呼我为“J”（就是这个字母啦），这是从初中沿袭下来的习惯了。 LHJ M xM NHF 赖宏基 我并不怎么接触LHJ，毕竟他和我一样也不大有存在感。一般被称为“肥J”。社交圈子好像也很小，一般和LZB、LHZ一起行动。 在M组内好像没怎么做好，在高二下文理分科后转到2班了。 LYY F C HF 梁颖怡 LYY最讨厌别人称呼她为“肥婆”，若是有人这么干了一定会被她拿着卷起来的习题册追着打。当然，实事求是地说，从外表上来看，我总感觉她是一个大概1×1×3（长×宽×高）的长方体。而且不仅整体看上去像一个长方体，我似乎觉得分块观察也是类似的形状，尤其是头。 在日常对话的时候用的口气相当于《功夫》里的包租婆，动作上也有几分形似。这也足以表现她的性格了。作为LJ的同桌和与其性格相似的人，她们总是用欢快的语气讨论东西。（至于是什么，我只能说我不怎么关心这些。）在讨论题目的时候会用一种沉着的语气说话，也安静了许多。从说话的方式上来看，总像一个有广州音的东北大妈。因此，也有时被吐槽“像大妈”。 少数的是走读生但来上晚自习的人。（我？那只是被强制安排住宿，算住宿生吧。） 在解题能力上与HS同等级，所以经常和HS叫板。想想针尖对麦芒，死磕的过程通常是很精彩的。这时候就能听见HS的大嗓门和LYY的大嗓门“交相辉映”了，有时还能听见LYY一巴掌拍在HS背上的明亮的声音（就乐器的音色来说是“明亮”了吧）。HS也会“调戏”LYY，手段应该属于八卦吧，然后就能听见LYY尖锐地喊：“HS你去死啦！” 虽说是嗓门和动作幅度大了一些，不过还是比较爱好和平的，很少发火。记忆中就见过一次，那架势，简直就是蛮牛一般，嘴上也变成了超大功率连珠炮，这应该属于“骂街”了吧；但是略有不同的是这并不是无理取闹。面对来势汹汹的高精度核弹头导弹，你怕不怕？ LZQ F xC HF 林之琪 LZQ是一个不怎么活跃的人，一般就是安静地坐着看书，或者和HYY（后来是CCJ）……咳咳。 之前是考入C组的，不过后来不想参加竞赛了所以在高一下学期就退出了。于是她成为了奥班首位不参加竞赛但是还留在班里的人，直到高三转移到2班。（本来C组是有13个人，实验室内座位是4人一排，刚好将LYC排挤出去。当LZQ离开的时候，LYC想到LZQ的位置上，结果直接被LYY骂回去了。垂头丧气？不，才没有，LYC又没有正常的思维。） LZQ的英语水平没得说。她是YXT和刘亦甦的好友（紧密的社交圈），这三人的英语水平都是数一数二的（YXT的口语弱一些）。班里能与之匹敌的，如果要考虑综合能力，应该只有LY了吧。这两位的对抗战也是非常有意思的。 附上记忆中的C组座位：林雁戈-吴广成-黄 山-佘晓健 梁颖怡-刘 佳-刘润菁(-林之琪) 龙宇驰 吕源堃-吴 桐-苍思骏-刘雨熙 LYG M C HF 林雁戈 LHR M M HF 凌浩然 LJT M xP NHF 林健韬 LJ F C HF 刘佳 LHZ M M HF 刘洹志 LRJ F C NHF 刘润菁 LYX M C NHF 刘雨熙 LZX M P HF 刘智轩 LYC M C NHF 龙宇驰 LZB M xM NHF 路泽斌 LYK M C HF 吕源堃 LLT M P HF 罗连通 LZK M P NHF 罗哲焜 MSQ M P HF 莫深秋 QH M P HF 邱恒 TDW M M HF 谭迪文 SXJ M C HF 佘晓健 TT F P HF 田甜 WLH M M HF 王力汉 WYK M P NHF 王阳开 WT M C HF 吴桐 WGC M C HF 吴广成 XZX F xM NHF 谢芷欣 TYX M pM NHF 唐涌翔 YM M xM NHF 杨眉 YPF M P HF 杨平凡 YJ F P NHF 叶婧 YXY M P NHF 叶新一 YXT F P HF 余欣彤 ZEY F P NHF 张尔雅 ZGY M M HF 张光远 ZQX M M HF 张启翔 ZZJ M M HF 张子健 ZYX M P HF 钟仰新 ZY M M HF 周洋 ZYF M M HF 周艺枫 ZZQ M M HF 周正清 ZXY M xM NHF 卓翔宇 ZXK F P HF 邹小珂","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"第三天和第四天（2012-07-20+2012-07-21）","slug":"zh/2012-07-22-Teaching-Records-07-20-07-21","date":"2012-07-21T17:31:00.000Z","updated":"2020-03-30T22:34:35.378Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-22-Teaching-Records-07-20-07-21/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-22-Teaching-Records-07-20-07-21/","excerpt":"","text":"第三天，我们教的是纸塔。 上午第一节课，我恰好没课，就跑到三班去看林文琪上纸塔的课。纸塔的幻灯片是林文琪做的，所以她非常熟悉里面的内容。看她眉飞色舞，从土塔讲到小蛮腰，整整讲了35分钟，而且那些小孩兴趣颇高。其中，她还穿插了各种细节和数据——当然，这整节课都是她设计的，她肯定熟悉，所以讲起来得心应手。 第3节课，到了我们。 第二节的时候，陈晓菲（她已经先跑去打印了讲稿）和黎荣舜还在看讲稿，准备怎么讲呢。我由于看了林文琪的课，已经清楚她的幻灯片里有什么（并且有点不道德的是，由于第一节她借了我的电脑放幻灯片，我就在没有说的情况下“截留”了幻灯片~）、大概要怎么讲，讲得好和不好的地方分别是什么，该怎么调整。这时我心中已经有数了，想着这两位狂看讲稿效果会怎么样，我差点笑了。我决定变一下课堂的形式，要把这幻灯片的效果发挥到极致——林文琪是先展示塔的材质再打出图片，我则要先展示图片再让孩子们猜是什么材质，然后开蛊（广州话，揭开谜底）。又比如，她讲课的时候提到了《碟中谍4》中有关哈利法塔的片段，但是没有图片——那些小孩子都没看过《碟中谍4》，你跟他们这么描述有什么用？于是我又动手找了相关的图片，插入到相应的位置上。总之，在听课到我讲课之间我是做足了准备工作。 然后我对黎荣舜说我来主讲（嗯，不是我损，如果他们讲，不知道那些学生受不受得了这么枯燥的念稿课），黎荣舜就把讲稿给我。我看也没看就扔到一边，说：“我不需要这东西，一切我来搞定。”关电脑，去上课。 二班的效果明显比一班好，见视频。 ——插话，我发现一件悲惨的事情：我讲得最好的那节课由于相机问题，只录了8分钟！最精彩的地方被错过了！ ——再插话，我觉得上课之类的，教案是死的，讲稿是死的，但是人是活的。看讲稿还不如去听听别人怎么讲，然后自己消化反思，再研发出更好的教学方式，“提升学生们的听课体验”（模仿微软的说话风格啊~）。另一点，示范是很重要的，不管是对初中生，还是对我们这些准大人，这一点下面还会讲到。 准备在一班讲的时候，黎荣舜说让陈晓菲主讲吧，我说我再来一堂。开始还好，讲着讲着就有点累了，状态没有上午好。好不容易撑过了小蛮腰（上午是轻松完成），在开始动手的时候我实在不想动了，找了一个小组就坐在椅子上，看他们做纸塔。没有空调，只有风扇，浑身大汗。 第四天，我们组没课。大佬叫我们10:30到，我原来还准备为去上大学买衣服（我能用的一共就3套衣服）呢。去吧去吧。 然后就有了很好玩的事。 上午第三节，听了一堂“遇见未知的自己”科组的课，讲心理减压的。我个人觉得，这堂课出彩的地方不多，比较失败的地方一个是没有很好地启发学生去观察思考（这堂课的主要目标是要他们知道最不好的事换个角度看也会发现好的方面，教师举出一些换角度图片做例子，还要求学生分享让自己最不舒服的事），另一个是写的东西太多，还有过于关注少数人而忽略了“沉默的大多数”。这堂课也有录像。 到了中午，吃饭，然后我不想陪着一些老师呆在有空调的餐馆里和一些小孩玩“杀人”游戏，于是跑回了没有空调的办公室……呃呃呃。我原本打算玩电脑的，结果另一个老师（小草新课堂，赵翼）来找我们的科组长。后来才知道，之前一次试讲的时候，她从新课堂的科组长那里听到说我们科组长的数学很强，而且之前他支教的时候就讲数学，所以她想来找他问上课的问题。 Prelude: 前天（按照这篇日志发布的时间算，是大前天）放学的时候我站在楼梯口，看到一个孩子眉心中间有一道痕迹（不是疤痕，而是像一条浅浅的线），于是进办公室说那个孩子可能有阴阳眼。（关于看这些，我只能算入门。另请尊重每个人的习惯。）然后林文琪就问：“哎呀，是不是那种能看到什么什么的阴阳眼啊？”好嘛，这话让进来的赵翼听到了，然后她就表现出了过量（适量？足量？）的兴趣。然后我就被揪着和她说了十几分钟的牛鬼蛇神，一直到我们（实验站一帮人）要进地铁站了才结束……天啊我要崩溃了。 赵翼看见我，然后又开始准备说牛鬼蛇神了。Blah blah blah，又是十几分钟，我快支撑不住了。（你不知道她躺在躺椅上闭眼问话那样子有多惬意！我还紧张得要死，上次已经领略过发问机的厉害了，我只能苦苦撑着，累得要死。）这时黎荣舜出现了！他一进门就说：“你们是不是又在讨论什么阴阳眼啊？”赵翼：“是啊。”黎荣舜：“WT学识非常渊博的，唯一的知识漏洞是在韩剧和日剧那里。”（点评：这个不全对。我学识渊博么……我觉得不啦，知道我知道的是很正常的，不知道才不正常。然后，我亚洲电影看得很少，世界所有国家的电视剧都看得很少，所以知识漏洞比大家认为的要大得多啊~）赵一听来兴趣了，要我帮她解决等会上课的问题——莫比乌斯环+七桥问题。我勒个去！这个要是将深层原理讲清楚了初三的都不懂，你拿这个给准初二的讲课？！不过我还是提出了一些能让这堂课更容易被孩子们接受的建议，并优化了一些课程的内容。 正式上课的时候，我先再说一次“不是我损”：赵同学上课真的很糟糕啊……不过鉴于她之前对上课讲的知识没有深刻了解，而且她的组员没有帮她准备这节课，因此大家请原谅她下面的表现。现总结如下： 规则还没讲清楚就开始游戏，小孩子输了肯定不服； 解释（莫比乌斯环+七桥问题）的时候导入还好，再往后就糟糕了：“我们把一个平面扭曲180°”、“这你们在大学才会学到，这还是什么关于宇宙的”，解释七桥问题的时候真的逻辑一团糟，我都没法听懂她究竟想表达什么，难怪孩子们被问到“听懂了吗”的时候各个眼睛呆滞；- 不注意课堂氛围，她居然没看到她讲七桥问题的时候下面有人玩手机，有人填听课表（就是学生评价老师上课好坏的表），听她讲的只有大约50%，而她没注意到冷场的情况，还是继续半兴奋地讲了下去。另外她说“A岛”、“B岛”等等的时候用粉笔在相应位置画圈，但是不回头看学生； 示范少，例如讲莫比乌斯环的时候她说“从中间剪开”，是直接在黑板上画图，而不是拿着一个莫比乌斯环演示；另外从三分之一处剪断这个她也没有示范，学生们有60%都没听懂。 其他的，看视频吧……我现在也累了。 总之，上课是要吸取别人的经验来丰富自己的经验的，所以我并不看低上课比我糟糕的人，也不羡慕上课比我好的人，人人相互学习嘛，又不是敌人。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"无题","slug":"zh/2012-07-21-No-Title","date":"2012-07-21T02:06:00.000Z","updated":"2020-03-30T22:34:35.378Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-21-No-Title/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-21-No-Title/","excerpt":"","text":"最近我去了一个初中，参加一个夏令营活动，算是轻量级支教吧。三天以来很忙，没有时间去学习大学的一些内容。 我的软肋是，从初中开始我的数学一直都不算好（虽然高中时我们班是全广州最强的班）。你也知道，有一个这么严重的短板，虽然在高中通过其他科目拉分还能撑一下，但是大学时以数学为基础，甚至数学本身将会是个麻烦事。 我昨晚正在陶醉于我的授课技巧越来越成熟，突然在空间中看到有个同学说“在高中没有好好发展数学是我最严重的错误”（实际上她的数学能力很强），而且说这话的原因是“积不定积分时碰到了没见过的三角恒等式”！顿时就如被泼了一盆冷水，一点心情都没有了。 我总觉得和这些人相比我似乎缺了些什么。我开导自己说这些人没体验给小孩上课的快乐，但是理性的我立刻指出这意味着我的数学水平不断落后。好像这次夏令营就是垃圾，但是我又不觉得。非常痛苦。我缺了什么…… 追求一切完美是 CC 的通病吗……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"关于第一次和女生打伞一起走","slug":"zh/2012-07-20-Oops-Umbrella","date":"2012-07-19T17:29:00.000Z","updated":"2020-03-30T22:34:35.378Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-20-Oops-Umbrella/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-20-Oops-Umbrella/","excerpt":"","text":"7月18日，下了第三节课，我们实验组全体出来吃午饭。走着走着，居然下大雨！我们没有预料到这一点，6个人，3把伞。当然，伞我是没带的；当然，我一向是不怕雨淋的（小时候就很喜欢在大雨里面跑）~不过考虑到下午要正装出现在学生们（二班）面前，以及带着的计算机和相机都是怕水的，我尽量在突出层遮着的地方走。然后……每个人都呆在伞里了，除了我~ 现在的情况是，除了陈晓菲，其他人都是处于 in pairs 的状态。于是大佬（罗泽仑）说：“陈晓菲你去遮一下吴桐吧。”开始我说其实我在没有雨的地方走着就可以了，但是到了房子的边缘，我实在撑不下去了，只好进了伞里。 你知道么？一个女生在大雨里给你打着伞（当然，CC 基本上是外貌协会的成员，因此对于某些女生，让她们帮你打伞你还不如雨中漫步呢！），你手里提着一个笔记本电脑，背着相机，这是什么一种小清新（乱用了……）的场景啊！哎呀居然有女生给你打伞，而不是你被强迫要求照顾女士哦！而且距离过近的话时不时会发生表皮接触~嗯，反正我之前是没有体验过这个的，因此会有种种美好的感觉，请大家不要笑抽了。 默默地走到了一家沙县小吃店里。一路上（其实也就三十来米），由于在同一把伞下，我能感受到她的存在诶，甚至是呼吸~就是存在一个人，活着的，正常的，而且就在我身边，是一个女生。呀呀呀，这个可是很美好啊！（这是 CC 的通病么……） 吃中午饭。这时雨停了！我勒个去…… 归程。 刚刚迈出沙县小吃店的店门，居然啊居然，又下暴雨了……然后我被要求打伞了 = = 右手拎着电脑+一个手提袋，斜挎着相机，只有左手是空的了，你妹！于是左手打伞。总之我是很照顾她的了，伞柄在她的左肩位置（我站在左边）。录像的时候我举着手，手臂能定住，所以现在其实也不算很难。然后陈晓菲觉得我这个动作有点别扭（演杂技呢你？），于是问：“你为什么不用右手打伞啊？”这这这……如果用右手打伞，那么左手要护着电脑，当然要放在伞下，右手又要到达左肩的位置……其实做一个模型就知道，我的身体会过于靠右（至少在旁观者眼中应该是）。我当然不能答出这些，只是回答：“因为我怕电脑淋湿了啊！电脑怕水的。”天，感觉像在博弈…… 然后：“那这样，我帮你提电脑包，你右手打伞吧。”还能如何？给她呗。然后电脑包连同手提袋她一起拿了。当然，由于她也挎着一个包，所以不知道提着这么多东西她的难受程度是多少。 再然后，她把电脑包抱着！抱着啊！问我：“我这样拿行不行？”嗯，她也许知道计算机（是的，还是用正式的名称吧）对于我的重要性吧，基本上我都数字化了。但是抱着，像抱着一个婴儿那样抱着，天啊！你难道不觉得，自己带着的很贵重（应该用“重要”一词更好）的东西，被一个女生小心翼翼地保护着，是一件很……嗯，怎么说……的事情吗？也许可以填入“令人激动”这个词吧。 再然后，我就用右手打伞了，只挎着一个相机，而她带着一堆东西。我不知道在旁人眼中这是什么样的一种情景，不过根据模板分析，这似乎意味着什么…… 最后到了教学楼下，其间还是说了一些话的。 唉，第一次被女生打伞，第一次帮女生打伞，这经历就这样经历了。对于我未来的女朋友来说，我可能少了这两个第一次…… 嗯，今天（2012-07-19）还有一个家伙对阴阳眼以及相关的东西非常感兴趣的……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"第二天上课（2012-07-19）","slug":"zh/2012-07-19-Teaching-Records-07-19","date":"2012-07-19T17:26:00.000Z","updated":"2020-03-30T22:34:35.378Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-19-Teaching-Records-07-19/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-19-Teaching-Records-07-19/","excerpt":"","text":"还好，今天没有出什么意外。就如我的 QQ 签名——二班孩子爱拆台，一班孩子很欢乐~ 不过其实一班和二班最大的区别……还是男女生待遇（相互之间）的问题。 第二节课是二班的课。昨天我们的自我介绍惨遭冷场，因此至少我，对二班有点不太好的印象。今天我们的实验是针扎气球+斜立易拉罐，附带任务是发种子。 出乎我意料的，二班的小家伙们很喜欢扎气球的实验。最后“黎叔”把这个实验搞到了接近20分钟！ 然后是我的易拉罐实验~我觉得引入还可以，主要就是很好地勾起了他们的好胜心与好奇心。然后大家很欢乐地玩了15分钟（有一组只用了25秒就立起了2个易拉罐，这是我们没想到的。前一节课我们在三班看到的牛人则是约30秒3个，而且还有人能推测出水平面的位置，在最短斜边的高以下）。到了最后，我让他们做两个易拉罐立起来的实验（当然，从理论上分析，这是不可能完成的），他们就做了……当然试了一段时间没有人成功。就是因为多了这段时间，我们严重超时了~呵呵。后面的种子，反正就是陈晓菲讲清楚了。 有小孩子说是因为上面的拉环没有取掉，没办法，只能未置可否。他们问：“老师，你们实验过没有？”我：“我们实验过，不过没有成功。”（很坑爹对吧！）但是到底为什么，二班没人问。 另外，二班那个比较沉默寡言的女生，在易拉罐实验完成之后把桌子上的水用纸巾擦干了，而其他的同学都没有注意到这个细节。因此，这个人以后如果碰上机遇，应该会是不一样的人。 到了中午，我在回到办公室的时候提出了新的讲解易拉罐实验原理的方法（早上坐地铁时想到的）。嗯，只剩下一班没有上过课了，绝佳的实验品。之前其他组的解释是把易拉罐看成一个圆柱体，与桌面有一个接触点，然后用类似杠杆原理的方式，“重心与接触点在一条垂直线上就不容易倒”来解释。我考虑到这样既不科学，小孩子也听不懂（特别是三班！），因此我突出了易拉罐斜立时的两个支撑点（请注意观察！），把它们类比为人的两只脚，然后叫一个小孩（实际上叫了凹凸曼，这个人见后文）上来，分开两只脚站着，把他向左向右偏，说明易拉罐与人向左向右偏的情况很像，不过只要感觉重量在两只脚之间（两个支撑点之间）就可以稳了。这种说明方法，小孩子更容易听懂，而且这才是有科学性的解释。 一班的开场白非常顺利~之前我们听说一班会很闷，但是介绍过之后觉得他们其实很活泼的。嗯，很晚了，所以还是写的简略一些，上课实录请见录像。 下课的时候，一班的家伙会来找我们实验组的老师（这一点和二班的不一样），问问题。当我用坑二班的手法坑完一班之后，发完种子下课了，就有学生来问我为什么两个易拉罐就不行了。对了，一班有几个人知道重心和平衡！有一个外号“凹凸曼”、一个外号叫“蚊子”、一个不知外号但是眼睛很大的男孩，这三个人特别活跃。问原因就是前两个人问的。凹凸曼知道重心这个概念，所以三下两下就解决了；另一个嘛……只好跟他说我们“通过理论计算得出‘不可能’这个结论”，然后说：“实验也是要有理论依据的嘛（实际上这不是很符合真实的情况，如姜-泰勒效应的发现），你以后就会学到怎么样用理论来预测实验的可行性。”（天，这是什么逻辑！） 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！第二天啊！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"昨天在地铁站发生的事情，以及某2B行为","slug":"zh/2012-07-19-On-the-Metro-and-Ridiculous-Actions","date":"2012-07-18T16:56:00.000Z","updated":"2020-03-30T22:34:35.378Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-19-On-the-Metro-and-Ridiculous-Actions/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-19-On-the-Metro-and-Ridiculous-Actions/","excerpt":"","text":"昨天（对，是昨天），我上完课（http://hi.baidu.com/micstudio/item/514983412a6da712886d10fd）后乘坐地铁回家。到了林和西，旁边有两个人（实际上是三个，一个没有参与讨论）说怎么怎么走。我从他们的话里听出他们要去一个能转五号线的站。 附地图： 已知：我正在乘坐的是三号线，林和西→体育西路方向。三号线有一个很奇怪的地方，和广州其他所有线路都不一样：体育西路这个站，有3个方向。对于一些没有坐过三号线的人来说，广州地铁上三号线的示意图是非常恼人的。 简单地说，三号线分两段。一段就是我正在的那一段（机场南-体育西路），第二段是其余部分（天河客运站-番禺广场）。其中，第二段是一条线，和其他的线路（比如一号线、五号线等等）很像，从一个总站坐到另一个总站，理论上可以在车厢里睡大觉。 但是问题来了，从机场南坐到天河客运站，必须在体育西路站下车，睡觉的话……准备接受超过2小时处罚吧。因为林和西所在的这一段是相对独立的，只有一趟列车往返地从机场南到体育西路。（换句话说，今天上午我赶车，碰到“还有2分钟入站”的事情已经算我幸运了。） 其实，广州地铁总公司啊，你们为什么不新开一条线路（或者把这段三号线命为另外的编号），而一定要把三号线搞成这样一个怪模样呢？想不通。 又已知，广州地铁的每个中转站都有一个类似“循环利用”的标志，表明这是哪两条线路的中转站。 接着说。两个人中，A 认为要到体育西路转一号线，然后通过某种方式转到五号线（嗯，算是读懂了图吧）；B 认为直接从林和西坐到珠江新城转五号线就行了。在 B 的意见即将要变成现实之时，我说话了~我纠正了 B 的方法的错误，当然是用一种耐心解说的方式……呃，寥寥数语肯定是无法讲清楚这种一开始会让人头晕的图的。 总之，我解决了说理问题。解决完之后，B 说：“麻烦你了。”最后我还为三位指明了正确的下车方向（体育西路站，我所在的支线上是有两个下车方向，分别对应两条主线的行车方向）。嗯，我觉得这是对我最大的赞扬！鼓掌~（啪啪啪）好了，我不是好大喜功，我只是想通过自己的、每个人的力量，让广州使人觉得更亲切，让更多来广州的人觉得，在广州还是有好人存在的。 好有成就感哦~ 顺便揭露两个关于广州交通的2B事情。 亚运即将来临时，市政府宣布即将对公交系统实行免费乘坐制度~呜呼！这下子，人们都跑去坐公共交通工具了，确实减轻了交通负担，而且减轻了环境负担。但是公交系统受不了了，主要是亏本，其次是拥挤问题，因为客流量太大了。结果，免费政策实行没几天就被一个发放50元出行补贴的公告代替了，从此再无下文。 当 BRT 系统刚开放时，新颖的站台让许多广州人觉得不适：前后门看起来是一样的啊！为了某种原因（形成广州交通新秩序？），出现了某公告，声明：“公交车前门进后门出的规则，在今天，作废了！”然后就是一片混乱。到了 BRT 系统成熟的时候这些拍脑瓜的家伙大概是觉得拥挤的站台有损广州形象，于是拍屁股：“建议大家还是遵守前门进后门出的习惯”……看看！真没把话说绝！我勒个去……由于再也没有严格的习惯或者规则约定，现在的 BRT 车站之混乱实属全广州公交系统之最。你不信的话可以来看看，一般时候，从后门进公交车的人比从前门进的多得多！但是，从前门下车和从后门下车的人数差不多，因此我们这些严格遵守传统习惯的人下车（从后门）有75%以上的几率遇到强大机械力（某同学语）。换句话说，后门的人类交换效率非常非常低。这不是典型的2B行为是什么！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"上课记录（2012-07-18）","slug":"zh/2012-07-18-Teaching-Records-07-18","date":"2012-07-18T12:58:00.000Z","updated":"2020-03-30T22:34:35.377Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-18-Teaching-Records-07-18/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-18-Teaching-Records-07-18/","excerpt":"","text":"今天是我们第一次正式讲课。 今天我们小组（实验组）有四节课，分别是上午第二节（6班，罗泽仑组）、上午第三节（3班，陈文豪组）、下午第一节（6班，罗泽仑组）和下午第二节（2班，陈晓菲组）。 第一节课没什么问题，罗泽仑真的是有很强的人格魅力～总之那些孩纸们（呃，13-15岁的人类）都比较听课，气氛很活跃（欢乐～）。第二节虽然陈文豪他们开始控场有点失败（过于学术，学生不想听），后半段很好。下午第一节我有点累，所以没有很认真听。具体的内容我都已经录制成视频放到115上了。 但是到我们这里问题来了。（个人意见。） 一开始我们 Ice Breaking 的时候，我们原来的想法是搞一个“同花顺”（扯！绝对扯！）的外壳，附上搞笑版三人引入与个人引入。结果实施时出现了混乱，陈晓菲在我们说完三人引入的台词之后忘了还有每个人的引入，就直接宣布做实验了……我在这边放着幻灯片，莫明其妙地听着要开始做实验，本来想纠正的，不过已经开始分组了，所以再回到介绍环节是不理智的……开场就乱了，出师不利。 之后进行实验。我们本来打算一开始是书分不开的实验（陈晓菲）到可乐-曼妥思实验（我）到牛奶-水彩颜料-洗洁精实验（黎荣舜），结果由于早上上了课，而且这些小东西互相通风报信导致他们已经知道上课内容，所以我感觉我们被当作猴儿耍…… 具体内容见视频。 没有被记录到的细节： 1、我画了两个图，就是为了让那些小东西能看懂，结果那些家伙居然对图一点反应都没有（我讲解的时候）！ 2、坐在中间（“验”组）的一个小男孩，在开始上课的时候是没有表现出想听的意向的（目光……），从玩颜料（第3个实验）开始就有点活跃了。到了陈晓菲做总结的时候，我盯着他，发现他正在似笑非笑地看着我（估计我当时在微笑。我总是不自觉地微笑，而且似乎这样的微笑很容易吸引观众）。我当时就笑出来了，他也笑了。 3、这个班男女隔阂非常严重！听说4班是极致（势不两立），但是我觉得2班也够可以了。我们在2班的分组是4(2+2)+3(2+1)+3(1+2)，就是2男+2女+2男+1女+1男+2女（“实”、“验”、“站”），女生、男生分别抱团，单一的男女生就被孤立了。 4、“验”组的一个女生（坐在从教师视角中间偏右的位置），看起来非常非常内向，总是低着头，表情……嗯，跟LMY（我的一个高中同学）刚入学的时候差不多。她明显是被孤立的。在书本实验要进入讲评阶段时，我下去强制收回小孩子们还在玩的书本（高中奥数小丛书！）。收到她的的时候，她刚刚一页一页把书页叠好（这样就拉不开了，是我们的实验内容），我说：“呃，该收书了。”接下来她的动作我有点忘了，反正我觉得这样下去要等到何年何月，感到有点不耐烦，认为她是拒绝交还。这小子违反纪律啊嘿！正准备强制收回时，旁边坐着的班主任（也是志愿者，和学生们年龄相仿）问：“你是不是想把书复原还给老师？”她点了点头，没说话，但是脸上有种坚定的神情。不知怎么，我对刚才我的想法感到惭愧，并一直默默等到她完成这任务。幸好我没有强制收回，要不然可能又要伤了这同学的心。天！班主任的这句话真的太及时了！ 5、下课之后，4提到的那位同学来问我们三个老师（正在收拾实验器材）关于可乐-曼妥思实验的科学依据。我在课堂上讲的似乎很模糊……好吧我要看看视频。“为什么把盐放进可乐里可乐也会爆出来？”（场外观众，真的是这样吗？我们没试过……）诶，我负责这个实验，所以我很耐心地讲解了～反正就是催化的问题嘛。最后这位也听懂了。呼～算是一个成功吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Astraea's Caroline 通用游戏启动器已经正式发布！","slug":"zh/2012-07-18-Astraeas-Caroline-First-Release","date":"2012-07-17T16:12:00.000Z","updated":"2020-03-30T22:34:35.377Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-18-Astraeas-Caroline-First-Release/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-18-Astraeas-Caroline-First-Release/","excerpt":"","text":"详情请见：http://tieba.baidu.com/p/1722228137 2.0.0.0 版安装：http://115.com/file/ankzs1cs 升级失败修复补丁：http://115.com/file/any4xvo5#AcUpdateBugFix.exe","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"准备开始支教~","slug":"zh/2012-07-18-Preparing-to-Volunteer-Teaching","date":"2012-07-17T16:01:00.000Z","updated":"2020-03-30T22:34:35.377Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-18-Preparing-to-Volunteer-Teaching/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-18-Preparing-to-Volunteer-Teaching/","excerpt":"","text":"明天就要去见小孩子们了！就要当十天孩子王了~ 我是实验课小组的一员。 虽然应用对象只是初一到初二的小孩，虽然我未来并不会选教师这个职业，虽然这次只是一次青草夏令营举行的活动……但是还是要认真对待啊。我期望的是，小孩子们认认真真听讲，从中能获取一些对他们将来有益的东西。 记得两个月前看中央九台的《新青年》，其中一集讲“中国花样调酒皇后”郑雯。我说，为什么我记住了这个人呢？郑雯在某电影里饰演一个配角，开拍之后认为服装太暴露，要求更换。她说：“我是一个老师，我要为人师表，有个老师的样子。”我一直对技校持比较鄙视的态度，听了这句话之后觉得，有些人还是不可小觑。所以我也要把这句话作为一个准则记住，有什么身份就要坚守什么身份的道德。 很期待明天~（哦，今天……）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Astraea's Caroline 更新数据","slug":"zh/2012-07-10-Astraeas-Update-Source","date":"2012-07-10T15:57:00.000Z","updated":"2020-03-30T22:34:35.375Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-10-Astraeas-Update-Source/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-10-Astraeas-Update-Source/","excerpt":"","text":"UD 2012年9月15日 LT http://dx.kukai.cc/downfile.php?file_id=116425&amp;file_key=o54yht02&amp;uid= EL ‘End log 注意：编辑地址时要取消超链接 2015-04-08 附注：原地址为 http://hi.baidu.com/micstudio/item/ff17cde06a210f226cabb8ea","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"我的空间轨迹！","slug":"zh/2012-07-10-My-Trails-in-Baidu-Space-before-2012-07-10","date":"2012-07-10T15:52:00.000Z","updated":"2020-03-30T22:34:35.375Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-10-My-Trails-in-Baidu-Space-before-2012-07-10/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-10-My-Trails-in-Baidu-Space-before-2012-07-10/","excerpt":"","text":"6年很长，6年很短，6年留下太多瞬间！ 2010年02月13号，我在百度空间安家，截至目前我的空间访问量达到 5773次 2010年03月 7号，我在空间发表第一篇内容 我已记录 37 篇内容，共计 7 个标签分类 感谢空间好友这些年的陪伴，愿我们在这里共同记录每个6年的精彩！ 6周年我们重新出发&gt;&gt;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"关于我的梦游……","slug":"zh/2012-07-07-About-My-Sleepwalking","date":"2012-07-07T02:55:00.000Z","updated":"2020-03-30T22:34:35.375Z","comments":true,"path":"categories/Misc/Records/zh/2012-07-07-About-My-Sleepwalking/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-07-07-About-My-Sleepwalking/","excerpt":"","text":"昨天去参加青草夏令营的培训，小组备课。之前一天呢，我晚上看电影看到第二天（星期五）早上8:15，睡觉，起床时是10:15，全速赶到广州青年文化宫，生龙活虎地备了上午两个小时+下午三个小时课。回到家（约18:20），打开电脑，碰到 Visual Studio 2012 RC 更新，比较慢，看着等待屏幕，想躺在沙发上休息一下，结果直接睡着了（19:00）。 这是前奏。 然后今早起来，发现自家鞋柜旁边有一箱荔枝。忙问我妈怎么来的。她说：“是你抱上来的啊……” 天，我昨晚一直睡觉，连自己吃饭没有都忘了……愿闻其详…… 原来，昨晚我妈接到电话说一个家长要送一箱荔枝来，就叫我（还睡着呢）下去拿。平时我都不会下去的……结果睡梦中的我（潜意识控制着）迷迷糊糊地答应了，连衣服都没换（因为回来时暴雨，所以把长裤换了，光膀子，光着脚，穿出门用的短裤[不是NK]），就下去了……然后拿到荔枝之后又坐电梯上来……到了家门前“妈……开……开门……”进家门之后放下荔枝又跑到沙发上睡着了……不对，这个过程中我一直没醒过…… 天啊，我太强大了~","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"WTF?!","slug":"zh/2012-06-26-WTF","date":"2012-06-26T11:00:00.000Z","updated":"2012-07-17T16:00:00.000Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-26-WTF/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-26-WTF/","excerpt":"","text":"重装系统之后 VS 2010 就崩溃了，IDE 启动时都报错。唉，重装吧。 用[程序与功能]一项一项卸载 VS 2010，卸载到 VS 2010 SP1 安装包的时候居然蓝屏了！ 我勒个去…… 重新启动系统之后，VS 2010 说什么都装不上。 至于 SP1 包……我已经看它不爽，手动删除了（包括注册表）。 这意味着我没法用 .NET Framework 做开发了！ 以及， Astraea’s Caroline 要延期…… P.S.: 如果有大神能解决一下这个问题，请留言，谢谢。我已经试过的方法有：用管理员权限运行解压之后的文件；用 sfc /scannow 命令修复系统文件。 后记（2012-07-18）： 前几天我上 MSDN 问人，回答的人看了错误报告，发现是 VC 10 Runtime 的 hash 错了，叫我用 VS Web Installer 安装，之后果然好了。不过……现在还是无法安装 SP1：什么叫“计算机的状态不支持安装”？！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"分享：Windows 7 正版激活工具","slug":"zh/2012-06-26-Hahahaha","date":"2012-06-26T04:07:00.000Z","updated":"2020-03-30T22:34:35.375Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-26-Hahahaha/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-26-Hahahaha/","excerpt":"","text":"今天和昨天晚上，我一共花了6个小时找一个 Windows 7 的正版激活工具（呃，因为我是用一个非官方镜像安装的）。我的计算机是联想昭阳E23，原装 Windows Vista，然后被我装了 Windows 7…… 好了废话不多说。在经过苦苦寻找之后，我试过用 KMS 激活、用 OEM 激活（当然，SLIC 要改），以及电话激活（“您的 Windows 版本无效，请购买一个正版”…… = =），但是卡在了找 BIOS 文件这一块。我差点就真的要用硬破解的方法了…… 然后突然发现了 OEM7 这款软件，真正的一键安装（当然我属于高级用户，还是配置了一些高级选项），直接忽略 SLIC~重启后居然就正版了…… 我的评价是：傻瓜化的操作很适合大众。 这么好的东西怎么能不分享呢？免得以后有人沿着我的老路走，费时费力。 115网盘上传：http://115.com/file/an7nniq5","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"MIC恶搞——发扬学霸精神！关于模拟人生2神奇地违反遗传学定律的问题~","slug":"zh/2012-06-21-About-The-Sims-2-Conflicting-with-Genetic-Laws","date":"2012-06-21T07:20:00.000Z","updated":"2020-03-30T22:34:35.375Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-21-About-The-Sims-2-Conflicting-with-Genetic-Laws/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-21-About-The-Sims-2-Conflicting-with-Genetic-Laws/","excerpt":"","text":"这是一个非常邪恶的操作~ 在模拟人生2中自交，并以此为基础，展开一项科学实验。 嗯，估计这么睾科技的东西，不是很多人会的吧。那么我来讲解一下步骤。 打开模拟人生2，选择一个城镇，然后在主界面按下 Ctrl+Shift+C，输入“BoolProp TestingCheatsEnabled True”；（问：这是怎么来的？答：在正版的碟里有，在 Readme.txt 里面。这告诉我们，要尊重他人的劳动成果，你才能见到好东西~） 选择一个家庭进行游戏。确保那个家庭里至少有一个成年女性A； 随便等A走到哪里，然后按住 Shift 左键单击她，选择[更多…]-&gt;[Spawn]，选择 Tombstone of L and D（以下简称 TLD），就会跳出一个类似墓碑的东西。至此我们就打开了一个程序员的后门；（向 The Matrix 致敬！） 把 A 切到主角，左键单击 TLD，选择[更多…]，然后选择[Make me pregnant with…]，选择自己； 然后听到表明 A 有喜了的声音，再用 TLD，选择[更多…]，选择[Speed up my pregnancy]，过不久 A 就会生下一个小孩了； 观察并记录实验结果，包括小孩的各种性状，特别是性别； 重复步骤4~6多次（经检验，最多是4次，之后 A 就会绝育……）； 分析实验结果。 结果：通过这样的繁殖方式，后代都是雄性的~这算是一个自然界的平衡么（雌性过多的时候就会有雄性出现。如，红腹水虎鱼，在群体里没有雄性时最强壮的雌性会变成雄性）？ 但是请注意，后代中的 Y 染色体是从哪里来的？ 通过类似的方法，我们可以进行杂交-自交-测交实验，以验证孟德尔的两个实验定律。（实际上游戏部分违背了实验定律。） 经过实验，另一些实验结果是： 当 P 自交产生 F1 之后，P 与 F1 的杂交后代雌雄比例接近1:1； 然后 F1 之间进行自由交配，后代性状与使用基因频率计算的结果吻合； F2 经过实验，也出现了类似上面一行的结果。 请大家自行根据上述事实作出结论。(6分) 综上所述，模拟人生2的遗传系统不完善。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"这才是优秀的中国学生！","slug":"zh/2012-06-20-This-Is-the-True-Chinese-Student","date":"2012-06-20T08:54:00.000Z","updated":"2020-03-30T22:34:35.375Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-20-This-Is-the-True-Chinese-Student/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-20-This-Is-the-True-Chinese-Student/","excerpt":"","text":"一个可以气死日本人的中国学生！这就叫文采，不愧是学国际关系的。 看完后记得顶贴哦~ 6月19日，日本共同社记者小泽一郎到北大进行突击采访。在南阁（国际合作部）门口，小泽一郎采访了一小个子男生（后证实该男生为国际关系学院学生）。以下是现场原版真实问答记录。 问：你支持抵制日货的这种观点或行动吗?答：每一个人都是一个个体,每个个体都是自由的。我无法左右别人的思想，也无权控制别人的行动。问：你如何定位中日关系？答：客观定位，平等互利关系。问：从学生的角度看，你认为两国关系中最大的障碍是什么？答：显然，日方在很多方面做出了错误的言论和举动，而这是我们不能接受和容忍的！一句话，改善中日关系需要日方正视历史，拿出善意和诚意。问：你个人使用日货吗？答：有，马桶。（在场学生大笑）问：那你告诉我，为什么日本的马桶会比中国的好？答：在中国，这种话题是不登大雅之堂的，在公共场合提论这种话题是很变态的。（笑声）当然，我不知道是你有这样的嗜好，还是贵国有这种习惯。（笑声）问：关于历史问题，中日两国是否有途径可以卸下这个沉重的“包袱”？答：请注意你的用词！我不同意你的这种说法。你的这个问题本身就在诬陷中国。自古至今，中国从不存在什么“沉重包袱”。中华民族是心胸开荡，豁达前瞻的优秀民族，宽厚待人，睦邻周边是中国的美德。因此我们正视历史，但绝不以怨抱怨。我们容忍和解，包括对待日本。请问，中国和中华民族的历史包袱是什么？中国人民做过对不起日本的事吗？问题恰恰是侵略中国、犯下滔天罪行的日本不正视历史，在中国烧杀掠夺，疯狂地要灭绝中华民族。犯罪的日本不向中国和中国人民认罪赔偿损失，还要叫嚣海外出兵扩疆，分裂中国，霸占中国国土，激怒中国人民。这样的史实太多。请问，这是中国背历史包袱吗？（在场学生鼓掌）问：我也经常看新闻，最近一段时间，中国生产事故频发，死亡率想必不会低吧？答：同你们国家一样，每人死一次。（笑声、掌声）问：在中国大学校园里，学生自杀频繁发生、屡禁不止，这是为什么？答：事实上，学生自杀最多的是在你们国家。许多稀奇古怪的自杀方式就是你们国家的自杀一族发明的。在联合国公布的相关资料中，日本的自杀率排名世界第一。我不知道你手上有什么足够的证据来证明我国的校园自杀事件。主席有一句名言“没有调查就没有发言权”。希望你做客观真实的报道。对你刚才提问中使用的词语我有必要纠正，在中国汉语语法中，“频繁发生”和“屡禁不止”是重复累赘，用词错误。而且，你的说法不符合事实！（掌声）问：在日本留学的中国学生非法窃取日本的机密情报，你知道吗?答：我无法核实你的消息的准确性和真实性。这种荒唐说法就跟布什打伊拉克是因为萨达姆偷了布什家的高压锅一样可笑。（现场大笑） 原文地址（CSDN）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Astraea's Caroline 正在编写","slug":"zh/2012-06-19-Astraeas-Caroline-Is-On-the-Way","date":"2012-06-19T11:19:00.000Z","updated":"2012-07-17T16:00:00.000Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-19-Astraeas-Caroline-Is-On-the-Way/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-19-Astraeas-Caroline-Is-On-the-Way/","excerpt":"","text":"主界面截图 部分代码基于之前的 Z-Abby，不过更换了内核。 预计7月15日放出 Release。 2012-07-18：已经正式发布！界面改变了。 请见：http://hi.baidu.com/micstudio/item/3bc406d70627891a21e250b0","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"前来的HF同学请注意","slug":"zh/2012-06-13-Hahahaha","date":"2012-06-13T12:27:00.000Z","updated":"2020-03-30T22:34:35.371Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-13-Hahahaha/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-13-Hahahaha/","excerpt":"","text":"某些同学注意了，不要曝光我的身份！ 以及，非理性审视是应当禁止的。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"毕业游随感","slug":"zh/2012-06-13-On-the-Trip-for-Graduation-of-High-School","date":"2012-06-12T16:27:00.000Z","updated":"2020-03-30T22:34:35.372Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-13-On-the-Trip-for-Graduation-of-High-School/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-13-On-the-Trip-for-Graduation-of-High-School/","excerpt":"","text":"我正在和另外34个同学在一个岛上进行毕业旅游。明天……不，今天上午我们就要离开，这意味着至少3年（我们之中有不少6年）的同学最终最终要离别了。我很想把这两天半记录成什么（虽然不大可能），然后不断地过，不断地过，直到有一天我不想再过了为止。我真的是不忍心看到离别啊！ 最有趣的事：我改动了一下宾馆的数字电视设备，用这个来上网，就是现在。没有宾馆的人发现了…… 因为这是非正式的出游，大家都穿着日常的装束。一些同学（大多是女的）的头发等等不用再符合学校的要求，于是她们换了发型。平时大家穿没有便装的机会（长住生在周末除外），现在看起来大家都不像原来的大家了。（说真的，一些女同学确实很美观，或者说，漂亮；虽然不能称之为美若天仙，但是用网络语言说，养眼。或者说，那一刹那就怔住了。）唉！以后见不到大家的这些样子了！ 而且，受益于“非正式”这个性质，没有老师管理，同学们之间的气氛和以往也不一样。真的……最主要的是亲昵的显现。嗯，这种感觉大概是由于至少3年的同学关系培养了感情吧！以后即使在大学，“同学”的性质也会发生变化，变得更加松散、没有凝聚力。那时毕业不知如何呢？更何况大家的心智也发生了变化，看人也不会再有现在的感情了吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"与两个同班女生有关的记忆碎片","slug":"zh/2012-06-10-Pieces-of-Memory-of-Two-Female-Classmates","date":"2012-06-10T11:50:00.000Z","updated":"2015-04-08T12:12:00.000Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-10-Pieces-of-Memory-of-Two-Female-Classmates/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-10-Pieces-of-Memory-of-Two-Female-Classmates/","excerpt":"","text":"写在前面 我一向被认为使很保守的。我听过我的一位同学说：“我姐（就是下文第一位，我们班那些乱认亲戚的情况非常混乱）说，小的时候你没有这么害羞的，越大反而越保守了。”呵呵，不敢当不敢当。自从觉察到这些心理的发展，我必须表现成这样以抵御它们，这样才能隐藏住我的想法。我的内心其实是很浪漫的（没开玩笑）……而现在，既然大家要分开了，那么公布我的一些历史也就无伤大雅。 我要写的，是关于我的两位同学——更加确切的说，是两位女同学的记忆碎片。她们，虽然大家已经高考完要分开了，但是已经给我留下了很深的记忆。我想说，不管她们是否喜欢过我，我曾经关注过她们，这是一个事实，烙在了历史上了。 XT： 她的名字与我的名字，两个字符串最后一个字发音相同，所以老师经常会把我们这两个字搞乱。一般来说，是会把她的那个字打成我的那个字。但是有一次——就那么一次，在临考的一次作文讲评上——老师把我的那个字打成了她的那个。当然，两个字读音相同这一点在初中就被那些不怀好意的家伙们发现了，他们最喜欢的就是叫“×××××，*”了，然后全班大笑（老师听着应该能听出来什么意思，不过一直没有明令禁止……）。所以我一直都很抗拒这句话。到了最后，我发现我还是喜欢她的。唉！这样的机遇有多少呢？小学的一个同学在毕业册上对我说：能碰上一个同月同日生，又是同姓的人真是太不简单了。那么碰上这样的女生的几率又是多少呢？ 其余的记忆好像都跟升旗有关。 我们班高一时曾经是国旗班（正如我之前的一篇日志写的），其中我（升旗手，男的），XT和XK（护旗手），ZY（号手，这个可是男的）是一个小组的。XT在右（以面对旗杆时为准），XK在左。当我把国旗从旗箱里拿出来右转（规定永远不允许左转），走向教室前门的时候，XK的脸被墙壁挡着，XT则面对着我……这个时候，我的感觉真的是太美妙了。但是我知道，我必须隐瞒这些思想。然后走着走着，走上升旗台，护旗手再走上升旗台上的白色台，转身。这是我就递旗，理旗，然后将末端卷好握成一团，右手放胸前，左手垂下，立正。当两位护旗手把国旗的扣子扣好之后我就把国旗团给右手边的那个人——如前文所说，就是XT。这个时候，我的感觉也是非常美妙的……最后就是吹哨，等待报告，升旗，转身，下升旗台，解散。 有一天，好像就是我们班开始担任国旗班的第二还是第三周，在准备出国旗的时候（我们教室里只有我们小组4个人），她突然笑着（对XK）说：“我昨晚做了一个梦，梦见××（鄙人），捧着一摞书给我……”我当时还是当什么也没发生（必须的，要不然……太不合礼法了吧……），含糊着就过去了。现在想起来，可能她说的是真的吧；如果是，那么这应该算是我和一个女孩子在心灵上处过的最近的距离了吧。之后，这种事情再也没有在任何人身上发生过。唉！无限的怀念。 当下午下雨、国旗被淋湿的时候，晚上我们就需要晾国旗。方法是将国旗白色（靠近旗杆的）那一边置于黑板上面的平台上，另一端置于讲台上，然后用一些词典之类的厚书压好。一般来说，我们班不是全员晚自习的，而晾国旗的（必须是升旗手）就更少了。我高一时一般也不在学校晚自习，除了星期五晚上，因为那天晚上我会去参加AI社的活动，简单说就是机器人制作和编程。好了，不扯闲话。我期盼的（呵呵，说不上最，但是还是有一点）就是那天晚上下雨了。晾国旗的时候，我们先全体肃立，然后第一个升旗手把国旗拿出来，接着两个升旗手都面对教师后墙，盲视递旗，展旗。展旗的速率要一致。当国旗展开了一定的长度之后，护旗手要把旗角捋起来，放到讲台上，拿书压着。然后护旗手摆好两张凳子，升旗手就踩上去（仍然要步调一致），继续展旗，知道展开完毕，把国旗一端用手压住，右手接护旗手递上来的书（都是盲视操作），用书压好国旗，下凳子，立正，结束。任何人都不允许从国旗下面穿过，要经过讲台就必须绕道。收的时候基本上是这个过程的逆过程。我想起这个的原因是，如果哪天我负责晾国旗，她一般就是递给我书的那位护旗手。哦，还漏了一点，所有人，包括升旗手、护旗手和号手都是要戴白手套的~不知你们有没有体验过那种感觉……我无法表达，就是觉得有一种莫名的激动，我只能这么说吧…… XK： 我曾经试过进入她的圈子，但是到了最后，我还是发现那不适合我。身为CC，我绝对不想往污水坑里跳！一开始我肯定是被迷了眼了。现在反省一下，还是觉得里面有一些值得留念的东西。 开始交流的时候，我们在学农期间互发短信。那时我还在用着我妈淘汰下来的旧手机，白色、厚厚的三星翻盖手机。我总是会发一条短信，等啊等啊，就在等那指示灯闪烁着红色。这表示有短信来了。那是一种多么值得怀念的等待啊，每一次见到灯亮起我都会小小地高兴一下，如果长时间没亮我反而觉得有点焦急。有一次，我问道：“你们那里需要割禾吗？”她说：“你随便吧。”过了一会我听到她那里似乎需要割禾，就拉了几个同屋的同学一起跑过去了。那时正是高二期中考试之前（回去过两天就要考试），大家伙都恨不得在屋里呆着自习呢。我为什么会做出这种举动……难道就是因为我当初以为是她认定的，而值得牺牲一些什么吗？这个例子教育我们，保持理智很重要…… 到了那一年年末，我们准备举行新年班会。我作为计算机技术强人，要做一个程序。当时我正好没有带以前的程序的代码，因为里面可能要用到如 Auto Presentation Assistant（呵呵，自制的）等需要慢慢调试才能完成的程序的代码。因此我晚自习上课开始写，到了晚自习第一节下课（1小时40分钟）还在写及调试。班主任说：“不要花太多精力在这上面了啊。”我倒觉得编程是一件很快乐的事情，但是编程很费时，我必须承认这一点。晚上我发短信说：“今天的效率太低了。”她的回复我还记得清：“看你从上课开始搞，用了这么久，我有点担心你的身体。”我接到短信的时候吓了一跳！ 后来我有一次看《星际迷航》（2010年电影版）的时候，我看着序章（intro，就是引入故事情节的那一段），不禁YY我留守在船上……呃呃呃，很不现实对吧。 她还抹过护肤油（估计许多女生都在公众场合做过吧）。我故意问她那是什么味道，因为我就是喜欢听着一些句子从她嘴里出来。我本来还想狠狠地嘲笑这种过度防护的行为，最后顾及和谐还是没有说出来。嗯，估计她还没有识破过。 最令我感动的是两类三件事。前两件是暖手的……我只记得其中一次经过了。高二的冬天，晚自习过20分钟才开始，这时大家都在闲聊。我不知道当时每个人都说了什么，然后她就走过来，一把把我的左手抓起来，把她的手伸进我的袖子里（我们当时大多穿冬装，长袖校服）。如果推论没错，她的体质应该属于极寒的那一类；我的体质是极热的，到了冬天也不会觉得冷。我就感觉她的手冰凉冰凉的，于是想把我的手缩回来。但是她抓住了，说：“哇，好暖啊！”整个就把我的手（科学一些，是小臂）当成暖炉了。我敢肯定，当时我的脸看起来绝对像熟透的番茄！第三件事发生在高一的冬天。晚自习第一节课下课之后，大家自由走动。我跑到教室后部的公告栏，去看一些通知。当然大家还是穿着长袖。我正看着，突然感觉衣领被人翻动了。我那个时候真的就跳了起来，“啊”地大叫了一声，准备肘击来犯之敌。结果听到她说：“嗯嗯？我看到你的衣领乱了，帮你整理一下，有必要这么紧张吗？”好嘛，脸又要像大番茄了……我只好乖乖地让她整理完，她还拍了几下。一直到高二末这段时期是我们相处（注意：还是一般关系）最好的时期，后来她的思想发生有害变异，我曾经试过把它拉回正轨，但是此时另一个人介入了。我没法抗击两个人，在坚持了两个月之后还是决定抽身。 这就是有关她们的一些故事。我把它们记录下来，希望最终有人知道我曾经的想法。这并不意味着我对其他人没有过观察，不过数据更少一些，无法得出有效结果。 但是在真正到了那个时候之前，我只能说：我曾经对你们有过好感，但是因为责任，我不能把我的想法说出来，以至于平常我的表现有些奇怪，愿你们原谅我。 2015-04-08 今天搬运过来的时候读到第一段，一看就记起来了，那话不是LZX说的嘛。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"高考结束~","slug":"zh/2012-06-10-High-School-Entrance-Exam-Is-Over","date":"2012-06-10T11:49:00.000Z","updated":"2020-03-30T22:34:35.371Z","comments":true,"path":"categories/Misc/Records/zh/2012-06-10-High-School-Entrance-Exam-Is-Over/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-06-10-High-School-Entrance-Exam-Is-Over/","excerpt":"","text":"高考结束，更新要开始啦！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"声明","slug":"zh/2012-04-21-Declaration-on-2012-04-21","date":"2012-04-21T13:03:00.000Z","updated":"2020-03-30T22:34:35.371Z","comments":true,"path":"categories/Misc/Records/zh/2012-04-21-Declaration-on-2012-04-21/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2012-04-21-Declaration-on-2012-04-21/","excerpt":"","text":"因即将面临高考，我无法使用电脑（家长控制。现在我就在用手机），所以博客更新缓慢。软件与技术帖、杂文都会到时更新。 望各位为高考的学子们加油！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"新的同桌","slug":"zh/2011-11-06-New-Deskmate","date":"2011-11-06T09:45:00.000Z","updated":"2012-10-13T16:00:00.000Z","comments":true,"path":"categories/Misc/Records/zh/2011-11-06-New-Deskmate/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2011-11-06-New-Deskmate/","excerpt":"","text":"我终于做了一个实验—— 从小学开始，18任同桌全是男的。而我呢，比较保守，确实比较保守，除了公事，其他时候不会主动和女生挑起话头，而且对话完全是为目的服务的（即不会去闲谈）。 好吧，既然我的高中生涯还有几个月就要结束了，我就体验一下和女生做同桌的感觉。于是乎，我就在换位的时候提出了申请啦。 这是一个破天荒的举动啊！之前我都是“你把我安排到哪里就哪里”型的，更何况这次还要求和一个女生同桌呢！ Anyway… 那天投影仪坏了，老师直接读出新的座位表……呜呼……我的新位置立刻就被公开了……不要啊…… 反正第一次和女生做同桌的经历就这么开始了。 一句话，压力。嗯，一切都要谨慎，再谨慎，细节很可能透露一些信息。所以绝对不能出差错！还有，以前我可以因为一个成功而大笑，拍同桌的肩膀，但是现在可不行；以前可以随便开同桌的玩笑，可以在相互损人自己损不过的情况下掐同桌的肩胛骨逼迫其就范，现在不行。唉，这不行，那不行，如何是好？所以所谓 restricted，大概就如此了吧。 Whatever… 嗯，还有有一些不好的是，她比较喜欢玩手机，你可以想想做题的时候旁边一个人拿着手机上网你是什么感受。不过她很聪明，这我承认，刷题速度比我快 - -! 而且……计算错误几乎为0。（你要问：“计算不是很基本的么？”唉，我被老师评价“眼高手低”，就是方向没问题但是总是因为计算的失误而得出奇奇怪怪的答案。一个问题有时要算三四遍才对……） 作为一个完美主义者（至少自认为），压力真的不是一般的大…… 就正常的推理得出，玩手机的后果就是休息不好。 有一次，是第三节课和第四节课之间的30分钟休息（我们学校的课程表就是如此），她用手肘捅一捅我，说：“过15分钟叫我起来。”这就是“经历”了，如果我没有提出申请，所有的一切我都不会知道。她说完之后就用手枕着头睡在桌子上。我在做题，回答了一声。 不知大多数有这些经历的人来说这怎么样，总之我的感觉是很奇妙的。如此安静——就这么躺着。如果这是一张照片的话（应该不难想象吧），那就是在旁边的人谈话、走动的时候（模糊），两个人，一个在做题，另一个在睡觉，就这么静静地。这种感觉……真的很难体会到。 如此唯美。就像水晶玫瑰（恶搞一下，Photoshop 教程里有“水晶苹果”咧），正所谓“捧在手心里”。这是 CCN 的通病么……？Never mind. 总之她也是非常独立的，并不需要过多的关心，我很清楚。 唉！这样的心情，以后还能体会到多少呢？ 在写了这么多技术日志之后，就写一篇比较情感化的东西吧。 1-28 之前有一段时间……唉，不知道怎么说好……算了，过去的就过去了吧。总之我一向是有理的就行了。 2012-10-14 根据 2012-10-12 的谈话，之前的……从2011年12月到2012年3月，那是一场误会，很大很大的误会，但是我们都没有说过，直至相互“不认识”……所以，就是现在的这个样子。 对“关于两个女生的记忆碎片”一文中，“她的思想发生有害变异”一句对她造成的损害表示歉意。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Zinc 技术披露","slug":"zh/2011-09-11-Zinc-Techs","date":"2011-09-11T11:29:00.000Z","updated":"2020-03-30T22:34:35.371Z","comments":true,"path":"categories/Tech/Coding/zh/2011-09-11-Zinc-Techs/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2011-09-11-Zinc-Techs/","excerpt":"","text":"涉及的几项技术： Aero 效果的实现 ListView 控件的系统风格化 控件默认使用 GDI+ 绘制文本 异步数据传输 全局热键的使用 在 .NET 中使用回调 一、Aero效果的实现 关键 API： 窗体的扩展样式必须带有 WS_EX_LAYERED，并部分（或全部）透明，因为 DWM 只会在窗体透明的部分进行渲染。 Declare Function DwmExtendFrameIntoClientArea Lib &quot;dwmapi.dll&quot; (ByVal hWnd As IntPtr, ByRef margin As MARGINS) As Integer 函数讲解：将 DWM 的渲染范围向窗体内拓展。hWnd 为窗体句柄，margin 为 MARGINS 结构，表示拓展的量。MARGINS 和 RECT 本质上相同，但是 MARGINS 表示向内范围，RECT 表示向外范围。 Declare Function DwmEnableBlurBehindWindow Lib &quot;dwmapi.dll&quot; (ByVal hWnd As IntPtr, ByRef pBlurBehind As DWM_BLURBEHIND) As Integer 函数讲解：启用窗口的 DWM 模糊渲染。hWnd 为窗体句柄，pBlurBehind 为 DWM_BLURBEHIND 结构，指明如何进行渲染。 Public Function DwmIsCompositionEnabled Lib &quot;dwmapi.dll&quot; (ByRef enabledPtr As Integer) As Integer 函数讲解：判断DWM 渲染是否已经启用。enablePtr 为是否已经开启的判断变量（注意传址的方式），enabledPtr 返回1为已经启用，0为未启用。 关键常数： &#39;是否只是渲染区域 Public Const DWM_BB_BLURREGION As Integer = &amp;H2 &#39;是否启用渲染 Public Const DWM_BB_ENABLE As Integer = &amp;H1 &#39;最大化窗口时是否渲染 Public Const DWM_BB_TRANSITIONONMAXIMIZED As Integer = &amp;H4 关键结构：. Public Structure MARGINS Public m_Left As Integer Public m_Right As Integer Public m_Top As Integer Public m_Bottom As Integer End Structure 结构讲解：四个数值分别是四周向内拓展的大小（以像素为单位）。 Public Structure DWM_BLURBEHIND Public dwFlags As Integer Public fEnable As Integer Public hRgnBlur As Integer Public fTransitionOnMaximized As Integer End Structure 结构讲解：dwFlags 是 DWM_BB_BLURREGION、DWM_BB_ENABLE、DWM_BB_TRANSITIONONMAXIMIZED 的组合。若指定一项，相应的值必须置为非零。其中 hRgnBlur 为目标渲染区域句柄（似乎没用），fEnable 和 fTransitionOnMaximized 置为1为打开，0为关闭。 使用 Windows.Forms.TransparencyKey 可以轻易实现透明效果。 综合使用效果如图： 二、ListView控件的系统风格化 关键函数： Public Function SetWindowTheme Lib &quot;uxtheme.dll&quot; (ByVal hWnd As IntPtr, ByVal textSubAppName As String, ByVal textSubIdList As String) As Integer 函数讲解：该函数用于开启或关闭或改变某窗口（及子窗口）的窗口主题。hWnd 为窗口句柄，textSubAppName 为主程序样式名称，textSubIdList 为子样式名称。 函数使用：若 textSubAppName 和 textSubIdList 使用 ByVal 传递整数零则可以启用一个窗口的主题，若使用 ByRef 传递空格字符（Chr(32)）则会停用一个窗口的主题（停用后窗口类似 Windows 98 中的窗口）。 使用 SetWindowTheme(ListViewCtrl.Handle, &quot;Explorer&quot;, Nothing) 可以启用 ListView、TreeView 的资源管理器效果： 上面是使用了 SetWindowTheme 函数之后的效果，下面是未使用的效果。 三、控件默认使用GDI+ 绘制文本 为什么要用 GDI+ 绘制文本？这是因为，如果启用了 Aero 效果，则窗体的所有颜色将会使用ARGB 方式参与计算。普通的 GDI 文本绘制函数如 DrawText 等绘制的文本会造成很奇特的效果，严重影响文本可读性。由于 GDI+ 也是使用 ARGB 方式计算颜色，就可以在使用 Aero 效果的窗体上绘制正常的文本。 在 Visual Studio .NET 2005（.NET Framework 版本 2.0）及以上的版本中，可以使用两种方式启用控件的 GDI+ 文本绘制。 1、使用 Application.SetCompatibleTextRenderingDefault。 原型：SetCompatibleTextRenderingDefault(defaultValue As Boolean)。defaultValue 为 True 时所有支持 GDI+ 绘制文本的控件都启用 GDI+ 绘制，为 False 时使用 GDI 绘制。默认值为 False。 在应用的时候会有一个问题。该函数需要在创建第一个窗口前调用，否则引发异常 InvalidOperationException。如果启用应用程序框架，则无法在第一个窗体加载之前调用函数。 解决方法如下：取消应用程序框架，使用 Sub Main() 启动，调用 Application.SetCompatibleTextRenderingDefault(True) 之后在结束之前调用 Application.Run(MainForm)，其中 MainForm 为主窗体名称。 2、使用控件的 UseCompatibleTextRendering 属性。 属性为 True 时所有支持 GDI+ 绘制文本的控件都启用 GDI+ 绘制，为 False 时使用 GDI 绘制。默认值为 False。 支持 GDI+ 文本绘制的控件有：Label，LinkLabel，Button，CheckBox，RadioButton，CheckedListBox，GroupBox，PropertyGrid。 四、异步数据传输 使用 WebClient 类的 DownloadDataAsync、UploadDataAsync 等函数进行异步数据传输。这里以 DownloadDataAsync 函数为例。 DownloadDataAysnc 的好处在于不占用系统时间，应用程序不需要等待数据返回才响应，之间可以完成其他工作。如果使用 DownloadData 函数，则在数据接收到之前无法进行其他操作。 那么控制权交给了其他函数，如何确定接收过程呢？ 使用 AddHandler 语句注册回调函数。AddHandler 使用方法如下：AddHandler ControlName.EventName, AddressOf CallbackProc。CallbackProc 的声明要与 ControlName.EventName 的声明参数一致，否则会造成“签名不一致”错误。实际上，AddHandler 是注册隐式委托的一个有效方法。关于委托请见第六点。 比如，注册 WebClient 的 DownloadDataComplete 事件函数例子： Public Sub DDACallback(ByVal sender AsObject, ByVal e As System.Net.DownloadDataCompletedEventArgs) 然后在里面处理就行了。 五、全局热键的使用 关键函数： Public Function RegisterHotKey Lib &quot;user32.dll&quot; (ByVal hWnd As IntPtr, ByVal nHotkeyID As Integer, ByVal fsModifiers As Integer, ByVal nVK As Integer) As Integer 函数讲解：hWnd 为窗口句柄，nHotkeyID 为热键 ID（应用程序范围为 &amp;H0000~&amp;HBFFF，DLL 范围为 &amp;HC000~&amp;HFFFF），fsModifiers 为修饰键（MOD_CONTROL，MOD_ALT，MOD_SHIFT，MOD_WIN），nVK 为虚拟键码。注册热键之后按下热键系统会将 WM_HOTKEY 发往 hWnd 指定的窗口的消息循环，wParam 为热键 ID，lParam 的高位为虚拟键码，低位为修饰键值。 使用方法：重写窗口消息处理函数。 Protected Overrides Sub WndProc (ByRef m As System.Windows.Forms.Message) If m.Msg = WM_HOTKEY Then If m.WParam = ID_HOTKEY Then &#39;这里做你想做的。 End If End If MyBase.WndProc(m) End Sub 自然之后要解除注册： Public Function UnregisterHotKey Lib &quot;user32.dll&quot; (ByVal hWnd As IntPtr, ByVal nHotkeyID As Integer) As Integer 函数讲解：hWnd 为窗口句柄，nHotkeyID 为已注册的热键 ID。 六、在 .NET 中使用回调 VB6 中使用回调很简单，AddressOf 就行了。比如：EnumWindows(AddressOf EWProc, 0)。.NET 可是宣称有安全性的，怎么会直接采用这种可能引发堆栈错误（比如参数不匹配）的方式呢？所以在 .NET 中，AddressOf 已经成为了创建显式委托的语句。如果直接对一个声明为 lpFunc As Integer 的函数传 AdressOf ProcName 的话，则会引发异常。 那么 Windows 中这么多的回调该怎么使用呢？ 题外话：其实一开始我也没有理解 .NET 中所谓“委托”为何物。为什么要选用“委托”一词呢？这个词在中文中可是一个动词啊……看了 MSDN Help Library 的示例之后我终于理解了，原来“委托”就是 C++ 中所谓的影子函数啊！ 对比一下： C++： int doSomething(int, int, float); int doSomething(int a, int b, float c) {...} VB .NET： Delegate Function DoSomethingDelegate(ByVal X As Integer, ByVal Y As Integer, ByVal Z As Integer) As Integer Function DoSomething(ByVal A As Integer, ByVal B As Integer, ByVal C As Integer) As Integer ... End Function 怎么样？很像吧！ 而且 MSDN Help Library 说“委托是一种类型”。那么，我们就可以用委托进行回调。 声明一个影子： Delegate Function EnumWindowsProc(ByVal hWnd As IntPtr, ByVal lParam As Integer) As Integer 此时，EnumWindowsProc 已经成为一个“委托”类型。在函数中可以使用这种类型，可以且仅可以接受 AdressOf 对正确函数实体的返回。 API 函数也要重新声明： Declare Function EnumWindows Lib &quot;user32.dll&quot; (ByVal EnumProc As EnumWindowsProc, ByVal lParam As Integer) As Integer 然后接下来声明真正的函数： Function EnumWindowProcRealizer(ByVal Handle As IntPtr, ByVal lParam As Integer) As Integer SetWindowText(Handle, &quot;窗口标题&quot;) Return 1 End Function 接着进行调用： EnumWindows(AddressOf EnumWindowProcRealizer, 0) 这样进行的调用就会传到实际的函数 EnumWindowProcRealizer。 另外，和 C++ 里的影子函数一样，实际的函数和形式函数要有相同的参数、参数类型和参数顺序（本质上是要保证堆栈一致），否则会引发“签名不匹配”的错误。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"一些技术细节","slug":"zh/2011-07-16-Some-Technical-Features-in-Developing-Z","date":"2011-07-15T17:35:00.000Z","updated":"2020-03-30T22:34:35.368Z","comments":true,"path":"categories/Misc/Records/zh/2011-07-16-Some-Technical-Features-in-Developing-Z/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2011-07-16-Some-Technical-Features-in-Developing-Z/","excerpt":"","text":"最近在写一个启动软件，现在的版本是 1.0.2.1 Beta。里面的一些技术细节会在正式版时更新到日志中。 包括：Aero 的完美无错误实现及故障排除（Visual Studio 2010 - VB），利用网页进行数据更新，以及一些界面效果。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Vista Aero 效果的纯 DWM API 实现，以及发光字 etc","slug":"zh/2011-04-09-Vista-Aero-and-Blurring-etc","date":"2011-04-09T13:37:00.000Z","updated":"2020-03-30T22:34:35.368Z","comments":true,"path":"categories/Tech/Coding/zh/2011-04-09-Vista-Aero-and-Blurring-etc/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2011-04-09-Vista-Aero-and-Blurring-etc/","excerpt":"","text":"DWM API 的使用已经更新，请见：http://hi.baidu.com/micstudio/blog/item/29ec4cef245164ca2e2e21d3.html 比如： &#39;很好的代码，粘贴到窗体内即可使用 &#39;缺点：直接使用 GDI+，导致 GDI 绘制的图像及文本出现不正常；在没有使用另外的某 DWM API 时（忘了……），窗口边框与客户区间还会有边界。 &#39;Vista Home Premium 以下（不含）的系统不支持，请勿使用 &#39;此源代码为从网上某处搜索得来，感谢原作者！ Option Explicit Private Declare Function DwmIsCompositionEnabled Lib &quot;dwmapi.dll&quot; (ByRef enabledptr As Long) As Long Private Declare Function DwmExtendFrameIntoClientArea Lib &quot;dwmapi.dll&quot; (ByVal hWnd As Long, margin As MARGINS) As Long Private Type MARGINS m_Left As Long m_Right As Long m_Top As Long m_Bottom As Long End Type Private Declare Function DwmEnableBlurBehindWindow Lib &quot;dwmapi&quot; (ByVal hWnd As Long, pBlurBehind As DWM_BLURBEHIND) As Long Private Declare Function DwmEnableComposition Lib &quot;dwmapi&quot; (ByVal bEnabled As Long) As Long Private Const DWM_BB_ENABLE = &amp;H1&amp; Private Const DWM_BB_BLURREGION = &amp;H2&amp; Private Const DWM_BB_TRANSITIONONMAXIMIZED = &amp;H4 Private Type DWM_BLURBEHIND dwFlags As Long fEnable As Long hRgnBlur As Long fTransitionOnMaximized As Long End Type Private Declare Function GetWindowLong Lib &quot;user32&quot; Alias &quot;GetWindowLongA&quot; (ByVal hWnd As Long, ByVal nIndex As Long) As Long Private Const LWA_COLORKEY = &amp;H1 Private Const WS_EX_LAYERED = &amp;H80000 Private Const GWL_EXSTYLE = (-20) Private Declare Function SetWindowLong Lib &quot;user32&quot; Alias &quot;SetWindowLongA&quot; (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long Private Declare Function SetLayeredWindowAttributesByColor Lib &quot;user32&quot; Alias &quot;SetLayeredWindowAttributes&quot; (ByVal hWnd As Long, ByVal crey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long Private Type RECT Left As Long Top As Long Right As Long Bottom As Long End Type Private Declare Function CreateSolidBrush Lib &quot;gdi32&quot; (ByVal crColor As Long) As Long Private Declare Function SelectObject Lib &quot;gdi32&quot; (ByVal hdc As Long, ByVal hObject As Long) As Long Private Declare Function GetClientRect Lib &quot;user32&quot; (ByVal hWnd As Long, lpRect As RECT) As Long Private Declare Function DeleteObject Lib &quot;gdi32&quot; (ByVal hObject As Long) As Long Private Declare Function FillRect Lib &quot;user32&quot; (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long Private Sub Form_Load() Dim m_transparencyKey As Long m_transparencyKey = 0 SetWindowLong Me.hWnd, GWL_EXSTYLE, GetWindowLong(Me.hWnd, GWL_EXSTYLE) Or WS_EX_LAYERED SetLayeredWindowAttributesByColor Me.hWnd, &amp;HC8C9CA, 0, LWA_COLORKEY Dim mg As MARGINS, en As Long mg.m_Left = -1 mg.m_Bottom = -1 mg.m_Right = -1 mg.m_Top = -1 Dim R&amp;, t&amp;, bb As DWM_BLURBEHIND bb.dwFlags = DWM_BB_ENABLE Or DWM_BB_BLURREGION bb.fEnable = 1 bb.hRgnBlur = 0 bb.fTransitionOnMaximized = 1 DwmEnableBlurBehindWindow hWnd, bb End Sub Private Sub Form_Paint() Dim hBrush As Long, m_Rect As RECT, hBrushOld As Long hBrush = CreateSolidBrush(&amp;HC8C9CA) hBrushOld = SelectObject(Me.hdc, hBrush) GetClientRect Me.hWnd, m_Rect FillRect Me.hdc, m_Rect, hBrush SelectObject Me.hdc, hBrushOld DeleteObject hBrush End Sub +新内容 以及自己根据资料写的一个函数，绘制发光文本（使用 VB .NET）： Public Function DrawGlowingText(ByVal hDC As IntPtr, ByVal Text As String, ByVal Font As Font, ByVal Color As Color, ByVal Rect As Rectangle, ByVal GlowSize As Integer) As Integer Dim hTheme As Integer = OpenThemeData(GetDesktopWindow, &quot;TextStyle&quot;) If hTheme &gt; 0 Then Dim dib As New BITMAPINFO Dim dto As New DTTOPTS Dim hMemDC As Integer = CreateCompatibleDC(hDC) With dib.bmiHeader .biSize = 40 .biWidth = Rect.Width * 40 .biHeight = -Rect.Height * Font.Size .biPlanes = 1 .biBitCount = 32 .biCompression = BI_RGB End With With dto .dwSize = Len(dto) .dwFlags = DTT_GLOWSIZE Or DTT_COMPOSITED Or DTT_TEXTCOLOR .iGlowSize = GlowSize .crText = ARGB2RGB(Color) &#39;注意，.NET 中以 ARGB 方式保存颜色信息，而 Windows Theme API 以 RGB 方式解读信息 End With Font = New Font(Font.FontFamily.Name, Font.Size) Dim hDIB As Integer = CreateDIBSection(hDC, dib, DIB_RGB_COLORS, 0, 0, 0) Dim hObjectOld As Integer = SelectObject(hMemDC, hDIB) SelectObject(hMemDC, Font.ToHfont()) Rect.X = Rect.X + GlowSize DrawThemeTextEx(hTheme, hMemDC, 0, 0, Text, -1, 0, Rect, dto) BitBlt(hDC, Rect.Top, Rect.Left, Rect.Width, Rect.Height, hMemDC, 0, 0, SRCCOPY) SelectObject(hMemDC, hObjectOld) &#39;SetTextColor(hMemDC, intOldTextColor) DeleteObject(hDIB) DeleteDC(hMemDC) CloseThemeData(hTheme) Return 0 Else Return GetLastError() End If End Function 附：最好是使用相应 WM_PAINT 消息时将窗体整个用黑色画刷填充，然后再向上面绘制图片、文字（DrawThemeTextEx 或者 GraphicsPath 均可），这才是最终的解决方案。 相关声明嘛……啊我放在另一个模块里面了，比较乱，不复制了，网上都有。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"一些有用却没怎么见到过的常数","slug":"zh/2011-02-27-Useful-Constants-with-Little-Attention","date":"2011-02-27T10:01:00.000Z","updated":"2020-03-30T22:34:35.368Z","comments":true,"path":"categories/Tech/Coding/zh/2011-02-27-Useful-Constants-with-Little-Attention/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2011-02-27-Useful-Constants-with-Little-Attention/","excerpt":"","text":"注： 分类为“Style”的常数通用使用方法是 Call SetWindowLong(hWnd, GWL_STYLE, GetWindowLong(hWnd, GWL_STYLE) Or {VALUE}) 分类为“ExStyle”的常数通用使用方法是 Call SetWindowLong(hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) Or {VALUE}) 1、PS_ALTERNATIVE（= &amp;H8） 所属分类：Style 作用于 PorgressBar，可以实现动态效果。 当用一个 Timer 去不断改变 ProgressBar 的值的时候，会显示出渐变的效果。有了这个，网上所有的模拟 Windows XP 或 Windows Vista 动态进度条的控件全部不需要了。 2、BS_COMMANDLINK（= &amp;HE） 所属分类：Style 作用于 Button 类且样式为 Button 的窗口（不支持 CommandButton），可以实现 Vista 按钮效果。 在 VB6 下需要自己用 CreateWindowEx 来创建窗口，这个窗口会自绘。一般来说，重载可以简化操作。 3、LVS_EX_ 系列 所属分类：ExStyle 作用于 ListView（TreeView 自行推论），实现各种高级效果。 有了这个，不用担心 Common Controls 5.0 不支持一些 6.0 才提供的属性了，真是不错。不过有时会出现异常。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"微软都给可怜的 VB6 用户们隐藏了什么","slug":"zh/2011-02-09-What-Did-Microsoft-Hide-from-VB6-Users","date":"2011-02-09T06:18:00.000Z","updated":"2020-03-30T22:34:35.368Z","comments":true,"path":"categories/Tech/Coding/zh/2011-02-09-What-Did-Microsoft-Hide-from-VB6-Users/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2011-02-09-What-Did-Microsoft-Hide-from-VB6-Users/","excerpt":"","text":"1、最简单的，PrivateExtractIcons（系统主版本大于5才有）。不过今天我看了 VC++6，里面也没有这个声明，应该是微软当时没有想到吧。 2、IMAGE_*_HEADER，组成 PE 文件的结构的结构声明。在 API 浏览器中根本没有，要自己到头文件里去找然后翻译。话说最近我直接写了一个程序，输入结构声明输出 VB6 式的结构声明，所以还不算特别辛苦。但是这样搞 PE 结构就非常麻烦了……当然 API 浏览器比起别的辅助软件实在是太简单了，所以也不能算它的错。 3、很多人把 Microsoft Windows Common Controls 6.0 奉为神，因为它在很多方面都强于5.0。但是很致命的是它不响应 InitCommonControls！这样就做不出 XP 效果了。其实5.0+SendMessage 就可以做出6.0的效果，还附带着 XP 风格；不过有时会出现异常（我的系统是 Windows Vista），比如用 LVS_EX_FULLROWSELECT 的时候会出现风格变为无图标+有复选框+首项有下划线，有时甚至不能显示首项。按理说 LVM_FIRST 应该是内定的啊…… 4、一堆的 Nt* 函数都没有公开，这点不详细谈了吧。所以如果没有高人指点，CPU 使用率等等等等的问题只有微软会获取。 更多更多，在以后的实践中我会不断更新这篇日志。敬请期待。或者可以发表评论协助补充，相关评论我不会删除。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"极速关机","slug":"zh/2011-01-28-Extreme-Shutdown","date":"2011-01-28T05:25:00.000Z","updated":"2020-03-30T22:34:35.368Z","comments":true,"path":"categories/Tech/Coding/zh/2011-01-28-Extreme-Shutdown/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2011-01-28-Extreme-Shutdown/","excerpt":"","text":"唉以前看着学校那个“xxx 技术工具”费了好大脑筋都想不出那是怎么搞出来的。 比如那个“一键关机”吧，运行之后连个“正在关机…”都没有了，直接“呼”的一下就关了。怎么做到的？终于找到了…… Option Explicit Private Declare Function RtlAdjustPrivilege&amp; Lib &quot;ntdll&quot; (ByVal Privilege&amp;, ByVal Newvalue&amp;, ByVal NewThread&amp;, Oldvalue&amp;) Private Declare Function NtShutdownSystem&amp; Lib &quot;ntdll&quot; (ByVal ShutdownAction&amp;) Const SE_SHUTDOWN_PRIVILEGE&amp; = 19 Const SHUTDOWN&amp; = 0 Const RESTART&amp; = 1 Const POWEROFF&amp; = 2 Private Sub LetsShutdown() RtlAdjustPrivilege&amp; SE_SHUTDOWN_PRIVILEGE&amp;, 1, 0, 0 NtShutdownSystem&amp; SHUTDOWN&amp; Or POWEROFF&amp; End Sub 是不是很简单？佩服第一个非微软做出这个东西的人！微软在留给我们 ExitWindowsEx 的同时还留了一手……","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"标签漫谈","slug":"zh/2011-01-23-Talking-About-Labels","date":"2011-01-22T17:25:00.000Z","updated":"2020-03-30T22:34:35.367Z","comments":true,"path":"categories/Misc/Records/zh/2011-01-23-Talking-About-Labels/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2011-01-23-Talking-About-Labels/","excerpt":"","text":"什么是标签？为什么标签成了标签？搞不清楚这两个问题，我们就无法看清事实。 什么是标签？此处的“标签”，是人类社会发展过程中，各个个体为了协调利益而建立的相对统一的价值观反过来在个体上的一种体现。为什么标签成了标签？人们在追求利益时需对他人定性判断，共同价值观很容易就成为了标尺；更何况贴标签时可以把“人类的”这个定语加上，压死人的功效很明显。在全球化时期，标签作用的扩展及其威力的增长也在进行。特别是现在全球“大多数人的心都一个样儿了”，是的标签及其标准也全球化了。至于小范围的标签，则是个体或小集体价值观的体现，其余类似。 比如说，梵高在世时被世人贴上了“疯子”的标签，但现在人们认为他是天才，那么在大众眼中标签的内容也就成了“天才”。 我对一种做法挺感兴趣的，就是网络上一种名为类似贴标签的小玩意。这个在百度、QQ上都有，甚至一种名为“第六感”的系统能将谈话对象被人贴的“标签”投射到他的衣服上。多有趣！这样无疑使其他人能迅速对目标进行了解。 但这些标签附着者摘不了，正所谓“解铃还须系铃人”。人是一种社会性动物，在进化过程中已经意识到了独立生存的危险性，所以追求社会的认同。这亦是标签存在的基础。像被挂了标签的狮子不会有什么事，因为它并不十分需要狮子社会的认同，或该社会不存在所以标签也便没了意义。 在一个色会中必有优者和劣者，在一个体系中的各个个体也必然受标签的限制。我们看那只狮子觉得有趣是因为我们是在体系外的个体，自然不会有什么不妥；但狮子本身笑不出来。 但一个个体无论怎么被贴标签，若他不受其影响而保持其内核，他就值得存在。和氏璧在未经雕琢之时人们认为这只是块劣石，但它没有（也不能）被标签所累，其美玉的核心犹在，它就还是块美玉。如果只追求认同感而疲于奔命，就不存在他这个个体，取而代之的是评论者的评论所形成的集合体。那只被贴了标签的狮子就是一个鲜活的例子——它是怎样迷失自己的，予人以警示。 这就是说，你是谁只有你知道，标签再多也无效。但你就是你认为的你，而且如果你不知道你是谁，那么你就谁也不是。被标签所左右的人的存在时无意义的。 在一定的时间内被人们贴上了标签的事物，总会因个体差异而不同。这篇作文是45分也好，54分也好，都不代表它真实的价值——就像误差一样，标签与真实价值的差距不会消失，只会减小。竹林七贤在那个时代并不被理解，但现在他们都成了正面名人了——随着社会的发展与价值观的改变，标签也会变的。 所以有人说：“怎么办啊，我确实在某方面有突出的才能，但别人认为我只是疯子！”哦，永恒的时间会越过标签给你最公正的评价——它永远不被限制在我们的价值体系之内。 标注类型： 独特的观点 有类似的观点（估计也没什么人想到） 有此观点，但本文表述更好 天啊……怎么百度空间的编辑控件支持 Microsoft Word 2003 的剪贴板格式……这个结构我还没有搞清楚呢…… 对了，这是堂上作文，得分：48/60，自己想想吧……","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"屏蔽键盘的键（如 Win、Ctrl），使用底层键盘钩子（Hook）","slug":"zh/2010-12-11-Blocking-Keyboard-Input-Using-Windows-Hook","date":"2010-12-11T15:49:00.000Z","updated":"2020-03-30T22:34:35.367Z","comments":true,"path":"categories/Tech/Coding/zh/2010-12-11-Blocking-Keyboard-Input-Using-Windows-Hook/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2010-12-11-Blocking-Keyboard-Input-Using-Windows-Hook/","excerpt":"","text":"&#39;从网上找来的，原文……大家不要费脑筋去读了，因为把它整理成 VB 懂的格式费了我20分钟。 &#39;可以屏蔽一切你想要屏蔽的键……当然代码要输入完全，否则…… &#39;模块代码（mMain.bas） Option Explicit Private Declare Function CallNextHookEx Lib &quot;user32&quot; (ByVal hHook As Long, ByVal nCode As Long, ByVal wParam As Long, lParam As Any) As Long Private Declare Function SetWindowsHookEx Lib &quot;user32&quot; Alias &quot;SetWindowsHookExA&quot; (ByVal idHook As Long, ByVal lpfn As Long, ByVal hmod As Long, ByVal dwThreadId As Long) As Long Private Declare Function UnhookWindowsHookEx Lib &quot;user32&quot; (ByVal hHook As Long) As Long Private Declare Sub CopyMemory Lib &quot;kernel32&quot; Alias &quot;RtlMoveMemory&quot; (Destination As Any, Source As Any, ByVal Length As Long) Private Type PKBDLLHOOKSTRUCT vkCode As Long scanCode As Long flags As Long time As Long dwExtraInfo As Long End Type Private Const WM_KEYDOWN = &amp;H100 Private Const WM_SYSKEYDOWN = &amp;H104 Private Const WM_KEYUP = &amp;H101 Private Const WM_SYSKEYUP = &amp;H105 Private Const VK_LWIN = &amp;H5B Private Const VK_RWIN = &amp;H5C Private Const HC_ACTION = 0 Private Const WH_KEYBOARD_LL = 13 Private Const VK_CONTROL = &amp;H11 Private Const VK_ESCAPE = &amp;H1B Private Const VK_MENU = &amp;H12 Private Const VK_TAB = &amp;H9 Private Const VK_Delete = &amp;H2E Private lngHook As Long &#39;使用底层KeyboardHook阻拦按键消息 Public Function LowLevelKeyboardProc(ByVal nCode As Long, ByVal wParam As Long, ByVal lParam As Long) As Long Dim blnHook As Boolean Dim p As PKBDLLHOOKSTRUCT If nCode = HC_ACTION Then Select Case wParam Case WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP Call CopyMemory(p,ByVal lParam,Len(p)) If p.vkCode = VK_LWIN Or p.vkCode = VK_RWIN Then blnHook = True &#39;按下了左/右Win键 If p.vkCode = VK_CONTROL Or p.vkCode = VK_ESCAPE Then blnHook = True &#39;按下了Ctrl Esc键，如不需屏蔽可注释这句 If p.vkCode = VK_MENU Or p.vkCode = VK_TAB Then blnHook = True &#39;按下了Alt Tab键，如不需屏蔽可注释这句 Case Else &#39;不做 End Select End If If blnHook Then LowLevelKeyboardProc = 1 Else Call CallNextHookEx(WH_KEYBOARD_LL,nCode,wParam,lParam) End If End Function Public Sub HooK() lngHook=SetWindowsHookEx(WH_KEYBOARD_LL, AddressOf LowLevelKeyboardProc, App.hInstance, 0) End Sub Public Sub UnHooK() Call UnhookWindowsHookEx(lngHook) End Sub &#39;窗体代码（fMain.frm） Private Sub Form_Load() Call HooK &#39;屏蔽Win键 End Sub Private Sub Form_Unload(Cancel As Integer) Call UnHooK &#39;取消屏蔽Win键 End Sub","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"从 PE 文件或图标里获取并绘制大尺寸的图标（大于 32×32）","slug":"zh/2010-12-05-Extracting-and-Drawing-Large-Icons-in-PE-Files","date":"2010-12-05T05:20:00.000Z","updated":"2020-03-30T22:34:35.367Z","comments":true,"path":"categories/Tech/Coding/zh/2010-12-05-Extracting-and-Drawing-Large-Icons-in-PE-Files/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2010-12-05-Extracting-and-Drawing-Large-Icons-in-PE-Files/","excerpt":"","text":"最近在创作一个类似 Windows 资源管理器的程序。有几个难关：动态加载图标与 ListView 的结合、获取文件详细信息（三个时间、大小[不是用 FileLen，所以可以支持 Double 级别的大小]、类型和图标）、弹出标准资源管理器菜单、获取超过 32×32 的图标。 其中只剩下最后这个没有攻破。今天在 Google 上查找，终于找到了突破口！感谢第一个发现这个函数的网友。 或许你会问：不是有 ExtractIcon 和 ExtractIconEx 吗？为什么费尽心思来找这个？这是由于 ExtractIcon 和 ExtractIconEx 只能提取 16×16、32×32 的图标，对于 Windows XP 的 48×48 图标已经无能为力，更别说 Windows Vista 的 256×256 的图标了。所以这个函数是专门用来提取大图标和不规则图标的（如 Windows Vista 的 ImageRes.dll 中第一个图标，大小是 40×40）。 现在附代码如下，可以不用 LoadIcon 直接获得 PE 文件或图标中的指定大小的图标。 Option Explicit Private Declare Function PrivateExtractIcons Lib &quot;user32&quot; _ Alias &quot;PrivateExtractIconsA&quot; (ByVal sFile As String, ByVal nIconIndex As Long, _ ByVal cxIcon As Long, ByVal cyIcon As Long, ByVal phicon As Long, piconid As Long, _ ByVal nIcons As Long, ByVal flags As Long) As Long &#39;精华！这个函数一般是找不到的！有了这个，不用使用 LoadIcon、ExtractIcon、ExtractIconEx 了 Public Declare Function DrawIconEx Lib &quot;user32&quot; (ByVal hDC As Long, ByVal xLeft As Long, ByVal yTop As Long, ByVal hIcon As Long, ByVal cxWidth As Long, ByVal cyWidth As Long, ByVal istepIfAniCur As Long, ByVal hbrFlickerFreeDraw As Long, ByVal diFlags As Long) As Long Public Declare Function DestroyIcon Lib &quot;user32&quot; (ByVal hIcon As Long) As Long Public Declare Function GetIconInfo Lib &quot;user32&quot; (ByVal hIcon As Long, piconinfo As ICONINFO) As Long Public Type ICONINFO fIcon As Long xHotspot As Long yHotspot As Long hbmMask As Long hbmColor As Long End Type Public Const DI_NORMAL = &amp;H3&amp; Public Const LR_DEFAULTCOLOR = &amp;H0&amp; Public Const LR_DEFAULTSIZE = &amp;H40 &#39;封装之后的函数 Public Sub DrawIconToDC(ByVal PE_Icon As String, ByVal IconIndex As Long, ByVal hDC As Long, cX As Long, cY As Long, X As Long, Y As Long) &#39;PE_Icon 是 PE 文件（*.exe;*.dll;*.ocx;*.vxd;*.cpl 等等）或图标文件的文件名 &#39;IconIndex 是图标的索引，以绝对值为准（如 0=0，-1=1） &#39;hDC 是目标 DC（Device Context，设备上下文）。可以使用 GetDC(hWindow) 获取一个窗口的 DC。 &#39;cX 是欲加载的图标宽度 &#39;cY 是欲加载的图标高度 &#39;X 是绘制在目标上的 X 坐标（模式由 hDC 所指的设备所决定） &#39;Y 是绘制在目标上的 Y 坐标‍（模式由 hDC 所指的设备所决定） Dim lRet As Long Dim phicon As Long Dim picon As Long &#39;Dim cX As Long &#39;欲加载的图标宽度 &#39;Dim cY As Long &#39;欲加载的图标高度 &#39;Windows 会自动根据 cX 和 cY 的值决定加载哪个图标（若有多种格式） &#39;如，存在 48×48、32×32 图标时，cX=36, cY=32 将加载 48×48 的图标， &#39;并按照 36×32 的大小输出 &#39;MsgBox PrivateExtractIcons(&quot;C:\\Windows\\System32\\imageres.dll&quot;, -1, 0, 0, 0, picon, 1, 0) lRet = PrivateExtractIcons(PE_Icon, 2, cX, cY, VarPtr(phicon), picon, 1, LR_DEFAULTCOLOR) &#39;Or LR_DEFAULTSIZE) &#39;MsgBox &quot;Return val:&quot; &amp; lRet, vbInformation &#39;Dim pII As ICONINFO &#39;GetIconInfo phicon, pII DrawIconEx Me.hDC, X, Y, phicon, 0, 0, 0, 0, DI_NORMAL &#39;Print &quot;cX:&quot; &amp; pII.xHotspot * 2 &amp; vbCrLf &amp; &quot;cY:&quot; &amp; pII.yHotspot * 2 &#39;MsgBox picon &#39;必须销毁图标，因为 Windows 不会帮你 DestroyIcon phicon End Sub 使用方法： Call DrawIconToDC(&quot;C:\\Windows\\System32\\cmd.exe&quot;, 0, Picture1.hDC, 48, 48, 0, 0)","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Google 翻译——杰作啊","slug":"zh/2010-11-21-Playing-Google-Translate","date":"2010-11-21T10:58:00.000Z","updated":"2020-03-30T22:34:35.366Z","comments":true,"path":"categories/Misc/Records/zh/2010-11-21-Playing-Google-Translate/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-11-21-Playing-Google-Translate/","excerpt":"","text":"为什么这么说呢？在 Google 翻译中输入“字母+-men”的字符串，就会出来有趣的东西……下面是详细的列表，原文复制。 A-men 阿战警B-men 乙战警BF-men 高炉战警C-men 的C -男子D-men ð战警E-men 电子人F-men 架F -男子G-men 的G -男子H-men H型男人I-men 本人战警J-men 日本男人K-men 钾男人L-men L型的男子M-men 的M -男子N-men 的N -男子O-men O型男人P-men 的P -男子Q-men 调Q男人R-men 的R -男子S-men 的S -男人T-men T型男人U-men U型男人V-men V型男人W-men 钨男人X-men X战警Y-men Y型男人Z-men Z型男人 a-men 一战警b-men β-人c-men 的C -男子d-men ð战警e-men 电子人f-men 架F -男子g-men 克战警h-men H型男人i-men 我战警j-men 日本男人k-men k个男人l-men 升战警m-men 米战警n-men 欧米茄男士o-men O型男人p-men p型男人q-men 调Q男人r-men 的r -男子s-men 的S -男人t-men T型男人u-men U型男人v-men V型男人w-men 瓦特战警x-men X战警y-men Y型男人z-men Z型男人","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"附中趣事志补(2)","slug":"zh/2010-10-01-Joy-in-High-School-Affiliated-to-SCNU-Completion-Part-2","date":"2010-09-30T19:41:00.000Z","updated":"2020-03-30T22:34:35.366Z","comments":true,"path":"categories/Misc/Records/zh/2010-10-01-Joy-in-High-School-Affiliated-to-SCNU-Completion-Part-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-10-01-Joy-in-High-School-Affiliated-to-SCNU-Completion-Part-2/","excerpt":"","text":"要知道这篇文章我是没有备份的。原因是……看下面就知道了。 看出来了么？HL2+用佘氏！至于后面这个，因为涉及到个人隐私，不透露。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"附中趣事志补(1)","slug":"zh/2010-09-23-Joy-in-High-School-Affiliated-to-SCNU-Completion-Part-1","date":"2010-09-23T08:24:00.000Z","updated":"2020-03-30T22:34:35.366Z","comments":true,"path":"categories/Misc/Records/zh/2010-09-23-Joy-in-High-School-Affiliated-to-SCNU-Completion-Part-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-09-23-Joy-in-High-School-Affiliated-to-SCNU-Completion-Part-1/","excerpt":"","text":"之后的修改都将以“补”的形式出现。 本次增加内容（2010/9/23）： 外号那一块，我忘记说第4种了。这就是“bish”。这个是怎么来的？嗯，一位同学姓Q，好事者使用了近音词Qbish来称呼（发音而已）。本义是……将手指一次放进一个双门的洞里面的动作。然后 bish 又泛滥了，什么 Dabish、Xiaobish，等等，漫天飞舞…… 老师也有失言的时候。 美术老师（特级的……）：“嗯。是大卫吗？呵呵呵，是大卫。”请注意“呵呵呵”三个字无法描述当时他的表情、动作和语气……准确，但是不雅地说，像傻子。 语文老师：“助敌杀夫。”在讲《芦花荡》的时候……老师“助敌杀夫”了。 历史老师：“然后，他 Shǐ 了。”怎么个 Shǐ 法？想不通。 一位同学的外号演变很有趣。有两个分支。宿舍外，由于名字是 CRF，所以就成了“臭**”。宿舍内，生活习惯问题，从“大臭鞋”到“大肉（鞋?蟹?）”再到……“大闸蟹”。自己试着把这12个字都用阴平读出来……之后此人与舍友讨论“乳猪”，辨析“乳”字在此处的用法。不可否认的是，此人文采出众，而且很要强。最后说“乳”字乃“小”之意的时候，来了一句很经典的话：“‘小’,那么这宿舍怎么说？‘乳房’？”结果之后这位和讨论对象就很喜欢用“乳”字互称。对象名“Ge”，所以会听到这样的话：“我每天上学经过一条乳沟”、“我很喜欢吃大乳鸽”……然后“战火燃起”，“大乳鸽”、“大闸蟹”混响……化学组插嘴：事实上应该命名为 CrF3（三氟化铬）更合适……“大肉鸽”，化学组老二，话说这个“肉鸽”名号就是大闸蟹取的…… Peter 语录： “I wrong.”（我错了） “哎呀，我 play egg 了。”（完蛋） “哇，无敌越也用佘氏！” “Go you!”（去你的） “请问能不能借{物品}啊？”（经常这么说！）","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"附中各种有趣的事情(2)","slug":"zh/2010-09-04-Joy-in-High-School-Affiliated-to-SCNU-Part-2","date":"2010-09-04T09:08:00.000Z","updated":"2020-03-30T22:34:35.366Z","comments":true,"path":"categories/Misc/Records/zh/2010-09-04-Joy-in-High-School-Affiliated-to-SCNU-Part-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-09-04-Joy-in-High-School-Affiliated-to-SCNU-Part-2/","excerpt":"","text":"回到正题。之后还有一些事情发生。这是一件与DBQ、FBQ 和另外一个下文也会提及的同学（老贼）有关的事情。我们对行为 X 的音效有特定的称呼：“Ash”或者“Ush”，这两个词也是DBQ的最爱……见到人就“Ush”一下。“Ash”这个词就是“灰烬”的意思，所以有人总是说“灰灰”，就代表“Ash ash”……“Ush”这个词不是一个正规的词，它只有一种形式“Usher”，意思是“剧院领座员”。其实这个词不是“Ush”的名词形式吗，而“Ush”是……所以，“Usher”在这里就有了“***”的意思。想想，还有一个说唱歌手（亚瑟小子），也就是“Usher”了，囍。某一天老贼被 FBQ 叫起来回答“将来想要做什么”，结果老贼在 DBQ 的怂恿之下回答了“Usher”！全班笑翻。FBQ 自然不知道这里面的缘故（而且根据下文，词汇量……），问老贼：“这是什么？”老贼一本正经地回答：“剧院领座员。”全班再次笑翻。FBQ 还很高兴，说：“没想到我们班的同学还有这种志向！”她还没有，也不会提及我们在她的电脑上新建了一个名为“FBQ”的隐藏账户了。 我们还有一些“有趣的”规则。其中，φ（大写形式为Φ，音 phi）也是一个很好的代表物。这就像一串冰糖葫芦，被一根木条穿过……就像……（文字已隐藏），所以一只手大拇指和食指围成一个圈，另一只手的食指穿过就有了 X 意思。说实话，根据一篇文章，这个手势威尼斯人都认得；若是中国人就表示找市中心，若是非中国人就表示找红灯区。不知道这以后会不会延伸，让红灯区也挂上这个恶名呢。一般人做这个手势的时候，另外三根手指都会直立，看起来就像是“OK”一样。结果我最近做了一次，让另外一些同学猜是什么意思。结果他们想了想，说“臭氧”（O3）！确实是“O3”啊……我无语了。O3（这里没有打错！）是一个同学的外号，他的名字以 Yang 字结尾，根据我们这些“科学性”的人一想，就成了“臭 Yang”，然后就是“臭氧”…… 我们班有一个强人，此人从初中就开始显现实力。我们有普遍的圣人崇拜倾向，所以就送外号曰“无敌 Y”或“LY 无敌”。到了高一，新加入的同学在最短的时间内认同了这一点，结果“LY 无敌”就被“选”为“班级口号”。因此又延伸出一些“无敌”、“大师”、马斯特（Master）：“HS 无敌”、“K 大师”（2个）、“马斯特 M”……只要有一次“成名”的机会，很可能就会被“封为”“马斯特”。高一时全校运动会上，我们差点就要选“高一*班 LY 无敌”作为口号了……只不过老师“从中作梗”，班长也比较严肃地支持“正常的”口号，所以最后还是用了一个差得多的口号。 我们这里还有贼，就是“老贼”。之所以得到这个别称，是“坊间流传”老贼在初三的时候“偷学校的化学药品”以中饱私囊。注意，此流言没有经过证实，但是根据老贼的药品储量和质量好像真的应该这么说……得到这个别名之后，我们碰到一些问题，比如，课室的门锁了而课室管理员还没有来的时候，就会说“让老贼进去，反正他很有经验”。 我们的话题都是高度地专业化的。比如今天（2010年9月3日）我们班就出现了了新的“X 话题”。起因不清楚了，估计是 LYY 和 HS 的“讨论”吧，反正我从生化楼回来做题，刚好赶上开始说“括约肌”。我当然知道括约肌是什么，当然是……很恶心（Words are harmonized）。然后又听到了“海绵体”……^$*#^$，开始了。然后在场的人就“兴致勃勃”地讨论起“海绵体大战括约肌”来（事实上一开始前面三个字我没听清，之后求讲解才知道的）。然后，我们班的精英们（留下来搞卫生）就不断地大声地讲这两个东西……当然，这里有人去过生物竞赛培训，所以……更专业了……其间夹杂着“Dane”（广州话，发音不好打，用发音相近的英文词语代替）的声音，但是没有人停下来……&amp;*$&amp;*%(^，看来他们很喜欢这个话题啊……真是“数理化组大混战”，特别是 HS 回敬 LYY 的“你是想大战括约肌还是大战海绵体”……连 X 话题都这么专业。 还有一些化学组内部的情况。有一个 SL（Salty Lake），他得到这个外号是因为“遗传”。当 HS 想要戏弄的时候就会说“咸死啦”或者“湖哥”。当然，不知道为什么他也摊上了原级长（高一时的）的外号“HIA”；原级长得到这个是因为他讲话的时候会说“……嗯，HIA”（这个嘛，HIA 只是发音的拼写，或者写成这样，更清晰：[‘hia]）。但是这个是怎么来的，我也不清楚。我们见到他也喊“HIA”，一段时间之后他又得到了“局长”的外号，原因是这个：“Huafu Intelligence Agency”（对比 CIA，Central Intelligence Agency），缩写还是“HIA”……还有一个“丙酮酸”，这个是根据生物必修一的“葡萄糖的分解”得来的。丙酮酸包括3个基团，甲基、酮基（羰基）和羧基。甲基嘛，是因为“芨芨草”；“酮基”，是一位同学名字结尾时“Tong”；“羧基”，是因为一位同学自认“酸腐”，而羧基因为氧对电子的吸引使氢容易电离，显酸性。这三个人的大体思想特征倒是挺统一的。内行人士都知道，“该该该不该改改该该该改的错误呢”是什么意思……都是“gai”（10个），创纪录了……因为对象本人要求，这里就不公开了。还有一位“犀利哥”，这是公认实力强劲的一个同学，被封“犀利”（广州话，强）。关于一位被称为“洞”的同学，那是因为在高一开学的时候有个人故意叫错名字，结果后来竟然变成了全班公认的外号了…… 华附真是一个有趣的地方，充满了欢乐（囍），不过还是需要技术的，连玩笑都需要高技术……没有高技术的人就会被淘汰。 PS：请不要对这篇文章做非法评论，否则会被放进黑名单。特别适用于同班者。 PPS：I am not headcrabbed. (No spelling mistakes here.) PPPS：The cake is great. – GLaDOS, from the game Portal series PPPPS：Thanks for your visit at the MIC Studio, which is leaded by the Black Mesa Research Facilities. PPPPPS：这里的“附中”指的是华师附中，其他什么乱七八糟的，滚蛋。 PPPPPPS：本文所用到的所有人物名称都是简写，禁止对这篇文章所提到的人物进行人肉搜索，这是不道德的！ MIC","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"附中各种有趣的事情(1)","slug":"zh/2010-09-04-Joy-in-High-School-Affiliated-to-SCNU-Part-1","date":"2010-09-04T09:06:00.000Z","updated":"2020-03-30T22:34:35.366Z","comments":true,"path":"categories/Misc/Records/zh/2010-09-04-Joy-in-High-School-Affiliated-to-SCNU-Part-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-09-04-Joy-in-High-School-Affiliated-to-SCNU-Part-1/","excerpt":"","text":"附中，有着强大的凝聚力。下面就是一些有趣的事情。 先从初一军训说起。记得最深刻的就是两件事：一件是“洁厕精洗碗事件”，另一件是“高歌事件”。DL 同学一次洗碗，随手用了洗衣台上的一瓶清洁剂。当时，他还以为是普通的洗洁精，但是之后……有同学“严肃地”指出，那瓶东西是洁厕精！这件事在6个小时之内就传遍了全级，影响力持续了半个学期。另一位同学则在洗澡的时候在浴室大声唱歌，内容是什么我倒忘了，这种“野性的行为”倒是使他具有了一定的吸引力。 接下来就是混合部分，将会涉及各个方面的内容。 初中最有名的外号系列有四个，分别是“J 系列”、“Botch 系列”、“狗系列”和“D 系列”。 1、关于“J”，我们只知道当初有两个同学上学时走在一起，其中一个说了3个字……然后这3个字的结构发生了2次变化，最终简化成了一个字母——J。不久之后，“J”这个字母就出名了。很多人的名字都被改编成与“J”有关的。直到现在，都存在着“刘J”之类的绰号……只要是名字带有声母 j 或类似的声母的字，立刻就会被“J”所代替……如果没有，就会贴上一个。唉，人间地狱啊——“*子J”、“JJJ”（事实上是一位老师……），等等等等，“J”铺天盖地而来。刚好初二有个就有“林 JJ”……之后，由于“J”和“丁”十分相似，很多的又变成“丁”了，有如“PF丁”之类的绰号占据了半壁江山。不过很巧的是，PF 丁本人很喜欢“丁”这个字，初中时每次见到我都会说“第10个字母”（即 J）或者直接说“丁”，甚至对“红桃勾”很感兴趣。巧合吧…… 2、Botch 这个词，在 Word 文档的自动检查下竟然没有红线（出错），一查结果是“因笨拙而弄坏”或者“笨拙的工作”的意思。不过这个词在我们的心目中就没有这么好运了，因为……读音……就是*$&amp;$#!^@*（这个词 is harmonized）的翻版。所以，它特别适合我们这些高智商搞怪人士的青睐。我们班（2班）的“四大传声筒”之一的 YD，非常喜欢这个，当然 J 这个字母也不例外。他给几乎所有人的名（如果名字是两个字就是名字）后面加上“Botch”。此时涌现的是“Da Botch”、“Wei Botch”、“FD Botch”等等。后来可能他觉得这样不过瘾，在“Botch”后面又加了“断”、“没”、“痿”、“Gay”、“龟”以及其他很多种的字，此时这个后缀就得发三个音节的音了。不过 D 同学的例子很好玩，大家念一下“Da Botch”看看。然后再念“Double 7”，其中“7”按中文的读法。所以这位仁兄被赐予了“77”的别名。当然，根据这个词的来源，此人又被称作 DBQ。还有很好玩的地方就是，下文的“D 系列”与他也有关，他又成为了“Dum Da”、“Dog Da”、“Dum dum Da”……反正很多种，但是简写都是一堆的“D”！发展到最后，一个“DDDDD”就行了，或者美其名曰“地对地导弹”。一次下文的英语老师恰好说到“Seventy seven”的时候，全班爆笑……由于初二的英语老师“太过随和”，落得了一个“FBQ”的“美名”。当然这还是在这个同学的操纵下。 3、狗，说实话是一种有意思的动物，特别是有人会去学习它的作风的时候……此时，第一个吃螃蟹的人就被达同学叫做“狗”（“L 狗”，或许参考了 LG 吧）。之后在这个“宣传队”、“播种机”的宣传下，又有一批人成为了“狗”的牺牲品。如“C 狗”。不过说实话除了第一个真的有点像狗以外，其他的倒是不这么像。为什么呢？话说 LG 等众人（包括 CG、DD）都喜欢玩小球（也就是把网球当作足球踢），而 LG“很有钱”，经常买网球来踢，所以 DD 有几次就偷了 LG 的网球（5元）然后谎称“我捡到了一个”，又“恰巧”LG 的网球没了，所以 LG 就以30-40元的价钱买下了自己的网球……DD 净赚了卖出价…… 4、D 系列，是指“Dog”、“Dum”和“Dum dum”。“Dog”其实就是“狗”的英文翻译，只要能称为“狗 X”的，也会被称为“Dog X”。至于“Dum dum”，是根据《博物馆奇妙夜》的“Dum dum, give me gum gum”而来的。结果“Dum”或者“Dum dum”迅速地流传，成为了伟大的前缀。如“Dum J”或“Dog J”、“DD”等等。 这里插一段题外话。先揭第二段的谜底吧，答案就是“boqi”。这个词与 iPod 倒是有联系，看这个： 这个是从一位网友的图片得到灵感的……不知乔布斯有没有想到这种“iPod 的‘中国情结’”……他的图片就是把一个 iPod 放到镜子前面……所以这个应该叫做镜像（Reflection），之所以要提英文是因为“镜像”还有一个意思就是“光盘镜像”，也称“光盘映像”，这个词的翻译就应该是“Image”了。这又让我想起了著名的“注意你的 P 和 Q”（Remind your Ps and Qs），意思是注意礼节，来源就是以前使用拉丁文的国家的排字工很可能会把“b”、“d”、“p”和“q”的字模搞错。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"拖动无标题栏的窗口","slug":"zh/2010-08-31-Dragging-A-No-Caption-Bar-Window","date":"2010-08-31T11:10:00.000Z","updated":"2020-03-30T22:34:35.365Z","comments":true,"path":"categories/Tech/Coding/zh/2010-08-31-Dragging-A-No-Caption-Bar-Window/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2010-08-31-Dragging-A-No-Caption-Bar-Window/","excerpt":"","text":"很多时候编程都需要拖动无标题栏的窗口，我不想每次都去查 API 浏览器和 MSDN，所以就把代码放到博客上。其实 Form（Form1）改为任何具有 hWnd 属性的控件都可以。 Option Explicit Private Type POINTAPI X As Long Y As Long End Type Private Declare Function SetCapture Lib &quot;user32&quot; (ByVal hwnd As Long) As Long Private Declare Function ReleaseCapture Lib &quot;user32&quot; () As Long Private Declare Function GetCursorPos Lib &quot;user32&quot; (lpPoint As POINTAPI) As Long Dim Pt As POINTAPI Private bM As Boolean, oldX As Long, oldY As Long Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) SetCapture Form1.hwnd bM = True GetCursorPos Pt oldX = Pt.X oldY = Pt.Y End Sub Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) If Not bM Then Exit Sub GetCursorPos Pt Form1.Left = Form1.Left + (Pt.X - oldX) * Screen.TwipsPerPixelX Form1.Top = Form1.Top + (Pt.Y - oldY) * Screen.TwipsPerPixelY oldX = Pt.X oldY = Pt.Y End Sub Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) ReleaseCapture bM = False End Sub 这样就可以了。随意拖动没有标题栏的窗口。 但是，更好的方法是使用 SendMessage 发送 WM_NCLEFTBUTTONDOWN 消息，采用 HTCAPTION。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"小程序：模拟蓝屏","slug":"zh/2010-08-23-Simulated-Blue-Screen","date":"2010-08-23T14:40:00.000Z","updated":"2020-03-30T22:34:35.365Z","comments":true,"path":"categories/Misc/Records/zh/2010-08-23-Simulated-Blue-Screen/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-08-23-Simulated-Blue-Screen/","excerpt":"","text":"最近去了微软的网站，找到了这个： http://technet.microsoft.com/en-us/sysinternals/bb897558.aspx 经典的蓝屏……比国内什么“神州蚂蚁”做的逼真多了。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"鼠标，别动！","slug":"zh/2010-08-23-Mouse-Do-Stop","date":"2010-08-23T14:32:00.000Z","updated":"2020-03-30T22:34:35.365Z","comments":true,"path":"categories/Tech/Coding/zh/2010-08-23-Mouse-Do-Stop/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2010-08-23-Mouse-Do-Stop/","excerpt":"","text":"Option Explicit Private Const lBorder As Long = 4 Dim R As RECT Private Type RECT Left As Long Top As Long Right As Long Bottom As Long End Type Private Declare Function ClipCursor Lib &quot;user32&quot; (lpRect As RECT) As Long Private Declare Function ClipCursorByNum Lib &quot;user32&quot; Alias &quot;ClipCursor&quot; (lpRect As Long) As Long Private Declare Function SetRect Lib &quot;user32&quot; (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long Private Sub Form_Load() Cliper Open Environ$(&quot;WinDir&quot;) &amp; &quot;\\system32\\taskmgr.exe&quot; For Binary Lock Read Write As #1 &#39;禁用任务管理器 End Sub Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Cliper End Sub Private Sub Form_Unload(Cancel As Integer) ClipCursorByNum 0 Close #1 End Sub Private Sub Cliper() SetRect R, Left / Screen.TwipsPerPixelX + lBorder, Top / Screen.TwipsPerPixelY + lBorder, (Left + Width) / Screen.TwipsPerPixelX - lBorder, (Top + Height) / Screen.TwipsPerPixelY - lBorder ClipCursor R End Function Private Sub Form_Click() Static Counter As Long Counter = Counter + 1 If Counter&gt;=100 Then MsgBox &quot;整你玩儿!&quot;, vbInformation: Unload Me End Sub 然后……等着好戏吧。鼠标被限制在当前的窗口里了……而且要有规律地点100次才会取消。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Click Me……","slug":"zh/2010-08-22-Click-Me","date":"2010-08-22T13:27:00.000Z","updated":"2020-03-30T22:34:35.365Z","comments":true,"path":"categories/Tech/Coding/zh/2010-08-22-Click-Me/","link":"","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/zh/2010-08-22-Click-Me/","excerpt":"","text":"参考经典的“ClickMe”。 &#39;Form1 的 BorderStyle=0 &#39;Form1 里面 Private Declare Function BitBlt Lib &quot;gdi32&quot; (ByVal hDestDC As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long Private Declare Function GetDesktopWindow Lib &quot;user32&quot;() As Long Private Declare Function GetDC Lib &quot;user32&quot; (ByVal hWnd As Long) As Long Private Sub Form_Load Form1.Height = Screen.Height Form1.Width = Screen.Width Form1.Top = 0 Form1.Left = 0 Me.AutoRedraw = True BitBlt Form1.hDC, 0, 0, Screen.Width, Screen.Height, GetDC(GetDesktopWindow), 0, 0, vbSrcCopy End Sub &#39;Form1 有一个 Timer（Timer1），Interval=1 Private Sub Timer1_Timer() Form2.Show 1 Timer1.Enabled = False End Sub &#39;Form2 里面 &#39;Form2 的 BorderStyle=0 &#39;设置 Form2 的 KeyPreview 为 True，否则……运行时就真的惨了…… Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Me.Left = Random(Screen.Width - Me.Width) Me.Top = Random(Screen.Height - Me.Height) End Sub Private Function Random(ByVal Number) As Long Random = CLng(Rnd * Number + 1) End Function &#39;如果 KeyPreview=False，就不会触发这个事件了，就…… Private Sub Form_KeyDown(KeyCode As Integer, Shift As Integer) If KeyCode = vbKeyEscape Then MsgBox &quot;哈哈,这是专门给你的 SURPRISE!&quot;, vbInformation End End If End Sub &#39;Form2 有一个 Label（Label1），Caption=&quot;点我&quot;，Left=0,Top=0,AutoSize=True,字体……随便吧，反正自动调整。 Private Sub Form_Load() Me.Height = Label1.Height + Me.Height - Me.SacleHeight Me.Width = Label1.Width + Me.Width - Me.ScaleWidth End Sub 呵呵，这个还是可以用任务管理器终结的，因为还没有 SetWindowPos。不用那么毒了。 看起来就像是电脑瞬间就不能响应了（截屏了），而且必须“点我”才能恢复正常。 以上代码在本机测试通过。按 Escape 键退出。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.mottomo.moe/categories/Tech/"},{"name":"Coding","slug":"Tech/Coding","permalink":"https://blog.mottomo.moe/categories/Tech/Coding/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"半条命2，及之类的事情……","slug":"zh/2010-08-17-Half-Life-2-Stuff","date":"2010-08-17T14:12:00.000Z","updated":"2020-03-30T22:34:35.365Z","comments":true,"path":"categories/Misc/Records/zh/2010-08-17-Half-Life-2-Stuff/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-08-17-Half-Life-2-Stuff/","excerpt":"","text":"最近狂热地爱上了《半条命2》系列的游戏。看看这个： 呵呵，自己做的。包括自动启动，自动加载图标（新领悟的），反正没有 BUG 就是了。这是我看到研究所的快捷方式这么杂（桌面上安完了一共是8个左右的图标），太费劲了，所以就做了这个。前几天一个同学说 Windows 7 的库很好用，但是至少那是操作系统附带的功能嘛，还是自己的东西好。声明：里面的检测路径用到了随便玩玩（dods.cn 上的网友）写的批处理文件内容，特此感谢。 下载地址：http://u.115.com/file/f07218e57 文件名：Release.rar，645KB。 如果发现链接失效，可以在留言栏上留言，我会续期的。 因为网络原因（我用别人的无线网络），所以能下完这些已经算很好的了……其中的 EP1 还是在咖啡馆下的…… 这里面我最喜欢的是传送门:序曲和半条命2 SMOD。这两个真的不错啊！一个考脑力，一个让人爽歪歪！ 不过可惜的是 Garry’s MOD 运行不了，所以……我本来很想做好的视频的，结果只能在半条命2里面做。效果自然不好。npc_create 命令远比不上布娃娃好用啊。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Portal 里面的经典语句(2)","slug":"zh/2010-07-12-Sayings-in-Portal-Part-2","date":"2010-07-12T01:26:00.000Z","updated":"2020-03-30T22:34:35.365Z","comments":true,"path":"categories/Misc/Records/zh/2010-07-12-Sayings-in-Portal-Part-2/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-07-12-Sayings-in-Portal-Part-2/","excerpt":"","text":"在丰富学习中心，我们承诺永远会将您的独特想法及创意置于您的生命安全之上。但是，请勿摧毁生命测试设备。 这句话……真是符合您的做法…… 所有移动设备都需装备听得见的警告装置。但是，警告与闪烁的危险指示灯会刺激高能量药丸，因此，为了您的安全，这些警示装置已经停用。 有人家要来你家，你家地上有个大坑但平常有警示标志，你专门为了人家把它除掉的吗？ 你刚刚是不是把“光圈科学这是啥玩意儿”丢进“光圈科学能量智慧焚化炉”？ 是的。那是伦理核心，我知道你要干什么，不过……我可以使用 impulse 101 指令，哈哈哈！ 您知道您可以将一项或全部重要器官，捐给光圈科学的女生自尊基金吗？没错！ 您是女的？只是声音是而已吧，要不然我还可以说我爱上了机枪炮塔。 但是，首先请注意出口的炽热粒子场域。 我感觉不到。 如果需更多信息，请参加“丰富学习中心电子安全”讲座。 所以我一直前进，就是为了参加这个……直到发现只有几个球我才生气了…… 好人不会来这里。 我承认。 哈！我要制造更多。但是要花个几分钟。同时…喔，听着，火箭塔是你的老朋友。 朋友之间也可以相互利用的嘛。 吭。那个核心也有点相关责任。我关不掉炮塔防御系统。 是吗？反正我可以上 www.aperturescience.com 来操控你，关掉它，后面的副本就不用这么费劲了……但是你不是已经全部掉进“光圈科学能量智慧焚化炉”了吗？ 我可以在这里面洗个澡。也可以放在麦片上。揉进我的眼睛里。说真的，这完全不会致命。对我而言。 我想看……你的眼睛，还有…… 我替你感到难过，因为你找错地方了。 你替我感到难过，但是我不难过。我找对地方了。 我邀请了你最好的朋友“同伴方块”。当然，他不会来了，因为你杀了他。 您会邀请吗？用撬棍？您不是说“同伴方块”不会说话吗？他会来。最后我还是看到了蛋糕，一个同伴方块参加的 Party。不过又被你搅浑了！ 我不在意那样东西。我猜如果碰了它，你的人生会更惨。 听好了，我是大名鼎鼎的 Gordon Freeman（为什么不叫我 GMan？）的女友 Alyx Vance 的妹妹 Chell Vance，其中 Freeman 是游戏史上最伟大的英雄之一。所以应该是你的生命周期会更惨，因为红客不是好惹的！","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Portal 里面的经典语句(1)","slug":"zh/2010-06-27-Sayings-in-Portal-Part-1","date":"2010-06-27T02:01:00.000Z","updated":"2020-03-30T22:34:35.363Z","comments":true,"path":"categories/Misc/Records/zh/2010-06-27-Sayings-in-Portal-Part-1/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-06-27-Sayings-in-Portal-Part-1/","excerpt":"","text":"想必大家知道 Portal 这款游戏。看看在见到 GLaDOS 并开始打击之后的“制作蛋糕核心”（Sphere CakeMix）说了些什么： 一个 18.25 盎司包装的巧克力蛋糕材料如下:One 18.25 ounce package chocolate cake mix.一罐处理过的椰子酱。One can prepared coconut pecan frosting.3/4 杯蔬菜油。Three slash four cup vegetable oil.四个大鸡蛋。一杯微甜巧克力碎片。Four large eggs. One cup semi-sweet chocolate chips.3/4 杯奶油或人造黄油。Three slash four cups butter or margarine.1 又 2/3 杯砂糖。One and two third cups granulated sugar.两杯全能花卉。Two cups all purpose flower.别忘了装饰，例如：Don’t forget garnishes such as:鱼形状的饼干。Fish shaped crackers.鱼形状的糖果。Fish shaped candies.鱼形状的废弃物。Fish shaped solid waste.鱼形状的烂泥。Fish shaped dirt.鱼形状的乙苯。Fish shaped ethyl benzene.削好的甘草。Pull and peel licorice.鱼形状的有机化合物以及沉积物形状的沉积物。Fish shaped &lt;&gt; organic compounds and sediment shaped sediment.糖衣花生奶油片。形状像鱼一样。Candy coated peanut butter pieces. Shaped like fish.一杯柠檬汁。One cup lemon juice.阿尔法树脂。Alpha resins.不饱和聚酯。Unsaturated polyester resin.玻璃纤维表面聚酯。Fiberglass surface resins.还有易挥发的麦芽精调乳制品。And volatile malted milk impoundments.九个大型蛋黄。Nine large egg yolks.十二个中型土工材料膜。Twelve medium geosynthetic membranes.一杯砂糖。One cup granulated sugar.一个名称为“如何赤手空拳杀人”的入口。An entry called ‘how to kill someone with your bare hands.两杯切片的大黄。Two cups rhubarb, sliced.2/3 杯颗粒状的大黄。Two slash three cups granulated rhubarb.一茶匙多用途大黄。One tablespoon all-purpose rhubarb.一茶匙磨碎的橙色大黄。One teaspoon grated orange rhubarb.三茶匙大黄，用火烤。Three tablespoons rhubarb, on fire.一大份大黄。One large rhubarb.一份混合钻孔的电磁成像大黄。One cross borehole electro-magnetic imaging rhubarb.两茶匙大黄汁。Two tablespoons rhubarb juice.可调整的铝制磁头定位器。Adjustable aluminum head positioner.屠杀电子针头注射器。Slaughter electric needle injector.无线电子针头注射器。Cordless electric needle injector.注射器针头驱动程序。Injector needle driver.注射器针头枪。Injector needle gun.头盖骨。Cranial caps.还包含经过许可的防腐剂、深入渗透的媒介，以及瓦斯和气味控制化学制品。And it contains proven preservatives, deep penetration agents, and gas and odor control chemicals.那可以去除臭味并保存腐败的组织。That will deodorize and preserve putrid tissue. 这是我好不容易从对话表里面按照顺序排好的。现在看看 Ellen McLain（GLaDOS 的配音演员）说了什么： [Ellen McLain：GLaDOS 的配音演员]当他们告诉我结尾的时候还要唱首歌时，我就寻思着，哪个来写这首歌呢？他们告诉我这首歌将由 Jonathan Coulton 来创作。之后我聆听了 Jonathan 创造的这首歌曲，这歌算是有趣又活泼的了。当然我就想，让我唱倒是没问题， 但我是唱歌剧的，我每天唱的都是 [歌剧唱腔]。我考虑的是，我能够把握这首歌曲的风格吗？真让我担心呐。但后来在录音前，他们把这首歌曲的 mp3 文件发给了我。这次是 Jonathan 演唱的，我听着听着， 不自觉地爱上了这首小曲儿。在家的时候，我趁着练歌的间隙，你知道，尝试着采用些 GLaDOS 的声音。里面有句“Aperture Science…”，就是这台可怜，虽然被动但又带有侵略性的电脑，她一直都孤独着，直到人们想要闯入并杀掉她。所以她当然会不安。但是，她好像 … 似乎她的不安来自于蛋糕。而且… 我也要玩这个游戏，因为我要改造里面的蛋糕秘方。然后在里面安个“传送门”，当有朋友来我家玩时，我就用这些蛋糕来招待我的朋友们。[Ellen McLain: Voice of GLaDOS] So when they told me that there was going to be a song at the end, I thought, well, allright, who’s going to write the song? And they told me there was going to be a song written by Jonathan Coulton. And I listened to a song that Jonathan had written, and it was very funny, very clever. So, I thought at that point, well, you know, this’ll be okay. But I am an opera singer, so usually I sing: [opera singing]. And I thought, well, will I be able to have the right style for the song? So I was concerned. But then before the recording, they sent me an mp3 file of the song. And I listened to it with Jonathan singing it. But I loved the little song. And at home, as I practiced the little song, I tried to, you know, get back to GLaDOS’s voice. You know: ‘Aperture Science…’ Just this tiny little passive-aggressive computer who’s all alone until people try to come in and murder her. So of course she gets upset! But she seems… She seems to have this real affinity for cake. And… And I want to play the game because I want to recreate the cake recipe. And then put ‘Portal’ on it, and be able to serve it to my friends when they come over to my house. 呕吐……看来 Ellen 很喜欢这个……那就享受大黄（Rhubarb）吧。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]},{"title":"Legend of Peter the Great","slug":"zh/2010-03-07-Legend-of-Peter-the-Great","date":"2010-03-06T22:11:00.000Z","updated":"2020-03-30T22:34:35.363Z","comments":true,"path":"categories/Misc/Records/zh/2010-03-07-Legend-of-Peter-the-Great/","link":"","permalink":"https://blog.mottomo.moe/categories/Misc/Records/zh/2010-03-07-Legend-of-Peter-the-Great/","excerpt":"","text":"世界处于混沌之中。 上帝说：让 Peter 出世吧！于是一切都显现。 上帝又说：Peter，看看这个我创造的世界。Peter 说：Go you! 上帝发火了：我是无敌Y（无敌R）上天化为上帝，你本来连参拜的资格都没有，还敢斗嘴？Peter：Sorry, I wrong. 上帝清醒了，说：我怎么会发火呢？对不起啦！Peter 云：It’s not important. 上帝，你有没有纸巾啊？你有没有《华附欢迎你》的碟啊？ 上帝：……我任命你为盐湖城的龙王吧，如何？ 结果这位 Peter 产生了大量 NO2，威胁到人类的生存。上帝怒吼：PTG，你在干什么！ 于是，世上终于少了一个皮x龙，多了一个 Peter the Great（彼得大帝，又名龙王，真名 Peter Long）。 严格来说，本文纯属胡扯。本文基于事实撰写，有一定现实意义。各位读者注意加粗、斜体与下划线所画出来的字，谢谢。 警告：切勿对本文提到的人名进行人肉搜索，这是绝对不道德的，违法的！望各位三思。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.mottomo.moe/categories/Misc/"},{"name":"Records","slug":"Misc/Records","permalink":"https://blog.mottomo.moe/categories/Misc/Records/"}],"tags":[{"name":"过去的人事物","slug":"过去的人事物","permalink":"https://blog.mottomo.moe/tags/%E8%BF%87%E5%8E%BB%E7%9A%84%E4%BA%BA%E4%BA%8B%E7%89%A9/"}]}]}