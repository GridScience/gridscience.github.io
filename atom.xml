<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花嫁達の部屋</title>
  
  
  <link href="https://blog.mottomo.moe/atom.xml" rel="self"/>
  
  <link href="https://blog.mottomo.moe/"/>
  <updated>2024-05-09T16:23:53.423Z</updated>
  <id>https://blog.mottomo.moe/</id>
  
  <author>
    <name>头蟹床(Headcrabbed)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MetaSound 实战：还原《马里奥惊奇》吞食花关卡的音频协同机制</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2024-03-18-MetaSound-Real-Application/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2024-03-18-MetaSound-Real-Application/</id>
    <published>2024-03-18T22:34:00.000Z</published>
    <updated>2024-05-09T16:23:53.423Z</updated>
    
    <content type="html"><![CDATA[<p>MetaSound 游戏音频实战，带程序化生成。做出成品已经到4月6日了。视频在这里：<a href="https://www.bilibili.com/video/BV1Pq421w7Eh/">https://www.bilibili.com/video/BV1Pq421w7Eh/</a>。这篇文章想以文字的方式记录一些要点。</p><span id="more"></span><p>起因就是群友传的图，关于《马里奥惊奇》（Super Mario Bros. Wonder）的：</p><p><img src="/images/misc/05AD18497027A86D4E0453B281201A4B.jpg" alt="赞美之词"></p><p>尤其是这一段：</p><blockquote><p>如果你看完上述细节之后，完全不觉得这些设计有什么厉害的……那么你可能是真的不了解游戏音乐吧。好做就都做了。</p><p>哪怕你是给奥本海默写了令我五体投地的原声带，也不能把游戏音乐想得太简单呢。</p></blockquote><p>我看到后就想，这些想法作为用户来说可以理解，但是在开发人员的角度提到的功能是很容易做的。完全没有必要发表这样的评论；这令人笑掉大牙。游戏创意不错是真的（虽然也不是新鲜的想法），游戏音乐不简单也是真的，但图中列举的这些功能并不难做。为了打脸，我就以一个非技术音频的身份来尝试还原这些机制，以此来证明确实不难。在此之前我并没有音频中间件的使用经验，手头也没有主流音频中间件，也不想为了这么一个小打小闹去购买一个授权再学习。所以我就想到了 MetaSound，正好符合我的需求。</p><p>MetaSound 是什么？<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/metasounds-in-unreal-engine">文档在这里</a>。简单来说，它是 Unreal Engine 5 新引入的一个模块，可以实现动态音频生成和控制（包括混合）的功能。在2021年的时候杨彦君就跟我提到过它。不过当时没时间，也没有需求去探索这一块内容。刚好，这次的打脸行动就给我创造了机会。</p><p>虽说不难做，但是要是实现这些功能，需要一定的知识储备。具体包括：</p><ol><li>音乐理论；</li><li>数字音乐中的数学；</li><li>主流游戏引擎的使用；</li><li>游戏编程；</li><li>动画制作。</li></ol><p>其中我暂时还不会做出符合我要求的动画，所以上面的最后一条，关于动画的那一条，就不做了。如果会的话，动画放进去直接循环播放就行。那么我们开始吧。</p><h1 id="一、音轨混合相关的功能"><a href="#一、音轨混合相关的功能" class="headerlink" title="一、音轨混合相关的功能"></a>一、音轨混合相关的功能</h1><p>混合器是 MetaSound 的一部分，也就是说中间件常用的多轨混合可以很方便地实现。因此我们要准备每个音轨的内容，所以要先根据需求写好一个多声部的乐谱，并导出音频文件作为素材。例如，这里的需求是：</p><ul><li>吞食花要有多个声部；</li><li>吞食花声部之间要有明确功能区分；</li><li>要有铃鼓声部；</li><li>要有哼唱声部；</li><li>其他的声部和正常乐曲需求差不多。</li></ul><p>准备好之后导出音频，就可以独立控制每个音轨的音量了。如果你想，还可以加效果器。这就足够完成声部相关的几个功能，只需要结合具体游戏逻辑即可。</p><h1 id="二、和弦相关的功能"><a href="#二、和弦相关的功能" class="headerlink" title="二、和弦相关的功能"></a>二、和弦相关的功能</h1><p>为了在恰当的时机演奏恰当的单个音符或者和弦，需要有能被订阅的事件。我在视频里是用了一个简单的相交查询来做的，还有就是订阅了角色落地事件，这里就略过了。另外，如果我们知道了此时的和弦，事件触发时，在什么时候演奏什么音，也是需要计算的。详细代码也略过，这是业务逻辑的一部分。</p><p>和弦和时间数据就用自定义资产类型来储存，只要代码里能拿到就行。</p><p>演奏单音很简单，只需要传入频率，接上波形生成器，并用节点控制持续时间即可。</p><p>演奏和弦（和琶音）稍微麻烦一点，要编写自定义的 MetaSound 节点。我参考的是 <code>FMusicalScaleToNoteArrayNode</code>（位于 <code>MetasoundMidiScaleToArrayNode.cpp</code>），节点输入和弦类型，输出和弦的一组半音。拿到半音数组后具体是齐奏（和弦）还是分解（琶音），在音频图里实现即可。</p><h1 id="三、尾声"><a href="#三、尾声" class="headerlink" title="三、尾声"></a>三、尾声</h1><p>说是简单，不过具体代码写起来和调试起来还是很花时间的，毕竟我不是技术音频嘛。例如上面的时间同步，联调还挺麻烦的。而且还有不少的辅助代码……</p><p>Unity 那边的情况我在视频里也锐评了一下。</p><p>原型有了，但是打磨其实也要花功夫。优化是必需的，考虑到 Switch 的性能……嗯，是必需的。音色的调节需要音效师帮助。还有一些具体的播放策略：</p><ul><li>给定和弦，应该播放什么样的序列？（我只是选择了和弦特征音分解）</li><li>演奏的时机如何？如果玩家在某个特定时间点做出动作，是立即播、延迟播，还是不播？（我是立即+限流的方式，听起来有瑕疵）</li><li>“前”“后”台音频（或者看作是音效和音乐）播放时是否需要其他音频控制，例如额外效果器？（我没做）</li></ul><p>只有方方面面都配合好了，才能带给玩家出色的游戏体验。这些才是困难的部分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MetaSound 游戏音频实战，带程序化生成。做出成品已经到4月6日了。视频在这里：&lt;a href=&quot;https://www.bilibili.com/video/BV1Pq421w7Eh/&quot;&gt;https://www.bilibili.com/video/BV1Pq421w7Eh/&lt;/a&gt;。这篇文章想以文字的方式记录一些要点。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="UE" scheme="https://blog.mottomo.moe/tags/UE/"/>
    
    <category term="MetaSound" scheme="https://blog.mottomo.moe/tags/MetaSound/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 转封装</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2024-01-26-FFmpeg-Transmux/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2024-01-26-FFmpeg-Transmux/</id>
    <published>2024-01-25T20:47:00.000Z</published>
    <updated>2024-01-25T21:04:14.386Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要把一个视频文件容器从 MKV 转为 MP4。以前的话就直接重编码了，反正看不出来。由于近期录屏用过 OBS，知道它有一个一键转封装的功能，而且又快又好，所以想用它的。试了一下，不行。（后面通过 FFmpeg 命令行输出推测应该就是部分流无法识别。）</p><p>那就直接用 FFmpeg 吧。我对它的命令行不熟，只用过几次，需求也不大。所以这里就做个记录。</p><p>源 MKV 有9条数据流，其中流0为视频流0，流1为音频流0，流2为字幕流0，其他分别是附件流0到5。我只需要在目标 MP4 中保留视频流和音频流。命令行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -find_stream_info -i input.mkv -map 0:v:0 -map 0:a:0 -map -0:s -codec copy output.mp4</span><br><span class="line"><span class="comment"># 在上述文件流结构的条件下，等价于：</span></span><br><span class="line">ffmpeg -find_stream_info -i input.mkv -map 0 -map -0:s -map -0:t -codec copy output.mp4</span><br></pre></td></tr></table></figure><ul><li><code>-find_stream_info</code> 测试流格式。</li><li><code>-codec copy</code> 复制编解码信息。（因为源视频流是 H.264、音频流是 AAC-LC，MP4 也支持这些格式。）</li><li><code>-map</code> <a href="https://trac.ffmpeg.org/wiki/Map">指定流映射</a>。其中可以指定负映射来删除流。上面删除字幕流等效于 <a href="https://superuser.com/a/1737568"><code>-sn</code></a>。</li></ul><p>这样在输出文件中就只有一条视频流和一条音频流了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近需要把一个视频文件容器从 MKV 转为 MP4。以前的话就直接重编码了，反正看不出来。由于近期录屏用过 OBS，知道它有一个一键转封装的功能，而且又快又好，所以想用它的。试了一下，不行。（后面通过 FFmpeg 命令行输出推测应该就是部分流无法识别。）&lt;/p&gt;
&lt;p&gt;那</summary>
      
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>NTFS 替代数据流</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2023-09-10-NTFS-Alternate-Data-Stream/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2023-09-10-NTFS-Alternate-Data-Stream/</id>
    <published>2023-09-10T01:30:00.000Z</published>
    <updated>2023-10-30T04:09:37.650Z</updated>
    
    <content type="html"><![CDATA[<p>替代数据流（alternate data stream）从 Windows 3.1 就开始正式使用了。这是 NTFS 的一项特性，<a href="https://www.ntfs.com/refs-features.htm" target="_blank" rel="noopener">ReFS 貌似有有限的支持</a>（我没测试过）。这个功能是 Windows 识别的文件系统的<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/e2b19412-a925-4360-b009-86e3b8a020c8" target="_blank" rel="noopener">可选功能</a>，不过（常见的）实现可以认为就一种。关于它的简要介绍，<a href="https://learn.microsoft.com/en-us/windows/win32/fileio/file-streams" target="_blank" rel="noopener">微软的文档</a>已经写得比较清晰了。</p><a id="more"></a><p>有意思的是，早期它会被<a href="https://www.jianshu.com/p/7842ee248621" target="_blank" rel="noopener">用于攻击</a>。当然，直到现在，如果没有合适的处理，你任然有可能掉到坑里——虽然绝大多数时候也不会遇上。</p><p>因为替代数据流也是一个文件系统对象，所以通用的文件操作（<code>CreateFile()</code>、<code>ReadFile()</code>、<code>WriteFile()</code>、<code>DeleteFile()</code>，省略了 ANSI/Unicode 后缀）都是支持的，只需要指定正确的对象名称就行。所谓“正确的对象名称”可以参照上面的文档链接。</p><p>怎么进行查询/枚举呢？查询的方法和标准文件是一样的，<code>CreateFile()</code> 就可以了。枚举，可以使用 <code>FindFirstStreamW()</code>、<code>FindNextStreamW()</code>。由于替代数据流和主文件共享属性，所以它只有名称和大小，没有额外的属性、权限信息。</p><p>如果你细心一点的话可以看到，<code>FindFirstStreamW()</code> 是从 Windows Vista 开始提供的。虽然那也是17年之前了而且早就被淘汰了，但是如果我想在更老的系统上去访问这些信息，行不行呢？答案是可以的，Windows XP 开始提供了 <code>BackupRead()</code>、<code>BackupSeek()</code>。更早的系统可能就真的需要人工读 MFT 了。</p><p>示例代码如下：</p><pre><code class="lang-c">// altdstrm.h#include &lt;Windows.h&gt;#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &quot;ll.h&quot; // linked list implementation, omittedtypedef struct tagAltDataStreamMetadata{    wchar_t fileName[MAX_PATH];    wchar_t streamName[MAX_PATH + 36];    uint64_t size;} AltDataStreamMetadata;typedef struct tagAltDataStreamEnumError{    wchar_t message[1024];} AltDataStreamEnumError;bool EnumerateAltDataStreams(const wchar_t* fileName, LinkedList* result, AltDataStreamEnumError* error);</code></pre><pre><code class="lang-c">// altdstrm.c#include &lt;wchar.h&gt;#include &quot;altdstrm.h&quot;bool EnumerateAltDataStreams(const wchar_t* fileName, LinkedList* result, AltDataStreamEnumError* error){    memset(error-&gt;message, 0, sizeof(error-&gt;message));    HANDLE hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE)    {        GetLastErrorMessage(GetLastError(), error-&gt;message, ARRAYSIZE(error-&gt;message));        return false;    }    bool hasError = false;    do    {        LPVOID backupContext = NULL;        BOOL shouldReadNextEntry = TRUE;        bool endOfFileReached = false;        while (shouldReadNextEntry)        {            AltDataStreamMetadata metadata;            bool gotMetadata = false;            shouldReadNextEntry = ReadSingleStreamMetadata(hFile, &amp;metadata, &amp;backupContext, &amp;gotMetadata, &amp;endOfFileReached);            if (shouldReadNextEntry &amp;&amp; gotMetadata)            {                wcsncpy_s(metadata.fileName, MAX_PATH, fileName, MAX_PATH);                llAppend(result, &amp;metadata, sizeof(metadata));            }        }        if (!endOfFileReached)        {            DWORD code = GetLastError();            if (code != ERROR_HANDLE_EOF)            {                GetLastErrorMessage(code, error-&gt;message, ARRAYSIZE(error-&gt;message));                hasError = true;            }        }        // Call BackupRead with bAbort=TRUE (see docs) to finish reading        {            WIN32_STREAM_ID dummy;            DWORD n;            BackupRead(hFile, (LPBYTE)(&amp;dummy), 0, &amp;n, TRUE, FALSE, &amp;backupContext);        }    }    while (false);    CloseHandle(hFile);    return !hasError;}BOOL ReadSingleStreamMetadata(HANDLE hFile, AltDataStreamMetadata* metadata, LPVOID* context, bool* gotMetadata, bool* endOfFileReached){    *endOfFileReached = false;    *gotMetadata = false;    // Windows expects the size of WIN32_STREAM_ID to be 20, but it is actually 24 on x64 machines (incorrect packing)    const size_t WIN32_STREAM_ID_SIZE = 20;    const size_t WRONG_WIN32_STREAM_ID_SIZE = sizeof(WIN32_STREAM_ID); // 24    // Extra bytes size is copied from WIN32_FIND_STREAM_DATA.    const size_t WIN32_STREAM_ID_BUFFER_SIZE = WIN32_STREAM_ID_SIZE + sizeof(wchar_t) * (MAX_PATH + 36);    LPBYTE dataBuffer = (LPBYTE)malloc(WIN32_STREAM_ID_BUFFER_SIZE);    memset(dataBuffer, 0, WIN32_STREAM_ID_BUFFER_SIZE);    BOOL continueReadingNextEntry = FALSE;    do    {        DWORD numBytesRead = 0;        BOOL readSomeData = BackupRead(hFile, dataBuffer, WIN32_STREAM_ID_SIZE, &amp;numBytesRead, FALSE, FALSE, context);        if (!readSomeData)        {            break;        }        if (numBytesRead == 0)        {            *endOfFileReached = true;            break;        }        LARGE_INTEGER toSeek = {0};        const WIN32_STREAM_ID* streamId = (const WIN32_STREAM_ID*)dataBuffer;        if (streamId-&gt;dwStreamId == BACKUP_DATA || streamId-&gt;dwStreamId == BACKUP_ALTERNATE_DATA)        {            readSomeData = BackupRead(hFile, dataBuffer + WIN32_STREAM_ID_SIZE, streamId-&gt;dwStreamNameSize, &amp;numBytesRead, FALSE, FALSE, context);            if (!readSomeData)            {                break;            }            wcsncpy_s(metadata-&gt;streamName, MAX_PATH + 36, (LPCWSTR)(dataBuffer + WIN32_STREAM_ID_SIZE), MAX_PATH + 36);            metadata-&gt;size = streamId-&gt;Size.QuadPart;            *gotMetadata = true;        }        toSeek.QuadPart += streamId-&gt;Size.QuadPart;        LARGE_INTEGER sought = {0};        if (toSeek.QuadPart &gt; 0)        {            BackupSeek(hFile, toSeek.LowPart, toSeek.HighPart, &amp;sought.LowPart, (DWORD*)&amp;sought.HighPart, context);        }        if (sought.QuadPart == toSeek.QuadPart)        {            continueReadingNextEntry = TRUE;        }    }    while (false);    free(dataBuffer);    return continueReadingNextEntry;}</code></pre><hr><p>另外一些有趣的链接：</p><ul><li><a href="https://blog.ironmansoftware.com/daily-powershell/powershell-alternate-data-streams/" target="_blank" rel="noopener">https://blog.ironmansoftware.com/daily-powershell/powershell-alternate-data-streams/</a></li><li><a href="https://www.codeproject.com/articles/13667/enumerating-alternate-data-streams" target="_blank" rel="noopener">https://www.codeproject.com/articles/13667/enumerating-alternate-data-streams</a></li><li><a href="http://www.irongeek.com/i.php?page=security/altds" target="_blank" rel="noopener">http://www.irongeek.com/i.php?page=security/altds</a></li><li><a href="https://unprotect.it/technique/ntfs-files-attributes/" target="_blank" rel="noopener">https://unprotect.it/technique/ntfs-files-attributes/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;替代数据流（alternate data stream）从 Windows 3.1 就开始正式使用了。这是 NTFS 的一项特性，&lt;a href=&quot;https://www.ntfs.com/refs-features.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReFS 貌似有有限的支持&lt;/a&gt;（我没测试过）。这个功能是 Windows 识别的文件系统的&lt;a href=&quot;https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/e2b19412-a925-4360-b009-86e3b8a020c8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可选功能&lt;/a&gt;，不过（常见的）实现可以认为就一种。关于它的简要介绍，&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/fileio/file-streams&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微软的文档&lt;/a&gt;已经写得比较清晰了。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>简单记录一下 GitHub SSH 主机密钥失效的问题解决</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2023-04-09-GitHub-SSH-Key-Error/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2023-04-09-GitHub-SSH-Key-Error/</id>
    <published>2023-04-09T10:37:00.000Z</published>
    <updated>2023-04-10T02:22:30.980Z</updated>
    
    <content type="html"><![CDATA[<p>3月23日的的时候 <a href="https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/" target="_blank" rel="noopener">GitHub 错误地更新了主机的 SSH 密钥</a>。这导致基于 SSH 的 Git 操作直到本地更新密钥之前都会失效。</p><p>由于我的博客是通过 Hexo-Git 部署的，所以这次一提交，也掉坑里了。</p><p>直接 <code>hexo d</code>，首先显示的是如下的错误消息（截取开头）：</p><pre><code class="lang-plain">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</code></pre><p>接着阅读可以发现是检测到密钥不匹配，而且开启了强制密钥验证，为了防止中间人攻击，所以就报错了。因为我以前通过 SSH 方式进行过 Git 提交，所以本地的密钥数据库（<code>.ssh/known_hosts</code>）存在主机记录。所以先按那篇文章所说的，删除旧的密钥：</p><pre><code class="lang-bash">ssh-keygen -R github.com</code></pre><p>执行完成后我再尝试推送，但遇到了另一个问题：</p><pre><code class="lang-plain">Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.</code></pre><p>因为此时我还没有手工通过 SSH 方式提交，所以数据库不存在记录。为了解决这个问题，我在 GitHub 上加回了本机的私钥（忘了是什么原因没掉了，之前是2017年设置的，呜呜）。但是这个问题仍然存在。有没有能不通过 SSH 进行一次 Git 拉取/提交而刷新 SSH 密钥的方法呢？（明显，直接 SSH Shell 上 GitHub 是不可能的。）</p><p>我对 SSH 工具不熟，所以还是找了一下。根据<a href="https://www.reviewplan.com/github-host-key-verification-failed/" target="_blank" rel="noopener">这篇文章</a>的指示，运行一下 <code>ssh-keyscan</code> 就行：</p><pre><code class="lang-bash">ssh-keyscan github.com</code></pre><p>然后将输出的内容加入到 <code>known_hosts</code> 里面。之后就正常了。</p><p>此外，还可以通过 <code>-F</code> 查询主机是否已知，或用 <code>-l</code> 列出所有已知主机：</p><pre><code class="lang-bash">ssh-keygen -F github.comssh-keygen -l</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3月23日的的时候 &lt;a href=&quot;https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 错误地更新了主机的 SSH 密</summary>
      
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Unity Input System 的控制方案（control scheme）应该怎么用？</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2023-04-09-Unity-Input-System-Control-Scheme/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2023-04-09-Unity-Input-System-Control-Scheme/</id>
    <published>2023-04-09T06:26:00.000Z</published>
    <updated>2023-04-10T02:16:18.549Z</updated>
    
    <content type="html"><![CDATA[<p>从 Unity 2019.1 开始，Unity 提供了一个新的模块 <a href="https://docs.unity3d.com/Manual/com.unity.inputsystem.html" target="_blank" rel="noopener">Input System</a>。它提供了方便的控制器切换、多控制方式可配置性、可扩展的控制器支持（例如映射虚拟控制器）等等。比起以前的 <a href="https://docs.unity3d.com/Manual/class-InputManager.html" target="_blank" rel="noopener">Input Manager</a> 来说结构化了不少，不用每个游戏都自己再写一套映射系统了。关于它的基础使用我就不说了，网上在它发布不久早就有了许多教程。这篇博文要记录的是绝大多数地方都没提到的，它的“控制方案”（control schemes）的使用方法和适合场景。</p><a id="more"></a><p>如果你使用的是 UGUI，项目中仅使用了 Input System（<code>Player</code> - <code>Configuration</code> - <code>Active Input Handling</code> 选择了 <code>Input System</code>），需要将其默认的 Input Manager 后端换为 Input System 后端。<a href="https://docs.unity3d.com/Manual/UIE-Runtime-Event-System.html" target="_blank" rel="noopener">这里</a>有操作指南。简单来说，直接找到场景中的 <code>EventSystem</code> 对象（通常是这个名字），将上面的 <code>Input Module</code> 换为 Input System UI Input Module。默认情况下，直接点击那个迁移按钮就行。</p><p>大多数情况下，你是不需要关心控制方案的，直接针对平台绑定输入源（按键、轴向输入）就行了。我一开始就是这么做的。这里以我做的玩意儿简化后的情况为例：</p><p><img src="/images/misc/20230409-input-system-01.jpg" alt="初始配置"></p><p>这张图值得注意的是，每个平台都分配了惯例的确认和取消按键（PlayStation 上用的是亚洲方案），即使它们的方位不一样。另外，所有控制都共享一个控制方案，没有独立的控制方案，这样的 input actions 资产应用后是这个样子：</p><p><img src="/images/misc/20230409-input-system-02.jpg" alt="Player Input 设置生成的资产"></p><p>这个文件粗看上去没什么问题。本地测试中，我测试了键盘和 XBox 手柄，两种控制器可以同时响应，手柄也是即插即用，不需要专门做控制切换的设置页面。（这是一个单人游戏，所以不用考虑本地多人之类的事情。）</p><p>然而，彩喵拿到 Switch 上测试之后反馈说，<kbd>A</kbd><kbd>B</kbd><kbd>X</kbd><kbd>Y</kbd> 根本没有响应。嗯？那 Unity 整一个专门的 Switch Pro Controller 控制器子类干什么呢？我不是针对这个 controller 分配了键 <kbd>A</kbd><kbd>B</kbd> 吗？你怎么就设置设置得上，运行运行不起来呢？</p><p>答：你不能直接使用 <kbd>A</kbd><kbd>B</kbd><kbd>X</kbd><kbd>Y</kbd> 绑定，而是需要用 <code>GamePad.buttonEast</code>、<code>GamePad.buttonSouth</code>、<code>GamePad.buttonNorth</code>、<code>GamePad.buttonWest</code> 来访问。也就是说整个 controller 必须退化成一个 generic D-pad controller，不能使用 Switch Pro Controller 子类。但是，如果你直接这么把原先分配给 Switch 的 <kbd>A</kbd> 和 <kbd>B</kbd> 替换成 <code>buttonEast</code> 和 <code>buttonSouth</code>，就会发现一个问题：虽然我们的目标是仅在 Switch 上使用它，但它在 PC 上也抢了 XBox 手柄的键位，导致 XBox 手柄的 <kbd>A</kbd> 和 <kbd>B</kbd> 变成了未定义行为。</p><p>到此直接分设备设置按键的尝试就失败了。怎么解决呢？我想到了分多钟控制方案。所以，第二版的是这样的：</p><p>首先在左上角添加四种控制方案：<code>Keyboard</code>、<code>XBox</code>、<code>PlayStation</code> 和 <code>Switch</code>。添加时记得把对应的设备需求选上。这里以 <code>XBox</code> 为例：</p><p><img src="/images/misc/20230409-input-system-03.jpg" alt="XBox Control Scheme"></p><p>然后，在主编辑界面将每个按键分配给对应的设备。这里还是以 XBox 为例：</p><p><img src="/images/misc/20230409-input-system-04.jpg" alt="每个按键分配到专门设备"></p><p>设置到 Player Input 上之后：</p><p><img src="/images/misc/20230409-input-system-05.jpg" alt="Player Input 设置生成的资产"></p><p>可以注意到在 <code>Actions</code> 下多了两项：<code>Default Scheme</code> 和 <code>Auto-Switch</code>。这两项的意义可以阅读工具提示来理解。前者控制的是默认的控制方案，如果未指定（<code>&lt;Any&gt;</code>）则会寻找第一个匹配到的；后者决定如果某个方案因为设备不满足而失效（例如，手柄断线），是否会尝试寻找并应用另一个可以匹配的。一般情况下，如果是全局只存在一个 Player Input，那选择 <code>&lt;Any&gt;</code> 和 auto-switch 是完全足够的。关于匹配过程可以参考 Input System 的<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/Devices.html#matching" target="_blank" rel="noopener">文档</a>，一句话概括就是匹配成功项最多者胜出。</p><p>看起来好了，那运行起来吧。等等，为什么手柄没反应，只支持键盘了？刚才不是好好的吗？我不是设置了 XBox 手柄的控制方案吗？为什么它没有同时启用呢？于是我开始找诸如“Unity input system control scheme”之类的网页，可惜基本没有解释。就算是 <a href="https://unity.com/features/input-system" target="_blank" rel="noopener">Unity 自己的页面</a>，里面的演示视频也只是简单添加了两种 control scheme 然后就正常运行了，看起来能动态切换，和我实测的并不一样。</p><p>直到我找到 Unity 官方论坛上一个讨论多个控制方案的帖子。其中一个开发者的<a href="https://forum.unity.com/threads/multiple-control-schemes-or-actions.727583/#post-4855205" target="_blank" rel="noopener">回帖</a>解答了我的疑问。（我之前也找过 Input System 相关的帖子，也见过这位老哥，他应该就是 Input System 的主要开发者之一。）以下是帖子节选，我加粗了重要部分：</p><blockquote><p>… Control schemes are only really relevant if you want to separate multiple different means of controlling your game/app from each other such that they are <strong>mutually exclusive</strong> and such that you can know which one is active at any one time (e.g. to display control hints).</p><p>So in effect, the intention for having two control schemes, one for keyboard and one for gamepad, would be that keyboard input is <strong>not meant to be used concurrently</strong> with gamepad input. While the keyboard bindings are active, the gamepad bindings will not be. If both are in the same control scheme, however, they will concurrently be active side by side. …</p></blockquote><p>本质上，不同控制方案之间是互斥的，同时只能采用一种。如果你玩过一些老的主机移植游戏，就很好理解：那些游戏不支持同时使用键鼠和手柄，而且也未必支持动态插拔，如果你想换控制器就需要进入游戏里专门的设置页面去切换。</p><p>到此问题也就有了个答案。如果希望同时支持键盘和手柄，而且不想做专门的手动切换，那么就应该是按照游玩设备分类，而非控制器分类。将 <code>Keyboard</code> 方案重命名为 <code>PC</code> 方案，然后添加可选设备：</p><p><img src="/images/misc/20230409-input-system-06.jpg" alt="PC 控制方案的控制器设备设置"></p><p>接着，将 PC 上可用的手柄输入也选上。这里以 XBox 为例：</p><p><img src="/images/misc/20230409-input-system-07.jpg" alt="手柄输入也适用于 PC"></p><p>图中 XBox 手柄的 <kbd>A</kbd> 不仅在 XBox 上有效，也在 PC 上有效。而在 PC 上，键盘也是有效的。（PlayStation 控制器同理。）所以，在 PC 上，你就可以同时接收到键盘和手柄输入了。</p><p>然而设置完毕后还有一个问题。可以见到对于“确认”行为，我们为手柄指定了三种按键：</p><ul><li>需要 XBox 控制器（PC 上或 XBox 上）<ul><li><kbd>A</kbd>（<code>&lt;XInputController&gt;/buttonSouth</code>）</li></ul></li><li>需要 PlayStation 控制器（PC 上或 PlayStation 上）<ul><li><kbd>○</kbd>（<code>&lt;DualShockGamePad&gt;/buttonEast</code>）</li></ul></li><li>需要 Switch Pro 控制器（Switch 上）<ul><li><code>buttonEast</code>（<code>&lt;GamePad&gt;/buttonEast</code>）</li></ul></li></ul><p>如果我没设置控制器需求的话，由于 <code>XInputController</code> 是 <code>GamePad</code> 的子控制器类型，所以通用 <code>GamePad</code> 的设置也会被响应，就出现了前文的未定义行为问题。但是理论上，既然我设置了控制器需求，而且我没有接入 Switch Pro 控制器，那最后一条应该不能响应才对。但是在实测中，虽然 input system 自动选择了 PC 方案，但 Switch 方案仍然会被响应。我认为这是 input system 的一个 bug。</p><p>这个bug要完美解决的话比较麻烦。不过在我的目标工程里不需要搞手动选择也不需要考虑多人，所以可以通过以下方法绕过去：<strong>保持 <code>Default Scheme</code> 为 <code>&lt;Any&gt;</code>，但是把 <code>Auto-Switch</code> 关了。</strong>该方法在 PC 和 Switch 上测试通过。（所以为什么 Switch 上又能识别 Switch Pro 控制器需求——HID，但直接配置特化不行呢？神秘。）</p><hr><p>Input System 是带有调试工具的，可以方便地看到当前连接的设备、采用的方案、按键映射等等，还有一些其他功能（给虚拟设备和远程设备用的），直接单击任意 Player Input 右下角的按钮即可。比如，正确设置后，运行时可以看到如下的界面：</p><p><img src="/images/misc/20230409-input-system-dbg-01.jpg" alt="实时观察 Input System 状态"></p><p>从图中可以看到：</p><ul><li>连接了3个设备（展开后可以看到是键盘、鼠标和 XBox 手柄）。</li><li>识别了一个玩家（默认的使用例）。<ul><li>玩家所占用的设备是键盘和 XBox 手柄。<ul><li>因此选用了 PC 控制方案。</li></ul></li><li>在 <code>.inputactions</code> 资产中定义的行为，实际被映射到了哪些控制器的哪些键/轴。<ul><li>如果出现了上文的“未定义行为”，可以看到 <code>Confirm</code> 和 <code>Cancel</code> 两个行为都同时绑定了 <code>buttonSouth</code> 和 <code>buttonEast</code>，因此按下后实际触发哪个是不确定的。</li></ul></li></ul></li></ul><hr><p>04-10: 配置的 control scheme 还是不能生效，跟 <code>Auto-Switch</code> 没关系。最后还是改加了一个手工过滤器，如下（健壮性不强，不过暂时够用）：</p><pre><code class="lang-csharp">using System;using UnityEngine;using UnityEngine.InputSystem;namespace Example{    public static class InputActionExtensions    {        public static bool MatchesExpected(this InputAction action)        {            // if (!PlayerInput.isSinglePlayer)            // {            //     Debug.LogWarning(&quot;Multiple players detected. Please fix PlayerInput setup.&quot;);            //     return false;            // }            var player0 = PlayerInput.GetPlayerByIndex(0);            if (player0 == null)            {                return false;            }            var activeControl = action.activeControl;            var bindings = action.bindings;            var schemeName = player0.currentControlScheme;            foreach (var binding in bindings)            {                if (binding.groups.IndexOf(&#39;;&#39;) &gt;= 0)                {                    var groups = binding.groups.Split(GroupSeparator, StringSplitOptions.RemoveEmptyEntries);                    var found = false;                    foreach (var group in groups)                    {                        if (group == schemeName)                        {                            found = true;                            break;                        }                    }                    if (!found)                    {                        continue;                    }                }                else                {                    if (binding.groups != schemeName)                    {                        continue;                    }                }                var bindingPath = binding.effectivePath;                if (InputControlPath.Matches(bindingPath, activeControl))                {                    return true;                }            }            return false;        }        private static readonly char[] GroupSeparator = { &#39;;&#39; };    }}</code></pre><p>使用示例：</p><pre><code class="lang-csharp">public void OnAction1(InputAction.CallbackContext context){    if (context.performed &amp;&amp; context.MatchesExpected())    {        // Logic here    }}</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Unity 2019.1 开始，Unity 提供了一个新的模块 &lt;a href=&quot;https://docs.unity3d.com/Manual/com.unity.inputsystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Input System&lt;/a&gt;。它提供了方便的控制器切换、多控制方式可配置性、可扩展的控制器支持（例如映射虚拟控制器）等等。比起以前的 &lt;a href=&quot;https://docs.unity3d.com/Manual/class-InputManager.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Input Manager&lt;/a&gt; 来说结构化了不少，不用每个游戏都自己再写一套映射系统了。关于它的基础使用我就不说了，网上在它发布不久早就有了许多教程。这篇博文要记录的是绝大多数地方都没提到的，它的“控制方案”（control schemes）的使用方法和适合场景。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="CSharp" scheme="https://blog.mottomo.moe/tags/CSharp/"/>
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Unity3D" scheme="https://blog.mottomo.moe/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>关于联想Y540键盘停止工作的事</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working/</id>
    <published>2022-04-19T23:23:00.000Z</published>
    <updated>2023-04-09T06:24:30.413Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上我的笔记本，联想Y540（9750H/16G/1650，在欧洲买的）的键盘突然罢工了。我本来想重启进 BIOS 开 VT 的，然而进入 BIOS 后键盘完全无法操作，只能电源键强杀。</p><p>再次开机，发现登录界面也无法用键盘控制（包括输入）了。没办法，先用屏幕键盘凑合一下。进去后打开设备管理器，发现键盘消失了，即插即用设备倒是多了一个无法读取设备描述符的设备（<a href="https://support.microsoft.com/kb/310123" target="_blank" rel="noopener">错误代码 <code>2B</code></a>）。禁用、卸载、重启数次依然如此。</p><p>由于我还有一个台式机，用的是 USB 键盘，所以先拿它来救急。我发现，在进入 BIOS 后，外置键盘是可以用的，笔记本自己的键盘倒是不行（<kbd>CapsLk</kbd>、<kbd>NumLk</kbd> 也不亮）。那么是不是固件问题呢？手动从 <code>BHCN42WW</code> 更新到 <code>BHCN44WW</code>，键盘依然无法使用。</p><p>这时候我发现了一个有趣但无法解决问题的事实。Y540 的键盘是有背光的，使用 <kbd>Fn</kbd>+空格调整亮度。现在，无论是在 Windows 下还是在 BIOS 中，这个功能都是可用的。另外，我能进入 BIOS，说明至少 F2 也是在那之前好好工作了的，要不根本没法进。也就是说，键盘的硬件（电路板、键帽、排线等等）应该是没问题的，大概率是软件出了意义不明的问题。</p><p>然后在联想自己的用户论坛上找到了<a href="https://forums.lenovo.com/topic/findpost/2250/5018199/5062483" target="_blank" rel="noopener">这么一个帖子</a>，让人把电池耗尽再开机。我试了试，断开电源，低电量时 Windows 自动休眠了。接回电源，再开机，键盘仍然没有恢复。我觉得这个方法行不通。但是在我第二天早上重启之后，<kbd>NumLk</kbd> 亮起来了。再一试，登录界面有响应了。也就是说，在接入电源后，你得再重启一次，让某个固件刷某个东西才行。</p><p>后来搜索发现，联想笔记本的键盘问题发生频率不低，断电法这种让人费解的办法甚至是一些网站推荐的在换修前的<a href="https://upgrades-and-options.com/2020/02/why-is-my-lenovo-laptop-keyboard-not.html#:~:text=Remove%20the%20battery%20and%20press%20the%20power%20button,keyboard%2C%20it%20might%20be%20time%20for%20a%20replacement." target="_blank" rel="noopener">最终手段</a>。也有因为联想自己固件更新导致硬件错误（而且无法回滚）的<a href="https://forums.lenovo.com/topic/findpost/2250/5018876/5350510" target="_blank" rel="noopener">愤怒老哥</a>，还有其他愤怒老哥（<a href="https://forums.lenovo.com/topic/findpost/2250/5100863/5439426" target="_blank" rel="noopener">1</a>、<a href="https://forums.lenovo.com/topic/findpost/2250/5107856/5484097" target="_blank" rel="noopener">2</a>）。究竟如何，还是大家评判吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上我的笔记本，联想Y540（9750H/16G/1650，在欧洲买的）的键盘突然罢工了。我本来想重启进 BIOS 开 VT 的，然而进入 BIOS 后键盘完全无法操作，只能电源键强杀。&lt;/p&gt;
&lt;p&gt;再次开机，发现登录界面也无法用键盘控制（包括输入）了。没办法，先用屏</summary>
      
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C# Tuple Element Names and Method Signatures</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/</id>
    <published>2020-07-26T05:42:00.000Z</published>
    <updated>2020-07-26T15:25:39.292Z</updated>
    
    <content type="html"><![CDATA[<p>Methods in C# have special checks if tuples appear in their signatures. Sometimes you can see confusing compile errors due to these checks, for example, in interface implementation. Unfortunately there is no such a “formal document” that defines these behaviors. So I note them down here, which may serve as a side note until the specification follows up (or not :D).</p><a id="more"></a><hr><p>I found this problem when writing a piece of code. An example is demonstrated below:</p><pre><code class="lang-csharp">using System;using System.Collections;using System.Collections.Generic;class Program{    static void Main()    {        var e = new SomeEnumerable();        foreach (var x in e)        {            Console.WriteLine(&quot;({0}, {1})&quot;, x.First, x.Second);        }    }}class SomeEnumerable : IEnumerable&lt;(int First, int Second)&gt;{    public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator()    {        throw new NotImplementedException();    }    IEnumerator IEnumerable.GetEnumerator()    {        return GetEnumerator();    }}</code></pre><p>The code compiles. That’s expected. But then I began to think, that the tuple (<code>(int First, int Second)</code>) is such a burden, because it spreads everywhere. Several classes have the similar definitions and usages, and those tuples all have the same semantics. According to the C# syntax, tuples equivalence are compared structurally. Element names are just <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/august/essential-net-csharp-7-0-tuples-explained" target="_blank" rel="noopener">a syntax sugar backed by attributes</a>. So, it should be okay to erase the names in the generics of interface, but keep them in the returned value to provide their semantics to the invoker. In other words, the code should be like this:</p><pre><code class="lang-csharp">//                                 ↓ notice the tuple hereclass SomeEnumerable : IEnumerable&lt;(int, int)&gt;{    //                 ↓ and here    public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator()    {        throw new NotImplementedException();    }    IEnumerator IEnumerable.GetEnumerator()    {        return GetEnumerator();    }}</code></pre><p>Guess what? I got a compile error. But what if I use the returned tuple without explicitly mentioning their element names?</p><pre><code class="lang-csharp">//           ↓ directly deconstruct the tupleforeach (var (f0, f1) in e){    Console.WriteLine(&quot;({0}, {1})&quot;, f0, f1);}</code></pre><p>When <code>SomeEnumerable</code> is unchanged, the code above can be compiled without any error.</p><p>Strange, isn’t it? It seems sometimes the tuples are structually equivalent, and sometimes they are not. Does it mean I have to keep all the frustrating <code>(int First, int Second)</code> pieces? Is it a negligence in language design, or some other problem?</p><p>Therefore I searched the specification and other documents. Unfortunately, by now the specification is only updated to <a href="https://github.com/dotnet/docs/issues/8251" target="_blank" rel="noopener">language version 5.0</a>. Microsoft Docs only has the full reference until <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/introduction" target="_blank" rel="noopener">the draft of version 6.0</a> (and it is not even a specification). Tuples were introduced in C# 7.0 and there is only <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples" target="_blank" rel="noopener">an incremental language reference</a> (only mentioned the lowest language version but not in an explicit branch). Well, C# 9.0 will be out soon. Unfortunately, there is no documentation of the compiler behaviors I presented above.</p><p>Then, according to the error code (<code>CS8141</code>) I was able to find <a href="https://github.com/dotnet/orleans/issues/3421" target="_blank" rel="noopener">dotnet/orleans#3421</a>. <a href="https://github.com/dotnet/orleans/issues/3421#issuecomment-390006944" target="_blank" rel="noopener">One of its discussion</a> mentioned <a href="https://github.com/dotnet/roslyn/pull/20838" target="_blank" rel="noopener">dotnet/roslyn#20838</a>, a pull request (PR) that relaxed the matching rules for tuple element names.</p><p>In C# 6.0, the types <code>System.ValueTuple&lt;...&gt;</code> are supported but the compilation will fail if the referened assembly is authored in C# 7.0 and custom tuple element names are used (<a href="https://github.com/dotnet/roslyn/issues/20528" target="_blank" rel="noopener">dotnet/roslyn#20528</a>). dotnet/roslyn#20838 fixed that problem by allowing names mismatch under certain situations. That is to say, the code below (taken from dotnet/orleans#3421) could not compile before, but can compile after that PR was merged:</p><pre><code class="lang-csharp">using System.Threading.Tasks;public interface ISomeGrain{    Task&lt;(bool someBool, string someString)&gt; Func();}class Impl : ISomeGrain{    public Task&lt;(bool, string)&gt; Func()    {        return Task.FromResult((true, &quot;&quot;));    }}</code></pre><p>However, this doesn’t solve my problem. My case is different from above and it can’t compile. According to dotnet/orleans#3421, this problem was fixed in .NET Core 2.1, but I still can’t compile on .NET Framework 4.7.2 and .NET Core 3.1 SDK. Is it a software regression?</p><p>I couldn’t find other PRs related to fixing tuple behaviors, so I read dotnet/roslyn#20838 carefully. The thing that interests me is the testing code added in this PR. Its snapshot (of the full file) in July 2020 is <a href="https://raw.githubusercontent.com/dotnet/roslyn/6ebca3944998fc585fde2a9a4beff2aa7cb82635/src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs" target="_blank" rel="noopener">here</a>.</p><p>After reading the tests I think I understand why it is like that: it is an <a href="https://en.wikipedia.org/wiki/Error-tolerant_design" target="_blank" rel="noopener">error-tolerant design</a>. All tuples (the ones that the syntax sugar use) are <code>System.ValueTuple&lt;...&gt;</code> types, and they can be assigned whenever implicit casts succeed. Moreover, you can use whatever name you like for the tuple elements (after C# 7.0). And those, may break code contracts and introduce subtle but deadly errors. Consider the code illustrated below:</p><pre><code class="lang-csharp">interface SomeInterface{    (string Name, string Address) GetContactInfo();}class SomeClass : SomeInterface{    // notice the element names of the tuple here    //   and the one defined in the interface    public (string Address, string Name) GetContactInfo()    {        // ...    }}</code></pre><p>Calling <code>GetContactInfo()</code> via <code>SomeClass</code> or <code>SomeInterface</code> will give you confusing results. So the best solution is prohibiting the change in element names.</p><p>Let’s head back to the problem at starting point. Unfortunately, if I want to preserve the semantics in code, I have to keep <code>(int First, int Second)</code> everywhere. I can’t omit some of them and write <code>(int, int)</code> instead. So be it.</p><hr><p>In the unit tests of <code>CodeGenTupleTest.cs</code> there are several error codes. After reading the invesigation process above, you should have understood why they are designed like that. However, the error messages are still unclear and confusing. They would be better with hints, like what GCC or Clang does. So here I will explain them with some examples. For each error there may be more than one way to be triggerred, and the examples below are the most simple ones.</p><p><code>CS8139</code>: Checked when overriding a method whose signature contains tuples. Thrown when element names in base and child classes differ.</p><pre><code class="lang-csharp">class Base{    public virtual (int, int) TupleAsReturn()    {        // ...    }    public virtual void TupleAsParam((int A, int B) value)    {        // ...    }}class Derived : Base{    //                             ↓ CS8139: cannot change tuple element name when overriding method    public override (int A, int B) TupleAsReturn()    {        // ...    }    //                   ↓ CS8139: cannot change tuple element name when overriding method    public override void TupleAsParam((int, int B) value)    {        // ...    }}</code></pre><p><code>CS8140</code>: Checked when one of a interface <code>I</code>‘s generic parameter <code>T</code> is instantiated with a tuple. Thrown when the <code>I</code>‘s implementation implements multiple <code>I</code>s but <code>T</code>s are the same tuple with different element names.</p><pre><code class="lang-csharp">interface IGeneric&lt;T&gt;{}//                                       ↓ CS0528：IGeneric&lt;(int A, int B)&gt; already exists in the implementation listclass Class1 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int A, int B)&gt;{}//                                       ↓ CS8140：IGeneric&lt;(int A, int B)&gt; already exists in the implementation list, with different tuple element namesclass Class2 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int C, int D)&gt;{}</code></pre><p><code>CS8141</code>: Checked when one of a interface <code>I</code>‘s generic parameters <code>T</code> is instantiated with a tuple. Thrown when <code>T</code>s have different element names.</p><pre><code class="lang-csharp">interface IGeneric&lt;T&gt;{    T Get();    void Set(T t);}class Class1 : IGeneric&lt;(int A, int B)&gt;{    //                        ↓ CS8141: tuple element names must match with interface method    public virtual (int, int) Get()    {        // ...    }    //                  ↓ CS8141: tuple element names must match with interface method    public virtual void Set((int, int) tuple)    {        // ...    }}class Class2 : Class1, IGeneric&lt;(int C, int D)&gt;{    //                             ↓ CS8141: tuple element names must match with interface method    public override (int C, int D) Get()    {        // ...    }    //                   ↓ CS8141: tuple element names must match with interface method    public override void Set((int C, int D) tuple)    {        // ...    }}</code></pre><p><code>CS8142</code>: Checked when defining a partial method whose signature contains tuples. Thrown when element names differ in declaration and definition.</p><pre><code class="lang-csharp">partial class Class{    partial void Method((int A, int B) tuple);}partial class Class{    //           ↓ CS8142: both parts of partial method must use the same tuple element names    partial void Method((int, int) tuple)    {        // ...    }}</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Methods in C# have special checks if tuples appear in their signatures. Sometimes you can see confusing compile errors due to these checks, for example, in interface implementation. Unfortunately there is no such a “formal document” that defines these behaviors. So I note them down here, which may serve as a side note until the specification follows up (or not :D).&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="English Version" scheme="https://blog.mottomo.moe/tags/English-Version/"/>
    
    <category term="CSharp" scheme="https://blog.mottomo.moe/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C# 元组元素名称和方法签名相关</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/</id>
    <published>2020-07-26T05:42:00.000Z</published>
    <updated>2020-07-26T15:04:02.574Z</updated>
    
    <content type="html"><![CDATA[<p>C# 中带元组的方法，在涉及继承、接口实现等等情况时遵循特殊的规则。可惜这部分并没有一篇文档记载，于是我就先记下来，以后如果这个规则正式成文了（或没成文），本文都可以起到参考作用。</p><a id="more"></a><hr><p>这是我在写一段代码时偶然发现的。示例代码如下：</p><pre><code class="lang-csharp">using System;using System.Collections;using System.Collections.Generic;class Program{    static void Main()    {        var e = new SomeEnumerable();        foreach (var x in e)        {            Console.WriteLine(&quot;({0}, {1})&quot;, x.First, x.Second);        }    }}class SomeEnumerable : IEnumerable&lt;(int First, int Second)&gt;{    public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator()    {        throw new NotImplementedException();    }    IEnumerator IEnumerable.GetEnumerator()    {        return GetEnumerator();    }}</code></pre><p>以上的代码编译通过，没有问题。然后我就想，这个元组（<code>(int First, int Second)</code>）写起来太麻烦了，几个类里都有相似的使用的地方，语义都是一样的。而且根据 C# 的语法，元组是可以判断结构等同的，字段的名字只不过是个<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/august/essential-net-csharp-7-0-tuples-explained" target="_blank" rel="noopener">有特性支持的语法糖</a>而已。那么，我就想将实现的接口相关类型的字段名称抹除，只在返回值提示字段意义。也就是说，改成下面这个样子：</p><pre><code class="lang-csharp">//                                 ↓ 注意这里的签名class SomeEnumerable : IEnumerable&lt;(int, int)&gt;{    //                 ↓ 和这里不一样    public IEnumerator&lt;(int First, int Second)&gt; GetEnumerator()    {        throw new NotImplementedException();    }    IEnumerator IEnumerable.GetEnumerator()    {        return GetEnumerator();    }}</code></pre><p>你猜怎么着？编译失败了。但是如果我使用的时候不加名字呢？</p><pre><code class="lang-csharp">//           ↓ 直接解构foreach (var (f0, f1) in e){    Console.WriteLine(&quot;({0}, {1})&quot;, f0, f1);}</code></pre><p>在保持 <code>SomeEnumerable</code> 为原状的情况下，上面这一段代码也可以正常编译。</p><p>怎么这么奇怪，有时候是结构等同的（只需要看字段顺序，不看字段名称），有时候不是结构等同的（字段顺序和名称都要看）？那岂不是我每个地方都得写上冗长的“<code>(int First, int Second)</code>”了吗？这是语言设计的缺漏还是其他什么问题？</p><p>于是我去找了这部分的规范和文档。可惜，<a href="https://github.com/dotnet/docs/issues/8251" target="_blank" rel="noopener">标准目前只到 5.0</a>，Microsoft Docs 上只到 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/introduction" target="_blank" rel="noopener">6.0 的草稿</a>。而元组是在 C# 7.0 引入的，相对正式的文档也只有一个<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples" target="_blank" rel="noopener">参考</a>。另外，不久之后，C# 9.0 就要出来了。很遗憾，没有任何文档记录了我上面演示的编译器行为。</p><p>接着，我根据编译器输出的错误信息（<code>CS8141</code>），找到了 <a href="https://github.com/dotnet/orleans/issues/3421" target="_blank" rel="noopener">dotnet/orleans#3421</a>。在其<a href="https://github.com/dotnet/orleans/issues/3421#issuecomment-390006944" target="_blank" rel="noopener">回复</a>中提到了 Roslyn 的修复 PR <a href="https://github.com/dotnet/roslyn/pull/20838" target="_blank" rel="noopener">dotnet/roslyn#20838</a>。这个 PR 的内容是放宽对元组名称匹配的限制，使得元组能在不支持元组字段命名、但是能使用元组类型本身的时候（例如 C# 6.0，见 <a href="https://github.com/dotnet/roslyn/issues/20528" target="_blank" rel="noopener">dotnet/roslyn#20528</a>），允许元组字段名称的部分或者全部不匹配。</p><p>也就是说，以下这段代码（dotnet/orleans#3421 中的例子）在这个 PR 之前会报告编译错误，但是之后是通过的：</p><pre><code class="lang-csharp">using System.Threading.Tasks;public interface ISomeGrain{    Task&lt;(bool someBool, string someString)&gt; Func();}class Impl : ISomeGrain{    public Task&lt;(bool, string)&gt; Func()    {        return Task.FromResult((true, &quot;&quot;));    }}</code></pre><p>但是这仍然不能解决我的问题，因为我的代码不是这种情况，并不能编译通过。根据 dotnet/orleans#3421 的描述，在 .NET Core 2.1 SDK 及之后应该是得到修复的。可是我在 .NET Framework 4.7.2 和 .NET Core 3.1 SDK 上编译，仍然无法通过。难道它是一个回归错误（regression）？</p><p>我没有找到类似的解决元组相关的 PR，所以就去看上面那个 PR 的内容。比较感兴趣的是加入的测试代码。现时点的快照是<a href="https://raw.githubusercontent.com/dotnet/roslyn/6ebca3944998fc585fde2a9a4beff2aa7cb82635/src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs" target="_blank" rel="noopener">这样的</a>。阅读了这些测试用例后才明白，原来这些编译错误就是防呆设计。理由也不难推测：元组的类型其实都是 <code>System.ValueTuple&lt;...&gt;</code>，而且可以任意修改元组字段名称；如果类型隐式转换通过的话，按照结构相等性，编译就会通过；但是修改字段名称就意味着修改代码约定，会引入难以排查的错误。考虑以下代码：</p><pre><code class="lang-csharp">interface SomeInterface{    (string Name, string Address) GetContactInfo();}class SomeClass : SomeInterface{    // 这里的返回值和接口规定的意义不一致    public (string Address, string Name) GetContactInfo()    {        // ...    }}</code></pre><p>在通过 <code>SomeClass</code> 和 <code>SomeInterface</code> 分别调用 <code>GetContactInfo()</code> 的时候就会产生令人困惑的结果。因此最好的方式就是禁止元组字段名称发生变化。</p><p>回到出发点的问题。所以很不幸地，如果要在代码中保留语义的话，我必须在每个地方都写上“<code>(int First, int Second)</code>”，而没法在一部分地方简写成“<code>(int, int)</code>”。</p><hr><p>在 <code>CodeGenTupleTest.cs</code> 的单元测试中出现了若干元组相关错误码。在阅读了上面的探索过程后，你应该理解了为什么它们这么设计。但是错误信息还是有点让人搞不清在说什么（GCC：我比你强），所以在这里简单做个整理。对于每一种错误，可能有多种触发方式，这里只举出简单直接的例子。</p><p><code>CS8139</code>：在类继承时，被覆盖的方法签名中含有元组时检查。如果元组各字段名称在基类和子类中不同，则输出这个错误。</p><pre><code class="lang-csharp">class Base{    public virtual (int, int) TupleAsReturn()    {        // ...    }    public virtual void TupleAsParam((int A, int B) value)    {        // ...    }}class Derived : Base{    //                             ↓ CS8139：覆盖时不可以更改元组元素名称    public override (int A, int B) TupleAsReturn()    {        // ...    }    //                   ↓ CS8139：覆盖时不可以更改元组元素名称    public override void TupleAsParam((int, int B) value)    {        // ...    }}</code></pre><p><code>CS8140</code>：某个泛型接口的泛型的实例化类型为元组时检查。如果实现了相同的泛型接口，只有元组字段名称不同时，输出这个错误。</p><pre><code class="lang-csharp">interface IGeneric&lt;T&gt;{}//                                       ↓ CS0528：IGeneric&lt;(int A, int B)&gt; 已经在实现列表中class Class1 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int A, int B)&gt;{}//                                       ↓ CS8140：IGeneric&lt;(int A, int B)&gt; 已经在实现列表中，只不过元组元素名称不同class Class2 : IGeneric&lt;(int A, int B)&gt;, IGeneric&lt;(int C, int D)&gt;{}</code></pre><p><code>CS8141</code>：某个泛型接口的泛型的实例化类型为元组时检查。如果实现时元组字段名称不同则输出这个错误。</p><pre><code class="lang-csharp">interface IGeneric&lt;T&gt;{    T Get();    void Set(T t);}class Class1 : IGeneric&lt;(int A, int B)&gt;{    //                        ↓ CS8141：元组元素名称必须和接口方法匹配    public virtual (int, int) Get()    {        // ...    }    //                  ↓ CS8141：元组元素名称必须和接口方法匹配    public virtual void Set((int, int) tuple)    {        // ...    }}class Class2 : Class1, IGeneric&lt;(int C, int D)&gt;{    //                             ↓ CS8141：元组元素名称必须和接口方法匹配    public override (int C, int D) Get()    {        // ...    }    //                   ↓ CS8141：元组元素名称必须和接口方法匹配    public override void Set((int C, int D) tuple)    {        // ...    }}</code></pre><p><code>CS8142</code>：分部方法签名中含有元组时检查。如果定义和实现中的元组字段名称不同则输出这个错误。</p><pre><code class="lang-csharp">partial class Class{    partial void Method((int A, int B) tuple);}partial class Class{    //           ↓ CS8142：分部方法的各个部分必须使用相同的元组元素名称    partial void Method((int, int) tuple)    {        // ...    }}</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;C# 中带元组的方法，在涉及继承、接口实现等等情况时遵循特殊的规则。可惜这部分并没有一篇文档记载，于是我就先记下来，以后如果这个规则正式成文了（或没成文），本文都可以起到参考作用。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="CSharp" scheme="https://blog.mottomo.moe/tags/CSharp/"/>
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>麻辣土豆新动作的骨骼曲线表</title>
    <link href="https://blog.mottomo.moe/categories/Tech/RE/zh/2020-05-07-MLTD-Skeleton-Curve-Table/"/>
    <id>https://blog.mottomo.moe/categories/Tech/RE/zh/2020-05-07-MLTD-Skeleton-Curve-Table/</id>
    <published>2020-05-06T20:15:00.000Z</published>
    <updated>2020-08-01T15:10:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>这次讲讲我是怎么得到土豆新动作的骨骼曲线表的。</p><a id="more"></a><hr><p>我在土豆二周年之后就没玩土豆了。但是从2019年8月开始，陆续接到一些土豆文件变化的 issue。Unity 版本更新引起的问题这里不讨论。<del>一个大的变化是土豆的动作文件不再公布源文件，只有“运行时”的文件。</del>大多数动作还是有源文件的，仅有“运行时”文件的只有少数，估计是复杂舞蹈的技术限制（运行时生成内存爆炸？）或者是资源发布错误。总之两种情况都必须处理。</p><p>在老的资源列表中，这两个文件都会给出。比如，<code>dan_shtstr_01.unity3d</code>（<a href="https://www.project-imas.com/wiki/Shooting_Stars" target="_blank" rel="noopener">Shooting Stars</a> 的动作）就会附带一个 <code>dan_shtstr_01.imo.unity3d</code>。在这个 <code>.imo.unity3d</code> 中就可以看到序列化了的源文件。将它转换成完整的帧序列还是很简单的。</p><p>但是新列表就不再带这些 <code>.imo.unity3d</code> 了。在 issue 中提到了 <a href="https://www.project-imas.com/wiki/Rebellion" target="_blank" rel="noopener">Rebellion</a>（<code>dan_rebell_01.unity3d</code>）。于是我只能去看这个文件的内容是什么。原来它是几个 <code>AnimationClip</code>，而且从结构和命名上分析，应该就是源文件“编译”之后的。也就是说，之前那些 <code>.imo.unity3d</code> 可能是不小心放进去的（自动构建时忘记排除）。也有可能是选择性地下载，如果网络差就下载源文件并在第一次播放时本地“编译”，这样可以减少数据传输量；如果网络好则直接下载成品。不管是因为什么，现在只有成品了。</p><p>那么第一步就很明显了：读取需要的 <code>AnimationClip</code>。这倒不难。而且由于土豆一直用的是 <code>Generic</code> 而不是 <code>Humanoid</code>，所以动作数据保存的是整个时间轴上的完整骨骼变换。也就是说，每一帧的所有变换的值都在。</p><p>接下来就有点麻烦了。可以看到骨骼动画中有180条曲线（curve）；那些源文件的曲线数量也是180，所以很大概率是一一对应的。但是这些曲线只有一个简单的索引值，并不像源文件那样写明对应的是哪个关节。这个索引肯定是在制作骨骼动画的时候自动按照某种规则指定的，而且应该是各文件统一的。所以，我们应该能找到一个静态的映射方式（映射表），得知某个索引对应的是哪个关节的什么变换。</p><p>我们先来看一下原来的顺序：</p><pre><code class="lang-plain">(POSITION, AngleX)(POSITION, AngleY)(POSITION, AngleZ)(MODEL_00, AngleX)(MODEL_00, AngleY)(MODEL_00, AngleZ)(MODEL_00/BODY_SCALE/BASE, AngleX)(MODEL_00/BODY_SCALE/BASE, AngleY)(MODEL_00/BODY_SCALE/BASE, AngleZ)...(MODEL_00, PositionX)(MODEL_00, PositionY)(MODEL_00, PositionZ)(MODEL_00/BODY_SCALE/BASE, PositionX)(MODEL_00/BODY_SCALE/BASE, PositionY)(MODEL_00/BODY_SCALE/BASE, PositionZ)</code></pre><p>先试试这个顺序吧。但是结果很不妙。为了避免精神污染，我就不放图了。</p><p>嗯……怎么找正确的顺序呢？又到了找弱点的时间了。我认为，在上文静态表的基础上，还应该有附加条件：</p><ol><li>这个表很可能不是随机的。如果是的话，美术方面的维护和调试会很麻烦。当然也不排除万代丧心病狂，写一个内部插件自动完成这件事——在国内还真的有可能，但是日本……不太可能。</li><li>项之间应该会呈现明显的逻辑相关性。<ol><li>同一个关节的某种分量会分组。比如，<code>MODEL_00</code> 的三个旋转分量会成一组，三个位移分量会成一组。</li><li>有固定的层次上的先后顺序。比如，考虑 <code>MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2</code> 和 <code>MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2/SAKOTSU_L</code>，前者是后者的父关节。如果前者在后者之前，那么所有的父节点应该在其子节点之前，反之则是之后。但是不确定对称关节的顺序，可能是左前右后，也可能是左后右前。根据老的数据推测，是左前右后。</li></ol></li><li>有可能遵循其他的简单先后逻辑或者它们的组合（可能性未知）：<ol><li>关节名称的字符串顺序；</li><li>所有旋转在位移之后或之前；</li><li>同一个关节的旋转组和位移组相邻，组成大组。</li></ol></li><li>考虑到骨骼层级，新顺序可能很大一部分的内部相对顺序都和原顺序中的一致。</li></ol><p>我试了几个写起来简单的顺序，但是都不对。这下我就有点头疼了，毕竟可是有180条曲线啊。</p><p>突然，在调试的时候，我发现动画帧的数据好像有着很明显的模式。一个帧存着这帧对应时间点的所有关节的变换数据，所以看这个帧里的数组的时候相当于在对各个变换进行横向的比较。于是我就想到了一种方法：能不能通过分析这种模式来找出新顺序呢？</p><p>说干就干。我写了两个小方法，将动画的帧输出到 CSV 文件中。用的分别是 <code>dan_hmt001_01.imo.unity3d</code>（<a href="https://www.project-imas.com/wiki/Blooming_Star" target="_blank" rel="noopener">Blooming Star</a>）和 <code>dan_rebell_01.unity3d</code>。在 Excel 中打开：</p><p><img src="/images/misc/20200507-dan-hmt001.jpg" alt="老文件：hmt001"></p><p><img src="/images/misc/20200507-dan-hmt001.jpg" alt="新文件：rebell"></p><p>可以看到，列之间显示出了很强的分组倾向。然后我们再将这些列的模式写出来（这一切发生在我的脑中，这里写出来更容易理解）：</p><pre><code class="lang-plain">[rebell]#1: (~-0.00x approx, 0 const, ~-0.07 approx)#2: (0 const, 0 const, 0 const)#3: (~-0.00x approx, 0 const, ~-0.07 approx)#4: (0 const, ~+0.87 approx, 0 const)#5: (0 const, 0 const, 0 const)...#60: (? var, ? var, ? var)[hmt001]MODEL_00#rotation: (0 const, 0 const, 0 const)MODEL_00#translation: (~-0.005 const, 0 const, ~-0.03x approx)BASE#rotation: (~+0.754 const, ~-78.6 const, ~-3.35 const)BASE#translation: (0 const, ~+0.87 approx, 0 const)...SCALE_POINT#translation: (0 const, 0 const, 0 const)</code></pre><p>有些分量是常数，有些是变化较小的（因舞蹈不同可能会有不同值，变化范围和速度作为分析依据不是很有用），有些是自由变化的（无法用作分析依据）。源文件中指明了一些曲线是常数，而且它们是0（比如 <code>POSITION</code> 的旋转分量）；这些是确定不会变化的，可以作为映射表结构的“基准点”使用。</p><p>考虑“是否为常量0”这点和基准值、变化速度，观察可以发现，中间一大块（人体关节）是有着完全相同的模式的。人体关节只有旋转。因此先假设这些关节顺序都不变。需要重点关注的是这几个关节：<code>POSITION</code>、<code>SCALE_POINT</code>、<code>MODEL_00</code> 和 <code>BASE</code>，它们一共有7个组（4个位移3个旋转）。只要搞清楚了这7个组的顺序，应该就能得到正确的结果。</p><p>接近了。</p><p><code>rebell</code> 的最后分量都不是常量组，所以仅有的会出现常量的组（就是上面这几个）一定是排在最前面的。再考虑到组之间的逻辑关系，开头的应该是 <code>POSITION</code>（模型子空间）而不是 <code>MODEL_00</code>（实际的模型根关节），否者就会将 <code>MODEL_00</code> 的层次给破坏掉（因为必定造成 <code>POSITION</code> 或者其子关节 <code>SCALE_POINT</code> 和后面的身体关节相邻）。</p><p>那么第1组是 <code>POSITION</code> 的位移还是旋转呢？观察数据的模式（<code>(?, 0, ?)</code>），是位移。</p><p>第2组是什么呢？根据上面的大前提，有两种可能：<code>POSITION</code> 的旋转，或者是 <code>SCALE_POINT</code> 的位移。不知道，先放着。</p><p>这时候可以看到第4组的模式（<code>(0, ?, 0)</code>）——而这个模式，在7个组中只有一种可能：<code>BASE</code> 的位移。</p><p>于是我们现在可以得到这样的一个顺序：</p><pre><code class="lang-plain">#1: POSITION#translation#2: ?#3: ?#4: MODEL_00/BASE#translation#5: ?#6: ?#7: ?#8: MODEL_00/BODY_SCALE/BASE/KOSHI#rotation（各个身体关节开始）...</code></pre><p>到这里应该很明显了。想想上面的大前提。如果在第1组和第4组之间插入任何的旋转，就会破坏整个逻辑。因此只有一种可能：</p><pre><code class="lang-plain">#1: POSITION#translation#2: POSITION/SCALE_POINT#translation#3: MODEL_00#translation#4: MODEL_00/BODY_SCALE/BASE#translation#5: POSITION#rotation#6: MODEL_00#rotation#7: MODEL_00/BODY_SCALE/BASE#rotation</code></pre><p>将这个顺序代入，就可以发现我们得到了正确的结果：</p><p><img src="/images/misc/20200507-rebell-mmm-result.jpg" alt="Rebellion"></p><p>代码在<a href="https://github.com/OpenMLTD/MLTDTools/blob/3e21599d466ea929d8dabb44926b243096995aee/src/MillionDance/Entities/Internal/BodyAnimation.cs#L530-L709" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次讲讲我是怎么得到土豆新动作的骨骼曲线表的。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="RE" scheme="https://blog.mottomo.moe/categories/Tech/RE/"/>
    
    
    <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="逆向工程" scheme="https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>博客提交记录已经丢失</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2020-03-31-Site-History-Lost/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2020-03-31-Site-History-Lost/</id>
    <published>2020-03-31T09:49:00.000Z</published>
    <updated>2020-03-31T15:59:31.147Z</updated>
    
    <content type="html"><![CDATA[<p>在换了机器之后因为分类问题第一次更新博客。在数据迁移的时候，因为一个月前已经将源文件用 Git 管理了，所以我就没有完全复制博客文件夹里的内容，而是直接 clone 下了源文件做 deploy。当看到显示出许多的 <code>create mode</code> 的时候我就有一种不好的预感，一看出现了个 forced update，就知道完了。上一次删除 <code>.deploy</code> 导致博客的 repo 被 forced update 还是在2014年末。所以整个博客的提交记录相当于又被清零了。这次就吸取了教训，给这个 repo 也加上了提交保护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在换了机器之后因为分类问题第一次更新博客。在数据迁移的时候，因为一个月前已经将源文件用 Git 管理了，所以我就没有完全复制博客文件夹里的内容，而是直接 clone 下了源文件做 deploy。当看到显示出许多的 &lt;code&gt;create mode&lt;/code&gt; 的时候我就</summary>
      
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>在 Foobar2000 中直接播放网易云音乐的缓存文件</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/</id>
    <published>2020-03-22T23:20:00.000Z</published>
    <updated>2020-03-31T15:37:07.100Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。</p><a id="more"></a><p>昨天晚上本来是计划做乐曲改编的。虽然源用的是网易云音乐，但是播放器我就不想用它，而是 Foobar2000。但是当我尝试下载的时候，却被提示仅允许付费/会员下载。</p><p>行吧，你是哪天买的版权（如果真买了的话，笑）我不知道；但是反正我没有很高的码率要求，默认播放的 128 Kbps 就行；而且如果这也不行，还有别的手段。这时候我就想到，虽然不可以下载，但是还是可以播放的啊。既然能播放，那么应该就缓存在本地了，除非产品设计抽风。</p><p>于是我就看了看缓存目录。结果发现了很多大小接近 128 Kbps MP3 的文件。（是不是有一种<a href="/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-2/">既视感</a>？）主体内容应该是音频没错，但是经过了某种形式的加密。不过这次不是 CTF 了，所以就直接 Google 吧。已经<a href="https://github.com/mbinary/netease-music-cracker" target="_blank" rel="noopener">有人搞定了</a>。果然还是屈服于性能，只采用了简单的异或。哈。</p><p>那么现在的目标就是把这个逻辑封装为一个 Foobar2000 的组件，这样就可以直接在 Foobar2000 中播放了。虽然我<a href="https://github.com/hozuki/foo_input_hca" target="_blank" rel="noopener">写过简单的组件</a>，不过这次不一样，用到的东西比 <code>input_stub</code> 要多一些。</p><p>这次稍微触及到了 Foobar2000 组件系统的核心之一，<code>service_base</code>。工程的目标是：实现一个文件流，对原文件流做一个读写封装。其实这次还算简单，是无状态的，简单异或每个字节就行了。但是麻烦在于 <code>service_base</code> 的设计。如果在 .NET 里面实现这个可是太简单了，继承并重写，重写中调用父类方法就行。<code>service_base</code> 是引用计数的，有点像 COM（接口查找和接口升级更像），但是（在 release 模式下）并没有虚表（V-table），成员查找完全依赖于模板。成员一般不使用原生指针，而是使用 <code>service_ptr_t&lt;T&gt;</code>。我本来就没做过 COM 开发，而且这玩意儿还是没有虚表的。</p><p>根据 SDK 附带的简单说明，继承自 <code>service_base</code> 的“类”实际上是接口（类似 <code>IUnknown</code>），不应该有任何字段和方法实现，实现细节相关应该在在对应的 <code>*_impl</code> 类中提供。等等，那我该怎么实例化我的 <code>service</code> 呢？我的指针模板应该填什么类型呢？怎么转换接口呢？</p><p>看一下相关的定义。如果你知道 COM 的话这个看起来绝对不陌生。</p><pre><code class="lang-cpp">class NOVTABLE service_base{public:    virtual int service_release() throw() = 0;    virtual int service_add_ref() throw() = 0;    virtual bool service_query(service_ptr &amp; p_out,const GUID &amp; p_guid) = 0;    // ...}class NOVTABLE file : public service_base, public stream_reader, public stream_writer{    // ...}</code></pre><p>但是要注意的是那些 <code>NOVTABLE</code> 修饰，这是和 COM 最大的不同。在 VC++ 的 release 模式下，它会被扩展为 <code>__declspec(novtable)</code>。<del>这样尽管在逻辑上，<code>file</code> 继承自 <code>service_base</code>，但是在编译后它们并没有 V-table，因此不可以进行虚函数调用，<code>dynamic_cast</code> 也应该会失效。</del>关于 <code>__declspec(novtable)</code> 对虚表和 vptr（虚指针）的影响可以参考<a href="https://stackoverflow.com/a/1836063" target="_blank" rel="noopener">这个回答</a>。简单说，就是修饰 <code>__declspec(novtable)</code> 没关系，RTTI 和虚函数照常工作（除了在构造/析构函数中）。所以，直观的结论是，要让代码正常工作的话，抽象类（也就是 Foobar2000 中的接口）可以修饰，但是抽象类的非抽象子类不可以；抽象类自身也不能在构造/析构函数中使用虚表或虚指针相关。</p><p><strong>怎么实例化呢？</strong>一种方法是使用工厂类（<code>service_factory_base</code>），不过过程就非常麻烦了。对于简单的接口，SDK 提供了一个非常方便的函数 <code>fb2k::service_new()</code>。只需要创建实现的实例，赋值给接口指针就行了。</p><p>在代码中，我定义了一个自定义文件流类型和它的实现：</p><pre><code class="lang-cpp">class NOVTABLE mapped_file : public file{    // ...}// 注意这个 NOVTABLE，可以这么写是因为 mapped_file_impl_t 还是抽象的，实例化由 service_impl_t 负责，见下文class NOVTABLE mapped_file_impl_t : public mapped_file{    // ...}</code></pre><p>在使用上就可以这样：</p><pre><code class="lang-cpp">service_ptr_t&lt;mapped_file&gt; ptr = fb2k::service_new&lt;mapped_file_impl_t&gt;(...);// 或者service_ptr_t&lt;file&gt; ptr = fb2k::service_new&lt;mapped_file_impl_t&gt;(...);</code></pre><p>有趣的是，<code>service_new()</code> 内部使用了 <code>service_impl_t&lt;T&gt;</code>。这个类型继承自 <code>implement_service_query&lt;T&gt;</code>，而正是 <code>implement_service_query&lt;T&gt;</code> 提供了新的 <code>service_query()</code> 的默认实现。<code>service_impl_t&lt;T&gt;</code> 则进一步提供了 <code>service_add_ref()</code> 和 <code>service_release()</code> 的默认实现。所以在写自己的类型实现（比如 <code>mapped_file_impl_t</code>）时，是不需要提供这三个方法的。因此，此时这个“类型实现”对于编译器而言还是抽象类型，不可以直接使用 <code>new</code> 实例化——将所有实例的创建过程进行托管，可以有效地消除某些 bug——这是一个附加的好处。<code>service_impl_t&lt;T&gt;</code> 正好可以作为使用模板来创建 mixin 的一个例子。</p><p><strong>指针模板应该填什么类型呢？</strong>由于巧妙的向上查找方式（见下文），所以可以使用实现类型或者其任意的父类型。</p><p><strong>怎么转换接口呢？</strong>其实这个组件的功能并没有涉及到这个问题，但是在开始摸索的时候，我也是实现了整个 <code>mapped_file</code>，所以大略知道一点。每个继承自 <code>service_base</code> 的类都要提供一个静态成员 <code>GUID class_guid</code>（用于特征萃取），在 <code>service_query()</code>（1.4 以后是 <code>handle_service_query()</code>）中进行判断。查询整体就是一个沿着继承链往上找的过程。思想则是，一个子类声明它能被转换为哪些父类。而这个继承链，实际上是编译期的，利用模板而不是虚表。可以看 <code>handle_service_query()</code> 的实现：</p><pre><code class="lang-cpp">static bool service_query_walk(service_ptr &amp;, const GUID &amp;, service_base *) {    return false;}template&lt;typename interface_t&gt; static bool service_query_walk(service_ptr &amp; out, const GUID &amp; guid, interface_t * in) {    if (guid == interface_t::class_guid) {        out = in; return true;    }    typename interface_t::t_interface_parent * chain = in;    return service_query_walk(out, guid, chain);}template&lt;typename class_t&gt; static bool handle_service_query(service_ptr &amp; out, const GUID &amp; guid, class_t * in) {    typename class_t::t_interface * in2 = in;    return service_query_walk( out, guid, in2 );}</code></pre><p>其中 <code>t_interface</code> 和 <code>t_interface_parent</code> 在接口的 <code>FB2K_MAKE_SERVICE_INTERFACE</code> 中被自动定义。其实就是宏的那两个参数。这里实现了自动沿着继承链向上查找的语义，终止则利用是模板参数的退化（不是无参特化，但是我不确定该怎么称呼）用一个重载实现的。</p><p>看来 Peter 也是把 C++ 吃透了。这些 API 的设计非常巧妙。</p><p>最终的成果是个<a href="https://github.com/hozuki/foo_input_nemuc" target="_blank" rel="noopener">小玩意儿</a>。使用 VS 2019 编译。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Foobar2000" scheme="https://blog.mottomo.moe/tags/Foobar2000/"/>
    
  </entry>
  
  <entry>
    <title>春天没有花儿</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/</id>
    <published>2019-12-20T11:03:00.000Z</published>
    <updated>2020-03-30T22:34:35.453Z</updated>
    
    <content type="html"><![CDATA[<p><em>欢迎到作品的 <a href="https://npckc.itch.io/spring-leaves-no-flowers" target="_blank" rel="noopener">Itch.io 页面</a>去支持作者。另外这个系列目前由三个连续的故事组成：<a href="https://npckc.itch.io/one-night-hot-springs" target="_blank" rel="noopener">one night, hot springs</a>、<a href="https://npckc.itch.io/last-day-of-spring" target="_blank" rel="noopener">last day of spring</a> 和本作 <a href="https://npckc.itch.io/spring-leaves-no-flowers" target="_blank" rel="noopener">spring leaves no flowers</a>。</em></p><p><strong>本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。</strong></p><p>我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。</p><a id="more"></a><hr><p>我玩过的游戏中，针对单人、强调情感体验的不多；而让我称奇，甚至是给予我某个方面启蒙的，则是屈指可数。<a href="https://store.steampowered.com/app/683320/GRIS/" target="_blank" rel="noopener">GRIS</a> 和 <a href="https://store.steampowered.com/app/1122720/Sayonara_Wild_Hearts/" target="_blank" rel="noopener">Sayonara Wild Hearts</a> 聚焦于短期心理状态，<a href="https://store.steampowered.com/app/206440/To_the_Moon/" target="_blank" rel="noopener">To the Moon</a> 和本（系列）作品则偏向于展示某种长期的“异常”。（Sayonara Wild Hearts 我虽然很感兴趣但是没玩，因为光是看实况录播，它的美术风格就已经让我生物意义上地头疼了。）</p><p>故事的三个主角：</p><ul><li><ruby>立花<rp>(</rp><rt>タチバナ</rt><rp>)</rp></ruby>　<ruby>愛美<rp>(</rp><rt>マナミ</rt><rp>)</rp></ruby>（本故事主角）</li><li><ruby>永田<rp>(</rp><rt>ナガタ</rt><rp>)</rp></ruby>　エリカ（第二部主角）</li><li><ruby>鈴木<rp>(</rp><rt>スズキ</rt><rp>)</rp></ruby>　<ruby>悠人<rp>(</rp><rt>ハルト</rt><rp>)</rp></ruby>/ハル（第一部主角）</li></ul><p>マナミ和ハル是青梅竹马，和エリカ是高中同学。三人对“少数”的一致认同和宽容，才使得故事顺利展开。</p><p>游戏系统并不复杂，比 AVG 还要纯粹的 AVG。叙事并没有什么出人意料的地方。不过有意思的是，虽然很多选项被划了删除线而且是灰色的，是一般意义上的“不可用”状态，但是实际上那些才是让游戏进入正轨的选项。我想，这大概是作者 npckc 设计的隐藏表现方式，意思是说在角色心中这个选项就是默认不可选择的。这可能是个亮点吧。</p><p>剧情其实没那么复杂，不需要怎么解释。マナミ无法理解“亲吻”的特殊含义（在现代语境下），因此无法推断出另外两人关系的变化——更重要的是，无法真正理解自己的处境。给我冲击力的是角色所面临的问题。是的，我知道有的人是不擅长理解暗示，或者一些词汇的含义（常见于自闭症），但这些都是作用域更广泛的社会行为的，我并不知道更“私人”的感情受到这样影响是怎么样的。我曾经听说过“无性恋”，但我只是以为这代表“不喜欢任何人/对任何人都保持着中立的态度”。读到了这个故事之后我才知道，我错了。</p><p>タツヤ，您真是勇士。虽然在故事里，マナミ得到了所有人的接受（毕竟她们都有着各自的“异常”），但是现实生活中，恐怕活得要艰难太多了。</p><p>整个游戏令我震惊的就是新概念的引入。而且是实事求是的平铺直叙，不是被包装的拜金主义，因此才能给（就算不是这样的）人以共鸣。词条的解释是很可能客观公正的，但是它没有活生生的人。当你从一个人的视角，而不是从上帝视角，去看的时候，才会真正地萌生一种想法：“这个困难的根源在哪里？”进而再去思考需求和生产力的关系等等。</p><hr><p>后来我把前两作读了一遍。这一读不要紧，第三部的印象崩塌了大半。不，不是因为歧视，而是因为总体的人物和剧情设置。</p><p>这次来总结一下，在看完三部曲后，完整的人物描述。虽然像是贴标签，但是对不起了，政治正确的气息太浓厚了。</p><ul><li>マナミ：无性恋（asexual）、无浪漫（aromantic）</li><li>エリカ：双性恋（bisexual）、纯素食主义者（vegan）</li><li>ハル：跨性别者（transgender）、潜在的同性恋（推测）</li></ul><p>她们都希望正常地活着——不是“矫正”，而是和其他人一样相互尊重。</p><p>但是一些剧情就有点……匪夷所思，或者说，如果真的发生了，想想还是可以理解的，但是概率太小了。</p><p>（第一部）ハル告诉エリカ说自己喜欢マナミ，不过マナミ已经有男朋友了所以说不出口。ハル可是认知性别为女的。……是心理上的百合倾向？还是生理上的激素作用？不得而知。而且喜欢很久了。</p><p>（第二部）与ハル的对话中，选错一个就会导致故事提早结束（bad end）。和另外两部不同，这里ハル在闹别扭，总觉得自己不值得参加活动，所以一旦选择了坦诚的选项，ハル就要不不接电话不回消息，要不就说干脆所有的活动都取消算了。但是老妹，你之前不是都去过温泉了吗？从那次事件中就可以见到人家品行如何。你这么缩着，说着不要再麻烦人家了，不是更给人添麻烦吗？</p><p>这么看来，第二部的真的是死亡选项。其他两部就友好一些，第一部有“心”的提示（左上角；可以关闭），第三部选项状态就是提示（见前文），就是这第二部麻烦多了。</p><p>（第一部/第二部）エリカ费老劲地照顾ハル，从化解ハル（不想见到マナミ的男朋友）的尴尬提出和ハル一起去市内转（最后真的去了），到给ハル准备生日活动，到真情流露，最后甚至说想亲上去了。而且经历了上面的死亡选项后，明显能看出，虽然エリカ认为自己是在尽一个朋友的责任，但是这负担起的已经超出了朋友的范围……更何况エリカ还是个双（很早就跟ハル说过）。然而结局是 as a friend。（摊手）</p><p>第二部的后日谈中，ハル表示要真诚地跟マナミ谈一谈。虽然不知道是想谈第二部里各种别扭的根本原因，还是谈她对マナミ的感情。不管是哪一种，总之从第三部可以看到，作为本故事的引子，ハル和エリカ在一起了。等等？嗯？这跳跃是怎么回事？跃迁吗？</p><p>（第三部）ハル引导マナミ去寻找解答。虽然于情于理这个指引者都应该是ハル，但是考虑到ハル的想法……作者真喜欢插刀子。</p><hr><p>ハル的话可以引起思考，也大致体现了真实的想法：</p><blockquote><p>ハル：我在各个意义上都是破碎的……怎么还会有人会被这样的我所吸引呢？</p></blockquote><p>以及：</p><blockquote><p>エリカ：（“悠人”）是你从前男生时的名字吗？</p><p>ハル：从前也不是男生……</p></blockquote><hr><p>有意思的是，一些词汇被意译的情况下，另一些作为专有概念被音译了。温泉（<ruby>温泉<rp>(</rp><rt>おんせん</rt><rp>)</rp></ruby>）就被普普通通地翻译成了“hot spring”。而旅馆（<ruby>旅館<rp>(</rp><rt>りょかん</rt><rp>)</rp></ruby>）、公共澡堂（<ruby>銭湯<rp>(</rp><rt>せんとう</rt><rp>)</rp></ruby>）、蜜柑（みかん）则分别被翻译成了“ryokan”、“sentou”和“mikan”。我想，这些玩意儿在西方语境下，哪一个都不是新鲜事物或者说异域风情啊。问问你们的先祖，要不听听人家<a href="https://movie.douban.com/subject/6037517/" target="_blank" rel="noopener">吐槽</a>也可以。<del>精罗震怒</del></p><hr><p>本文涉及的主题可能是目前我所有的博文中最容易引起争议的。游戏中说了这么多，其实都是陈述一些客观事实，以及中立的处理方式。真要从法律法规层面上实施起来，就开始碰到主观观点、碰到蛋糕了，和其他行为公认的（但是根据各种标准再细分，或“先进”或“落后”的）行为准则一冲突，也是很麻烦的事。比如，奥巴马的<a href="https://en.wikipedia.org/wiki/Bathroom_bill" target="_blank" rel="noopener">公共厕所指导条例</a>，就是十分粗暴的尝试。如果你要问我怎么解决，我只能耸耸肩，说，我不是神，不知道最优解是什么，也不知道那个最优的平衡在哪里；但是也许可以渐进，近似出这个特定的函数。退一步来说，这个群体内部也是分裂的——就像是多组相互独立、每组内容易相互排斥的选项，就算是第一组都选了同一个，第二组不同，就会看不顺眼。从宏观到微观，人就是这么分裂。感受不到的话……可能是很幸运地选到了大众选项。</p><p>不管如何，我依然将其视为社会生产力发展的证明。这个观点来自于<a href="https://book.douban.com/subject/1286994/" target="_blank" rel="noopener">《在时间的长河里》</a>中对于毕达哥拉斯学派素食规定的解读。小众的特化需求得到满足，必须是以高生产力为条件的。否则，他们就会成为主流（提供人类这一物种生存的保障的人）的负担，从而遭到排挤。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;欢迎到作品的 &lt;a href=&quot;https://npckc.itch.io/spring-leaves-no-flowers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Itch.io 页面&lt;/a&gt;去支持作者。另外这个系列目前由三个连续的故事组成：&lt;a href=&quot;https://npckc.itch.io/one-night-hot-springs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;one night, hot springs&lt;/a&gt;、&lt;a href=&quot;https://npckc.itch.io/last-day-of-spring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;last day of spring&lt;/a&gt; 和本作 &lt;a href=&quot;https://npckc.itch.io/spring-leaves-no-flowers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring leaves no flowers&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。&lt;/p&gt;</summary>
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>小谈 .NET 和 Java 的并发容器 API 设计</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/</id>
    <published>2019-12-19T07:49:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>今天看博客园，看到<a href="https://www.cnblogs.com/thisiswhy/p/12059240.html" target="_blank" rel="noopener">一篇文章</a>。它的主要内容是：</p><ul><li>为什么 <code>ConcurrentHashMap&lt;K, V&gt;</code> 不支持 <code>null</code> 值？因为这样就无法区分给定的键不存在还是对应值就是 <code>null</code>。</li><li>为什么 <code>ConcurrentHashMap&lt;K, V&gt;</code> 不支持 <code>null</code> 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。</li></ul><p>文章内容不赘述了。</p><p>我看完之后想到的是，.NET 的并发容器（<code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的坑联系在一起，可能会发现什么。</p><a id="more"></a><p>以前我笑话过 .NET 的容器 API 设计。我们知道，.NET 的 <code>Stack&lt;T&gt;</code> 和 <code>Queue&lt;T&gt;</code> 是基于数组的。这给予了它们一定的随机访问能力（不过没什么卵用，想想它们是做什么的），保持内存连续性（提高缓存命中率），但是坏处就是不适合频繁的扩容和收缩。（在提高数组的利用率上，<code>Stack&lt;T&gt;</code> 比较好办，<code>Queue&lt;T&gt;</code> 用的是循环缓冲区。）我想实现基于 <code>LinkedListNode&lt;T&gt;</code> 的版本，却发现 .NET 并没有提供 <code>IStack&lt;T&gt;</code> 和 <code>IQueue&lt;T&gt;</code>。简单搜索就可以找到 StackOverflow 上的<a href="https://stackoverflow.com/questions/4367893/why-is-there-no-iqueuet-or-istackt-interface-in-the-net-framework" target="_blank" rel="noopener">问题</a>。其中有那么一句话：</p><blockquote><p>As it pointed <code>Queue</code> and <code>ConcurrentQueue</code> don’t have that much similar to make them implement single interface.</p></blockquote><p>我就顺着看了一下 <code>ConcurrentQueue&lt;T&gt;</code> 的 API，接着就被震撼到了。其他的容器也是类似的。这是什么玩意儿！相比之下，人家 Java，<code>ConcurrentHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;</code>，多么优雅。也就是说，理论上，我可以将某个类型为 <code>Map&lt;K, V&gt;</code> 的成员字段啊参数啊变量啊，从原来赋值为 <code>HashMap&lt;K, V&gt;</code> 的实例改为 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的实例，然后瞬间就不担心这里的多线程问题了（假设其余部分正确实现）。这不是很爽吗？而如果我使用了 <code>Dictionary&lt;TKey, TValue&gt;</code>，由于其和 <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 没有共同的基类或者适合的接口，所以我无法只使用一个变量就兼容二者。太麻烦了，就为了这个区别，也得开始使用策略模式吗……</p><p>今天突然理解了。<code>ConcurrentHashMap&lt;K, V&gt;</code> 中的 <code>null</code> 是一个坑，而且“这种限制”这样的无聊问题会成为 Java 开发者懂不懂并发的其中一个筛子，很大程度上就是因为它实现了 <code>Map&lt;K, V&gt;</code>，而后者在设计之初就计划使用 <code>null</code> 作为键不存在的表示，从而没有其余携带信息的手段。这是不是设计失误我不敢下结论（不知道 Bloch 当初是怎么想的），但是一定是有问题的。</p><p>我们先来看看 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的存取 API。由于实现了 <code>Map&lt;K, V&gt;</code>，所以签名是一样的：</p><pre><code class="lang-java">interface Map&lt;K, V&gt; /* ... */ {    // ...    public V get(Object key);    public V put(K key, V value);    // ...}class ConcurrentHashMap&lt;K, V&gt; /* ... */    implements Map&lt;K, V&gt; /* ... */ {    // ...    public V get(Object key);    public V put(K key, V value);    public V putIfAbsent(K key, V value);    // ...}</code></pre><p>“无法使用 <code>null</code> 值”可以从“需要实现 <code>Map&lt;K, V&gt;</code>”这个前提推断出来：</p><ol><li>必须实现 <code>Map&lt;K, V&gt;</code>，因此存取必须使用 <code>get(K)</code> 和 <code>put(K, V)</code>。</li><li>在 <code>Map&lt;K, V&gt;</code> 的大多数实现中，<code>get(K)</code> 对于不存在的键会返回 <code>null</code> 而不是抛出异常。</li><li>怎么判断返回 <code>null</code> 是代表键不存在，还是代表设置的值就是 <code>null</code> 呢？那就得在获取值之前先使用 <code>contains(K)</code> 检查了。</li><li>假设允许 <code>null</code> 值。一样会遇到2所示的问题。那么此时怎么判断是哪一种情况呢？还是先用 <code>contains(K)</code> 吗？这可是可能处于并发状态下的啊，两次操作之间或许这个容器状态就改变了，引发别的问题。因此，不可以使用预先判断。</li><li>现在唯一能表示键不存在的只有返回值了。在这里做文章，规定一个特殊值 <code>null</code>（有经验都知道使用特殊值一般不是个好主意），用它来表示键不存在。</li><li>由于 <code>null</code> 返回值在这个操作的上下文中有了“键不存在”的特殊意义，为了不引发冲突，容器内的所有值都不允许为 <code>null</code>。</li></ol><p>可以注意到，状态附加、原子性保证，使得应用前提发生了变化。因此，<code>ConcurrentHashMap&lt;K, V&gt;</code> 不适合实现 <code>Map&lt;K, V&gt;</code>。</p><p>再来看看 .NET 这边。</p><pre><code class="lang-csharp">interface IDictionary&lt;TKey, TValue&gt; /* ... */ {    // ...    void Add(TKey key, TValue value);    bool TryGetValue(TKey key, out TValue value);    // ...}class ConcurrentDictionary&lt;TKey, TValue&gt;    : IDictionary&lt;TKey, TValue&gt; /* ... */ {    // ...    public bool TryGetValue(TKey key, out TValue value);    public TValue GetOrAdd(TKey key, TValue value);    public bool TryAdd(TKey key, TValue value);    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);    // ...}</code></pre><p>（或许你要问，其余对 <code>IDictionary&lt;TKey, TValue&gt;</code> 的方法实现，比如 <code>Add(TKey, TValue)</code> 呢？答案是它们都成了显式接口实现。）</p><p>可见，虽然同样是实现了字典接口，但是由于 .NET 这边并未采用特殊值，所以 <code>TryGetValue(TKey, out TValue)</code> 有很高的并发接口适应性。开发者不需要关心特殊值的问题，而是可以和普通的 <code>Dictionary&lt;TKey, TValue&gt;</code> 一样，使用 <code>null</code> 作为项的值，不需要抓破脑袋。</p><p>.NET 这样设计的一部分原因也可能是不得已而为之。因为在 <a href="https://docs.microsoft.com/en-us/dotnet/standard/common-type-system" target="_blank" rel="noopener">CTS</a> 中是有严格的值类型和引用类型的区分的。<code>ConcurrentDictionary&lt;T&gt;</code> 并没有泛型类型约束，因此可以用于这两种类型。如果想像 Java 那样找 <code>null</code> 这样的特殊值，是找不到的——值类型没有“空”（null）的概念，但是不排除有“空”（empty）的值，包括默认的全零值。因此，为了携带状态，就得多加参数。</p><p>这个设计带来的一个（可能是）意想不到的好处是，它将“检测并获取”作为一个原子操作（API 层面，当然不是指令层面），而且没有副作用。这样开发者过渡到并发反而容易了。</p><p>我们再来看看在队列上的区别。</p><pre><code class="lang-java">interface Queue&lt;E&gt; /* ... */ {    // ...    // 失败抛出异常    public boolean add(E e);    public E remove();    public E element();    // 失败返回特殊值    public boolean offer(E e);    public E poll();    public E peek();    // ...}// 和 Queue&lt;E&gt; 一样，不赘述class ConcurrentLinkedQueue&lt;E&gt; /* ... */    implements Queue&lt;E&gt; /* ... */ {    // ...}</code></pre><pre><code class="lang-csharp">class Queue&lt;T&gt; /* ... */ {    // ...    public void Enqueue(T item);    public T Dequeue();    public T Peek();    // ...}class ConcurrentQueue&lt;T&gt; /* ... */ {    // ...    public void Enqueue(T item);    public bool TryDequeue(out T result);    public bool TryPeek(out T result);    // ...}</code></pre><p>在这个设计上，Java 提供了两套令人迷惑的 API。它们提供相同的功能，但是在失败时的行为完全不同。一套是快速失败（fail-fast），抛出异常，另一套是安全失败（fail-safe），返回特殊值 <code>null</code>。（说实话，如果不是这次我看了文档，否则我也不会知道两套的区别。）很明显，抛出异常适用于简单开发，而在复杂的并发系统中返回“失败”这个状态更好。但是由于使用的特殊值也是个合法值（<code>null</code>），因此 <code>Queue&lt;E&gt;</code> <strong>一般</strong>是不允许其中的项是 <code>null</code> 的。（但是也有例外：<code>LinkedList&lt;E&gt;</code> 是允许 <code>null</code> 项的，因为用内部的 <code>Node&lt;E&gt;</code> 包装了。新的坑。）且不论两套 API 是否让人头大，针对 <code>null</code> 的行为已经让人头大。不过，和 <code>Map&lt;K, V</code> 到 <code>HashMap&lt;K, V&gt;</code>/<code>ConcurrentHashMap&lt;K, V&gt;</code> 的暗坑，<code>Queue&lt;E&gt;</code> 到 <code>LinkedList&lt;E&gt;</code>/<code>ConcurrentLinkedQueue&lt;E&gt;</code> 反而没什么坑。</p><p>当然，你也可以说 <code>null</code> 本身就是个 <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" target="_blank" rel="noopener">billion dollar mistake</a>。在这种意义上，<code>null</code> 本来就不该出现。可惜广泛应用的语言大多都没有禁止 <code>null</code>……</p><p>.NET 这边的设计就有意思了。对于普通场景的 <code>Queue&lt;T&gt;</code>，失败都是抛出异常的。而 <code>ConcurrentQueue&lt;T&gt;</code> 入队失败抛出异常，后两者失败时是返回 <code>false</code> 的（从命名就可以看出来）。而且 <code>ConcurrentQueue&lt;T&gt;</code> 和 <code>Queue&lt;T&gt;</code> 没有关系（见上文），因此不提供相同的 API。失败行为和 API 对于是否支持并发时线程安全（和性能！）完全不同——这虽然“适应”了不同场景，让开发者只需要“自然地”使用，但这差异同样增加了认知的负担。</p><hr><p>另外还有一个有意思的讨论。我们知道有 <code>ConcurrentHashMap&lt;K, V&gt;</code>，但是线程安全的<em>随机访问</em>列表实现只有 <code>Vector&lt;E&gt;</code>（或者使用 <code>Collections.synchronizedList()</code> 包装），而且原理还是全部加锁的。<a href="http://ifeve.com/why-is-there-not-concurrent-arraylist-in-java-util-concurrent-package/" target="_blank" rel="noopener">为什么没有 <code>ConcurrentArrayList</code></a>？（原文链接已经失效，所以只好引用译文。）</p><p>回答是：</p><blockquote><p>很难去开发一个通用并且没有并发瓶颈的线程安全的 <code>List</code>。</p><p>像 <code>ConcurrentHashMap</code> 这样的类的真正价值并不是它们保证了线程安全，而在于它们在保证线程安全的同时不存在并发瓶颈。……</p></blockquote><p>比如，调用 <code>contains()</code> 或者 <code>indexOf()</code> 的时候，最坏的情况下需要搜索整个列表，所以必须锁定整个列表。这个时候如果要修改列表（增删改）那必然会引发瓶颈。</p><p>相比之下，<code>ConcurrentHashMap&lt;K, V&gt;</code> 在修改/搜索的最坏情况下最多只需要锁住其一部分（如果你疯狂构造哈希冲突；另参考 Java 7 到 Java 8 的实现变更）。<code>ConcurrentLinkedQueue&lt;E&gt;</code>/<code>ConcurrentLinkedDeque&lt;E&gt;</code> 则更简单，无法搜索，修改也只有一个/两个方向。因此它们的使用不会构成瓶颈。</p><hr><p>我本来还想吐槽一下 wildcard capture 的，因为我记得以前在哪里看到过，它的不恰当应用会得出合乎语法却毫无意义的结果。我写这篇文章的时候找了很久，可是就是找不到了。不过反而有了其他的发现，比如<a href="http://wouter.coekaerts.be/2018/java-type-system-broken" target="_blank" rel="noopener">这个</a>和<a href="https://doi.org/10.1145/2983990.2984004" target="_blank" rel="noopener">这个</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天看博客园，看到&lt;a href=&quot;https://www.cnblogs.com/thisiswhy/p/12059240.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇文章&lt;/a&gt;。它的主要内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 不支持 &lt;code&gt;null&lt;/code&gt; 值？因为这样就无法区分给定的键不存在还是对应值就是 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 不支持 &lt;code&gt;null&lt;/code&gt; 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章内容不赘述了。&lt;/p&gt;
&lt;p&gt;我看完之后想到的是，.NET 的并发容器（&lt;code&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 的坑联系在一起，可能会发现什么。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Java" scheme="https://blog.mottomo.moe/tags/Java/"/>
    
    <category term=".NET" scheme="https://blog.mottomo.moe/tags/NET/"/>
    
    <category term="并发" scheme="https://blog.mottomo.moe/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python 加速好帮手：Numba</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/</id>
    <published>2019-12-06T14:08:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>一次无可奈何的 Python 提速。</p><a id="more"></a><hr><p>先简单介绍一下背景。</p><p>这门课是 Visualization，由两个作业组成。第一个作业的代码部分，要求补完一个体渲染器（volume renderer）。这个渲染器是完全软件渲染的，而且需要支持几种渲染方式（也就是几种软件着色器）：切片（代码已给出）、<a href="https://en.wikipedia.org/wiki/Maximum_intensity_projection" target="_blank" rel="noopener">最大密度投影（MIP）</a>、体元合成（compositing）。不管哪一种，核心都是 <a href="https://en.wikipedia.org/wiki/Volume_ray_casting" target="_blank" rel="noopener">ray casting</a>。严格来说，每一个都有“合成”步骤，不过最后一个实际上指的是最常见的、使用 Phong 模型的着色。</p><p>今年我就被一个认识我的人叫过去帮忙了。去年我修这门课的时候，用的是 Java。今年据说因为 Java 入门（一个 master level 的课程，本来在 Q1，也就是 visualization 的前一个 quartile）移到了 bachelor level 3，所以在改革之后这门课默认所有选课的人都没有 Java 基础。因此，使用的语言改为了 Python。</p><p>我不得不严重吐槽今年的老师，虽然我并不认识他。内容比较长而且跟题目切合度不算太大，所以就放在文末。</p><p>好，接着就讲优化的事。下文的渲染时间以提供的橘子的数据为准。</p><p>由于各种坑爹因素的综合作用，切片的每帧渲染时间就已经超过了2秒。至于体元合成，因为所有体元基本都要至少被投射一次，总时间可达每帧10分钟（600秒）左右。其他的已经实现了这个的小组也反馈说，用时10分钟“是非常正常的”。</p><p>正常个毛！作为读者而不是这个坑爹软件的使用者，你可能不是很清楚它对人精神的打击有多大。首先，切换到体元合成模式，渲染初始帧，10分钟。接着，你会发现默认的迁移函数（transfer function）效果很差，需要调整曲线。当你调整第一个数值的时候，新的渲染开始了，又是10分钟。在这段时间内，你对迁移函数的调整完全不会反映出来——因为上一帧还没有渲染完成，所有更改都不会应用。你根据密度直方图大致估摸出了一个曲线，但为了它能起作用，你必须在上一帧渲染完成后，再次触发更改（比如调整颜色）才能获得正确的渲染结果，于是又要等10分钟。然后，你会看到默认的视角并不能看到什么有意义的东西，于是你得尝试调整视角。跟迁移函数一样，如果正在渲染，则新的视角不会应用。这就是多个10分钟。在你获得最后的满意的图像之前，精神上要受到长时间的折磨。说“折磨”，是因为这个时间根本就是因为种种错误导致的浪费生命，而且不止是一个人的生命。</p><p>怎么办呢？我们来想想方案的必要条件：</p><ul><li>使用 Python（恶心的规定）</li><li>非侵入式的</li><li>支持 GUI 实例</li></ul><p>补充条件：</p><ul><li>应用容易</li></ul><p>其实说到底，就是加速。加速，无外乎就是提高硬件利用率、合理利用硬件。例如，并行（CPU、GPU）、更高效率的代码（设计上、编译后）、提高缓存命中等等。</p><p>各位或许听说过 <a href="https://cython.org/" target="_blank" rel="noopener">Cython</a>。但是很可惜，虽然 Python 代码是合法的 Cython 代码，但是为了让 Cython 达到最高效率，必须要将代码改写成其方言。这就违反了非侵入式的条件，代码提交后别人也不容易运行这些代码。</p><p>Python 以性能为代价提供了极高的自由，而这给解释器设计让生成高效率的机器码带来的巨大的困难。所以不可能寄希望于 Python 解释器自身给我们提供极致性能。</p><p>我也试过用 <code>multiprocessing</code> 模块来加速。然而这并没有什么卵用。需要优化的函数是一个虚函数，而且位于事件回调，跟 GUI 有相当的耦合。这就不像一些常用 <code>multiprocessing</code> 优化的模块，那些模块基本是用于数值计算。而且它们的函数是全局的（对于子进程来说是入口），参数也利于封送，运行时产生的都是后台进程。当我简单使用 <code>multiprocessing</code> 的时候，这个程序直接弹出了好几个窗口，把我吓了一跳——而且它们没有一个在干活。</p><p><code>threading</code>？别忽悠人了。</p><p>还有一些其他的方法，不过投入的成本太高，对于一个作业，精力有限，做不起。（见文末讨论。）</p><hr><p>这时候偶然搜索到了 <a href="http://numba.pydata.org/" target="_blank" rel="noopener">Numba</a>。它和 Cython 的思路是相似的，在一定条件下，转换成 C 代码后编译运行，利用 C 的速度优势（“C 的速度优势”不是很准确，但是在此不展开了），提高代码执行效率。在满足一些苛刻的条件时，甚至还可以<a href="https://numba.pydata.org/numba-doc/dev/user/vectorize.html" target="_blank" rel="noopener">应用并行化</a>，进一步提高执行效率。</p><p>就使用体验而言，Numba 总体来说还是相当友好的。在正式用到作业项目之前，我用<a href="http://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/" target="_blank" rel="noopener">一篇文章中的示例</a>简单测试了一下优化效率。</p><pre><code class="lang-python">import timefrom typing import Callableimport numpy as npfrom numba import jitdef pairwise_python(X: np.ndarray) -&gt; np.ndarray:    M = X.shape[0]    N = X.shape[1]    D = np.empty((M, M), dtype=np.float)    for i in range(M):        for j in range(M):            d = 0.0            for k in range(N):                tmp = X[i, k] - X[j, k]                d += tmp * tmp            D[i, j] = np.sqrt(d)    return D@jit(nopython=True)def pairwise_numba(X: np.ndarray) -&gt; np.ndarray:    M = X.shape[0]    N = X.shape[1]    # https://github.com/numba/numba/issues/3993    # Use float_/int_ instead of float{XX}/int{XX}    D = np.empty((M, M), dtype=np.float_)    for i in range(M):        for j in range(M):            d = 0.0            for k in range(N):                tmp = X[i, k] - X[j, k]                d += tmp * tmp            D[i, j] = np.sqrt(d)    return Ddef pairwise_numpy(X: np.ndarray) -&gt; np.ndarray:    return np.sqrt(((X[:, None, :] - X) ** 2).sum(-1))def run_python() -&gt; None:    X = np.random.random((1000, 3))    pairwise_python(X)def run_numba() -&gt; None:    X = np.random.random((1000, 3))    pairwise_numba(X)def run_numpy() -&gt; None:    X = np.random.random((1000, 3))    pairwise_numpy(X)def time_it(name: str, func: Callable[[], None]) -&gt; None:    time_start = time.time()    func()    time_end = time.time()    print(f&quot;{name} used {time_end - time_start} second(s)&quot;)if __name__ == &quot;__main__&quot;:    time_it(&quot;raw python&quot;, run_python)    time_it(&quot;numba&quot;, run_numba)    time_it(&quot;numpy&quot;, run_numpy)</code></pre><p>在我的机器上运行，结果：</p><pre><code class="lang-plain">raw python used 5.295958518981934 second(s)numba used 0.3148195743560791 second(s)numpy used 0.05596804618835449 second(s)</code></pre><p>可见，仅仅是转换成等价 C 代码（还没有并行）并编译，就已经获得了巨大的效率提升。当然，这还是比不过 NumPy 的向量化操作（<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html" target="_blank" rel="noopener">ufunc</a>）。</p><p>不过，在这个作业里，每个最终像素点的实际生成过程是异构（heterogeneous）的，因此无法将其向量化，自然无法充分利用 NumPy。使用 Numba 并行是可能的；考虑到作业中的这个函数远比上面的简单例子复杂，尤其是输入的参数，所以尽管理论上可能，我也没这么多精力去适配它的条件了。</p><p>我们继续来看 Numba。Numba 提供了两种模式，一种是 <a href="https://numba.pydata.org/numba-doc/latest/glossary.html#term-nopython-mode" target="_blank" rel="noopener"><code>nopython</code> 模式</a>，一种是 <a href="https://numba.pydata.org/numba-doc/latest/glossary.html#term-object-mode" target="_blank" rel="noopener"><code>object</code> 模式</a>。前者不需要涉及 Python 的解释器，后者需要。什么时候需要呢？访问除了特定受支持的数据类型（<code>int</code>、<code>float</code>、<code>numpy.ndarray</code> 等等）之外的，尤其是自定义的复杂类型（简单类型可以用 <a href="https://numba.pydata.org/numba-doc/dev/user/jitclass.html" target="_blank" rel="noopener"><code>@jitclass</code></a>）。很明显，一旦和 Python 解释器扯上关系，那么效率就得大打折扣。再加上 JIT 是有开销的，所以最后总体甚至会慢于直接在解释器中执行。因此，一般都得用 <code>nopython</code> 模式。</p><p>接下来就是痛苦的转换了。毕竟 Numba 要能应用，是有限制条件的。</p><p>所以第一步，就是尽量做到与 OO 无关，而是回退到面向过程的方式。毕竟文档自己说了“越像 C 越好”（笑）。拆！拆！拆！好在原程序大部分都是不需要跟对象进行交互的，因此将主体变换为面向过程的方式并没有太复杂，就是繁琐一些，花一个小时就搞定了。同时考虑到 Python 无法内联的特性，分块大小偏大，减少调用开销。</p><p>不过里面有一个问题如鲠在喉；甚至说，如果不将它解决，那么其他的优化都无法生效，Numba 必然会回退到 <code>object</code> 模式。在循环的最深处，需要根据迁移函数获取在该视角（viewpoint）下某个体素（voxel）的对应颜色值。这可是插在层层循环中最深的地方的一个钉子。而必需的迁移函数，在实现上是一个复杂对象，<code>@jitclass</code> 还不支持。嗯，仔细观察一下，颜色计算其实是根据一张表实现的，而这张表在单次渲染中不发生变化。所以我就写了一个计算量不大的函数，将迁移函数的内部状态提取到了一个 <code>ndarray</code> 中，并修改颜色计算使其用这个 <code>ndarray</code> 而不是原来的迁移函数对象。这样核心计算就可以在 <code>nopython</code> 模式下进行了。</p><p>目前（0.46）Numba 还不支持 <code>MAKE_FUNCTION</code> opcode。Numba 只会报错说“<code>op_MAKE_FUNCTION</code> 未实现”。这么一个莫名其妙的错误信息还是得猜一下。结果是，它不支持函数内定义的函数，无论内部的函数是否形成闭包。所以我只好又违反了模块化原则，把一些内部的小函数提出来放到全局范围里。</p><p>最后优化到了什么程度呢？原先的每帧渲染时间是大约600秒，优化后冷启动24秒（含 JIT 时间），多次运行18秒。整整33倍！而且这仅仅是将 Python 代码 JIT 的结果，甚至都没有并行化。这个函数输入太多，签名复杂，所以我就不浪费时间去做并行化了——软件本身只是用来出结果的，后面还有报告呢，这时候离截止日期已经不远了。比起再花几个小时尝试优化到最佳状态，还不如就18秒先用着，毕竟看模型又不是重复数十次上百次的重复劳动，最后总计花费时间也不会太久。</p><hr><p>接下来就是纸上谈兵环节了。</p><p>我们看到了解释代码到原生代码的效率提升。如果要进一步优化异构任务的话，该怎么办呢？在这里再加一个前提：跟宿主语言无关，也就是要找一个相对通用的解。</p><p>一个很容易想到的方案是使用传统的 GPU。将计算逻辑变换成 shader，输入变换为顶点数据，输出从图像中解码。使用的 API 可以是 OpenGL（vertex/fragment）、Direct3D。这种做法别说现代 GPU，老一点的 GPU 都支持。缺点就是结果的复杂度不能太高，毕竟单元输出最多只有4个单精度浮点数。</p><p>如果使用 GPGPU，就可以避开许多输入输出的限制。可以使用的有 OpenGL（compute）、DirectCompute，以及 OpenCL 和 CUDA。其中一些还支持异构设备计算。</p><p>以上的方案，只要所使用的语言提供对应的绑定，就可以使用。</p><p>如果放宽“语言无关”限制，只针对 C/C++ 的话，有 OpenMP、OpenACC 和 SYCL。它们的效率提升方式不尽相同，有自动多线程并行的，有（合适时）使用 GPU 的。但是它们几乎可以和 C/C++ 无缝集成，而不需要将计算逻辑分离到独立的管线中。</p><hr><p>对这个老师的吐槽。</p><p>客观来讲，他犯了一个严重的选型错误。他应该是这么想的，Python 不是什么“新时代的基础语言”、“万能胶水语言”，“上手十分简单”嘛。但是很明显，Python 和 VB 一样，学习曲线的上升幅度开始平缓，接着立马就极端地陡峭，也就是易于上手，难于深入，更难于精通。Python 的运行效率不能说差，但是很不擅长计算密集型的任务（至少在包括默认的 CPython 上的大部分实现，因为有 <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock" target="_blank" rel="noopener">GIL</a>）。（另外插一句，<a href="https://www.python.org/dev/peps/pep-0554/" target="_blank" rel="noopener">PEP-554</a> 安排在 Python 3.9 了，所以现在也用不了。）而这门课要做的是一个<strong>软件</strong>渲染器，不仅是一个计算密集型的任务，而且是一个异构任务（不能简单地通过向量化完成）。写出逻辑是很简单的，但是一旦运行起来，就会发现它的运行时间无法忍受。想优化？对不起，优化异构任务的难度，已经远远超出了花样使用 NumPy（优化同构任务）；后者也早就不是初学者范围内的东西了。也就是说，这个作业在目标之外设置了一个巨大的障碍，而所有人不得不做出选择——要不就克服这个障碍，要不就得忍受折磨——而几乎没有人有能力克服。这是完全没有意义的精神消耗，至少对于学生而言。（现实工作中也有可能会遇到这样的问题，不过都已经到了工作了，自然就不能假设有保护了。）</p><p>他貌似对自己的水平没有准确的估计。由于很多人被折磨得死去活来，所以他似乎收到了一些问问题的邮件。将这些整理成 FAQ 之后，其中就有令人哭笑不得的回答。在程序中有一个 bug，它导致计算出的图像不会绘制到窗口中，也就是体现为“看不见”。这几乎是致命的问题，自然有人会问。而他的回答呢？“看不见图像的原因，很可能是因为你的计算机在计算上出了问题。”我真不知道该说什么好。</p><p>在代码上，可以明显看出 Java 移植的痕迹。在命名上和一些辅助类的结构上就看出来。除了 GUI 部分的代码遵循 wxPython 的一般规则、OpenGL（仅用来画包围盒）用 PyOpenGL，其他都是 Java 的简单移植。不过要说命名，Python 本身就已经很混乱了，缩写的、连写（无分隔）的、snake_case 的、camelCase 的，乱成一锅粥。以颜色的记录来说，OO 的组织方式比较利于理解，而直接使用 <code>ndarray</code> 更利于和 NumPy 交互，也利于优化。这更多地是一种设计选择，但是我认为有经验的话不会做出这样的选择。</p><p>程序本身交互极差。上面也提到了一部分。这个作业在最后还要完成第四种模式，将你所选定的可视化方式应用于分块的体数据。这相当于有一个一级列表，让你选择某个物体，然后再有一个二级列表，选择其在某个时间点下的数据。但是要进入这第四种模式可不是那么简单。这个模式对应的单选框默认是无效（灰色）的，你得先手工选择两个文件夹（体数据索引、各个时间），再选定了其中一个物体的其中一个时间点后，这个单选框才会激活。要不然，想切换都没法切换。这个操作本身就非常反直觉，如果没有那同学的讲解，我恐怕也得摸索个几分钟。在代码逻辑上，单物体（直接打开体数据）和多物体（本段所述的分块选择）的交互是两套代码……</p><p>由于不断地有人哀嚎渲染一帧实在是太久了，这老师在截止日期前几天发了一则公告，说如果想加速的话推荐使用 Numba。然而他在给出的例子是切片——最简单的渲染模式，基本上就是简单的 <code>ndarray</code> 读取，没有复杂循环，没有合成。这个直接套个 <code>@jit(nopython=True)</code> 就搞定了，非常简单。然而真正有优化需求的体元合成，要用上 Numba，那得知道 Numba 是怎么工作的、它对数据结构是怎么支持的、Python 本身的瓶颈在哪里、什么时候 Python 解释器是必需的（例如让人又爱又恨的 <code>inspect</code>），这样才能知道什么能加速什么不行，如果不行能不能换成等价的写法使得它能被加速。这在我看来，对知识厚度的要求远远超过这门课。将这种任务放在一个作业里，就是高射炮打蚊子。而且看来，他也没有对任务难度的合理估计，以为后面都只是像他给的例子那样，直接加个装饰器（decorator）那么简单。</p><p>不过，不是没有厉害的老师的。在我选过的课里面，就发生过：</p><ul><li>Foundations of Machine Learning。老师讲得很好，而且看代码也是简明扼要，清晰易懂，几乎没有冗余。</li><li>Recommender Systems，和 FML 是同一个老师。在第四个作业中，我们要实现一个 <a href="https://en.wikipedia.org/wiki/Autoencoder#Variational_autoencoder_%28VAE%29" target="_blank" rel="noopener">VAE</a>。其中助教提示的是“别忘了用 <a href="https://keras.io/backend/#flatten" target="_blank" rel="noopener"><code>flatten()</code></a> 调整数据的形状”，但是在查阅资料后我判断应该用 <a href="https://keras.io/backend/#batch_flatten" target="_blank" rel="noopener"><code>batch_flatten()</code></a>，就这么写了。后来在作业的点评里这一条被专门指了出来，说确实应该用 <code>batch_flatten()</code>，是他失误了。</li><li>VLSI Programming。就是我<a href="/categories/Misc/zh/2019-04-23-Misc/">之前</a>写过的老先生。图的构造代码写得非常漂亮，而且指出过我的一些 pythonic 的写法（例如<a href="https://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">列表推导</a>）有效率问题——在这门课里，效率是一个很重要的衡量因素。</li><li>Programming Methods。这门课其实是一个本科3级的课程，偏向于软件工程，我自愿选的。最后的一个作业是写一个 <a href="https://en.wikipedia.org/wiki/Takuzu" target="_blank" rel="noopener">Takuzu</a>（类似于数独，不过只填入0和1）的求解器，而且是可视化的。这个程序本来是用作各种设计模式的练习的，不过它的交互设计和代码水平都很不错。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次无可奈何的 Python 提速。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Python" scheme="https://blog.mottomo.moe/tags/Python/"/>
    
    <category term="Numba" scheme="https://blog.mottomo.moe/tags/Numba/"/>
    
  </entry>
  
  <entry>
    <title>C++ 模板类的非待决名查找</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/</id>
    <published>2019-10-06T09:30:00.000Z</published>
    <updated>2020-07-26T13:49:08.003Z</updated>
    
    <content type="html"><![CDATA[<p>今天要做某个功能，其中我想用一个<em>单一参数的</em>宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）：</p><pre><code class="lang-cpp">#define DECLARE_CLASS(this_class, base_class) \    typedef base_class MyBase; \    typedef this_class MyClass</code></pre><p>对于普通的类，实现起来是这个样子：</p><pre><code class="lang-cpp">#define DECLARE_ROOT_CLASS(class_name) \    typedef class_name MyClass#define DECLARE_CLASS(class_name) \    typedef MyClass MyBase; \    typedef class_name MyClass</code></pre><p>使用：</p><pre><code class="lang-cpp">class Base {    DECLARE_ROOT_CLASS(Base);};class Derived : public Base {    DECLARE_CLASS(Derived);};</code></pre><p>很明显，这样利用 <code>typedef</code> 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 <code>typedef</code> 而不是更现代的 <code>using</code>，这在这里只是风格问题，对语义无影响。</p><p>对于模板类，我打算如法炮制。可是，问题出现了。</p><a id="more"></a><p>我的宏定义是这样的：</p><pre><code class="lang-cpp">#define DECLARE_ROOT_CLASS_TEMPLATE(class_name, TArgs...) \    typedef class_name&lt;TArgs&gt; MyClass#define DECLARE_CLASS_TEMPLATE(class_name, TArgs...) \    typedef MyClass MyBase; \    typedef class_name&lt;TArgs&gt; MyClass</code></pre><p>然而在编译的时候，在第4行产生了错误：</p><ul><li>（Clang 提示说，）VC++ 认为，<code>MyBase</code> 等同于 <code>MyClass</code>（假设仍然使用后文的例子，则 <code>Derived::MyBase</code> 等同于 <code>Derived</code> 而不是期望的 <code>Base</code>）；</li><li>Clang 和 GCC 认为，<code>MyBase</code> 未定义。</li></ul><p>我就不理解了，为什么是未定义呢？似乎以前 stat 给 UB（两个把 C++ 玩出花的大佬）讲过 VC++ 有符号名称查找（name lookup）上的错误，与标准的不符。但是，Clang 和 GCC 是怎么回事？这里的 VC++ 又是怎么回事？</p><p>所以我就问了 stat，如下的例子中为什么 <code>TBase</code> 处出错了。</p><pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;class Base {    typedef Base&lt;T1, T2&gt; TBase;    typedef TBase TThis;}template&lt;typename T1&gt;class Derived : public Base&lt;T1, T1*&gt; {    // 后注：在提问时我手写的；不过这样写在所有编译器中都不能通过编译，出问题的还是“typedef TThis TBase;”    typedef typename TBase::TThis TBase;    typedef Derived TThis;}</code></pre><p>stat 想了一会儿，说：“<code>TBase</code> 是 non-dependent，第一遍解析的时候找不到。”</p><p>什么是 non-dependent 呢，就是 dependent 的反义词咯。那什么又是 dependent 呢？我就搜索了一下。全称应该叫做 <a href="https://en.cppreference.com/w/cpp/language/dependent_name" target="_blank" rel="noopener">dependent name</a>，具体还可以分为 type-dependent 和 value-dependent。（不是 <a href="https://www.modernescpp.com/index.php/c-core-guidelines-argument-dependent-lookup-or-koenig-lookup" target="_blank" rel="noopener">argument-dependent lookup</a>！）</p><p>stat 所说的“第一遍解析的时候找不到”，指的是对模板类中符号的<a href="https://stackoverflow.com/a/1643190" target="_blank" rel="noopener">二次查找</a>。这里由于 <code>MyBase</code>（<code>TBase</code>）是一个普通符号，而不是 type-dependent（<code>SomeTemplate&lt;T&gt;::TBase</code>、<code>TBase&lt;T&gt;</code>）也不是 value-dependent（<code>SomeTemplate&lt;N&gt;::TBase</code>、<code>TBase&lt;N&gt;</code>），所以不能通过一次扫描来确定合适的上下文。也就是 stat 说的：“（解析）模版的时候 <code>TBase</code> 是不知道是基类的 <code>typedef</code> 的”。</p><p>不过，我并不知道中文该叫什么，本文标题里的“待决名”是将语言切换到中文后显示的翻译。</p><p>下一个问题，VC++ 这里的行为是怎么回事。让我们看看<a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance" target="_blank" rel="noopener">文档</a>和<a href="https://devblogs.microsoft.com/cppblog/permissive-switch/" target="_blank" rel="noopener">开发博客</a>里是怎么说的。VC++ 默认遵照的不是标准行为，而是往里面加了点毒。在进行二次查找时，查找的<a href="https://devblogs.microsoft.com/cppblog/two-phase-name-lookup-support-comes-to-msvc/" target="_blank" rel="noopener">位置错了</a>。就从文章中的例子来看看：</p><pre><code class="lang-cpp">#include &lt;cstdio&gt;void func(void*) {    std::puts(&quot;The call resolves to void*&quot;);}template&lt;typename T&gt;void g(T x) {    func(0);}void func(int) {    std::puts(&quot;The call resolves to int&quot;);}int main() {    g(3.14);}</code></pre><p>标准行为是，在模板类/模板函数中使用的符号，其查找位置为<em>定义处</em>，也就是说，要查找这个符号，范围应该从开头至此处。“定义”指的是模板的定义。而 VC++ 的行为是，查找位置在实际使用处。</p><p>按照这么个逻辑，上面的例子结果就很明显了。</p><ul><li>在标准行为下：<code>g()</code> 对 <code>func(0)</code> 的调用会被解析到 <code>void func(void*)</code>。因为在此时（直到 <code>func(0)</code>）编译器只知道这个声明，而且隐式转换是可以接受的。</li><li>在 VC++ 行为下，会被解析到 <code>void func(int)</code>。因为在此时（直到 <code>g(3.14)</code>）编译器知道两个重载了的声明（<code>void func(void*)</code> 和 <code>void func(int)</code>，而其中根据参数类型决断，更合适的是后者。</li></ul><p>同理，也就产生了上面的问题。在代码中，如果 <code>MyBase</code> 的使用晚于 <code>MyClass</code>，就会产生 <code>MyClass</code> 已经被重新 <code>typedef</code> 的情况，从而让 <code>MyBase</code> 指向错误的类型。当然，就算是顺序恰巧对了，在某些情况下（比如调用前出现了多种特化/偏特化），还有可能因为非标准行为而产生难以预料的后果。</p><hr><p>另外偶然看到的一个有意思的“可选命名参数”<a href="https://www.fluentcpp.com/2018/12/14/named-arguments-cpp/" target="_blank" rel="noopener">实现思路</a>和<a href="https://gitlab.com/tillheinzel/unorderednamedarguments" target="_blank" rel="noopener">代码</a>。调用效果类似 C# 的可选命名参数：</p><pre><code class="lang-cpp">void Test() {    CallSomeMethod(param2 = &quot;Param2Value&quot;, param1 = param1Value);    CallSomeMethod(param1 = param1Value, &quot;Param2Value&quot;);    CallSomeMethod(param1Value, &quot;Param2Value&quot;);}</code></pre><p>副作用就是会有少许污染。</p><hr><p>在移植的时候，在变量上我使用了和原来代码相同的命名，其中就包括 <code>xor</code>。结果编译器就报错了。</p><p>一查，才知道原来 C++ 还有一串<a href="https://en.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">运算符的替代表示法</a>。在默认情况下，这些替代名称是启用的，除非使用选项关闭。以链接中的例子来说，这样的代码虽然看上去很奇怪，但也是可以正常编译的：</p><pre><code class="lang-cpp">%:include &lt;iostream&gt;struct X&lt;%    compl X() &lt;%%&gt; // 析构函数    X() &lt;%%&gt;    X(const X bitand) = delete; // 复制构造函数    bool operator not_eq(const X bitand other)    &lt;%       return this not_eq bitand other;    %&gt;%&gt;;int main(int argc, char* argv&lt;::&gt;) &lt;%    // 带引用捕获的 lambda    auto greet = &lt;:bitand:&gt;(const char* name)    &lt;%        std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name                  &lt;&lt; &quot; from &quot; &lt;&lt; argv&lt;:0:&gt; &lt;&lt; &#39;\n&#39;;    %&gt;;    if (argc &gt; 1 and argv&lt;:1:&gt; not_eq nullptr) &lt;%        greet(argv&lt;:1:&gt;);    %&gt;%&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天要做某个功能，其中我想用一个&lt;em&gt;单一参数的&lt;/em&gt;宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;#define DECLARE_CLASS(this_class, base_class) &#92;
    typedef base_class MyBase; &#92;
    typedef this_class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于普通的类，实现起来是这个样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;#define DECLARE_ROOT_CLASS(class_name) &#92;
    typedef class_name MyClass

#define DECLARE_CLASS(class_name) &#92;
    typedef MyClass MyBase; &#92;
    typedef class_name MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;class Base {
    DECLARE_ROOT_CLASS(Base);
};

class Derived : public Base {
    DECLARE_CLASS(Derived);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显，这样利用 &lt;code&gt;typedef&lt;/code&gt; 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 &lt;code&gt;typedef&lt;/code&gt; 而不是更现代的 &lt;code&gt;using&lt;/code&gt;，这在这里只是风格问题，对语义无影响。&lt;/p&gt;
&lt;p&gt;对于模板类，我打算如法炮制。可是，问题出现了。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="CPlusPlus" scheme="https://blog.mottomo.moe/tags/CPlusPlus/"/>
    
  </entry>
  
  <entry>
    <title>哈哈</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/</id>
    <published>2019-04-23T10:56:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>技术长草。</p><a id="more"></a><hr><p>今天讲到 <a href="https://en.wikipedia.org/wiki/Kahn_process_networks" target="_blank" rel="noopener">Kahn Process Network</a>（KPN），我看到图示之后立刻反应过来，这结构不就是消息队列（message queue）吗。噫，消息队列“天然地”支持分布式架构，我理所当然地就接受了，因为有一点工程经验它就显得很自然了。没想到也是有一个理论支持的。</p><p>讲到并行化的实现思路（也即 parallelism），一般分为两类。<a href="https://ieeexplore.ieee.org/abstract/document/1631937" target="_blank" rel="noopener">多线程</a>实现的“并行”，虽然在具体实现中是不可或缺的，但是只能说是技巧（technique），而不是架构（architecture）。这门课针对的是 parallelism by design，是架构上的并行，而且在系统设计时就有着确定的行为。（注：KPN 中各个过程是可以并行的，但是整个系统仍然有着确定的行为。这是 KPN 的一个特性。）在课程描述里还讲到有一个叫做 parallelism by compilation 的，我不知道是什么（毕竟 compilation 可能指常见的“编译”之外的更泛的意思），所以就去问了。教授（略有学究气的老先生）回答说，如果编译器足够智能的话，就可以将过程分离（注：原话用的是“process”，不过并不是指进程，而是抽象出的过程——粒度可以是大到功能模块，也可以小到一个原子操作），并抽取出可以并行的部分，自动并行。说完之后，他盯着我，很认真地（从语气和眼神里可以体会到）说：“我<em>坚信</em>确定的并行化（parallelism by design）是最好的方案，虽然很少人这么想。”我不知道该说什么好了。我大概能猜到他的心情；不过总有一种“力挽狂澜”之感，专门开这么一门课。</p><p>这又让我想起了复杂系统的设计方式，构造和自组织。我的思想仍然受到<a href="https://www.techug.com/post/python-ai.html" target="_blank" rel="noopener">这篇文章</a>的影响。或许以前我引用过，但是在这里我还是想引用一次：</p><blockquote><p>但我并不认为 Java 有很大的机会，因为它本质上是为构造大型复杂系统而设计的。什么是大型复杂系统？就是由人清清楚楚描述和构造出来的系统，其规模和复杂性是外生的，或者说外界赋予的。</p><p>而 AI 的本质是一个自学习、自组织的系统，其规模和复杂性是一个数学模型在数据的喂养下自己长出来的，是内生的。</p></blockquote><p>不过，我仍然认为关键系统需要人为地设计其架构。“it just works”地在精细尺度上的、不可预测的并行，虽然显得很迷人，却是非常危险的。</p><hr><p>想起编译器优化的同时我又想起了之前和“博导”（我以前的一个同学，高中去了美国，大学读的……好像是电子工程；反正一直碾压同龄人）的一段对话。以下是节选：</p><blockquote><p>（前略）</p><p>我：这算什么，原教旨？<em>（注：指纯 C 写移动设备 app）</em></p><p>博导：算是吧，C 系手动内存正统，Java 等 GC 语言异端！我要确定性，掌控每一行代码！</p><p>我：抱歉，指令预测真的可以为所欲为。除非不断加 memory barrier，要不严格来说你无法掌控“每一行代码”。</p><p>博导：我知道 Intel 内部运作，知道 reordering 和 uop，所以是掌控的。<em>（注：uop = micro-operation）</em></p><p>博导：当然更加知道 GCC 每一行代码会编译成什么。</p><p>我：（图片：熊猫膜拜）</p><p>博导：其实 Intel 8卷读一遍就知道了。</p><p>我：（图片：许多熊猫一起膜拜）</p></blockquote><hr><p>不知道放哪里好，就放这里吧。</p><p><a href="https://www.semanticscholar.org/paper/Background-%3A-Physics-and-Math-of-Shading-Hoffman/237a3b12974e4bcf3d527dfd771271251133c3b6" target="_blank" rel="noopener">原文</a>：</p><blockquote><p>In a sense, the specular term gets “dibs” on the incoming light energy, and the diffuse term<br>can only use its “leftovers”. </p></blockquote><p><a href="https://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-3.html" target="_blank" rel="noopener">译文</a>：</p><blockquote><p>某种意义上，specular项指着入射光能量大喊“归我了”，然后diffuse项只能用“剩下的”。</p></blockquote><p>我读到这里的时候哈哈大笑。虽然这个翻译仍然有可以提高的地方，但是这个版本很有画面感。</p><blockquote><p>某种意义上，高光（specular）项占了入射光能量的大头，散射（diffuse）项就只能利用余下的能量。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;技术长草。&lt;/p&gt;</summary>
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>几种斐波那契数列项算法的复杂度分析</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/</id>
    <published>2019-04-07T12:44:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 <a href="http://bangumi.tv/subject/227102" target="_blank" rel="noopener">BEATLESS</a>。</p><hr><p>“回字有四样写法，你知道么？”</p><p>而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。</p><a id="more"></a><hr><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天在面试的时候被问到了这样一个问题：求斐波那契数列的第 $n$ 项，你能想到多少种算法？</p><p>自然，猴子都知道简单递归。再进一步，黑猩猩都能看出来递归可以用一个额外的表来速查（空间换时间）。有递归就自然要想能不能迭代。稍稍想一下的话可以知道是能迭代的。</p><p>然后又问，时间和空间复杂度是多少？</p><p>迭代简单，$T(n) = O(n)$，$S(n) = O(1)$。递归我就炸了（所以说我太水了），时间分析就满脸问号（用表的话……优化是优化了，但是和迭代也没差多少了，却还多了调用开销；简单递归分析卡壳了），没答上来，面试官也就没问空间复杂度。所以我当时只想到了两种；后来因为提到迭代的空间复杂度为 $O(1)$，面试官可能没太听清，说道：“（时间复杂度）$O(1)$ 的解法也是有的，不过你用了迭代只能是 $O(n)$ 了。”虽然和我的回答意思相差了一些，但是我还是惊诧了一下（没出声）：“这个 $O(1)$ 是怎么来的？”</p><p>所以下午我就搜索了一下。</p><p>……连个本科生（复杂度计算本科生都会）都比不过，我自裁罢。</p><h1 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h1><p>斐波那契数列 $f_n (n \in \mathbb{N})​$ 的定义如下：</p><script type="math/tex; mode=display">f_n = \begin{cases}    0,\quad &n \lt 1\\    1,\quad &1 \le n \le 2\\    f_{n-1} + f_{n-2},\quad &n \gt 2\end{cases}</script><p>之后的代码以此为准。</p><p>为了简单起见，在之后的代码中使用 <code>int</code>，而不是更大的 <code>long long</code>，懒得用无符号数，也没有防溢出机制。</p><h1 id="三、直接的代码解法"><a href="#三、直接的代码解法" class="headerlink" title="三、直接的代码解法"></a>三、直接的代码解法</h1><p>这部分的方法就是只用到代码、基础算法和优化，几乎不需要数学。</p><h2 id="3-1-递归法"><a href="#3-1-递归法" class="headerlink" title="3.1 递归法"></a>3.1 递归法</h2><p>递归就是最简单直接的方法了，代码形式和数学形式接近，理解很好理解，大部分工作交给计算机完成。</p><h3 id="3-1-1-朴素递归"><a href="#3-1-1-朴素递归" class="headerlink" title="3.1.1 朴素递归"></a>3.1.1 朴素递归</h3><p>朴素递归应该学过代码都会，代码就不需要多讲了。</p><pre><code class="lang-c">int fib(int n) {    if (n &lt; 1) {        return 0;    } else if (n &lt;= 2) {        return 1;    } else {        return fib(n - 1) + fib(n - 2);    }}</code></pre><p>对应的调用如下：</p><pre><code class="lang-c">int result = fib(15);</code></pre><p>这个算法的空间复杂度比较好分析（虽然有点绕），是 $O(n)$。令初始调用为第0层，调用一次加深一层。可以知道，在某一层的所有调用结束之前，不会产生新的调用（即，栈深不会增加）。那么栈深最深的是什么时候呢？画一棵调用树就可以看出，是从 <code>fib(n)</code> 开始到 <code>fib(1)</code>（实际上可以算到 <code>fib(2)</code> 为止）的这条“单刀直入”的路径。或者可以这么想，每次 <code>fib(n)</code> 执行实际计算（求和）的时候，<code>fib(n - 1)</code> 已经计算完成了。所以空间复杂度是 $O(n)$（更准确地说是 $\Theta(n)$）。</p><p>那么，时间复杂度是多少呢？许多文章直接就说结论是 $O(2^n)$，但是也没给出推导过程，或许也是因为太简单了。观察调用树可以知道，一个非叶子节点最多有两个子节点，而树的深度是 $O(n)$；在每个节点的操作都是简单加法，时间为 $\Theta(1)$；所以总计就是 $O(2^n)$。</p><p>但是大多数人没想过，这是一个好的估算吗？我们知道，大 O 函数只是给出上界；给出比一个已知上界更高的上界也不算错。也就是说，我可以胡扯说复杂度是 $O(2^{2^n})$，你也不能说我错了，只能说这个上界“质量不好”。</p><p>再次观察调用树，可以很明显地发现不管树高度如何增长，总是有不可忽视的一部分节点“缺失”了。因此，很明显还能找出比 $O(2^n)$ 更紧的上界。</p><p>为了计算这个上界，我们不妨来观察函数调用的过程。设 <code>fib(n)</code> 的调用时间为 $t<em>{n}​$ ，我们可以知道：$t</em>{n} = \Theta(1) + t<em>{n-1} + t</em>{n-2}​$。那么，这不是和原来的斐波那契数列形式完全一样吗？回到原点了。</p><p>但是等一下！斐波那契数列是可以求出通项的（见 <a href="4-3-%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F">4.3 节</a>）。提取“公因式” $\Theta(1)$（不是公因式，不过在复杂度分析中可以视作等量级；另外这个 $\Theta(1)$ 虽然上面是出现在递归式里，但是在通项中可以化为一个系数——这么讲不是很准确，不过意思就是这样）之后可以知道：</p><script type="math/tex; mode=display">\begin{align}T(n) &= \Theta(1) O((\frac{1+\sqrt{5}}{2})^n + (\frac{1-\sqrt{5}}{2})^n)\\     &= O((\frac{1+\sqrt{5}}{2})^n)\end{align}</script><p>$\frac{1+\sqrt{5}}{2} \approx 1.618$，虽说看起来好像比2差不了多少，不过对于 $n$ 很大的时候差距就比较明显了。这个上界明显比 $O(2^n)$ 要好，也是能获得的最紧的上界。</p><h3 id="3-1-2-尾递归"><a href="#3-1-2-尾递归" class="headerlink" title="3.1.2 尾递归"></a>3.1.2 尾递归</h3><p>既然朴素递归开销这么大，有没有可能用无敌的尾递归想想办法呢？毕竟一些现代编译器是支持尾递归优化为循环（迭代）的。（注：其实尾递归并不是无敌的，有着严格的应用条件；这里只是玩梗。）</p><p>我们知道，尾递归的一个重要条件是对调用自身后返回的结果不可以进行处理（即，尾调用——对自身的调用必须是返回前的最后一条指令）。那么我们将对之前的两个状态的操作（相加）转移到参数中，不就成了尾递归了吗。代码如下：</p><pre><code class="lang-c">int fib(int x1, int x2, int n) {    if (n &lt; 1) {        return 0;    } else if (n &lt;= 2) {        return 1;    } else if (n == 3) {        return x1 + x2;    } else {        return fib(x2, x1 + x2, n - 1);    }}</code></pre><p>对应的调用如下：</p><pre><code class="lang-c">int result = fib(1, 1, 15);</code></pre><p>这个的复杂度分析要考虑一下编译器。对于支持尾递归优化的编译器，这实际上跟下面的迭代是一样的，所以时间复杂度同为 $O(n)$，空间复杂度同为 $O(1)$。对于不支持的编译器，时间和空间的复杂度都很好分析，看参数 <code>n</code> 的变化就行——单次调用开销为 $\Theta(1)$，所以总复杂度同为 $O(n)$。</p><h2 id="3-2-迭代法"><a href="#3-2-迭代法" class="headerlink" title="3.2 迭代法"></a>3.2 迭代法</h2><p>不管是否想到了尾递归的方法，迭代都应该比较容易想到。如果想到了尾递归的话，很自然地可以进一步到迭代。</p><p>想法直截了当：既然每次只需要前两项的结果（状态），而 $f<em>{n-3}$ 并不会被 $f_n$ 及之后的计算直接用到，那么为什么要保存其他状态呢？$f</em>{n-1}$ 和 $f_{n-2}$ 已经很好地充当了“缓存”的功能。代码如下：</p><pre><code class="lang-c">int fib(int n) {    if (n &lt; 1) {        return 0;    } else if (n &lt;= 2) {        return 1;    } else {        int n1 = 1, n2 = 1;        int tmp;        for (int i = 3; i &lt; n; ++i) {            tmp = n1 + n2;            n1 = n2;            n2 = tmp;        }        return n2;    }}</code></pre><p>调用如下：</p><pre><code class="lang-c">int result = fib(15);</code></pre><p>显而易见，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$（更准确地说是 $\Theta(1)​$）。我觉得分析都不用写了。</p><h1 id="四、含数学分析的解法"><a href="#四、含数学分析的解法" class="headerlink" title="四、含数学分析的解法"></a>四、含数学分析的解法</h1><p>简单暴力的代码解法毕竟是太拿衣服。要往深了优化（或者给出无法继续优化的证据）还是得要数学。</p><h2 id="4-1-数列分析"><a href="#4-1-数列分析" class="headerlink" title="4.1 数列分析"></a>4.1 数列分析</h2><p>为了理解接下来的分析，首先要知道特征方程。数列的特征方程我记得是高中讲过的，可是后来一直都没怎么用过（高数里也是）；加上本来我数学就弱，所以基本就是忘光了。对不起了，宋老师。</p><p>斐波那契数列是一个二阶的递推数列，一般形式为 $x<em>{n} = c</em>{1}x<em>{n-1} + c</em>{2}x<em>{n-2}$。假设能找到两个数 $p$ 和 $q$，使得 $x</em>{n} - px<em>{n-1} = q(x</em>{n-1} - px<em>{n-2})$，移项得 $x_n = (p+q)x</em>{n-1} - pqx<em>{n-2}$。所以有 $p + q = c_1$，$pq = -c_2$。不难看出 $p$ 和 $q$ 的地位是相等的，因此消去任意一个（以 $q$ 为例）可得 $p^2 - c</em>{1}p - c_2 = 0$。这就是二阶递推数列的特征方程。求解该二次方程，两个实根（如果有）就是 $p$ 和 $q$。</p><p>代回原来的数列形式，若 $p \ne q$，则通项为 $x_n = \frac{x_2-qx_1}{p(p-q)}p^n + \frac{px_1-x_2}{q(p-q)}q^n$；若 $p=q$，则通项为 $x_n = (\frac{px_1-x_2}{p^2} + \frac{x_2-px_1}{p^2}n)p^n$。</p><p>将斐波那契数列代入（即 $c_1 = 1, c_2 = 1$）可以解得 $p = \frac{1+\sqrt{5}}{2}$，$q = \frac{1-\sqrt{5}}{2}$（$p$ 和 $q​$ 可互换）。</p><h2 id="4-2-改进的迭代：矩阵快速幂"><a href="#4-2-改进的迭代：矩阵快速幂" class="headerlink" title="4.2 改进的迭代：矩阵快速幂"></a>4.2 改进的迭代：矩阵快速幂</h2><p>（是搜索之后才知道有可以应用“矩阵快速幂”这么一类问题的。我没参加过 ACM，所以渣了。）</p><p>从 <a href="#4-1-%E6%95%B0%E5%88%97%E5%88%86%E6%9E%90">4.1 节</a>可知，存在符合条件的 $p$ 和 $q$。于是，就可以将每次求值化为矩阵乘法。</p><p>对于 $k$ 阶线性递推数列 $x<em>n = c</em>{1}x<em>{n-1} + c</em>{2}x<em>{n-2} + \cdots + c</em>{k}x_{n-k}$，每次递推可以表示为：</p><script type="math/tex; mode=display">[x_n, x_{n-1}, \dots, x_{n-(k-1)}] = [x_{n-1}, x_{n-2}, \dots, x_{n-k}] \times \mathbf{M}</script><p>其中大小为 $k \times k$ 的矩阵 $\mathbf{M}$ 就是……呃，好像没有标准称呼？就叫递推矩阵好了。由此可见，由于 $\mathbf{M}$ 在递推过程中不变，计算 $x_n$ 就被转化为了计算矩阵的幂的问题。这个矩阵受初始值选取和递推公式两方面的影响。</p><p>对于斐波那契数列，给定初始值 $[1, 1]$，可以得到</p><script type="math/tex; mode=display">\mathbf{M} = \begin{bmatrix}    1 & 1\\    1 & 0\end{bmatrix}</script><p>虽说是矩阵快速幂，但是对幂函数的计算优化其实和数的是一样的，只不过乘法的定义略有不同。</p><p>要计算一个数 $a$ 的 $n$ 次幂，最直接的想法是连乘，时间复杂度为 $O(n)$。但是只要见过质数筛这类的问题，或者是插值函数优化，就马上会意识到，其中许多次的乘法是多余的，结果是可以缓存的（甚至可以不用缓存）。那么，如何剔除这些多余的计算呢？</p><p>不是有对数函数嘛。大杀器。</p><p>考虑到实现的便利性，一般就取 2 为底了。将幂次 $n$ 分解为 2 的幂的和：$n = c<em>{0}2^0 + c</em>{1}2^1 + \cdots + c<em>{m}2^{m}$，其中 $c_i \in {0, 1} (0 \le i \lt m), c_m = 1$。进一步展开到乘法，就可以看到，$a^n = a^{c</em>{0}2^0} \times a^{c<em>{1}2^1} \times \cdots \times a^{c</em>{m}2^m}$。这样，从前往后“扫描”，由于 $a^{2^n} \times a^{2^n} = a^{2^{n+1}}$（废话），所以只需要保存最近的中间结果，就可以依次得到正确的乘积，并最终得到 $a^n$。代码如下：</p><pre><code class="lang-c">// 简洁起见，仅处理 a &gt; 0, n &gt;= 0 的情况int pown_fast(int a, int n) {    int result = 1;    int cur = a;    while (n &gt; 0) {        if (n &amp; 1) {            result = result * cur;        }        cur = cur * cur;        n = n &gt;&gt; 1;    }    return result;}</code></pre><p>可以见到，<code>pown_fast()</code> 的时间复杂度为 $O(\log n)​$，空间复杂度为 $O(1)​$（$\Theta(1)​$）。对于矩阵的幂，由于斐波那契数列相关的递推矩阵大小是常数，所以时间和空间复杂度都和计算数的幂是一样的。再考虑初始值的输入等等，最终的时间复杂度为 $O(\log n) + \Theta(1) = O(\log n)​$，空间复杂度为 $\Theta(1) + \Theta(1) = \Theta(1)​$。</p><p>也有用类似思想，但不是快速幂的解法，而是采用新的递推公式，参见<a href="http://blog.zhengyi.one/fibonacci-in-logn.html" target="_blank" rel="noopener">[1]</a>。</p><h2 id="4-3-通项公式"><a href="#4-3-通项公式" class="headerlink" title="4.3 通项公式"></a>4.3 通项公式</h2><p>将 $p​$ 和 $q​$ 的值代入 <a href="#4-1-%E6%95%B0%E5%88%97%E5%88%86%E6%9E%90">4.1 节</a>的通项公式可得： $f_n = \frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^n + (\frac{1-\sqrt{5}}{2})^n)​$。</p><p>按照这个通项计算 $f_n​$，理论上可以达到 $O(1)​$ 的时间复杂度。</p><p>很美妙，不是吗？$O(1)$ 和 $O(1)$ 啊！但是简单地计算依然会出问题。这个公式中，多处涉及了（在最终结果前）无法约简的无理数。在现代的计算框架中，如果按照一般的思维，用浮点数来表示这些无理数，进行计算的话，一定有因浮点数的不精确性导致的误差。$n$ 越大，误差越大。且不说“四舍五入”这个行为在此正不正确，当误差超过 0.5 的时候，舍入都救不回来了。所以在实践中，这个方法是不可取的。</p><p>当然不是没有能保证精度的方法。采用符号代数就可以了。而且这个计算过程中的无理数只有 $\sqrt{5}$ 一个，而且 $(\sqrt{5})^2 = 5$ 还是个整数。不过计算过程就得根据二项式定理展开，然后累加并分类求和，所花的时间肯定会多于 $O(n)$，空间开销也不会小。</p><h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>以上我们见到了五种计算 $f_n$ 的方法：</p><ul><li>朴素递归，$T(n) = O((\frac{1+\sqrt{5}}{2})^n)$，$S(n) = O(n)$；</li><li>尾递归，在有优化的情况下 $T(n) = O(n)$，$S(n) = O(1)$；</li><li>迭代，$T(n) = O(n)$，$S(n) = O(1)$；</li><li>快速幂，$T(n) = O(\log n)$，$S(n) = O(1)$；</li><li>通项，$T(n) = O(1)$，$S(n) = O(1)​$。</li></ul><p>在几种方法中，时间和空间复杂度都是从前往后越来越好。但是通项由于需要用浮点数表示无理数的值会导致误差所以基本上不能用。所以综合各种因素考虑，最优的算法是采用快速幂计算 $f_n$。</p><hr><p>参考：</p><ul><li>[1] <a href="http://blog.zhengyi.one/fibonacci-in-logn.html" target="_blank" rel="noopener">五种方法计算斐波那契数列的第n项</a></li><li>[2] <a href="https://blog.csdn.net/dangzhangjing97/article/details/78778536" target="_blank" rel="noopener">斐波那契数列的三种解法及时间复杂度</a></li><li>[3] <a href="https://blog.csdn.net/u012684062/article/details/76330075" target="_blank" rel="noopener">斐波那契数列数列的三种时间复杂度的实现方法</a></li><li>[4] <a href="https://www.geeksforgeeks.org/time-complexity-recursive-fibonacci-program/" target="_blank" rel="noopener">Time complexity of recursive Fibonacci program</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 &lt;a href=&quot;http://bangumi.tv/subject/227102&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BEATLESS&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;“回字有四样写法，你知道么？”&lt;/p&gt;
&lt;p&gt;而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="算法" scheme="https://blog.mottomo.moe/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随便写点什么</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/</id>
    <published>2019-03-05T17:33:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>GRIS 的文章呢？</p><p>别急，不会鸽的。</p><hr><p>二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。</p><p>那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。）</p><p>反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。</p><a id="more"></a><hr><p>昨晚又小小地反向了一把，对象是<del>京东娃娃项目</del><a href="http://www.projecttokyodolls.jp/" target="_blank" rel="noopener">东京偶像计划</a>（プロジェクト東京ドールズ）。关于结果 esterTion 应该已经更新在他的<a href="https://estertion.win/2019/03/project-tokyo-dolls-%e6%8b%86%e8%a7%a3%e7%9b%b8%e5%85%b3/" target="_blank" rel="noopener">文章</a>里了。</p><p>其实只是蹲坑的时候刷 Google Play，给我推荐了一个这玩意儿。看着画风还行，打开看看。嘛游戏内容（小人打架加一些反应要素）我就不感兴趣了（而且世界观的建构更是让人一脸问号），但是一些图啊模型啊还是不错的。（“穿着偶像衣服却不干偶像的事。” by 群友）饰品分离目前我只见过 Square Enix（<a href="http://schoolgirlstrikers.jp/" target="_blank" rel="noopener">SGS</a>、京东娃娃）和 Konami（<a href="https://www.konami.com/games/tokimeki-idol/" target="_blank" rel="noopener">心跳凉凉</a>）做过，大概还有一些参考价值？心跳偶像本来我想着跟土豆一样反向的，但是安卓严重混淆，我又没有越狱的 iPhone，没办法；后来……它就停服了。</p><p>有点远了。这次反向其实还挺简单的，esterTion 已经找到了关键的类和方法，所以省了很多事，只要耐心读就行了。他大概只是心急失手了而已。如果他又想吹我，您别听他的；我只是个弱渣。</p><p>IL2CPP 的反向比一般的原生代码要简单的一点是，它保留了很多 IL 的特征，C++ 编译器无法完全将它们优化。比如在这次挨个设置密钥数组元素的时候，就出现了很明显的一种模式：</p><pre><code class="lang-c++">if (array.metadata.length &lt; 0) throw_index_out_of_range_exception();array.elements[0] = elem0;if (array.metadata.length &lt; 1) throw_index_out_of_range_exception();array.elements[1] = elem1;if (array.metadata.length &lt; 2) throw_index_out_of_range_exception();array.elements[2] = elem2;if (array.metadata.length &lt; 3) throw_index_out_of_range_exception();array.elements[3] = elem3;</code></pre><p>在反编译的代码中，上面都是用偏移表示的。虽然在没看 IL2CPP <code>Array</code> 的源代码的情况下，并不清楚这个结构每个偏移是什么（快去看，懒虫），但是根据这么几个连续的偏移规律，也能摸个大概。再想想对应的 C# 是怎么样的：</p><pre><code class="lang-c#">arr[0] = elem0;arr[1] = elem1;arr[2] = elem2;arr[3] = elem3;</code></pre><p>在实际使用中，这个索引测试一般不是手工做的。因此可以猜测是在 IL2CPP 变换的过程中自动插入的片段，以保持语义一致（<code>ldelem.*</code>）。</p><p>与此类似的还有 IL2CPP 类型初始化（不是 <code>.cctor</code>）、IL2CPP 实例初始化（不是 <code>.ctor</code>）、加载静态的引用类型字段等等，生成的代码一看就知道是干什么的。这些重复的模式比起“一般的” C++ 来说要仁慈多了。</p><p>当然 C++ 编译器也不是吃素的，明显能优化的地方一定会优化。比如简单的 getter/setter，尤其是简单类型的自动属性，会被直接内联。我就说怎么一些属性的 getter/setter 无法被 xref，结果一看只要是简单赋值，全都跑到实际使用位置去了。而且恶心的是，这通常指的是指针+偏移访问。这就防住了简单的使用检索（find usage），如果是关键属性的话会非常头疼。</p><p>IDA 的 F5 并不能完美地反编译，有时候需要进入函数再出来，让它更新函数签名，特别是变参函数和看上去参数奇怪的函数调用。再比如，在 <code>MakeUrlCore()</code> 的关键调用签名更新完毕后，会发现有返回值没被使用的情况。而这些函数并没有修改 call site 所在实例的内部状态，这时就根据下文推断返回值使用的地方，而且可以回到汇编窗口验证。对，我说的是获取 UTF-8 字节数组之后计算 MD5 hash 的那一块。</p><p>如果对 .NET 比较了解，少数虚函数表里的调用也可以根据上下文推断。<code>string + Encoding.MethodX() -&gt; A; HashAlgorithm.ComputeHash(A)</code>，那么这个 <code>MethodX()</code> 就极有可能是 <code>GetBytes()</code>，即使是虚函数，而且（在 F5 中）缺少实参来判断。再比如，<code>StringBuilder.MethodY() -&gt; B; string.Concat(B, ...)</code>，那么这个 <code>MethodY()</code> 就极有可能是 <code>ToString()</code>，即使因为虚函数表+静态分析的原因无法看到实际调用的是哪个函数。这种思路跟中学的化合物推断是很相似的。</p><hr><p>说到反向，还有有趣的事情。上一周有一次组会的时候，我们预订的是学校最新的大楼的一个房间。那里面就有一个无线屏幕，可以把设备的屏幕无线地投射到显示器上。一个组员（本科生）说，他在另一门课（好像是 IoT Security 还是什么的）的小组就对这个屏幕使用的客户端下手了，写了一个非官方的客户端，能绕过一些限制来登录。</p><p>这肯定让我玩心大发啦。简单看了一下客户端，是一个无任何混淆的 WPF 应用程序。迅速扒光。然后跟着进入 P/Invoke 的原生库，稍微摸了一下结构。另一个是 C++/CLI 的 wrapper，依赖的是 C++ 的。在找不到公开文档和调试信息的情况下，后者基本是不可能静态分析的。</p><p>根据我原来看到的信息，我觉得这个系统的验证是存在漏洞的，理论上可以很容易地伪造用户登录和播放任意内容。不过刚才我看了更多的资料和代码之后否定了之前的想法。任意登录下降为<em>可能的</em>，在服务器配置存在特定配置缺陷的情况下；同时对登录有比之前所见的更大的限制。这就带来了攻击成本的上升和回报的下降，导致显得不划算。不过，反跟踪仍然是可以使用低成本的方式做到。</p><p>关于这个 WPF 程序的软件质量，我要称赞它，是软件工程的范本。遍地都是契约检查、防御性编程、打印日志（而且模糊了隐私信息），很专业嘛。</p><p>啊，本来还想着也许能做个白帽黑客的，不过现在看起来这个案例可能没什么能让我出手的地方了。</p><p>不过等到假期结束，我还是想亲手试试。</p><p>毕竟人家本科生都能做到的事情，我要是做不到，就太丢脸了。我虽然不知道他们做到了哪一步，但是必须要假设我想到的都已经完成了。</p><hr><p>说到假期，这个星期是<a href="https://en.wikipedia.org/wiki/Carnival_in_the_Netherlands" target="_blank" rel="noopener">狂欢节</a>假期。因为艾因霍温在南部嘛，而狂欢节是南部地区在庆祝，所以我们就有了这么一个假期咯。</p><p>上周六和昨天晚上去超市的时候，路上偶尔会看见一些穿着“奇装异服”的人。在上面的维基百科链接中可以看到大概的样子。你也可以在<a href="https://www.local-life.com/eindhoven/articles/carnaval-in-eindhoven" target="_blank" rel="noopener">这里</a>读到去年的样子。不过我没事又不经常出门，而且这还是在晚上，所以只能看见整个节日的一点点。狂欢游行什么的根本没有参与过，但是的确能在市中心看到不少散发着啤酒味的一次性杯子和几个临时的 live house。</p><hr><p>前几天开始我的左耳突然出毛病了。最开始的时候是时不时堵着，就跟坐飞机一样；但无法通过活动咽喉来解决，只能手动按压通气。而后一天晚上玩了一下 <a href="https://store.steampowered.com/app/210970/The_Witness/" target="_blank" rel="noopener">The Witness</a>，不过饱和度太高，不久就中等恶心（我玩大多数游戏都没有3D眩晕），受不了了。第二天起来还没发现什么异常，但是联机打了一局黑魂之后就发现对敌人的听觉定位不准了——正中的声源，会听起来偏右。再自言自语的时候就感觉颅内传导的声音，右耳出去了，但左耳好像碰到了什么，反射回来一部分，形成了混响。</p><p>虽说现在已经要找医生了，但是还得先处理别的麻烦事——验证邮件收不到，就无法完成电子身份认证，就无法预约。而现在正是狂欢节假期，不知道会不会影响。即使是能预约了，按照我的经验，也得等至少一个星期。这时候我就很怀念国内的挂号了。</p><p>所以……没办法咯，只好先习惯目前的处境，调整大脑的处理方式，希望之后不会耽误什么。</p><p>哇，如果听不见声音的话（或者只能借助于骨传导），我可会很难过的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GRIS 的文章呢？&lt;/p&gt;
&lt;p&gt;别急，不会鸽的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。&lt;/p&gt;
&lt;p&gt;那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。）&lt;/p&gt;
&lt;p&gt;反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。&lt;/p&gt;</summary>
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="逆向工程" scheme="https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="手游" scheme="https://blog.mottomo.moe/tags/%E6%89%8B%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>新年</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/</id>
    <published>2019-02-04T23:42:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。</p><p>如果有人关注我最近的活动的话或许会注意到，这半年来我推代码的频次相较以往同期要少。嗯，首先是 CS 确实很有意思，而且以我的基础可以看得比较全面（能自然地看见“点”之间的“线”），这样要深挖的就多多了。HTI……我的思维运转方式不是那样的，所以除了课上讲的冰山一角，基本都看不清，所以业余时间都投入到代码上了。</p><p>还有一个原因是我希望做一个更<em>有趣</em>的人。除了抽象的代码，我也乐于欣赏艺术创作。欣赏久了，自然就产生了投身于创作的想法。就像笼中之鸟羡慕飞翔的鸟儿一样。以我的性格，要是只能代码一条路走到黑我肯定要抹脖子了。临渊羡鱼，不如退而结网。</p><p>在B站上我之前一般是做烧笋的创作谱面；去年因为造一些轮子所以发了一些成果视频。这是我放松的一个选择。但是这毕竟形式非常单一而且（我认为）总是摆脱不了无生命感。——写谱面，在许许多多的规则之下，发挥的余地其实比较少（我不是硬核玩家），而且普遍关注的是技术难度，缺少要表达的主题。每一种艺术都不过是表达的方式，私以为代码也是这么一种手段；有的人擅长这种，有的人擅长那种，仅此而已。当然观众也得有相应的鉴赏能力。</p><p>所以我就想了，要是投入等量的时间，能让一种技能从70上升到75，或者让另一种从0上升到15，该如何选择呢？事实上这和 RPG 游戏加点一样是个一直困扰着我的难题。我选择在艺术上从0加到15，很清楚这并不会带来“一技傍身”的优势，而是希望借由将自身化为艺术创作者，去理解他们的视角和思维，会遇到什么问题，我的方案比别人差在哪里或者好在哪里。</p><p>继最开始的简单剪辑（<a href="https://www.bilibili.com/video/av34419159" target="_blank" rel="noopener">1</a>、<a href="https://www.bilibili.com/video/av36992638" target="_blank" rel="noopener">2</a>）之后，我开始尝试其他的形式：混搭（<a href="https://www.bilibili.com/video/av37445247" target="_blank" rel="noopener">1</a>、<a href="https://www.bilibili.com/video/av37593014" target="_blank" rel="noopener">2</a>）、手书（<a href="https://www.bilibili.com/video/av38332164" target="_blank" rel="noopener">1</a>、<a href="https://www.bilibili.com/video/av42680447" target="_blank" rel="noopener">2</a>）、<a href="https://www.bilibili.com/video/av39367371" target="_blank" rel="noopener">MAD</a> 和<a href="https://www.bilibili.com/video/av40274183" target="_blank" rel="noopener">改谱</a>（远算不上编曲）。每个作品的个中滋味恐怕都不是一两段话能说完的，也并不只是视频简介里的那些。当然，创作水平肯定是无法一蹴而就的。所以除了我自己的练习和体悟之外，我希望寻找更新的<em>想法</em>，希望它们也确实地传达给观众了。反正又不图名又不图利，若是能被欣赏，或进一步地，在此基础上衍生创作，丰富大环境，那就是更好的了。</p><p>那么近况如何呢？我确实在大脑没退化的前提下比之前更快乐了。比之前整天在代码上挖掘，望天叹气要好多了。我觉得这偶尔的音乐、绘画和视频创作是有一份功劳的。自己有趣不有趣……还不知道。至于产出的效益，那要等时间来回答。</p><p>胡乱说了一些话，权当跨（农历）年的一篇吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。&lt;/p&gt;
&lt;p&gt;如果有人关注我最近</summary>
      
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>NW.js 的上下文问题</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/</id>
    <published>2018-12-19T11:03:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>NW.js 有一个或两个上下文，使用时要多加小心。</p><a id="more"></a><hr><p>最近因为做项目，需要用到 NW.js。在搭环境的时候，我自然要写一个最简单的功能来测试了。我的例子是一个关闭按钮。简明起见，下面的代码复现的是在第二次试验。注释“2”的是第二次测试添加的输出，“1”是第一次的。</p><p><code>bootstrap.ts</code>：</p><pre><code class="lang-typescript">import * as main from &quot;./main&quot;;console.log(&quot;imported&quot;); // 2main.bindCloseKey();</code></pre><p><code>bootstrap.ts</code> 是编译为 ECMAScript 5 之后，加了个简单的兼容片段（解决 <code>exports</code> 找不到的问题），直接从页面链接的。</p><p><code>main.ts</code>：</p><pre><code class="lang-typescript">console.log(&quot;exported&quot;); // 2export function bindCloseKey(): void {    console.log(&quot;called&quot;); // 2    const button: HTMLButtonElement = document.querySelector(&quot;#close&quot;);    if (!button) {        console.log(&quot;Button not found: &quot; + selector); // 1    } else {        console.log(&quot;Button found&quot;); // 1        button.addEventListener(&quot;close&quot;, () =&gt; {            window.close();        });    }}</code></pre><p>主要功能如上所示，功能很简单，如果找到按钮就尝试绑定事件，不管找没找到都有一个输出。</p><p>但奇怪的是，实际运行的时候，点击按钮没有反应；打开开发者控制台（直接按 <kbd>F12</kbd>）却看不见任何输出。</p><p>于是加了几条注释之后再跑，只见到了第一条输出，也就是“imported”。</p><p>那么其他的输出在哪里？功能到底执行了没有？我猜想是目标问题，于是切换到 ECMAScript 6，顺便认识和试用了一下 <a href="https://nodejs.org/api/esm.html" target="_blank" rel="noopener">ESM</a>（就是那些 <code>.mjs</code> 文件），但问题还是没有解决。</p><p>无奈之下只好谷歌了。但是大多数人是希望将开发者控制台的输出重定向到系统控制台（确实有<a href="https://stackoverflow.com/a/38972028" target="_blank" rel="noopener">解决方案</a>，在     <code>package.json</code> 里加入 <code>&quot;chromium-args&quot;: &quot;--enable-logging=stderr&quot;</code>），我是纳闷为什么看不见开发者控制台的输出。结果发现了<a href="https://stackoverflow.com/a/35127692" target="_blank" rel="noopener">答案</a>，也就是该做的是手动右键检查背景页；<kbd>F12</kbd> 是审查应用的当前页，而 NW.js 的 app 是作为扩展载入的，所以两个页面不同。</p><p>考虑到项目完工时手动右键检查背景页未必可用，我想了一个变通的方法。<code>console</code> 看上去是个全局对象，实际上是 <code>window</code> 的属性。那么我将 <code>window</code> 的引用传过去不就好了？</p><p><code>bootstrap.ts</code>：</p><pre><code class="lang-typescript">import * as main from &quot;./main&quot;;main.setWindow(window);main.bindCloseKey();</code></pre><p><code>main.ts</code>：</p><pre><code class="lang-typescript">let $window: Window = null;export function setWindow(window: Window): void {    $window = window;}export function bindCloseKey(): void {    const button: HTMLButtonElement = document.querySelector(&quot;#close&quot;);    if (!button) {        $window.console.log(&quot;Button not found: &quot; + selector); // 1    } else {        $window.console.log(&quot;Button found&quot;); // 1        button.addEventListener(&quot;close&quot;, () =&gt; {            $window.close();        });    }}</code></pre><p>这次能看到输出了。但是显示的居然是“Button not found”！</p><p>我再次确认了，HTML 页面是能找到这个按钮的元素的。好吧，手动执行一下试试。分别在 app 页和背景页的开发者控制台执行 <code>document.querySelector(&quot;#close&quot;)</code>，前者返回的是 <code>null</code>，而后者返回了一个 <code>&lt;button&gt;</code>。</p><p>这下我就知道为什么了。两个页面之间有一堵无形的“墙”，一个负责前台（Chromium 端），一个负责逻辑（Node.js 端），有点类似 WebWorker。但和 WebWorker 不同的是，这个隔离的双方都能访问通用全局对象（<code>window</code> 等等），然而访问的却不是同一个对象。上面 <code>$window.console</code> 来自“能和页面交互的” <code>window</code>，<code>document</code>（实际上是 <code>window.document</code>）来自“不能和页面交互的” <code>window</code>。</p><p>后来再看，原来是 0.13 加入的上下文分离，在 NW.js 的<a href="http://docs.nwjs.io/en/latest/For%20Users/Advanced/JavaScript%20Contexts%20in%20NW.js/" target="_blank" rel="noopener">文档</a>里其实也写明白了。调试不同上下文的代码则需要分<a href="http://docs.nwjs.io/en/latest/For%20Users/Debugging%20with%20DevTools/#nodejs-modules-debugging" target="_blank" rel="noopener">不同的开发者工具</a>。用 <code>require()</code> 加载的模块都会运行在 Node.js 上下文中，路径解析和能访问的对象都是和浏览器上下文不同的。Node.js 上下文中确实有一个 <code>window</code> 对象，但指向的是<strong>背景页</strong>。如果需要在 Node.js 上下文中访问浏览器的对象，包括全局对象，必须要将这个对象传递过去（就像我上面做的那样）。当然如果偷懒可以用文档后面提到的上下文混合模式（mixed context mode），但它有潜在的上下文不同导致的问题（路径、原型链；见文档）。所以最保险的方法就是在设计的时候就注意，尽量将前后完全分离，消息交换只用上下文无关的对象（例如普通的 <code>{}</code>、<code>Object.create(null)</code> 创建的对象）。</p><p>那么既然上面说在上下文混合模式下会有问题，那么默认的上下文分离模式（separate context mode）下，传递对象会不会出错呢？答案是不会。NW.js 自动处理了对象封送，在传递的时候切换了上下文。我们可以做一个小实验。</p><p><code>bootstrap.ts</code>：</p><pre><code class="lang-typescript">import * as main from &quot;./main&quot;;console.log(&quot;From Chromium? &quot; + (window.close instanceof (window as any).Function));main.testWindow(window);</code></pre><p><code>main.ts</code>：</p><pre><code class="lang-typescript">export function testWindow(window: Window): void {    window.console.log(&quot;Context of Node? &quot; + (window.close instanceof Function));    window.console.log(&quot;Context of Chromium? &quot; + (window.close instanceof (window as any).Function));}</code></pre><p>运行，结果：</p><pre><code class="lang-plain">From Chromium? trueContext of Node? trueContext of Chromium? false</code></pre><p>由于 <code>main.ts</code> 是被用 <code>require()</code> 加载的，所以它运行在 Node.js 的上下文下，直接访问全局的 <code>Function</code> 访问到的是 Node.js 的 <code>Function</code>。而传入的 <code>window</code> 参数，原对象是在 Chromium 上下文中的。访问它带的 <code>Function</code>（不会被重新指派上下文）访问的到的是 Chromium 的 <code>Function</code>。由此可见，在对象传递过来的时候，也包括传递回去的时候，对象的上下文都会自动发生变化。</p><p>可能要问了，既然是上古版本更新引入的分离，为什么我以前没发现呢？因为以前为了做即时示例，要在没有 Node.js 的浏览器环境下运行，所以都用了 Browserify。这样在 NW.js 中实际上所有代码都是在 Chromium 的上下文里执行的，不会引发问题。而这次我并没有想把它完全部署为普通网页，就用了分文件、模块加载（毕竟 NW.js 也支持 <code>require()</code>），这下上下文分离的事实立马就暴露了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NW.js 有一个或两个上下文，使用时要多加小心。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="NW.js" scheme="https://blog.mottomo.moe/tags/NW-js/"/>
    
  </entry>
  
</feed>
