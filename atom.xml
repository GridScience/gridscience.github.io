<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花嫁達の部屋</title>
  
  
  <link href="https://blog.mottomo.moe/atom.xml" rel="self"/>
  
  <link href="https://blog.mottomo.moe/"/>
  <updated>2024-04-07T19:27:18.506Z</updated>
  <id>https://blog.mottomo.moe/</id>
  
  <author>
    <name>头蟹床(Headcrabbed)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MetaSound 实战：还原《马里奥惊奇》吞食花关卡的音频协同机制</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2024-03-18-MetaSound-Real-Application/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2024-03-18-MetaSound-Real-Application/</id>
    <published>2024-03-18T22:34:00.000Z</published>
    <updated>2024-04-07T19:27:18.506Z</updated>
    
    <content type="html"><![CDATA[<p>MetaSound 游戏音频实战，带程序化生成。做出成品已经到4月6日了。视频在这里：<a href="https://www.bilibili.com/video/BV1Pq421w7Eh/">https://www.bilibili.com/video/BV1Pq421w7Eh/</a>。这篇文章想以文字的方式记录一些要点。</p><span id="more"></span><p>起因就是群友传的图，关于《马里奥惊奇》（Super Mario Bros. Wonder）的：</p><p><img src="/images/misc/05AD18497027A86D4E0453B281201A4B.jpg" alt="赞美之词"></p><p>尤其是这一段：</p><blockquote><p>如果你看完上述细节之后，完全不觉得这些设计有什么厉害的……那么你可能是真的不了解游戏音乐吧。好做就都做了。</p><p>哪怕你是给奥本海默写了令我五体投地的原声带，也不能把游戏音乐想得太简单呢。</p></blockquote><p>我看到后就想，这些想法作为用户来说可以理解，但是在开发人员的角度提到的功能是很容易做的。完全没有必要发表这样的评论；这令人笑掉大牙。游戏创意不错是真的（虽然也不是新鲜的想法），游戏音乐不简单也是真的，但图中列举的这些功能并不难做。为了打脸，我就以一个非技术音频的身份来尝试还原这些机制，以此来证明确实不难。在此之前我并没有音频中间件的使用经验，手头也没有主流音频中间件，也不想为了这么一个小打小闹去购买一个授权再学习。所以我就想到了 MetaSound，正好符合我的需求。</p><p>MetaSound 是什么？<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/metasounds-in-unreal-engine">文档在这里</a>。简单来说，它是 Unreal Engine 5 新引入的一个模块，可以实现动态音频生成和控制（包括混合）的功能。在2021年的时候杨彦君就跟我提到过它。不过当时没时间，也没有需求去探索这一块内容。刚好，这次的打脸行动就给我创造了机会。</p><p>虽说不难做，但是要是实现这些功能，需要一定的知识储备。具体包括：</p><ol><li>音乐理论；</li><li>数字音乐中的数学；</li><li>主流游戏引擎的使用；</li><li>游戏编程；</li><li>动画制作。</li></ol><p>其中我暂时还不会做出符合我要求的动画，所以上面的最后一条，关于动画的那一条，就不做了。如果会的话，动画放进去直接循环播放就行。那么我们开始吧。</p><h1 id="一、音轨混合相关的功能"><a href="#一、音轨混合相关的功能" class="headerlink" title="一、音轨混合相关的功能"></a>一、音轨混合相关的功能</h1><p>混合器是 MetaSound 的一部分，也就是说中间件常用的多轨混合可以很方便地实现。因此我们要准备每个音轨的内容，所以要先根据需求写好一个多声部的乐谱，并导出音频文件作为素材。例如，这里的需求是：</p><ul><li>吞食花要有多个声部；</li><li>吞食花声部之间要有明确功能区分；</li><li>要有铃鼓声部；</li><li>要有哼唱声部；</li><li>其他的声部和正常乐曲需求差不多。</li></ul><p>准备好之后导出音频，就可以独立控制每个音轨的音量了。如果你想，还可以加效果器。这就足够完成声部相关的几个功能，只需要结合具体游戏逻辑即可。</p><h1 id="二、和弦相关的功能"><a href="#二、和弦相关的功能" class="headerlink" title="二、和弦相关的功能"></a>二、和弦相关的功能</h1><p>为了在恰当的时机演奏恰当的单个音符或者和弦，需要有能被订阅的事件。我在视频里是用了一个简单的相交查询来做的，还有就是订阅了角色落地事件，这里就略过了。另外，如果我们知道了此时的和弦，事件触发时，在什么时候演奏什么音，也是需要计算的。详细代码也略过，这是业务逻辑的一部分。</p><p>和弦和时间数据就用自定义资产类型来储存，只要代码里能拿到就行。</p><p>演奏单音很简单，只需要传入频率，接上波形生成器，并用节点控制持续时间即可。</p><p>演奏和弦（和琶音）稍微麻烦一点，要编写自定义的 MetaSound 节点。我参考的是 <code>FMusicalScaleToNoteArrayNode</code>（位于 <code>MetasoundMidiScaleToArrayNode.cpp</code>），节点输入和弦类型，输出和弦的一组半音。拿到半音数组后具体是齐奏（和弦）还是分解（琶音），在音频图里实现即可。</p><h1 id="三、尾声"><a href="#三、尾声" class="headerlink" title="三、尾声"></a>三、尾声</h1><p>说是简单，不过具体代码写起来和调试起来还是很花时间的，毕竟我不是技术音频嘛。例如上面的时间同步，联调还挺麻烦的。而且还有不少的辅助代码……</p><p>Unity 那边的情况我在视频里也锐评了一下。</p><p>原型有了，但是打磨其实也要花功夫。优化是必需的，考虑到 Switch 的性能……嗯，是必需的。音色的调节需要音效师帮助。还有一些具体的播放策略：</p><ul><li>给定和弦，应该播放什么样的序列？（我只是选择了和弦特征音分解）</li><li>演奏的时机如何？如果玩家在某个特定时间点做出动作，是立即播、延迟播，还是不播？（我是立即+限流的方式，听起来有瑕疵）</li><li>“前”“后”台音频（或者看作是音效和音乐）播放时是否需要其他音频控制，例如额外效果器？（我没做）</li></ul><p>只有方方面面都配合好了，才能带给玩家出色的游戏体验。这些才是困难的部分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MetaSound 游戏音频实战，带程序化生成。做出成品已经到4月6日了。视频在这里：&lt;a href=&quot;https://www.bilibili.com/video/BV1Pq421w7Eh/&quot;&gt;https://www.bilibili.com/video/BV1Pq421w7Eh/&lt;/a&gt;。这篇文章想以文字的方式记录一些要点。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="UE" scheme="https://blog.mottomo.moe/tags/UE/"/>
    
    <category term="MetaSound" scheme="https://blog.mottomo.moe/tags/MetaSound/"/>
    
  </entry>
  
  <entry>
    <title>简单记录一下 GitHub SSH 主机密钥失效的问题解决</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2023-04-09-GitHub-SSH-Key-Error/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2023-04-09-GitHub-SSH-Key-Error/</id>
    <published>2023-04-09T10:37:00.000Z</published>
    <updated>2023-04-10T02:22:30.980Z</updated>
    
    <content type="html"><![CDATA[<p>3月23日的的时候 <a href="https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/">GitHub 错误地更新了主机的 SSH 密钥</a>。这导致基于 SSH 的 Git 操作直到本地更新密钥之前都会失效。</p><p>由于我的博客是通过 Hexo-Git 部署的，所以这次一提交，也掉坑里了。</p><p>直接 <code>hexo d</code>，首先显示的是如下的错误消息（截取开头）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br></code></pre></td></tr></table></figure><p>接着阅读可以发现是检测到密钥不匹配，而且开启了强制密钥验证，为了防止中间人攻击，所以就报错了。因为我以前通过 SSH 方式进行过 Git 提交，所以本地的密钥数据库（<code>.ssh/known_hosts</code>）存在主机记录。所以先按那篇文章所说的，删除旧的密钥：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keygen -R github.com<br></code></pre></td></tr></table></figure><p>执行完成后我再尝试推送，但遇到了另一个问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Error: Host key verification failed.<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre></td></tr></table></figure><p>因为此时我还没有手工通过 SSH 方式提交，所以数据库不存在记录。为了解决这个问题，我在 GitHub 上加回了本机的私钥（忘了是什么原因没掉了，之前是2017年设置的，呜呜）。但是这个问题仍然存在。有没有能不通过 SSH 进行一次 Git 拉取/提交而刷新 SSH 密钥的方法呢？（明显，直接 SSH Shell 上 GitHub 是不可能的。）</p><p>我对 SSH 工具不熟，所以还是找了一下。根据<a href="https://www.reviewplan.com/github-host-key-verification-failed/">这篇文章</a>的指示，运行一下 <code>ssh-keyscan</code> 就行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keyscan github.com<br></code></pre></td></tr></table></figure><p>然后将输出的内容加入到 <code>known_hosts</code> 里面。之后就正常了。</p><p>此外，还可以通过 <code>-F</code> 查询主机是否已知，或用 <code>-l</code> 列出所有已知主机：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keygen -F github.com<br>ssh-keygen -l<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3月23日的的时候 &lt;a href=&quot;https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/&quot;&gt;GitHub 错误地更新了主机的 SSH 密钥&lt;/a&gt;。这导致基于 SSH 的 Git 操作直到本地更新密</summary>
      
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Unity Input System 的控制方案（control scheme）应该怎么用？</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2023-04-09-Unity-Input-System-Control-Scheme/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2023-04-09-Unity-Input-System-Control-Scheme/</id>
    <published>2023-04-09T06:26:00.000Z</published>
    <updated>2023-04-10T02:16:18.549Z</updated>
    
    <content type="html"><![CDATA[<p>从 Unity 2019.1 开始，Unity 提供了一个新的模块 <a href="https://docs.unity3d.com/Manual/com.unity.inputsystem.html">Input System</a>。它提供了方便的控制器切换、多控制方式可配置性、可扩展的控制器支持（例如映射虚拟控制器）等等。比起以前的 <a href="https://docs.unity3d.com/Manual/class-InputManager.html">Input Manager</a> 来说结构化了不少，不用每个游戏都自己再写一套映射系统了。关于它的基础使用我就不说了，网上在它发布不久早就有了许多教程。这篇博文要记录的是绝大多数地方都没提到的，它的“控制方案”（control schemes）的使用方法和适合场景。</p><span id="more"></span><p>如果你使用的是 UGUI，项目中仅使用了 Input System（<code>Player</code> - <code>Configuration</code> - <code>Active Input Handling</code> 选择了 <code>Input System</code>），需要将其默认的 Input Manager 后端换为 Input System 后端。<a href="https://docs.unity3d.com/Manual/UIE-Runtime-Event-System.html">这里</a>有操作指南。简单来说，直接找到场景中的 <code>EventSystem</code> 对象（通常是这个名字），将上面的 <code>Input Module</code> 换为 Input System UI Input Module。默认情况下，直接点击那个迁移按钮就行。</p><p>大多数情况下，你是不需要关心控制方案的，直接针对平台绑定输入源（按键、轴向输入）就行了。我一开始就是这么做的。这里以我做的玩意儿简化后的情况为例：</p><p><img src="/images/misc/20230409-input-system-01.jpg" alt="初始配置"></p><p>这张图值得注意的是，每个平台都分配了惯例的确认和取消按键（PlayStation 上用的是亚洲方案），即使它们的方位不一样。另外，所有控制都共享一个控制方案，没有独立的控制方案，这样的 input actions 资产应用后是这个样子：</p><p><img src="/images/misc/20230409-input-system-02.jpg" alt="Player Input 设置生成的资产"></p><p>这个文件粗看上去没什么问题。本地测试中，我测试了键盘和 XBox 手柄，两种控制器可以同时响应，手柄也是即插即用，不需要专门做控制切换的设置页面。（这是一个单人游戏，所以不用考虑本地多人之类的事情。）</p><p>然而，彩喵拿到 Switch 上测试之后反馈说，<kbd>A</kbd><kbd>B</kbd><kbd>X</kbd><kbd>Y</kbd> 根本没有响应。嗯？那 Unity 整一个专门的 Switch Pro Controller 控制器子类干什么呢？我不是针对这个 controller 分配了键 <kbd>A</kbd><kbd>B</kbd> 吗？你怎么就设置设置得上，运行运行不起来呢？</p><p>答：你不能直接使用 <kbd>A</kbd><kbd>B</kbd><kbd>X</kbd><kbd>Y</kbd> 绑定，而是需要用 <code>GamePad.buttonEast</code>、<code>GamePad.buttonSouth</code>、<code>GamePad.buttonNorth</code>、<code>GamePad.buttonWest</code> 来访问。也就是说整个 controller 必须退化成一个 generic D-pad controller，不能使用 Switch Pro Controller 子类。但是，如果你直接这么把原先分配给 Switch 的 <kbd>A</kbd> 和 <kbd>B</kbd> 替换成 <code>buttonEast</code> 和 <code>buttonSouth</code>，就会发现一个问题：虽然我们的目标是仅在 Switch 上使用它，但它在 PC 上也抢了 XBox 手柄的键位，导致 XBox 手柄的 <kbd>A</kbd> 和 <kbd>B</kbd> 变成了未定义行为。</p><p>到此直接分设备设置按键的尝试就失败了。怎么解决呢？我想到了分多钟控制方案。所以，第二版的是这样的：</p><p>首先在左上角添加四种控制方案：<code>Keyboard</code>、<code>XBox</code>、<code>PlayStation</code> 和 <code>Switch</code>。添加时记得把对应的设备需求选上。这里以 <code>XBox</code> 为例：</p><p><img src="/images/misc/20230409-input-system-03.jpg" alt="XBox Control Scheme"></p><p>然后，在主编辑界面将每个按键分配给对应的设备。这里还是以 XBox 为例：</p><p><img src="/images/misc/20230409-input-system-04.jpg" alt="每个按键分配到专门设备"></p><p>设置到 Player Input 上之后：</p><p><img src="/images/misc/20230409-input-system-05.jpg" alt="Player Input 设置生成的资产"></p><p>可以注意到在 <code>Actions</code> 下多了两项：<code>Default Scheme</code> 和 <code>Auto-Switch</code>。这两项的意义可以阅读工具提示来理解。前者控制的是默认的控制方案，如果未指定（<code>&lt;Any&gt;</code>）则会寻找第一个匹配到的；后者决定如果某个方案因为设备不满足而失效（例如，手柄断线），是否会尝试寻找并应用另一个可以匹配的。一般情况下，如果是全局只存在一个 Player Input，那选择 <code>&lt;Any&gt;</code> 和 auto-switch 是完全足够的。关于匹配过程可以参考 Input System 的<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/Devices.html#matching">文档</a>，一句话概括就是匹配成功项最多者胜出。</p><p>看起来好了，那运行起来吧。等等，为什么手柄没反应，只支持键盘了？刚才不是好好的吗？我不是设置了 XBox 手柄的控制方案吗？为什么它没有同时启用呢？于是我开始找诸如“Unity input system control scheme”之类的网页，可惜基本没有解释。就算是 <a href="https://unity.com/features/input-system">Unity 自己的页面</a>，里面的演示视频也只是简单添加了两种 control scheme 然后就正常运行了，看起来能动态切换，和我实测的并不一样。</p><p>直到我找到 Unity 官方论坛上一个讨论多个控制方案的帖子。其中一个开发者的<a href="https://forum.unity.com/threads/multiple-control-schemes-or-actions.727583/#post-4855205">回帖</a>解答了我的疑问。（我之前也找过 Input System 相关的帖子，也见过这位老哥，他应该就是 Input System 的主要开发者之一。）以下是帖子节选，我加粗了重要部分：</p><blockquote><p>… Control schemes are only really relevant if you want to separate multiple different means of controlling your game/app from each other such that they are <strong>mutually exclusive</strong> and such that you can know which one is active at any one time (e.g. to display control hints).</p><p>So in effect, the intention for having two control schemes, one for keyboard and one for gamepad, would be that keyboard input is <strong>not meant to be used concurrently</strong> with gamepad input. While the keyboard bindings are active, the gamepad bindings will not be. If both are in the same control scheme, however, they will concurrently be active side by side. …</p></blockquote><p>本质上，不同控制方案之间是互斥的，同时只能采用一种。如果你玩过一些老的主机移植游戏，就很好理解：那些游戏不支持同时使用键鼠和手柄，而且也未必支持动态插拔，如果你想换控制器就需要进入游戏里专门的设置页面去切换。</p><p>到此问题也就有了个答案。如果希望同时支持键盘和手柄，而且不想做专门的手动切换，那么就应该是按照游玩设备分类，而非控制器分类。将 <code>Keyboard</code> 方案重命名为 <code>PC</code> 方案，然后添加可选设备：</p><p><img src="/images/misc/20230409-input-system-06.jpg" alt="PC 控制方案的控制器设备设置"></p><p>接着，将 PC 上可用的手柄输入也选上。这里以 XBox 为例：</p><p><img src="/images/misc/20230409-input-system-07.jpg" alt="手柄输入也适用于 PC"></p><p>图中 XBox 手柄的 <kbd>A</kbd> 不仅在 XBox 上有效，也在 PC 上有效。而在 PC 上，键盘也是有效的。（PlayStation 控制器同理。）所以，在 PC 上，你就可以同时接收到键盘和手柄输入了。</p><p>然而设置完毕后还有一个问题。可以见到对于“确认”行为，我们为手柄指定了三种按键：</p><ul><li>需要 XBox 控制器（PC 上或 XBox 上）<ul><li><kbd>A</kbd>（<code>&lt;XInputController&gt;/buttonSouth</code>）</li></ul></li><li>需要 PlayStation 控制器（PC 上或 PlayStation 上）<ul><li><kbd>○</kbd>（<code>&lt;DualShockGamePad&gt;/buttonEast</code>）</li></ul></li><li>需要 Switch Pro 控制器（Switch 上）<ul><li><code>buttonEast</code>（<code>&lt;GamePad&gt;/buttonEast</code>）</li></ul></li></ul><p>如果我没设置控制器需求的话，由于 <code>XInputController</code> 是 <code>GamePad</code> 的子控制器类型，所以通用 <code>GamePad</code> 的设置也会被响应，就出现了前文的未定义行为问题。但是理论上，既然我设置了控制器需求，而且我没有接入 Switch Pro 控制器，那最后一条应该不能响应才对。但是在实测中，虽然 input system 自动选择了 PC 方案，但 Switch 方案仍然会被响应。我认为这是 input system 的一个 bug。</p><p>这个bug要完美解决的话比较麻烦。不过在我的目标工程里不需要搞手动选择也不需要考虑多人，所以可以通过以下方法绕过去：<strong>保持 <code>Default Scheme</code> 为 <code>&lt;Any&gt;</code>，但是把 <code>Auto-Switch</code> 关了。</strong>该方法在 PC 和 Switch 上测试通过。（所以为什么 Switch 上又能识别 Switch Pro 控制器需求——HID，但直接配置特化不行呢？神秘。）</p><hr><p>Input System 是带有调试工具的，可以方便地看到当前连接的设备、采用的方案、按键映射等等，还有一些其他功能（给虚拟设备和远程设备用的），直接单击任意 Player Input 右下角的按钮即可。比如，正确设置后，运行时可以看到如下的界面：</p><p><img src="/images/misc/20230409-input-system-dbg-01.jpg" alt="实时观察 Input System 状态"></p><p>从图中可以看到：</p><ul><li>连接了3个设备（展开后可以看到是键盘、鼠标和 XBox 手柄）。</li><li>识别了一个玩家（默认的使用例）。<ul><li>玩家所占用的设备是键盘和 XBox 手柄。<ul><li>因此选用了 PC 控制方案。</li></ul></li><li>在 <code>.inputactions</code> 资产中定义的行为，实际被映射到了哪些控制器的哪些键/轴。<ul><li>如果出现了上文的“未定义行为”，可以看到 <code>Confirm</code> 和 <code>Cancel</code> 两个行为都同时绑定了 <code>buttonSouth</code> 和 <code>buttonEast</code>，因此按下后实际触发哪个是不确定的。</li></ul></li></ul></li></ul><hr><p>04-10: 配置的 control scheme 还是不能生效，跟 <code>Auto-Switch</code> 没关系。最后还是改加了一个手工过滤器，如下（健壮性不强，不过暂时够用）：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.InputSystem;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InputActionExtensions</span><br>    &#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MatchesExpected</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> InputAction action</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// if (!PlayerInput.isSinglePlayer)</span><br>            <span class="hljs-comment">// &#123;</span><br>            <span class="hljs-comment">//     Debug.LogWarning(&quot;Multiple players detected. Please fix PlayerInput setup.&quot;);</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;</span><br>            <span class="hljs-keyword">var</span> player0 = PlayerInput.GetPlayerByIndex(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (player0 == <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">var</span> activeControl = action.activeControl;<br>            <span class="hljs-keyword">var</span> bindings = action.bindings;<br>            <span class="hljs-keyword">var</span> schemeName = player0.currentControlScheme;<br><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> binding <span class="hljs-keyword">in</span> bindings)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (binding.groups.IndexOf(<span class="hljs-string">&#x27;;&#x27;</span>) &gt;= <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">var</span> groups = binding.groups.Split(GroupSeparator, StringSplitOptions.RemoveEmptyEntries);<br>                    <span class="hljs-keyword">var</span> found = <span class="hljs-literal">false</span>;<br><br>                    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">in</span> groups)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">group</span> == schemeName)<br>                        &#123;<br>                            found = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (!found)<br>                    &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (binding.groups != schemeName)<br>                    &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">var</span> bindingPath = binding.effectivePath;<br><br>                <span class="hljs-keyword">if</span> (InputControlPath.Matches(bindingPath, activeControl))<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">char</span>[] GroupSeparator = &#123; <span class="hljs-string">&#x27;;&#x27;</span> &#125;;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnAction1</span>(<span class="hljs-params">InputAction.CallbackContext context</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (context.performed &amp;&amp; context.MatchesExpected())<br>    &#123;<br>        <span class="hljs-comment">// Logic here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Unity 2019.1 开始，Unity 提供了一个新的模块 &lt;a href=&quot;https://docs.unity3d.com/Manual/com.unity.inputsystem.html&quot;&gt;Input System&lt;/a&gt;。它提供了方便的控制器切换、多控制方式可配置性、可扩展的控制器支持（例如映射虚拟控制器）等等。比起以前的 &lt;a href=&quot;https://docs.unity3d.com/Manual/class-InputManager.html&quot;&gt;Input Manager&lt;/a&gt; 来说结构化了不少，不用每个游戏都自己再写一套映射系统了。关于它的基础使用我就不说了，网上在它发布不久早就有了许多教程。这篇博文要记录的是绝大多数地方都没提到的，它的“控制方案”（control schemes）的使用方法和适合场景。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="CSharp" scheme="https://blog.mottomo.moe/tags/CSharp/"/>
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Unity3D" scheme="https://blog.mottomo.moe/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>关于联想Y540键盘停止工作的事</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2022-04-20-Lenovo-Y540-Keyboard-Stopped-Working/</id>
    <published>2022-04-19T23:23:00.000Z</published>
    <updated>2023-04-09T06:24:30.413Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上我的笔记本，联想Y540（9750H/16G/1650，在欧洲买的）的键盘突然罢工了。我本来想重启进 BIOS 开 VT 的，然而进入 BIOS 后键盘完全无法操作，只能电源键强杀。</p><p>再次开机，发现登录界面也无法用键盘控制（包括输入）了。没办法，先用屏幕键盘凑合一下。进去后打开设备管理器，发现键盘消失了，即插即用设备倒是多了一个无法读取设备描述符的设备（<a href="https://support.microsoft.com/kb/310123">错误代码 <code>2B</code></a>）。禁用、卸载、重启数次依然如此。</p><p>由于我还有一个台式机，用的是 USB 键盘，所以先拿它来救急。我发现，在进入 BIOS 后，外置键盘是可以用的，笔记本自己的键盘倒是不行（<kbd>CapsLk</kbd>、<kbd>NumLk</kbd> 也不亮）。那么是不是固件问题呢？手动从 <code>BHCN42WW</code> 更新到 <code>BHCN44WW</code>，键盘依然无法使用。</p><p>这时候我发现了一个有趣但无法解决问题的事实。Y540 的键盘是有背光的，使用 <kbd>Fn</kbd>+空格调整亮度。现在，无论是在 Windows 下还是在 BIOS 中，这个功能都是可用的。另外，我能进入 BIOS，说明至少 F2 也是在那之前好好工作了的，要不根本没法进。也就是说，键盘的硬件（电路板、键帽、排线等等）应该是没问题的，大概率是软件出了意义不明的问题。</p><p>然后在联想自己的用户论坛上找到了<a href="https://forums.lenovo.com/topic/findpost/2250/5018199/5062483">这么一个帖子</a>，让人把电池耗尽再开机。我试了试，断开电源，低电量时 Windows 自动休眠了。接回电源，再开机，键盘仍然没有恢复。我觉得这个方法行不通。但是在我第二天早上重启之后，<kbd>NumLk</kbd> 亮起来了。再一试，登录界面有响应了。也就是说，在接入电源后，你得再重启一次，让某个固件刷某个东西才行。</p><p>后来搜索发现，联想笔记本的键盘问题发生频率不低，断电法这种让人费解的办法甚至是一些网站推荐的在换修前的<a href="https://upgrades-and-options.com/2020/02/why-is-my-lenovo-laptop-keyboard-not.html#:~:text=Remove%20the%20battery%20and%20press%20the%20power%20button,keyboard%2C%20it%20might%20be%20time%20for%20a%20replacement.">最终手段</a>。也有因为联想自己固件更新导致硬件错误（而且无法回滚）的<a href="https://forums.lenovo.com/topic/findpost/2250/5018876/5350510">愤怒老哥</a>，还有其他愤怒老哥（<a href="https://forums.lenovo.com/topic/findpost/2250/5100863/5439426">1</a>、<a href="https://forums.lenovo.com/topic/findpost/2250/5107856/5484097">2</a>）。究竟如何，还是大家评判吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上我的笔记本，联想Y540（9750H/16G/1650，在欧洲买的）的键盘突然罢工了。我本来想重启进 BIOS 开 VT 的，然而进入 BIOS 后键盘完全无法操作，只能电源键强杀。&lt;/p&gt;
&lt;p&gt;再次开机，发现登录界面也无法用键盘控制（包括输入）了。没办法，先用屏</summary>
      
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C# Tuple Element Names and Method Signatures</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/en/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/</id>
    <published>2020-07-26T05:42:00.000Z</published>
    <updated>2020-07-26T15:25:39.292Z</updated>
    
    <content type="html"><![CDATA[<p>Methods in C# have special checks if tuples appear in their signatures. Sometimes you can see confusing compile errors due to these checks, for example, in interface implementation. Unfortunately there is no such a “formal document” that defines these behaviors. So I note them down here, which may serve as a side note until the specification follows up (or not :D).</p><span id="more"></span><hr><p>I found this problem when writing a piece of code. An example is demonstrated below:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> SomeEnumerable();<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> e)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, x.First, x.Second);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SomeEnumerable</span> : <span class="hljs-title">IEnumerable</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">First</span>, <span class="hljs-title">int</span> <span class="hljs-title">Second</span>)&gt;<br>&#123;<br><br>    <span class="hljs-keyword">public</span> IEnumerator&lt;(<span class="hljs-built_in">int</span> First, <span class="hljs-built_in">int</span> Second)&gt; GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>The code compiles. That’s expected. But then I began to think, that the tuple (<code>(int First, int Second)</code>) is such a burden, because it spreads everywhere. Several classes have the similar definitions and usages, and those tuples all have the same semantics. According to the C# syntax, tuples equivalence are compared structurally. Element names are just <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/august/essential-net-csharp-7-0-tuples-explained">a syntax sugar backed by attributes</a>. So, it should be okay to erase the names in the generics of interface, but keep them in the returned value to provide their semantics to the invoker. In other words, the code should be like this:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//                                 ↓ notice the tuple here</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">SomeEnumerable</span> : <span class="hljs-title">IEnumerable</span>&lt;(<span class="hljs-title">int</span>, <span class="hljs-title">int</span>)&gt;<br>&#123;<br><br>    <span class="hljs-comment">//                 ↓ and here</span><br>    <span class="hljs-keyword">public</span> IEnumerator&lt;(<span class="hljs-built_in">int</span> First, <span class="hljs-built_in">int</span> Second)&gt; GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Guess what? I got a compile error. But what if I use the returned tuple without explicitly mentioning their element names?</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//           ↓ directly deconstruct the tuple</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> (f0, f1) <span class="hljs-keyword">in</span> e)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, f0, f1);<br>&#125;<br></code></pre></td></tr></table></figure><p>When <code>SomeEnumerable</code> is unchanged, the code above can be compiled without any error.</p><p>Strange, isn’t it? It seems sometimes the tuples are structually equivalent, and sometimes they are not. Does it mean I have to keep all the frustrating <code>(int First, int Second)</code> pieces? Is it a negligence in language design, or some other problem?</p><p>Therefore I searched the specification and other documents. Unfortunately, by now the specification is only updated to <a href="https://github.com/dotnet/docs/issues/8251">language version 5.0</a>. Microsoft Docs only has the full reference until <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/introduction">the draft of version 6.0</a> (and it is not even a specification). Tuples were introduced in C# 7.0 and there is only <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples">an incremental language reference</a> (only mentioned the lowest language version but not in an explicit branch). Well, C# 9.0 will be out soon. Unfortunately, there is no documentation of the compiler behaviors I presented above.</p><p>Then, according to the error code (<code>CS8141</code>) I was able to find <a href="https://github.com/dotnet/orleans/issues/3421">dotnet/orleans#3421</a>. <a href="https://github.com/dotnet/orleans/issues/3421#issuecomment-390006944">One of its discussion</a> mentioned <a href="https://github.com/dotnet/roslyn/pull/20838">dotnet/roslyn#20838</a>, a pull request (PR) that relaxed the matching rules for tuple element names.</p><p>In C# 6.0, the types <code>System.ValueTuple&lt;...&gt;</code> are supported but the compilation will fail if the referened assembly is authored in C# 7.0 and custom tuple element names are used (<a href="https://github.com/dotnet/roslyn/issues/20528">dotnet/roslyn#20528</a>). dotnet/roslyn#20838 fixed that problem by allowing names mismatch under certain situations. That is to say, the code below (taken from dotnet/orleans#3421) could not compile before, but can compile after that PR was merged:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISomeGrain</span><br>&#123;<br>    Task&lt;(<span class="hljs-built_in">bool</span> someBool, <span class="hljs-built_in">string</span> someString)&gt; Func();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Impl</span> : <span class="hljs-title">ISomeGrain</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Task&lt;(<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">string</span>)&gt; Func()<br>    &#123;<br>        <span class="hljs-keyword">return</span> Task.FromResult((<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>However, this doesn’t solve my problem. My case is different from above and it can’t compile. According to dotnet/orleans#3421, this problem was fixed in .NET Core 2.1, but I still can’t compile on .NET Framework 4.7.2 and .NET Core 3.1 SDK. Is it a software regression?</p><p>I couldn’t find other PRs related to fixing tuple behaviors, so I read dotnet/roslyn#20838 carefully. The thing that interests me is the testing code added in this PR. Its snapshot (of the full file) in July 2020 is <a href="https://raw.githubusercontent.com/dotnet/roslyn/6ebca3944998fc585fde2a9a4beff2aa7cb82635/src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs">here</a>.</p><p>After reading the tests I think I understand why it is like that: it is an <a href="https://en.wikipedia.org/wiki/Error-tolerant_design">error-tolerant design</a>. All tuples (the ones that the syntax sugar use) are <code>System.ValueTuple&lt;...&gt;</code> types, and they can be assigned whenever implicit casts succeed. Moreover, you can use whatever name you like for the tuple elements (after C# 7.0). And those, may break code contracts and introduce subtle but deadly errors. Consider the code illustrated below:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">SomeInterface</span><br>&#123;<br>    (<span class="hljs-built_in">string</span> Name, <span class="hljs-built_in">string</span> Address) GetContactInfo();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> : <span class="hljs-title">SomeInterface</span><br>&#123;<br>    <span class="hljs-comment">// notice the element names of the tuple here</span><br>    <span class="hljs-comment">//   and the one defined in the interface</span><br>    <span class="hljs-keyword">public</span> (<span class="hljs-built_in">string</span> Address, <span class="hljs-built_in">string</span> Name) GetContactInfo()<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Calling <code>GetContactInfo()</code> via <code>SomeClass</code> or <code>SomeInterface</code> will give you confusing results. So the best solution is prohibiting the change in element names.</p><p>Let’s head back to the problem at starting point. Unfortunately, if I want to preserve the semantics in code, I have to keep <code>(int First, int Second)</code> everywhere. I can’t omit some of them and write <code>(int, int)</code> instead. So be it.</p><hr><p>In the unit tests of <code>CodeGenTupleTest.cs</code> there are several error codes. After reading the invesigation process above, you should have understood why they are designed like that. However, the error messages are still unclear and confusing. They would be better with hints, like what GCC or Clang does. So here I will explain them with some examples. For each error there may be more than one way to be triggerred, and the examples below are the most simple ones.</p><p><code>CS8139</code>: Checked when overriding a method whose signature contains tuples. Thrown when element names in base and child classes differ.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> (<span class="hljs-params"><span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) <span class="hljs-title">TupleAsReturn</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TupleAsParam</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span> A, <span class="hljs-built_in">int</span> B</span>) <span class="hljs-keyword">value</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">Base</span><br>&#123;<br>    <span class="hljs-comment">//                             ↓ CS8139: cannot change tuple element name when overriding method</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> A, <span class="hljs-built_in">int</span> B</span>) <span class="hljs-title">TupleAsReturn</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">//                   ↓ CS8139: cannot change tuple element name when overriding method</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TupleAsParam</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span> B</span>) <span class="hljs-keyword">value</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CS8140</code>: Checked when one of a interface <code>I</code>‘s generic parameter <code>T</code> is instantiated with a tuple. Thrown when the <code>I</code>‘s implementation implements multiple <code>I</code>s but <code>T</code>s are the same tuple with different element names.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGeneric</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>&#125;<br><br><span class="hljs-comment">//                                       ↓ CS0528：IGeneric&lt;(int A, int B)&gt; already exists in the implementation list</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> : <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;, <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;<br>&#123;<br>&#125;<br><br><span class="hljs-comment">//                                       ↓ CS8140：IGeneric&lt;(int A, int B)&gt; already exists in the implementation list, with different tuple element names</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> : <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;, <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">C</span>, <span class="hljs-title">int</span> <span class="hljs-title">D</span>)&gt;<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CS8141</code>: Checked when one of a interface <code>I</code>‘s generic parameters <code>T</code> is instantiated with a tuple. Thrown when <code>T</code>s have different element names.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGeneric</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">Get</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">T t</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> : <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;<br>&#123;<br>    <span class="hljs-comment">//                        ↓ CS8141: tuple element names must match with interface method</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> (<span class="hljs-params"><span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) <span class="hljs-title">Get</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">//                  ↓ CS8141: tuple element names must match with interface method</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) tuple)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> : <span class="hljs-title">Class1</span>, <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">C</span>, <span class="hljs-title">int</span> <span class="hljs-title">D</span>)&gt;<br>&#123;<br>    <span class="hljs-comment">//                             ↓ CS8141: tuple element names must match with interface method</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> C, <span class="hljs-built_in">int</span> D</span>) <span class="hljs-title">Get</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">//                   ↓ CS8141: tuple element names must match with interface method</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span> C, <span class="hljs-built_in">int</span> D</span>) tuple)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CS8142</code>: Checked when defining a partial method whose signature contains tuples. Thrown when element names differ in declaration and definition.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Class</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span> A, <span class="hljs-built_in">int</span> B</span>) tuple)</span>;<br>&#125;<br><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Class</span><br>&#123;<br>    <span class="hljs-comment">//           ↓ CS8142: both parts of partial method must use the same tuple element names</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) tuple)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Methods in C# have special checks if tuples appear in their signatures. Sometimes you can see confusing compile errors due to these checks, for example, in interface implementation. Unfortunately there is no such a “formal document” that defines these behaviors. So I note them down here, which may serve as a side note until the specification follows up (or not :D).&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="English Version" scheme="https://blog.mottomo.moe/tags/English-Version/"/>
    
    <category term="CSharp" scheme="https://blog.mottomo.moe/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C# 元组元素名称和方法签名相关</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-07-26-CSharp-Tuple-Element-Names-and-Method-Signatures/</id>
    <published>2020-07-26T05:42:00.000Z</published>
    <updated>2020-07-26T15:04:02.574Z</updated>
    
    <content type="html"><![CDATA[<p>C# 中带元组的方法，在涉及继承、接口实现等等情况时遵循特殊的规则。可惜这部分并没有一篇文档记载，于是我就先记下来，以后如果这个规则正式成文了（或没成文），本文都可以起到参考作用。</p><span id="more"></span><hr><p>这是我在写一段代码时偶然发现的。示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> SomeEnumerable();<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> e)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, x.First, x.Second);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SomeEnumerable</span> : <span class="hljs-title">IEnumerable</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">First</span>, <span class="hljs-title">int</span> <span class="hljs-title">Second</span>)&gt;<br>&#123;<br><br>    <span class="hljs-keyword">public</span> IEnumerator&lt;(<span class="hljs-built_in">int</span> First, <span class="hljs-built_in">int</span> Second)&gt; GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上的代码编译通过，没有问题。然后我就想，这个元组（<code>(int First, int Second)</code>）写起来太麻烦了，几个类里都有相似的使用的地方，语义都是一样的。而且根据 C# 的语法，元组是可以判断结构等同的，字段的名字只不过是个<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/august/essential-net-csharp-7-0-tuples-explained">有特性支持的语法糖</a>而已。那么，我就想将实现的接口相关类型的字段名称抹除，只在返回值提示字段意义。也就是说，改成下面这个样子：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//                                 ↓ 注意这里的签名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">SomeEnumerable</span> : <span class="hljs-title">IEnumerable</span>&lt;(<span class="hljs-title">int</span>, <span class="hljs-title">int</span>)&gt;<br>&#123;<br><br>    <span class="hljs-comment">//                 ↓ 和这里不一样</span><br>    <span class="hljs-keyword">public</span> IEnumerator&lt;(<span class="hljs-built_in">int</span> First, <span class="hljs-built_in">int</span> Second)&gt; GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>你猜怎么着？编译失败了。但是如果我使用的时候不加名字呢？</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//           ↓ 直接解构</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> (f0, f1) <span class="hljs-keyword">in</span> e)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, f0, f1);<br>&#125;<br></code></pre></td></tr></table></figure><p>在保持 <code>SomeEnumerable</code> 为原状的情况下，上面这一段代码也可以正常编译。</p><p>怎么这么奇怪，有时候是结构等同的（只需要看字段顺序，不看字段名称），有时候不是结构等同的（字段顺序和名称都要看）？那岂不是我每个地方都得写上冗长的“<code>(int First, int Second)</code>”了吗？这是语言设计的缺漏还是其他什么问题？</p><p>于是我去找了这部分的规范和文档。可惜，<a href="https://github.com/dotnet/docs/issues/8251">标准目前只到 5.0</a>，Microsoft Docs 上只到 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/introduction">6.0 的草稿</a>。而元组是在 C# 7.0 引入的，相对正式的文档也只有一个<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples">参考</a>。另外，不久之后，C# 9.0 就要出来了。很遗憾，没有任何文档记录了我上面演示的编译器行为。</p><p>接着，我根据编译器输出的错误信息（<code>CS8141</code>），找到了 <a href="https://github.com/dotnet/orleans/issues/3421">dotnet/orleans#3421</a>。在其<a href="https://github.com/dotnet/orleans/issues/3421#issuecomment-390006944">回复</a>中提到了 Roslyn 的修复 PR <a href="https://github.com/dotnet/roslyn/pull/20838">dotnet/roslyn#20838</a>。这个 PR 的内容是放宽对元组名称匹配的限制，使得元组能在不支持元组字段命名、但是能使用元组类型本身的时候（例如 C# 6.0，见 <a href="https://github.com/dotnet/roslyn/issues/20528">dotnet/roslyn#20528</a>），允许元组字段名称的部分或者全部不匹配。</p><p>也就是说，以下这段代码（dotnet/orleans#3421 中的例子）在这个 PR 之前会报告编译错误，但是之后是通过的：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISomeGrain</span><br>&#123;<br>    Task&lt;(<span class="hljs-built_in">bool</span> someBool, <span class="hljs-built_in">string</span> someString)&gt; Func();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Impl</span> : <span class="hljs-title">ISomeGrain</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Task&lt;(<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">string</span>)&gt; Func()<br>    &#123;<br>        <span class="hljs-keyword">return</span> Task.FromResult((<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这仍然不能解决我的问题，因为我的代码不是这种情况，并不能编译通过。根据 dotnet/orleans#3421 的描述，在 .NET Core 2.1 SDK 及之后应该是得到修复的。可是我在 .NET Framework 4.7.2 和 .NET Core 3.1 SDK 上编译，仍然无法通过。难道它是一个回归错误（regression）？</p><p>我没有找到类似的解决元组相关的 PR，所以就去看上面那个 PR 的内容。比较感兴趣的是加入的测试代码。现时点的快照是<a href="https://raw.githubusercontent.com/dotnet/roslyn/6ebca3944998fc585fde2a9a4beff2aa7cb82635/src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs">这样的</a>。阅读了这些测试用例后才明白，原来这些编译错误就是防呆设计。理由也不难推测：元组的类型其实都是 <code>System.ValueTuple&lt;...&gt;</code>，而且可以任意修改元组字段名称；如果类型隐式转换通过的话，按照结构相等性，编译就会通过；但是修改字段名称就意味着修改代码约定，会引入难以排查的错误。考虑以下代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">SomeInterface</span><br>&#123;<br>    (<span class="hljs-built_in">string</span> Name, <span class="hljs-built_in">string</span> Address) GetContactInfo();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> : <span class="hljs-title">SomeInterface</span><br>&#123;<br>    <span class="hljs-comment">// 这里的返回值和接口规定的意义不一致</span><br>    <span class="hljs-keyword">public</span> (<span class="hljs-built_in">string</span> Address, <span class="hljs-built_in">string</span> Name) GetContactInfo()<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在通过 <code>SomeClass</code> 和 <code>SomeInterface</code> 分别调用 <code>GetContactInfo()</code> 的时候就会产生令人困惑的结果。因此最好的方式就是禁止元组字段名称发生变化。</p><p>回到出发点的问题。所以很不幸地，如果要在代码中保留语义的话，我必须在每个地方都写上“<code>(int First, int Second)</code>”，而没法在一部分地方简写成“<code>(int, int)</code>”。</p><hr><p>在 <code>CodeGenTupleTest.cs</code> 的单元测试中出现了若干元组相关错误码。在阅读了上面的探索过程后，你应该理解了为什么它们这么设计。但是错误信息还是有点让人搞不清在说什么（GCC：我比你强），所以在这里简单做个整理。对于每一种错误，可能有多种触发方式，这里只举出简单直接的例子。</p><p><code>CS8139</code>：在类继承时，被覆盖的方法签名中含有元组时检查。如果元组各字段名称在基类和子类中不同，则输出这个错误。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> (<span class="hljs-params"><span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) <span class="hljs-title">TupleAsReturn</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TupleAsParam</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span> A, <span class="hljs-built_in">int</span> B</span>) <span class="hljs-keyword">value</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">Base</span><br>&#123;<br>    <span class="hljs-comment">//                             ↓ CS8139：覆盖时不可以更改元组元素名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> A, <span class="hljs-built_in">int</span> B</span>) <span class="hljs-title">TupleAsReturn</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">//                   ↓ CS8139：覆盖时不可以更改元组元素名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TupleAsParam</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span> B</span>) <span class="hljs-keyword">value</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CS8140</code>：某个泛型接口的泛型的实例化类型为元组时检查。如果实现了相同的泛型接口，只有元组字段名称不同时，输出这个错误。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGeneric</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>&#125;<br><br><span class="hljs-comment">//                                       ↓ CS0528：IGeneric&lt;(int A, int B)&gt; 已经在实现列表中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> : <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;, <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;<br>&#123;<br>&#125;<br><br><span class="hljs-comment">//                                       ↓ CS8140：IGeneric&lt;(int A, int B)&gt; 已经在实现列表中，只不过元组元素名称不同</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> : <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;, <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">C</span>, <span class="hljs-title">int</span> <span class="hljs-title">D</span>)&gt;<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CS8141</code>：某个泛型接口的泛型的实例化类型为元组时检查。如果实现时元组字段名称不同则输出这个错误。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGeneric</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">Get</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">T t</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> : <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>)&gt;<br>&#123;<br>    <span class="hljs-comment">//                        ↓ CS8141：元组元素名称必须和接口方法匹配</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> (<span class="hljs-params"><span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) <span class="hljs-title">Get</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">//                  ↓ CS8141：元组元素名称必须和接口方法匹配</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) tuple)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> : <span class="hljs-title">Class1</span>, <span class="hljs-title">IGeneric</span>&lt;(<span class="hljs-title">int</span> <span class="hljs-title">C</span>, <span class="hljs-title">int</span> <span class="hljs-title">D</span>)&gt;<br>&#123;<br>    <span class="hljs-comment">//                             ↓ CS8141：元组元素名称必须和接口方法匹配</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> C, <span class="hljs-built_in">int</span> D</span>) <span class="hljs-title">Get</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">//                   ↓ CS8141：元组元素名称必须和接口方法匹配</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span> C, <span class="hljs-built_in">int</span> D</span>) tuple)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CS8142</code>：分部方法签名中含有元组时检查。如果定义和实现中的元组字段名称不同则输出这个错误。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Class</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span> A, <span class="hljs-built_in">int</span> B</span>) tuple)</span>;<br>&#125;<br><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Class</span><br>&#123;<br>    <span class="hljs-comment">//           ↓ CS8142：分部方法的各个部分必须使用相同的元组元素名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params">(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>) tuple)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C# 中带元组的方法，在涉及继承、接口实现等等情况时遵循特殊的规则。可惜这部分并没有一篇文档记载，于是我就先记下来，以后如果这个规则正式成文了（或没成文），本文都可以起到参考作用。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="CSharp" scheme="https://blog.mottomo.moe/tags/CSharp/"/>
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>麻辣土豆新动作的骨骼曲线表</title>
    <link href="https://blog.mottomo.moe/categories/Tech/RE/zh/2020-05-07-MLTD-Skeleton-Curve-Table/"/>
    <id>https://blog.mottomo.moe/categories/Tech/RE/zh/2020-05-07-MLTD-Skeleton-Curve-Table/</id>
    <published>2020-05-06T20:15:00.000Z</published>
    <updated>2020-08-01T15:10:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>这次讲讲我是怎么得到土豆新动作的骨骼曲线表的。</p><span id="more"></span><hr><p>我在土豆二周年之后就没玩土豆了。但是从2019年8月开始，陆续接到一些土豆文件变化的 issue。Unity 版本更新引起的问题这里不讨论。<del>一个大的变化是土豆的动作文件不再公布源文件，只有“运行时”的文件。</del>大多数动作还是有源文件的，仅有“运行时”文件的只有少数，估计是复杂舞蹈的技术限制（运行时生成内存爆炸？）或者是资源发布错误。总之两种情况都必须处理。</p><p>在老的资源列表中，这两个文件都会给出。比如，<code>dan_shtstr_01.unity3d</code>（<a href="https://www.project-imas.com/wiki/Shooting_Stars">Shooting Stars</a> 的动作）就会附带一个 <code>dan_shtstr_01.imo.unity3d</code>。在这个 <code>.imo.unity3d</code> 中就可以看到序列化了的源文件。将它转换成完整的帧序列还是很简单的。</p><p>但是新列表就不再带这些 <code>.imo.unity3d</code> 了。在 issue 中提到了 <a href="https://www.project-imas.com/wiki/Rebellion">Rebellion</a>（<code>dan_rebell_01.unity3d</code>）。于是我只能去看这个文件的内容是什么。原来它是几个 <code>AnimationClip</code>，而且从结构和命名上分析，应该就是源文件“编译”之后的。也就是说，之前那些 <code>.imo.unity3d</code> 可能是不小心放进去的（自动构建时忘记排除）。也有可能是选择性地下载，如果网络差就下载源文件并在第一次播放时本地“编译”，这样可以减少数据传输量；如果网络好则直接下载成品。不管是因为什么，现在只有成品了。</p><p>那么第一步就很明显了：读取需要的 <code>AnimationClip</code>。这倒不难。而且由于土豆一直用的是 <code>Generic</code> 而不是 <code>Humanoid</code>，所以动作数据保存的是整个时间轴上的完整骨骼变换。也就是说，每一帧的所有变换的值都在。</p><p>接下来就有点麻烦了。可以看到骨骼动画中有180条曲线（curve）；那些源文件的曲线数量也是180，所以很大概率是一一对应的。但是这些曲线只有一个简单的索引值，并不像源文件那样写明对应的是哪个关节。这个索引肯定是在制作骨骼动画的时候自动按照某种规则指定的，而且应该是各文件统一的。所以，我们应该能找到一个静态的映射方式（映射表），得知某个索引对应的是哪个关节的什么变换。</p><p>我们先来看一下原来的顺序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">(POSITION, AngleX)<br>(POSITION, AngleY)<br>(POSITION, AngleZ)<br>(MODEL_00, AngleX)<br>(MODEL_00, AngleY)<br>(MODEL_00, AngleZ)<br>(MODEL_00/BODY_SCALE/BASE, AngleX)<br>(MODEL_00/BODY_SCALE/BASE, AngleY)<br>(MODEL_00/BODY_SCALE/BASE, AngleZ)<br>...<br>(MODEL_00, PositionX)<br>(MODEL_00, PositionY)<br>(MODEL_00, PositionZ)<br>(MODEL_00/BODY_SCALE/BASE, PositionX)<br>(MODEL_00/BODY_SCALE/BASE, PositionY)<br>(MODEL_00/BODY_SCALE/BASE, PositionZ)<br></code></pre></td></tr></table></figure><p>先试试这个顺序吧。但是结果很不妙。为了避免精神污染，我就不放图了。</p><p>嗯……怎么找正确的顺序呢？又到了找弱点的时间了。我认为，在上文静态表的基础上，还应该有附加条件：</p><ol><li>这个表很可能不是随机的。如果是的话，美术方面的维护和调试会很麻烦。当然也不排除万代丧心病狂，写一个内部插件自动完成这件事——在国内还真的有可能，但是日本……不太可能。</li><li>项之间应该会呈现明显的逻辑相关性。<ol><li>同一个关节的某种分量会分组。比如，<code>MODEL_00</code> 的三个旋转分量会成一组，三个位移分量会成一组。</li><li>有固定的层次上的先后顺序。比如，考虑 <code>MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2</code> 和 <code>MODEL_00/BODY_SCALE/BASE/MUNE1/MUNE2/SAKOTSU_L</code>，前者是后者的父关节。如果前者在后者之前，那么所有的父节点应该在其子节点之前，反之则是之后。但是不确定对称关节的顺序，可能是左前右后，也可能是左后右前。根据老的数据推测，是左前右后。</li></ol></li><li>有可能遵循其他的简单先后逻辑或者它们的组合（可能性未知）：<ol><li>关节名称的字符串顺序；</li><li>所有旋转在位移之后或之前；</li><li>同一个关节的旋转组和位移组相邻，组成大组。</li></ol></li><li>考虑到骨骼层级，新顺序可能很大一部分的内部相对顺序都和原顺序中的一致。</li></ol><p>我试了几个写起来简单的顺序，但是都不对。这下我就有点头疼了，毕竟可是有180条曲线啊。</p><p>突然，在调试的时候，我发现动画帧的数据好像有着很明显的模式。一个帧存着这帧对应时间点的所有关节的变换数据，所以看这个帧里的数组的时候相当于在对各个变换进行横向的比较。于是我就想到了一种方法：能不能通过分析这种模式来找出新顺序呢？</p><p>说干就干。我写了两个小方法，将动画的帧输出到 CSV 文件中。用的分别是 <code>dan_hmt001_01.imo.unity3d</code>（<a href="https://www.project-imas.com/wiki/Blooming_Star">Blooming Star</a>）和 <code>dan_rebell_01.unity3d</code>。在 Excel 中打开：</p><p><img src="/images/misc/20200507-dan-hmt001.jpg" alt="老文件：hmt001"></p><p><img src="/images/misc/20200507-dan-hmt001.jpg" alt="新文件：rebell"></p><p>可以看到，列之间显示出了很强的分组倾向。然后我们再将这些列的模式写出来（这一切发生在我的脑中，这里写出来更容易理解）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">[rebell]<br><br>#1: (~-0.00x approx, 0 const, ~-0.07 approx)<br>#2: (0 const, 0 const, 0 const)<br>#3: (~-0.00x approx, 0 const, ~-0.07 approx)<br>#4: (0 const, ~+0.87 approx, 0 const)<br>#5: (0 const, 0 const, 0 const)<br>...<br>#60: (? var, ? var, ? var)<br><br>[hmt001]<br><br>MODEL_00#rotation: (0 const, 0 const, 0 const)<br>MODEL_00#translation: (~-0.005 const, 0 const, ~-0.03x approx)<br>BASE#rotation: (~+0.754 const, ~-78.6 const, ~-3.35 const)<br>BASE#translation: (0 const, ~+0.87 approx, 0 const)<br>...<br>SCALE_POINT#translation: (0 const, 0 const, 0 const)<br></code></pre></td></tr></table></figure><p>有些分量是常数，有些是变化较小的（因舞蹈不同可能会有不同值，变化范围和速度作为分析依据不是很有用），有些是自由变化的（无法用作分析依据）。源文件中指明了一些曲线是常数，而且它们是0（比如 <code>POSITION</code> 的旋转分量）；这些是确定不会变化的，可以作为映射表结构的“基准点”使用。</p><p>考虑“是否为常量0”这点和基准值、变化速度，观察可以发现，中间一大块（人体关节）是有着完全相同的模式的。人体关节只有旋转。因此先假设这些关节顺序都不变。需要重点关注的是这几个关节：<code>POSITION</code>、<code>SCALE_POINT</code>、<code>MODEL_00</code> 和 <code>BASE</code>，它们一共有7个组（4个位移3个旋转）。只要搞清楚了这7个组的顺序，应该就能得到正确的结果。</p><p>接近了。</p><p><code>rebell</code> 的最后分量都不是常量组，所以仅有的会出现常量的组（就是上面这几个）一定是排在最前面的。再考虑到组之间的逻辑关系，开头的应该是 <code>POSITION</code>（模型子空间）而不是 <code>MODEL_00</code>（实际的模型根关节），否者就会将 <code>MODEL_00</code> 的层次给破坏掉（因为必定造成 <code>POSITION</code> 或者其子关节 <code>SCALE_POINT</code> 和后面的身体关节相邻）。</p><p>那么第1组是 <code>POSITION</code> 的位移还是旋转呢？观察数据的模式（<code>(?, 0, ?)</code>），是位移。</p><p>第2组是什么呢？根据上面的大前提，有两种可能：<code>POSITION</code> 的旋转，或者是 <code>SCALE_POINT</code> 的位移。不知道，先放着。</p><p>这时候可以看到第4组的模式（<code>(0, ?, 0)</code>）——而这个模式，在7个组中只有一种可能：<code>BASE</code> 的位移。</p><p>于是我们现在可以得到这样的一个顺序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">#1: POSITION#translation<br>#2: ?<br>#3: ?<br>#4: MODEL_00/BASE#translation<br>#5: ?<br>#6: ?<br>#7: ?<br>#8: MODEL_00/BODY_SCALE/BASE/KOSHI#rotation（各个身体关节开始）<br>...<br></code></pre></td></tr></table></figure><p>到这里应该很明显了。想想上面的大前提。如果在第1组和第4组之间插入任何的旋转，就会破坏整个逻辑。因此只有一种可能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">#1: POSITION#translation<br>#2: POSITION/SCALE_POINT#translation<br>#3: MODEL_00#translation<br>#4: MODEL_00/BODY_SCALE/BASE#translation<br>#5: POSITION#rotation<br>#6: MODEL_00#rotation<br>#7: MODEL_00/BODY_SCALE/BASE#rotation<br></code></pre></td></tr></table></figure><p>将这个顺序代入，就可以发现我们得到了正确的结果：</p><p><img src="/images/misc/20200507-rebell-mmm-result.jpg" alt="Rebellion"></p><p>代码在<a href="https://github.com/OpenMLTD/MLTDTools/blob/3e21599d466ea929d8dabb44926b243096995aee/src/MillionDance/Entities/Internal/BodyAnimation.cs#L530-L709">这里</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次讲讲我是怎么得到土豆新动作的骨骼曲线表的。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="RE" scheme="https://blog.mottomo.moe/categories/Tech/RE/"/>
    
    
    <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="逆向工程" scheme="https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>博客提交记录已经丢失</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2020-03-31-Site-History-Lost/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2020-03-31-Site-History-Lost/</id>
    <published>2020-03-31T09:49:00.000Z</published>
    <updated>2020-03-31T15:59:31.147Z</updated>
    
    <content type="html"><![CDATA[<p>在换了机器之后因为分类问题第一次更新博客。在数据迁移的时候，因为一个月前已经将源文件用 Git 管理了，所以我就没有完全复制博客文件夹里的内容，而是直接 clone 下了源文件做 deploy。当看到显示出许多的 <code>create mode</code> 的时候我就有一种不好的预感，一看出现了个 forced update，就知道完了。上一次删除 <code>.deploy</code> 导致博客的 repo 被 forced update 还是在2014年末。所以整个博客的提交记录相当于又被清零了。这次就吸取了教训，给这个 repo 也加上了提交保护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在换了机器之后因为分类问题第一次更新博客。在数据迁移的时候，因为一个月前已经将源文件用 Git 管理了，所以我就没有完全复制博客文件夹里的内容，而是直接 clone 下了源文件做 deploy。当看到显示出许多的 &lt;code&gt;create mode&lt;/code&gt; 的时候我就</summary>
      
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>在 Foobar2000 中直接播放网易云音乐的缓存文件</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/</id>
    <published>2020-03-22T23:20:00.000Z</published>
    <updated>2020-03-31T15:37:07.100Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。</p><span id="more"></span><p>昨天晚上本来是计划做乐曲改编的。虽然源用的是网易云音乐，但是播放器我就不想用它，而是 Foobar2000。但是当我尝试下载的时候，却被提示仅允许付费/会员下载。</p><p>行吧，你是哪天买的版权（如果真买了的话，笑）我不知道；但是反正我没有很高的码率要求，默认播放的 128 Kbps 就行；而且如果这也不行，还有别的手段。这时候我就想到，虽然不可以下载，但是还是可以播放的啊。既然能播放，那么应该就缓存在本地了，除非产品设计抽风。</p><p>于是我就看了看缓存目录。结果发现了很多大小接近 128 Kbps MP3 的文件。（是不是有一种<a href="/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-2/">既视感</a>？）主体内容应该是音频没错，但是经过了某种形式的加密。不过这次不是 CTF 了，所以就直接 Google 吧。已经<a href="https://github.com/mbinary/netease-music-cracker">有人搞定了</a>。果然还是屈服于性能，只采用了简单的异或。哈。</p><p>那么现在的目标就是把这个逻辑封装为一个 Foobar2000 的组件，这样就可以直接在 Foobar2000 中播放了。虽然我<a href="https://github.com/hozuki/foo_input_hca">写过简单的组件</a>，不过这次不一样，用到的东西比 <code>input_stub</code> 要多一些。</p><p>这次稍微触及到了 Foobar2000 组件系统的核心之一，<code>service_base</code>。工程的目标是：实现一个文件流，对原文件流做一个读写封装。其实这次还算简单，是无状态的，简单异或每个字节就行了。但是麻烦在于 <code>service_base</code> 的设计。如果在 .NET 里面实现这个可是太简单了，继承并重写，重写中调用父类方法就行。<code>service_base</code> 是引用计数的，有点像 COM（接口查找和接口升级更像），但是（在 release 模式下）并没有虚表（V-table），成员查找完全依赖于模板。成员一般不使用原生指针，而是使用 <code>service_ptr_t&lt;T&gt;</code>。我本来就没做过 COM 开发，而且这玩意儿还是没有虚表的。</p><p>根据 SDK 附带的简单说明，继承自 <code>service_base</code> 的“类”实际上是接口（类似 <code>IUnknown</code>），不应该有任何字段和方法实现，实现细节相关应该在在对应的 <code>*_impl</code> 类中提供。等等，那我该怎么实例化我的 <code>service</code> 呢？我的指针模板应该填什么类型呢？怎么转换接口呢？</p><p>看一下相关的定义。如果你知道 COM 的话这个看起来绝对不陌生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NOVTABLE</span> service_base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">service_release</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">service_add_ref</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">service_query</span><span class="params">(service_ptr &amp; p_out,<span class="type">const</span> GUID &amp; p_guid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NOVTABLE</span> file : <span class="keyword">public</span> service_base, <span class="keyword">public</span> stream_reader, <span class="keyword">public</span> stream_writer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意的是那些 <code>NOVTABLE</code> 修饰，这是和 COM 最大的不同。在 VC++ 的 release 模式下，它会被扩展为 <code>__declspec(novtable)</code>。<del>这样尽管在逻辑上，<code>file</code> 继承自 <code>service_base</code>，但是在编译后它们并没有 V-table，因此不可以进行虚函数调用，<code>dynamic_cast</code> 也应该会失效。</del>关于 <code>__declspec(novtable)</code> 对虚表和 vptr（虚指针）的影响可以参考<a href="https://stackoverflow.com/a/1836063">这个回答</a>。简单说，就是修饰 <code>__declspec(novtable)</code> 没关系，RTTI 和虚函数照常工作（除了在构造/析构函数中）。所以，直观的结论是，要让代码正常工作的话，抽象类（也就是 Foobar2000 中的接口）可以修饰，但是抽象类的非抽象子类不可以；抽象类自身也不能在构造/析构函数中使用虚表或虚指针相关。</p><p><strong>怎么实例化呢？</strong>一种方法是使用工厂类（<code>service_factory_base</code>），不过过程就非常麻烦了。对于简单的接口，SDK 提供了一个非常方便的函数 <code>fb2k::service_new()</code>。只需要创建实现的实例，赋值给接口指针就行了。</p><p>在代码中，我定义了一个自定义文件流类型和它的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NOVTABLE</span> mapped_file : <span class="keyword">public</span> file</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这个 NOVTABLE，可以这么写是因为 mapped_file_impl_t 还是抽象的，实例化由 service_impl_t 负责，见下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NOVTABLE</span> <span class="type">mapped_file_impl_t</span> : <span class="keyword">public</span> mapped_file</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用上就可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">service_ptr_t</span>&lt;mapped_file&gt; ptr = fb2k::<span class="built_in">service_new</span>&lt;<span class="type">mapped_file_impl_t</span>&gt;(...);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">service_ptr_t</span>&lt;file&gt; ptr = fb2k::<span class="built_in">service_new</span>&lt;<span class="type">mapped_file_impl_t</span>&gt;(...);</span><br></pre></td></tr></table></figure><p>有趣的是，<code>service_new()</code> 内部使用了 <code>service_impl_t&lt;T&gt;</code>。这个类型继承自 <code>implement_service_query&lt;T&gt;</code>，而正是 <code>implement_service_query&lt;T&gt;</code> 提供了新的 <code>service_query()</code> 的默认实现。<code>service_impl_t&lt;T&gt;</code> 则进一步提供了 <code>service_add_ref()</code> 和 <code>service_release()</code> 的默认实现。所以在写自己的类型实现（比如 <code>mapped_file_impl_t</code>）时，是不需要提供这三个方法的。因此，此时这个“类型实现”对于编译器而言还是抽象类型，不可以直接使用 <code>new</code> 实例化——将所有实例的创建过程进行托管，可以有效地消除某些 bug——这是一个附加的好处。<code>service_impl_t&lt;T&gt;</code> 正好可以作为使用模板来创建 mixin 的一个例子。</p><p><strong>指针模板应该填什么类型呢？</strong>由于巧妙的向上查找方式（见下文），所以可以使用实现类型或者其任意的父类型。</p><p><strong>怎么转换接口呢？</strong>其实这个组件的功能并没有涉及到这个问题，但是在开始摸索的时候，我也是实现了整个 <code>mapped_file</code>，所以大略知道一点。每个继承自 <code>service_base</code> 的类都要提供一个静态成员 <code>GUID class_guid</code>（用于特征萃取），在 <code>service_query()</code>（1.4 以后是 <code>handle_service_query()</code>）中进行判断。查询整体就是一个沿着继承链往上找的过程。思想则是，一个子类声明它能被转换为哪些父类。而这个继承链，实际上是编译期的，利用模板而不是虚表。可以看 <code>handle_service_query()</code> 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">service_query_walk</span><span class="params">(service_ptr &amp;, <span class="type">const</span> GUID &amp;, service_base *)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">interface_t</span>&gt; <span class="type">static</span> <span class="type">bool</span> <span class="title">service_query_walk</span><span class="params">(service_ptr &amp; out, <span class="type">const</span> GUID &amp; guid, <span class="type">interface_t</span> * in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (guid == <span class="type">interface_t</span>::class_guid) &#123;</span><br><span class="line">        out = in; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> <span class="type">interface_t</span>::t_interface_parent * chain = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">service_query_walk</span>(out, guid, chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">class_t</span>&gt; <span class="type">static</span> <span class="type">bool</span> <span class="title">handle_service_query</span><span class="params">(service_ptr &amp; out, <span class="type">const</span> GUID &amp; guid, <span class="type">class_t</span> * in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="type">class_t</span>::t_interface * in2 = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">service_query_walk</span>( out, guid, in2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>t_interface</code> 和 <code>t_interface_parent</code> 在接口的 <code>FB2K_MAKE_SERVICE_INTERFACE</code> 中被自动定义。其实就是宏的那两个参数。这里实现了自动沿着继承链向上查找的语义，终止则利用是模板参数的退化（不是无参特化，但是我不确定该怎么称呼）用一个重载实现的。</p><p>看来 Peter 也是把 C++ 吃透了。这些 API 的设计非常巧妙。</p><p>最终的成果是个<a href="https://github.com/hozuki/foo_input_nemuc">小玩意儿</a>。使用 VS 2019 编译。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Foobar2000" scheme="https://blog.mottomo.moe/tags/Foobar2000/"/>
    
  </entry>
  
  <entry>
    <title>春天没有花儿</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/</id>
    <published>2019-12-20T11:03:00.000Z</published>
    <updated>2020-03-30T22:34:35.453Z</updated>
    
    <content type="html"><![CDATA[<p><em>欢迎到作品的 <a href="https://npckc.itch.io/spring-leaves-no-flowers">Itch.io 页面</a>去支持作者。另外这个系列目前由三个连续的故事组成：<a href="https://npckc.itch.io/one-night-hot-springs">one night, hot springs</a>、<a href="https://npckc.itch.io/last-day-of-spring">last day of spring</a> 和本作 <a href="https://npckc.itch.io/spring-leaves-no-flowers">spring leaves no flowers</a>。</em></p><p><strong>本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。</strong></p><p>我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。</p><span id="more"></span><hr><p>我玩过的游戏中，针对单人、强调情感体验的不多；而让我称奇，甚至是给予我某个方面启蒙的，则是屈指可数。<a href="https://store.steampowered.com/app/683320/GRIS/">GRIS</a> 和 <a href="https://store.steampowered.com/app/1122720/Sayonara_Wild_Hearts/">Sayonara Wild Hearts</a> 聚焦于短期心理状态，<a href="https://store.steampowered.com/app/206440/To_the_Moon/">To the Moon</a> 和本（系列）作品则偏向于展示某种长期的“异常”。（Sayonara Wild Hearts 我虽然很感兴趣但是没玩，因为光是看实况录播，它的美术风格就已经让我生物意义上地头疼了。）</p><p>故事的三个主角：</p><ul><li><ruby>立花<rp>(</rp><rt>タチバナ</rt><rp>)</rp></ruby>　<ruby>愛美<rp>(</rp><rt>マナミ</rt><rp>)</rp></ruby>（本故事主角）</li><li><ruby>永田<rp>(</rp><rt>ナガタ</rt><rp>)</rp></ruby>　エリカ（第二部主角）</li><li><ruby>鈴木<rp>(</rp><rt>スズキ</rt><rp>)</rp></ruby>　<ruby>悠人<rp>(</rp><rt>ハルト</rt><rp>)</rp></ruby>/ハル（第一部主角）</li></ul><p>マナミ和ハル是青梅竹马，和エリカ是高中同学。三人对“少数”的一致认同和宽容，才使得故事顺利展开。</p><p>游戏系统并不复杂，比 AVG 还要纯粹的 AVG。叙事并没有什么出人意料的地方。不过有意思的是，虽然很多选项被划了删除线而且是灰色的，是一般意义上的“不可用”状态，但是实际上那些才是让游戏进入正轨的选项。我想，这大概是作者 npckc 设计的隐藏表现方式，意思是说在角色心中这个选项就是默认不可选择的。这可能是个亮点吧。</p><p>剧情其实没那么复杂，不需要怎么解释。マナミ无法理解“亲吻”的特殊含义（在现代语境下），因此无法推断出另外两人关系的变化——更重要的是，无法真正理解自己的处境。给我冲击力的是角色所面临的问题。是的，我知道有的人是不擅长理解暗示，或者一些词汇的含义（常见于自闭症），但这些都是作用域更广泛的社会行为的，我并不知道更“私人”的感情受到这样影响是怎么样的。我曾经听说过“无性恋”，但我只是以为这代表“不喜欢任何人/对任何人都保持着中立的态度”。读到了这个故事之后我才知道，我错了。</p><p>タツヤ，您真是勇士。虽然在故事里，マナミ得到了所有人的接受（毕竟她们都有着各自的“异常”），但是现实生活中，恐怕活得要艰难太多了。</p><p>整个游戏令我震惊的就是新概念的引入。而且是实事求是的平铺直叙，不是被包装的拜金主义，因此才能给（就算不是这样的）人以共鸣。词条的解释是很可能客观公正的，但是它没有活生生的人。当你从一个人的视角，而不是从上帝视角，去看的时候，才会真正地萌生一种想法：“这个困难的根源在哪里？”进而再去思考需求和生产力的关系等等。</p><hr><p>后来我把前两作读了一遍。这一读不要紧，第三部的印象崩塌了大半。不，不是因为歧视，而是因为总体的人物和剧情设置。</p><p>这次来总结一下，在看完三部曲后，完整的人物描述。虽然像是贴标签，但是对不起了，政治正确的气息太浓厚了。</p><ul><li>マナミ：无性恋（asexual）、无浪漫（aromantic）</li><li>エリカ：双性恋（bisexual）、纯素食主义者（vegan）</li><li>ハル：跨性别者（transgender）、潜在的同性恋（推测）</li></ul><p>她们都希望正常地活着——不是“矫正”，而是和其他人一样相互尊重。</p><p>但是一些剧情就有点……匪夷所思，或者说，如果真的发生了，想想还是可以理解的，但是概率太小了。</p><p>（第一部）ハル告诉エリカ说自己喜欢マナミ，不过マナミ已经有男朋友了所以说不出口。ハル可是认知性别为女的。……是心理上的百合倾向？还是生理上的激素作用？不得而知。而且喜欢很久了。</p><p>（第二部）与ハル的对话中，选错一个就会导致故事提早结束（bad end）。和另外两部不同，这里ハル在闹别扭，总觉得自己不值得参加活动，所以一旦选择了坦诚的选项，ハル就要不不接电话不回消息，要不就说干脆所有的活动都取消算了。但是老妹，你之前不是都去过温泉了吗？从那次事件中就可以见到人家品行如何。你这么缩着，说着不要再麻烦人家了，不是更给人添麻烦吗？</p><p>这么看来，第二部的真的是死亡选项。其他两部就友好一些，第一部有“心”的提示（左上角；可以关闭），第三部选项状态就是提示（见前文），就是这第二部麻烦多了。</p><p>（第一部/第二部）エリカ费老劲地照顾ハル，从化解ハル（不想见到マナミ的男朋友）的尴尬提出和ハル一起去市内转（最后真的去了），到给ハル准备生日活动，到真情流露，最后甚至说想亲上去了。而且经历了上面的死亡选项后，明显能看出，虽然エリカ认为自己是在尽一个朋友的责任，但是这负担起的已经超出了朋友的范围……更何况エリカ还是个双（很早就跟ハル说过）。然而结局是 as a friend。（摊手）</p><p>第二部的后日谈中，ハル表示要真诚地跟マナミ谈一谈。虽然不知道是想谈第二部里各种别扭的根本原因，还是谈她对マナミ的感情。不管是哪一种，总之从第三部可以看到，作为本故事的引子，ハル和エリカ在一起了。等等？嗯？这跳跃是怎么回事？跃迁吗？</p><p>（第三部）ハル引导マナミ去寻找解答。虽然于情于理这个指引者都应该是ハル，但是考虑到ハル的想法……作者真喜欢插刀子。</p><hr><p>ハル的话可以引起思考，也大致体现了真实的想法：</p><blockquote><p>ハル：我在各个意义上都是破碎的……怎么还会有人会被这样的我所吸引呢？</p></blockquote><p>以及：</p><blockquote><p>エリカ：（“悠人”）是你从前男生时的名字吗？</p><p>ハル：从前也不是男生……</p></blockquote><hr><p>有意思的是，一些词汇被意译的情况下，另一些作为专有概念被音译了。温泉（<ruby>温泉<rp>(</rp><rt>おんせん</rt><rp>)</rp></ruby>）就被普普通通地翻译成了“hot spring”。而旅馆（<ruby>旅館<rp>(</rp><rt>りょかん</rt><rp>)</rp></ruby>）、公共澡堂（<ruby>銭湯<rp>(</rp><rt>せんとう</rt><rp>)</rp></ruby>）、蜜柑（みかん）则分别被翻译成了“ryokan”、“sentou”和“mikan”。我想，这些玩意儿在西方语境下，哪一个都不是新鲜事物或者说异域风情啊。问问你们的先祖，要不听听人家<a href="https://movie.douban.com/subject/6037517/">吐槽</a>也可以。<del>精罗震怒</del></p><hr><p>本文涉及的主题可能是目前我所有的博文中最容易引起争议的。游戏中说了这么多，其实都是陈述一些客观事实，以及中立的处理方式。真要从法律法规层面上实施起来，就开始碰到主观观点、碰到蛋糕了，和其他行为公认的（但是根据各种标准再细分，或“先进”或“落后”的）行为准则一冲突，也是很麻烦的事。比如，奥巴马的<a href="https://en.wikipedia.org/wiki/Bathroom_bill">公共厕所指导条例</a>，就是十分粗暴的尝试。如果你要问我怎么解决，我只能耸耸肩，说，我不是神，不知道最优解是什么，也不知道那个最优的平衡在哪里；但是也许可以渐进，近似出这个特定的函数。退一步来说，这个群体内部也是分裂的——就像是多组相互独立、每组内容易相互排斥的选项，就算是第一组都选了同一个，第二组不同，就会看不顺眼。从宏观到微观，人就是这么分裂。感受不到的话……可能是很幸运地选到了大众选项。</p><p>不管如何，我依然将其视为社会生产力发展的证明。这个观点来自于<a href="https://book.douban.com/subject/1286994/">《在时间的长河里》</a>中对于毕达哥拉斯学派素食规定的解读。小众的特化需求得到满足，必须是以高生产力为条件的。否则，他们就会成为主流（提供人类这一物种生存的保障的人）的负担，从而遭到排挤。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;欢迎到作品的 &lt;a href=&quot;https://npckc.itch.io/spring-leaves-no-flowers&quot;&gt;Itch.io 页面&lt;/a&gt;去支持作者。另外这个系列目前由三个连续的故事组成：&lt;a href=&quot;https://npckc.itch.io/one-night-hot-springs&quot;&gt;one night, hot springs&lt;/a&gt;、&lt;a href=&quot;https://npckc.itch.io/last-day-of-spring&quot;&gt;last day of spring&lt;/a&gt; 和本作 &lt;a href=&quot;https://npckc.itch.io/spring-leaves-no-flowers&quot;&gt;spring leaves no flowers&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。&lt;/p&gt;</summary>
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>小谈 .NET 和 Java 的并发容器 API 设计</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/</id>
    <published>2019-12-19T07:49:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>今天看博客园，看到<a href="https://www.cnblogs.com/thisiswhy/p/12059240.html">一篇文章</a>。它的主要内容是：</p><ul><li>为什么 <code>ConcurrentHashMap&lt;K, V&gt;</code> 不支持 <code>null</code> 值？因为这样就无法区分给定的键不存在还是对应值就是 <code>null</code>。</li><li>为什么 <code>ConcurrentHashMap&lt;K, V&gt;</code> 不支持 <code>null</code> 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。</li></ul><p>文章内容不赘述了。</p><p>我看完之后想到的是，.NET 的并发容器（<code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的坑联系在一起，可能会发现什么。</p><span id="more"></span><p>以前我笑话过 .NET 的容器 API 设计。我们知道，.NET 的 <code>Stack&lt;T&gt;</code> 和 <code>Queue&lt;T&gt;</code> 是基于数组的。这给予了它们一定的随机访问能力（不过没什么卵用，想想它们是做什么的），保持内存连续性（提高缓存命中率），但是坏处就是不适合频繁的扩容和收缩。（在提高数组的利用率上，<code>Stack&lt;T&gt;</code> 比较好办，<code>Queue&lt;T&gt;</code> 用的是循环缓冲区。）我想实现基于 <code>LinkedListNode&lt;T&gt;</code> 的版本，却发现 .NET 并没有提供 <code>IStack&lt;T&gt;</code> 和 <code>IQueue&lt;T&gt;</code>。简单搜索就可以找到 StackOverflow 上的<a href="https://stackoverflow.com/questions/4367893/why-is-there-no-iqueuet-or-istackt-interface-in-the-net-framework">问题</a>。其中有那么一句话：</p><blockquote><p>As it pointed <code>Queue</code> and <code>ConcurrentQueue</code> don’t have that much similar to make them implement single interface.</p></blockquote><p>我就顺着看了一下 <code>ConcurrentQueue&lt;T&gt;</code> 的 API，接着就被震撼到了。其他的容器也是类似的。这是什么玩意儿！相比之下，人家 Java，<code>ConcurrentHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;</code>，多么优雅。也就是说，理论上，我可以将某个类型为 <code>Map&lt;K, V&gt;</code> 的成员字段啊参数啊变量啊，从原来赋值为 <code>HashMap&lt;K, V&gt;</code> 的实例改为 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的实例，然后瞬间就不担心这里的多线程问题了（假设其余部分正确实现）。这不是很爽吗？而如果我使用了 <code>Dictionary&lt;TKey, TValue&gt;</code>，由于其和 <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 没有共同的基类或者适合的接口，所以我无法只使用一个变量就兼容二者。太麻烦了，就为了这个区别，也得开始使用策略模式吗……</p><p>今天突然理解了。<code>ConcurrentHashMap&lt;K, V&gt;</code> 中的 <code>null</code> 是一个坑，而且“这种限制”这样的无聊问题会成为 Java 开发者懂不懂并发的其中一个筛子，很大程度上就是因为它实现了 <code>Map&lt;K, V&gt;</code>，而后者在设计之初就计划使用 <code>null</code> 作为键不存在的表示，从而没有其余携带信息的手段。这是不是设计失误我不敢下结论（不知道 Bloch 当初是怎么想的），但是一定是有问题的。</p><p>我们先来看看 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的存取 API。由于实现了 <code>Map&lt;K, V&gt;</code>，所以签名是一样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">putIfAbsent</span><span class="hljs-params">(K key, V value)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>“无法使用 <code>null</code> 值”可以从“需要实现 <code>Map&lt;K, V&gt;</code>”这个前提推断出来：</p><ol><li>必须实现 <code>Map&lt;K, V&gt;</code>，因此存取必须使用 <code>get(K)</code> 和 <code>put(K, V)</code>。</li><li>在 <code>Map&lt;K, V&gt;</code> 的大多数实现中，<code>get(K)</code> 对于不存在的键会返回 <code>null</code> 而不是抛出异常。</li><li>怎么判断返回 <code>null</code> 是代表键不存在，还是代表设置的值就是 <code>null</code> 呢？那就得在获取值之前先使用 <code>contains(K)</code> 检查了。</li><li>假设允许 <code>null</code> 值。一样会遇到2所示的问题。那么此时怎么判断是哪一种情况呢？还是先用 <code>contains(K)</code> 吗？这可是可能处于并发状态下的啊，两次操作之间或许这个容器状态就改变了，引发别的问题。因此，不可以使用预先判断。</li><li>现在唯一能表示键不存在的只有返回值了。在这里做文章，规定一个特殊值 <code>null</code>（有经验都知道使用特殊值一般不是个好主意），用它来表示键不存在。</li><li>由于 <code>null</code> 返回值在这个操作的上下文中有了“键不存在”的特殊意义，为了不引发冲突，容器内的所有值都不允许为 <code>null</code>。</li></ol><p>可以注意到，状态附加、原子性保证，使得应用前提发生了变化。因此，<code>ConcurrentHashMap&lt;K, V&gt;</code> 不适合实现 <code>Map&lt;K, V&gt;</code>。</p><p>再来看看 .NET 这边。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TryGetValue</span>(<span class="hljs-params">TKey key, <span class="hljs-keyword">out</span> TValue <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentDictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt;<br>    : <span class="hljs-title">IDictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryGetValue</span>(<span class="hljs-params">TKey key, <span class="hljs-keyword">out</span> TValue <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TValue <span class="hljs-title">GetOrAdd</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryAdd</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryUpdate</span>(<span class="hljs-params">TKey key, TValue newValue, TValue comparisonValue</span>)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（或许你要问，其余对 <code>IDictionary&lt;TKey, TValue&gt;</code> 的方法实现，比如 <code>Add(TKey, TValue)</code> 呢？答案是它们都成了显式接口实现。）</p><p>可见，虽然同样是实现了字典接口，但是由于 .NET 这边并未采用特殊值，所以 <code>TryGetValue(TKey, out TValue)</code> 有很高的并发接口适应性。开发者不需要关心特殊值的问题，而是可以和普通的 <code>Dictionary&lt;TKey, TValue&gt;</code> 一样，使用 <code>null</code> 作为项的值，不需要抓破脑袋。</p><p>.NET 这样设计的一部分原因也可能是不得已而为之。因为在 <a href="https://docs.microsoft.com/en-us/dotnet/standard/common-type-system">CTS</a> 中是有严格的值类型和引用类型的区分的。<code>ConcurrentDictionary&lt;T&gt;</code> 并没有泛型类型约束，因此可以用于这两种类型。如果想像 Java 那样找 <code>null</code> 这样的特殊值，是找不到的——值类型没有“空”（null）的概念，但是不排除有“空”（empty）的值，包括默认的全零值。因此，为了携带状态，就得多加参数。</p><p>这个设计带来的一个（可能是）意想不到的好处是，它将“检测并获取”作为一个原子操作（API 层面，当然不是指令层面），而且没有副作用。这样开发者过渡到并发反而容易了。</p><p>我们再来看看在队列上的区别。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 失败抛出异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 失败返回特殊值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 和 Queue&lt;E&gt; 一样，不赘述</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;E&gt; <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Dequeue</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentQueue</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-comment">/* ... */</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryDequeue</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T result</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryPeek</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T result</span>)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个设计上，Java 提供了两套令人迷惑的 API。它们提供相同的功能，但是在失败时的行为完全不同。一套是快速失败（fail-fast），抛出异常，另一套是安全失败（fail-safe），返回特殊值 <code>null</code>。（说实话，如果不是这次我看了文档，否则我也不会知道两套的区别。）很明显，抛出异常适用于简单开发，而在复杂的并发系统中返回“失败”这个状态更好。但是由于使用的特殊值也是个合法值（<code>null</code>），因此 <code>Queue&lt;E&gt;</code> <strong>一般</strong>是不允许其中的项是 <code>null</code> 的。（但是也有例外：<code>LinkedList&lt;E&gt;</code> 是允许 <code>null</code> 项的，因为用内部的 <code>Node&lt;E&gt;</code> 包装了。新的坑。）且不论两套 API 是否让人头大，针对 <code>null</code> 的行为已经让人头大。不过，和 <code>Map&lt;K, V</code> 到 <code>HashMap&lt;K, V&gt;</code>/<code>ConcurrentHashMap&lt;K, V&gt;</code> 的暗坑，<code>Queue&lt;E&gt;</code> 到 <code>LinkedList&lt;E&gt;</code>/<code>ConcurrentLinkedQueue&lt;E&gt;</code> 反而没什么坑。</p><p>当然，你也可以说 <code>null</code> 本身就是个 <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion dollar mistake</a>。在这种意义上，<code>null</code> 本来就不该出现。可惜广泛应用的语言大多都没有禁止 <code>null</code>……</p><p>.NET 这边的设计就有意思了。对于普通场景的 <code>Queue&lt;T&gt;</code>，失败都是抛出异常的。而 <code>ConcurrentQueue&lt;T&gt;</code> 入队失败抛出异常，后两者失败时是返回 <code>false</code> 的（从命名就可以看出来）。而且 <code>ConcurrentQueue&lt;T&gt;</code> 和 <code>Queue&lt;T&gt;</code> 没有关系（见上文），因此不提供相同的 API。失败行为和 API 对于是否支持并发时线程安全（和性能！）完全不同——这虽然“适应”了不同场景，让开发者只需要“自然地”使用，但这差异同样增加了认知的负担。</p><hr><p>另外还有一个有意思的讨论。我们知道有 <code>ConcurrentHashMap&lt;K, V&gt;</code>，但是线程安全的<em>随机访问</em>列表实现只有 <code>Vector&lt;E&gt;</code>（或者使用 <code>Collections.synchronizedList()</code> 包装），而且原理还是全部加锁的。<a href="http://ifeve.com/why-is-there-not-concurrent-arraylist-in-java-util-concurrent-package/">为什么没有 <code>ConcurrentArrayList</code></a>？（原文链接已经失效，所以只好引用译文。）</p><p>回答是：</p><blockquote><p>很难去开发一个通用并且没有并发瓶颈的线程安全的 <code>List</code>。</p><p>像 <code>ConcurrentHashMap</code> 这样的类的真正价值并不是它们保证了线程安全，而在于它们在保证线程安全的同时不存在并发瓶颈。……</p></blockquote><p>比如，调用 <code>contains()</code> 或者 <code>indexOf()</code> 的时候，最坏的情况下需要搜索整个列表，所以必须锁定整个列表。这个时候如果要修改列表（增删改）那必然会引发瓶颈。</p><p>相比之下，<code>ConcurrentHashMap&lt;K, V&gt;</code> 在修改/搜索的最坏情况下最多只需要锁住其一部分（如果你疯狂构造哈希冲突；另参考 Java 7 到 Java 8 的实现变更）。<code>ConcurrentLinkedQueue&lt;E&gt;</code>/<code>ConcurrentLinkedDeque&lt;E&gt;</code> 则更简单，无法搜索，修改也只有一个/两个方向。因此它们的使用不会构成瓶颈。</p><hr><p>我本来还想吐槽一下 wildcard capture 的，因为我记得以前在哪里看到过，它的不恰当应用会得出合乎语法却毫无意义的结果。我写这篇文章的时候找了很久，可是就是找不到了。不过反而有了其他的发现，比如<a href="http://wouter.coekaerts.be/2018/java-type-system-broken">这个</a>和<a href="https://doi.org/10.1145/2983990.2984004">这个</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天看博客园，看到&lt;a href=&quot;https://www.cnblogs.com/thisiswhy/p/12059240.html&quot;&gt;一篇文章&lt;/a&gt;。它的主要内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 不支持 &lt;code&gt;null&lt;/code&gt; 值？因为这样就无法区分给定的键不存在还是对应值就是 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 不支持 &lt;code&gt;null&lt;/code&gt; 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章内容不赘述了。&lt;/p&gt;
&lt;p&gt;我看完之后想到的是，.NET 的并发容器（&lt;code&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 的坑联系在一起，可能会发现什么。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Java" scheme="https://blog.mottomo.moe/tags/Java/"/>
    
    <category term=".NET" scheme="https://blog.mottomo.moe/tags/NET/"/>
    
    <category term="并发" scheme="https://blog.mottomo.moe/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python 加速好帮手：Numba</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/</id>
    <published>2019-12-06T14:08:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>一次无可奈何的 Python 提速。</p><span id="more"></span><hr><p>先简单介绍一下背景。</p><p>这门课是 Visualization，由两个作业组成。第一个作业的代码部分，要求补完一个体渲染器（volume renderer）。这个渲染器是完全软件渲染的，而且需要支持几种渲染方式（也就是几种软件着色器）：切片（代码已给出）、<a href="https://en.wikipedia.org/wiki/Maximum_intensity_projection">最大密度投影（MIP）</a>、体元合成（compositing）。不管哪一种，核心都是 <a href="https://en.wikipedia.org/wiki/Volume_ray_casting">ray casting</a>。严格来说，每一个都有“合成”步骤，不过最后一个实际上指的是最常见的、使用 Phong 模型的着色。</p><p>今年我就被一个认识我的人叫过去帮忙了。去年我修这门课的时候，用的是 Java。今年据说因为 Java 入门（一个 master level 的课程，本来在 Q1，也就是 visualization 的前一个 quartile）移到了 bachelor level 3，所以在改革之后这门课默认所有选课的人都没有 Java 基础。因此，使用的语言改为了 Python。</p><p>我不得不严重吐槽今年的老师，虽然我并不认识他。内容比较长而且跟题目切合度不算太大，所以就放在文末。</p><p>好，接着就讲优化的事。下文的渲染时间以提供的橘子的数据为准。</p><p>由于各种坑爹因素的综合作用，切片的每帧渲染时间就已经超过了2秒。至于体元合成，因为所有体元基本都要至少被投射一次，总时间可达每帧10分钟（600秒）左右。其他的已经实现了这个的小组也反馈说，用时10分钟“是非常正常的”。</p><p>正常个毛！作为读者而不是这个坑爹软件的使用者，你可能不是很清楚它对人精神的打击有多大。首先，切换到体元合成模式，渲染初始帧，10分钟。接着，你会发现默认的迁移函数（transfer function）效果很差，需要调整曲线。当你调整第一个数值的时候，新的渲染开始了，又是10分钟。在这段时间内，你对迁移函数的调整完全不会反映出来——因为上一帧还没有渲染完成，所有更改都不会应用。你根据密度直方图大致估摸出了一个曲线，但为了它能起作用，你必须在上一帧渲染完成后，再次触发更改（比如调整颜色）才能获得正确的渲染结果，于是又要等10分钟。然后，你会看到默认的视角并不能看到什么有意义的东西，于是你得尝试调整视角。跟迁移函数一样，如果正在渲染，则新的视角不会应用。这就是多个10分钟。在你获得最后的满意的图像之前，精神上要受到长时间的折磨。说“折磨”，是因为这个时间根本就是因为种种错误导致的浪费生命，而且不止是一个人的生命。</p><p>怎么办呢？我们来想想方案的必要条件：</p><ul><li>使用 Python（恶心的规定）</li><li>非侵入式的</li><li>支持 GUI 实例</li></ul><p>补充条件：</p><ul><li>应用容易</li></ul><p>其实说到底，就是加速。加速，无外乎就是提高硬件利用率、合理利用硬件。例如，并行（CPU、GPU）、更高效率的代码（设计上、编译后）、提高缓存命中等等。</p><p>各位或许听说过 <a href="https://cython.org/">Cython</a>。但是很可惜，虽然 Python 代码是合法的 Cython 代码，但是为了让 Cython 达到最高效率，必须要将代码改写成其方言。这就违反了非侵入式的条件，代码提交后别人也不容易运行这些代码。</p><p>Python 以性能为代价提供了极高的自由，而这给解释器设计让生成高效率的机器码带来的巨大的困难。所以不可能寄希望于 Python 解释器自身给我们提供极致性能。</p><p>我也试过用 <code>multiprocessing</code> 模块来加速。然而这并没有什么卵用。需要优化的函数是一个虚函数，而且位于事件回调，跟 GUI 有相当的耦合。这就不像一些常用 <code>multiprocessing</code> 优化的模块，那些模块基本是用于数值计算。而且它们的函数是全局的（对于子进程来说是入口），参数也利于封送，运行时产生的都是后台进程。当我简单使用 <code>multiprocessing</code> 的时候，这个程序直接弹出了好几个窗口，把我吓了一跳——而且它们没有一个在干活。</p><p><code>threading</code>？别忽悠人了。</p><p>还有一些其他的方法，不过投入的成本太高，对于一个作业，精力有限，做不起。（见文末讨论。）</p><hr><p>这时候偶然搜索到了 <a href="http://numba.pydata.org/">Numba</a>。它和 Cython 的思路是相似的，在一定条件下，转换成 C 代码后编译运行，利用 C 的速度优势（“C 的速度优势”不是很准确，但是在此不展开了），提高代码执行效率。在满足一些苛刻的条件时，甚至还可以<a href="https://numba.pydata.org/numba-doc/dev/user/vectorize.html">应用并行化</a>，进一步提高执行效率。</p><p>就使用体验而言，Numba 总体来说还是相当友好的。在正式用到作业项目之前，我用<a href="http://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/">一篇文章中的示例</a>简单测试了一下优化效率。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Callable</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> jit<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pairwise_python</span>(<span class="hljs-params">X: np.ndarray</span>) -&gt; np.ndarray:<br>    M = X.shape[<span class="hljs-number">0</span>]<br>    N = X.shape[<span class="hljs-number">1</span>]<br>    D = np.empty((M, M), dtype=np.<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):<br>            d = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>                tmp = X[i, k] - X[j, k]<br>                d += tmp * tmp<br>            D[i, j] = np.sqrt(d)<br>    <span class="hljs-keyword">return</span> D<br><br><span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pairwise_numba</span>(<span class="hljs-params">X: np.ndarray</span>) -&gt; np.ndarray:<br>    M = X.shape[<span class="hljs-number">0</span>]<br>    N = X.shape[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># https://github.com/numba/numba/issues/3993</span><br>    <span class="hljs-comment"># Use float_/int_ instead of float&#123;XX&#125;/int&#123;XX&#125;</span><br>    D = np.empty((M, M), dtype=np.float_)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):<br>            d = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>                tmp = X[i, k] - X[j, k]<br>                d += tmp * tmp<br>            D[i, j] = np.sqrt(d)<br>    <span class="hljs-keyword">return</span> D<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pairwise_numpy</span>(<span class="hljs-params">X: np.ndarray</span>) -&gt; np.ndarray:<br>    <span class="hljs-keyword">return</span> np.sqrt(((X[:, <span class="hljs-literal">None</span>, :] - X) ** <span class="hljs-number">2</span>).<span class="hljs-built_in">sum</span>(-<span class="hljs-number">1</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_python</span>() -&gt; <span class="hljs-literal">None</span>:<br>    X = np.random.random((<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>    pairwise_python(X)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_numba</span>() -&gt; <span class="hljs-literal">None</span>:<br>    X = np.random.random((<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>    pairwise_numba(X)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_numpy</span>() -&gt; <span class="hljs-literal">None</span>:<br>    X = np.random.random((<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>    pairwise_numpy(X)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_it</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, func: <span class="hljs-type">Callable</span>[[], <span class="hljs-literal">None</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    time_start = time.time()<br>    func()<br>    time_end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> used <span class="hljs-subst">&#123;time_end - time_start&#125;</span> second(s)&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    time_it(<span class="hljs-string">&quot;raw python&quot;</span>, run_python)<br>    time_it(<span class="hljs-string">&quot;numba&quot;</span>, run_numba)<br>    time_it(<span class="hljs-string">&quot;numpy&quot;</span>, run_numpy)<br></code></pre></td></tr></table></figure><p>在我的机器上运行，结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">raw python used 5.295958518981934 second(s)<br>numba used 0.3148195743560791 second(s)<br>numpy used 0.05596804618835449 second(s)<br></code></pre></td></tr></table></figure><p>可见，仅仅是转换成等价 C 代码（还没有并行）并编译，就已经获得了巨大的效率提升。当然，这还是比不过 NumPy 的向量化操作（<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html">ufunc</a>）。</p><p>不过，在这个作业里，每个最终像素点的实际生成过程是异构（heterogeneous）的，因此无法将其向量化，自然无法充分利用 NumPy。使用 Numba 并行是可能的；考虑到作业中的这个函数远比上面的简单例子复杂，尤其是输入的参数，所以尽管理论上可能，我也没这么多精力去适配它的条件了。</p><p>我们继续来看 Numba。Numba 提供了两种模式，一种是 <a href="https://numba.pydata.org/numba-doc/latest/glossary.html#term-nopython-mode"><code>nopython</code> 模式</a>，一种是 <a href="https://numba.pydata.org/numba-doc/latest/glossary.html#term-object-mode"><code>object</code> 模式</a>。前者不需要涉及 Python 的解释器，后者需要。什么时候需要呢？访问除了特定受支持的数据类型（<code>int</code>、<code>float</code>、<code>numpy.ndarray</code> 等等）之外的，尤其是自定义的复杂类型（简单类型可以用 <a href="https://numba.pydata.org/numba-doc/dev/user/jitclass.html"><code>@jitclass</code></a>）。很明显，一旦和 Python 解释器扯上关系，那么效率就得大打折扣。再加上 JIT 是有开销的，所以最后总体甚至会慢于直接在解释器中执行。因此，一般都得用 <code>nopython</code> 模式。</p><p>接下来就是痛苦的转换了。毕竟 Numba 要能应用，是有限制条件的。</p><p>所以第一步，就是尽量做到与 OO 无关，而是回退到面向过程的方式。毕竟文档自己说了“越像 C 越好”（笑）。拆！拆！拆！好在原程序大部分都是不需要跟对象进行交互的，因此将主体变换为面向过程的方式并没有太复杂，就是繁琐一些，花一个小时就搞定了。同时考虑到 Python 无法内联的特性，分块大小偏大，减少调用开销。</p><p>不过里面有一个问题如鲠在喉；甚至说，如果不将它解决，那么其他的优化都无法生效，Numba 必然会回退到 <code>object</code> 模式。在循环的最深处，需要根据迁移函数获取在该视角（viewpoint）下某个体素（voxel）的对应颜色值。这可是插在层层循环中最深的地方的一个钉子。而必需的迁移函数，在实现上是一个复杂对象，<code>@jitclass</code> 还不支持。嗯，仔细观察一下，颜色计算其实是根据一张表实现的，而这张表在单次渲染中不发生变化。所以我就写了一个计算量不大的函数，将迁移函数的内部状态提取到了一个 <code>ndarray</code> 中，并修改颜色计算使其用这个 <code>ndarray</code> 而不是原来的迁移函数对象。这样核心计算就可以在 <code>nopython</code> 模式下进行了。</p><p>目前（0.46）Numba 还不支持 <code>MAKE_FUNCTION</code> opcode。Numba 只会报错说“<code>op_MAKE_FUNCTION</code> 未实现”。这么一个莫名其妙的错误信息还是得猜一下。结果是，它不支持函数内定义的函数，无论内部的函数是否形成闭包。所以我只好又违反了模块化原则，把一些内部的小函数提出来放到全局范围里。</p><p>最后优化到了什么程度呢？原先的每帧渲染时间是大约600秒，优化后冷启动24秒（含 JIT 时间），多次运行18秒。整整33倍！而且这仅仅是将 Python 代码 JIT 的结果，甚至都没有并行化。这个函数输入太多，签名复杂，所以我就不浪费时间去做并行化了——软件本身只是用来出结果的，后面还有报告呢，这时候离截止日期已经不远了。比起再花几个小时尝试优化到最佳状态，还不如就18秒先用着，毕竟看模型又不是重复数十次上百次的重复劳动，最后总计花费时间也不会太久。</p><hr><p>接下来就是纸上谈兵环节了。</p><p>我们看到了解释代码到原生代码的效率提升。如果要进一步优化异构任务的话，该怎么办呢？在这里再加一个前提：跟宿主语言无关，也就是要找一个相对通用的解。</p><p>一个很容易想到的方案是使用传统的 GPU。将计算逻辑变换成 shader，输入变换为顶点数据，输出从图像中解码。使用的 API 可以是 OpenGL（vertex/fragment）、Direct3D。这种做法别说现代 GPU，老一点的 GPU 都支持。缺点就是结果的复杂度不能太高，毕竟单元输出最多只有4个单精度浮点数。</p><p>如果使用 GPGPU，就可以避开许多输入输出的限制。可以使用的有 OpenGL（compute）、DirectCompute，以及 OpenCL 和 CUDA。其中一些还支持异构设备计算。</p><p>以上的方案，只要所使用的语言提供对应的绑定，就可以使用。</p><p>如果放宽“语言无关”限制，只针对 C/C++ 的话，有 OpenMP、OpenACC 和 SYCL。它们的效率提升方式不尽相同，有自动多线程并行的，有（合适时）使用 GPU 的。但是它们几乎可以和 C/C++ 无缝集成，而不需要将计算逻辑分离到独立的管线中。</p><hr><p>对这个老师的吐槽。</p><p>客观来讲，他犯了一个严重的选型错误。他应该是这么想的，Python 不是什么“新时代的基础语言”、“万能胶水语言”，“上手十分简单”嘛。但是很明显，Python 和 VB 一样，学习曲线的上升幅度开始平缓，接着立马就极端地陡峭，也就是易于上手，难于深入，更难于精通。Python 的运行效率不能说差，但是很不擅长计算密集型的任务（至少在包括默认的 CPython 上的大部分实现，因为有 <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">GIL</a>）。（另外插一句，<a href="https://www.python.org/dev/peps/pep-0554/">PEP-554</a> 安排在 Python 3.9 了，所以现在也用不了。）而这门课要做的是一个<strong>软件</strong>渲染器，不仅是一个计算密集型的任务，而且是一个异构任务（不能简单地通过向量化完成）。写出逻辑是很简单的，但是一旦运行起来，就会发现它的运行时间无法忍受。想优化？对不起，优化异构任务的难度，已经远远超出了花样使用 NumPy（优化同构任务）；后者也早就不是初学者范围内的东西了。也就是说，这个作业在目标之外设置了一个巨大的障碍，而所有人不得不做出选择——要不就克服这个障碍，要不就得忍受折磨——而几乎没有人有能力克服。这是完全没有意义的精神消耗，至少对于学生而言。（现实工作中也有可能会遇到这样的问题，不过都已经到了工作了，自然就不能假设有保护了。）</p><p>他貌似对自己的水平没有准确的估计。由于很多人被折磨得死去活来，所以他似乎收到了一些问问题的邮件。将这些整理成 FAQ 之后，其中就有令人哭笑不得的回答。在程序中有一个 bug，它导致计算出的图像不会绘制到窗口中，也就是体现为“看不见”。这几乎是致命的问题，自然有人会问。而他的回答呢？“看不见图像的原因，很可能是因为你的计算机在计算上出了问题。”我真不知道该说什么好。</p><p>在代码上，可以明显看出 Java 移植的痕迹。在命名上和一些辅助类的结构上就看出来。除了 GUI 部分的代码遵循 wxPython 的一般规则、OpenGL（仅用来画包围盒）用 PyOpenGL，其他都是 Java 的简单移植。不过要说命名，Python 本身就已经很混乱了，缩写的、连写（无分隔）的、snake_case 的、camelCase 的，乱成一锅粥。以颜色的记录来说，OO 的组织方式比较利于理解，而直接使用 <code>ndarray</code> 更利于和 NumPy 交互，也利于优化。这更多地是一种设计选择，但是我认为有经验的话不会做出这样的选择。</p><p>程序本身交互极差。上面也提到了一部分。这个作业在最后还要完成第四种模式，将你所选定的可视化方式应用于分块的体数据。这相当于有一个一级列表，让你选择某个物体，然后再有一个二级列表，选择其在某个时间点下的数据。但是要进入这第四种模式可不是那么简单。这个模式对应的单选框默认是无效（灰色）的，你得先手工选择两个文件夹（体数据索引、各个时间），再选定了其中一个物体的其中一个时间点后，这个单选框才会激活。要不然，想切换都没法切换。这个操作本身就非常反直觉，如果没有那同学的讲解，我恐怕也得摸索个几分钟。在代码逻辑上，单物体（直接打开体数据）和多物体（本段所述的分块选择）的交互是两套代码……</p><p>由于不断地有人哀嚎渲染一帧实在是太久了，这老师在截止日期前几天发了一则公告，说如果想加速的话推荐使用 Numba。然而他在给出的例子是切片——最简单的渲染模式，基本上就是简单的 <code>ndarray</code> 读取，没有复杂循环，没有合成。这个直接套个 <code>@jit(nopython=True)</code> 就搞定了，非常简单。然而真正有优化需求的体元合成，要用上 Numba，那得知道 Numba 是怎么工作的、它对数据结构是怎么支持的、Python 本身的瓶颈在哪里、什么时候 Python 解释器是必需的（例如让人又爱又恨的 <code>inspect</code>），这样才能知道什么能加速什么不行，如果不行能不能换成等价的写法使得它能被加速。这在我看来，对知识厚度的要求远远超过这门课。将这种任务放在一个作业里，就是高射炮打蚊子。而且看来，他也没有对任务难度的合理估计，以为后面都只是像他给的例子那样，直接加个装饰器（decorator）那么简单。</p><p>不过，不是没有厉害的老师的。在我选过的课里面，就发生过：</p><ul><li>Foundations of Machine Learning。老师讲得很好，而且看代码也是简明扼要，清晰易懂，几乎没有冗余。</li><li>Recommender Systems，和 FML 是同一个老师。在第四个作业中，我们要实现一个 <a href="https://en.wikipedia.org/wiki/Autoencoder#Variational_autoencoder_%28VAE%29">VAE</a>。其中助教提示的是“别忘了用 <a href="https://keras.io/backend/#flatten"><code>flatten()</code></a> 调整数据的形状”，但是在查阅资料后我判断应该用 <a href="https://keras.io/backend/#batch_flatten"><code>batch_flatten()</code></a>，就这么写了。后来在作业的点评里这一条被专门指了出来，说确实应该用 <code>batch_flatten()</code>，是他失误了。</li><li>VLSI Programming。就是我<a href="/categories/Misc/zh/2019-04-23-Misc/">之前</a>写过的老先生。图的构造代码写得非常漂亮，而且指出过我的一些 pythonic 的写法（例如<a href="https://en.wikipedia.org/wiki/List_comprehension">列表推导</a>）有效率问题——在这门课里，效率是一个很重要的衡量因素。</li><li>Programming Methods。这门课其实是一个本科3级的课程，偏向于软件工程，我自愿选的。最后的一个作业是写一个 <a href="https://en.wikipedia.org/wiki/Takuzu">Takuzu</a>（类似于数独，不过只填入0和1）的求解器，而且是可视化的。这个程序本来是用作各种设计模式的练习的，不过它的交互设计和代码水平都很不错。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次无可奈何的 Python 提速。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="Python" scheme="https://blog.mottomo.moe/tags/Python/"/>
    
    <category term="Numba" scheme="https://blog.mottomo.moe/tags/Numba/"/>
    
  </entry>
  
  <entry>
    <title>C++ 模板类的非待决名查找</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/</id>
    <published>2019-10-06T09:30:00.000Z</published>
    <updated>2020-07-26T13:49:08.003Z</updated>
    
    <content type="html"><![CDATA[<p>今天要做某个功能，其中我想用一个<em>单一参数的</em>宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_CLASS(this_class, base_class) \</span></span><br><span class="line"><span class="meta">typedef base_class MyBase; \</span></span><br><span class="line"><span class="meta">typedef this_class MyClass</span></span><br></pre></td></tr></table></figure><p>对于普通的类，实现起来是这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_ROOT_CLASS(class_name) \</span></span><br><span class="line"><span class="meta">    typedef class_name MyClass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_CLASS(class_name) \</span></span><br><span class="line"><span class="meta">    typedef MyClass MyBase; \</span></span><br><span class="line"><span class="meta">    typedef class_name MyClass</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="built_in">DECLARE_ROOT_CLASS</span>(Base);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="built_in">DECLARE_CLASS</span>(Derived);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显，这样利用 <code>typedef</code> 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 <code>typedef</code> 而不是更现代的 <code>using</code>，这在这里只是风格问题，对语义无影响。</p><p>对于模板类，我打算如法炮制。可是，问题出现了。</p><span id="more"></span><p>我的宏定义是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_ROOT_CLASS_TEMPLATE(class_name, TArgs...) \</span></span><br><span class="line"><span class="meta">    typedef class_name<span class="string">&lt;TArgs&gt;</span> MyClass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_CLASS_TEMPLATE(class_name, TArgs...) \</span></span><br><span class="line"><span class="meta">    typedef MyClass MyBase; \</span></span><br><span class="line"><span class="meta">    typedef class_name<span class="string">&lt;TArgs&gt;</span> MyClass</span></span><br></pre></td></tr></table></figure><p>然而在编译的时候，在第4行产生了错误：</p><ul><li>（Clang 提示说，）VC++ 认为，<code>MyBase</code> 等同于 <code>MyClass</code>（假设仍然使用后文的例子，则 <code>Derived::MyBase</code> 等同于 <code>Derived</code> 而不是期望的 <code>Base</code>）；</li><li>Clang 和 GCC 认为，<code>MyBase</code> 未定义。</li></ul><p>我就不理解了，为什么是未定义呢？似乎以前 stat 给 UB（两个把 C++ 玩出花的大佬）讲过 VC++ 有符号名称查找（name lookup）上的错误，与标准的不符。但是，Clang 和 GCC 是怎么回事？这里的 VC++ 又是怎么回事？</p><p>所以我就问了 stat，如下的例子中为什么 <code>TBase</code> 处出错了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Base&lt;T1, T2&gt; TBase;</span><br><span class="line">    <span class="keyword">typedef</span> TBase TThis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T1, T1*&gt; &#123;</span><br><span class="line"><span class="comment">// 后注：在提问时我手写的；不过这样写在所有编译器中都不能通过编译，出问题的还是“typedef TThis TBase;”</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TBase::TThis TBase;</span><br><span class="line">    <span class="keyword">typedef</span> Derived TThis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stat 想了一会儿，说：“<code>TBase</code> 是 non-dependent，第一遍解析的时候找不到。”</p><p>什么是 non-dependent 呢，就是 dependent 的反义词咯。那什么又是 dependent 呢？我就搜索了一下。全称应该叫做 <a href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent name</a>，具体还可以分为 type-dependent 和 value-dependent。（不是 <a href="https://www.modernescpp.com/index.php/c-core-guidelines-argument-dependent-lookup-or-koenig-lookup">argument-dependent lookup</a>！）</p><p>stat 所说的“第一遍解析的时候找不到”，指的是对模板类中符号的<a href="https://stackoverflow.com/a/1643190">二次查找</a>。这里由于 <code>MyBase</code>（<code>TBase</code>）是一个普通符号，而不是 type-dependent（<code>SomeTemplate&lt;T&gt;::TBase</code>、<code>TBase&lt;T&gt;</code>）也不是 value-dependent（<code>SomeTemplate&lt;N&gt;::TBase</code>、<code>TBase&lt;N&gt;</code>），所以不能通过一次扫描来确定合适的上下文。也就是 stat 说的：“（解析）模版的时候 <code>TBase</code> 是不知道是基类的 <code>typedef</code> 的”。</p><p>不过，我并不知道中文该叫什么，本文标题里的“待决名”是将语言切换到中文后显示的翻译。</p><p>下一个问题，VC++ 这里的行为是怎么回事。让我们看看<a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance">文档</a>和<a href="https://devblogs.microsoft.com/cppblog/permissive-switch/">开发博客</a>里是怎么说的。VC++ 默认遵照的不是标准行为，而是往里面加了点毒。在进行二次查找时，查找的<a href="https://devblogs.microsoft.com/cppblog/two-phase-name-lookup-support-comes-to-msvc/">位置错了</a>。就从文章中的例子来看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;The call resolves to void*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;The call resolves to int&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(<span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准行为是，在模板类/模板函数中使用的符号，其查找位置为<em>定义处</em>，也就是说，要查找这个符号，范围应该从开头至此处。“定义”指的是模板的定义。而 VC++ 的行为是，查找位置在实际使用处。</p><p>按照这么个逻辑，上面的例子结果就很明显了。</p><ul><li>在标准行为下：<code>g()</code> 对 <code>func(0)</code> 的调用会被解析到 <code>void func(void*)</code>。因为在此时（直到 <code>func(0)</code>）编译器只知道这个声明，而且隐式转换是可以接受的。</li><li>在 VC++ 行为下，会被解析到 <code>void func(int)</code>。因为在此时（直到 <code>g(3.14)</code>）编译器知道两个重载了的声明（<code>void func(void*)</code> 和 <code>void func(int)</code>，而其中根据参数类型决断，更合适的是后者。</li></ul><p>同理，也就产生了上面的问题。在代码中，如果 <code>MyBase</code> 的使用晚于 <code>MyClass</code>，就会产生 <code>MyClass</code> 已经被重新 <code>typedef</code> 的情况，从而让 <code>MyBase</code> 指向错误的类型。当然，就算是顺序恰巧对了，在某些情况下（比如调用前出现了多种特化/偏特化），还有可能因为非标准行为而产生难以预料的后果。</p><hr><p>另外偶然看到的一个有意思的“可选命名参数”<a href="https://www.fluentcpp.com/2018/12/14/named-arguments-cpp/">实现思路</a>和<a href="https://gitlab.com/tillheinzel/unorderednamedarguments">代码</a>。调用效果类似 C# 的可选命名参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallSomeMethod</span>(param2 = <span class="string">&quot;Param2Value&quot;</span>, param1 = param1Value);</span><br><span class="line">    <span class="built_in">CallSomeMethod</span>(param1 = param1Value, <span class="string">&quot;Param2Value&quot;</span>);</span><br><span class="line">    <span class="built_in">CallSomeMethod</span>(param1Value, <span class="string">&quot;Param2Value&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>副作用就是会有少许污染。</p><hr><p>在移植的时候，在变量上我使用了和原来代码相同的命名，其中就包括 <code>xor</code>。结果编译器就报错了。</p><p>一查，才知道原来 C++ 还有一串<a href="https://en.cppreference.com/w/cpp/language/operator_alternative">运算符的替代表示法</a>。在默认情况下，这些替代名称是启用的，除非使用选项关闭。以链接中的例子来说，这样的代码虽然看上去很奇怪，但也是可以正常编译的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%:include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="function"><span class="keyword">compl</span> <span class="title">X</span><span class="params">()</span> &lt;%%&gt; <span class="comment">// 析构函数</span></span></span><br><span class="line"><span class="function">    <span class="title">X</span><span class="params">()</span> &lt;%%&gt;</span></span><br><span class="line"><span class="function">    <span class="title">X</span><span class="params">(<span class="type">const</span> X <span class="keyword">bitand</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 复制构造函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="keyword">operator</span> <span class="title">not_eq</span><span class="params">(<span class="type">const</span> X <span class="keyword">bitand</span> other)</span></span></span><br><span class="line"><span class="function">    &lt;%</span></span><br><span class="line"><span class="function">       <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">not_eq</span> <span class="keyword">bitand</span> other</span>;</span><br><span class="line">    %&gt;</span><br><span class="line">%&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv&lt;::&gt;)</span> </span></span><br><span class="line"><span class="function">&lt;%</span></span><br><span class="line"><span class="function">    <span class="comment">// 带引用捕获的 lambda</span></span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> greet </span>= &lt;:<span class="keyword">bitand</span>:&gt;(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">    &lt;%</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; name</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; argv&lt;:<span class="number">0</span>:&gt; &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    %&gt;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> <span class="keyword">and</span> argv&lt;:<span class="number">1</span>:&gt; <span class="keyword">not_eq</span> <span class="literal">nullptr</span>) &lt;%</span><br><span class="line">        <span class="built_in">greet</span>(argv&lt;:<span class="number">1</span>:&gt;);</span><br><span class="line">    %&gt;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天要做某个功能，其中我想用一个&lt;em&gt;单一参数的&lt;/em&gt;宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; DECLARE_CLASS(this_class, base_class) &#92;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;	typedef base_class MyBase; &#92;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;	typedef this_class MyClass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于普通的类，实现起来是这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; DECLARE_ROOT_CLASS(class_name) &#92;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    typedef class_name MyClass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; DECLARE_CLASS(class_name) &#92;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    typedef MyClass MyBase; &#92;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    typedef class_name MyClass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Base&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;DECLARE_ROOT_CLASS&lt;/span&gt;(Base);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Derived&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Base &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;DECLARE_CLASS&lt;/span&gt;(Derived);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很明显，这样利用 &lt;code&gt;typedef&lt;/code&gt; 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 &lt;code&gt;typedef&lt;/code&gt; 而不是更现代的 &lt;code&gt;using&lt;/code&gt;，这在这里只是风格问题，对语义无影响。&lt;/p&gt;
&lt;p&gt;对于模板类，我打算如法炮制。可是，问题出现了。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="CPlusPlus" scheme="https://blog.mottomo.moe/tags/CPlusPlus/"/>
    
  </entry>
  
  <entry>
    <title>哈哈</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/</id>
    <published>2019-04-23T10:56:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>技术长草。</p><span id="more"></span><hr><p>今天讲到 <a href="https://en.wikipedia.org/wiki/Kahn_process_networks">Kahn Process Network</a>（KPN），我看到图示之后立刻反应过来，这结构不就是消息队列（message queue）吗。噫，消息队列“天然地”支持分布式架构，我理所当然地就接受了，因为有一点工程经验它就显得很自然了。没想到也是有一个理论支持的。</p><p>讲到并行化的实现思路（也即 parallelism），一般分为两类。<a href="https://ieeexplore.ieee.org/abstract/document/1631937">多线程</a>实现的“并行”，虽然在具体实现中是不可或缺的，但是只能说是技巧（technique），而不是架构（architecture）。这门课针对的是 parallelism by design，是架构上的并行，而且在系统设计时就有着确定的行为。（注：KPN 中各个过程是可以并行的，但是整个系统仍然有着确定的行为。这是 KPN 的一个特性。）在课程描述里还讲到有一个叫做 parallelism by compilation 的，我不知道是什么（毕竟 compilation 可能指常见的“编译”之外的更泛的意思），所以就去问了。教授（略有学究气的老先生）回答说，如果编译器足够智能的话，就可以将过程分离（注：原话用的是“process”，不过并不是指进程，而是抽象出的过程——粒度可以是大到功能模块，也可以小到一个原子操作），并抽取出可以并行的部分，自动并行。说完之后，他盯着我，很认真地（从语气和眼神里可以体会到）说：“我<em>坚信</em>确定的并行化（parallelism by design）是最好的方案，虽然很少人这么想。”我不知道该说什么好了。我大概能猜到他的心情；不过总有一种“力挽狂澜”之感，专门开这么一门课。</p><p>这又让我想起了复杂系统的设计方式，构造和自组织。我的思想仍然受到<a href="https://www.techug.com/post/python-ai.html">这篇文章</a>的影响。或许以前我引用过，但是在这里我还是想引用一次：</p><blockquote><p>但我并不认为 Java 有很大的机会，因为它本质上是为构造大型复杂系统而设计的。什么是大型复杂系统？就是由人清清楚楚描述和构造出来的系统，其规模和复杂性是外生的，或者说外界赋予的。</p><p>而 AI 的本质是一个自学习、自组织的系统，其规模和复杂性是一个数学模型在数据的喂养下自己长出来的，是内生的。</p></blockquote><p>不过，我仍然认为关键系统需要人为地设计其架构。“it just works”地在精细尺度上的、不可预测的并行，虽然显得很迷人，却是非常危险的。</p><hr><p>想起编译器优化的同时我又想起了之前和“博导”（我以前的一个同学，高中去了美国，大学读的……好像是电子工程；反正一直碾压同龄人）的一段对话。以下是节选：</p><blockquote><p>（前略）</p><p>我：这算什么，原教旨？<em>（注：指纯 C 写移动设备 app）</em></p><p>博导：算是吧，C 系手动内存正统，Java 等 GC 语言异端！我要确定性，掌控每一行代码！</p><p>我：抱歉，指令预测真的可以为所欲为。除非不断加 memory barrier，要不严格来说你无法掌控“每一行代码”。</p><p>博导：我知道 Intel 内部运作，知道 reordering 和 uop，所以是掌控的。<em>（注：uop = micro-operation）</em></p><p>博导：当然更加知道 GCC 每一行代码会编译成什么。</p><p>我：（图片：熊猫膜拜）</p><p>博导：其实 Intel 8卷读一遍就知道了。</p><p>我：（图片：许多熊猫一起膜拜）</p></blockquote><hr><p>不知道放哪里好，就放这里吧。</p><p><a href="https://www.semanticscholar.org/paper/Background-%3A-Physics-and-Math-of-Shading-Hoffman/237a3b12974e4bcf3d527dfd771271251133c3b6">原文</a>：</p><blockquote><p>In a sense, the specular term gets “dibs” on the incoming light energy, and the diffuse term<br>can only use its “leftovers”. </p></blockquote><p><a href="https://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-3.html">译文</a>：</p><blockquote><p>某种意义上，specular项指着入射光能量大喊“归我了”，然后diffuse项只能用“剩下的”。</p></blockquote><p>我读到这里的时候哈哈大笑。虽然这个翻译仍然有可以提高的地方，但是这个版本很有画面感。</p><blockquote><p>某种意义上，高光（specular）项占了入射光能量的大头，散射（diffuse）项就只能利用余下的能量。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;技术长草。&lt;/p&gt;</summary>
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>几种斐波那契数列项算法的复杂度分析</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/</id>
    <published>2019-04-07T12:44:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 <a href="http://bangumi.tv/subject/227102">BEATLESS</a>。</p><hr><p>“回字有四样写法，你知道么？”</p><p>而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。</p><span id="more"></span><hr><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天在面试的时候被问到了这样一个问题：求斐波那契数列的第 $n$ 项，你能想到多少种算法？</p><p>自然，猴子都知道简单递归。再进一步，黑猩猩都能看出来递归可以用一个额外的表来速查（空间换时间）。有递归就自然要想能不能迭代。稍稍想一下的话可以知道是能迭代的。</p><p>然后又问，时间和空间复杂度是多少？</p><p>迭代简单，$T(n) = O(n)$，$S(n) = O(1)$。递归我就炸了（所以说我太水了），时间分析就满脸问号（用表的话……优化是优化了，但是和迭代也没差多少了，却还多了调用开销；简单递归分析卡壳了），没答上来，面试官也就没问空间复杂度。所以我当时只想到了两种；后来因为提到迭代的空间复杂度为 $O(1)$，面试官可能没太听清，说道：“（时间复杂度）$O(1)$ 的解法也是有的，不过你用了迭代只能是 $O(n)$ 了。”虽然和我的回答意思相差了一些，但是我还是惊诧了一下（没出声）：“这个 $O(1)$ 是怎么来的？”</p><p>所以下午我就搜索了一下。</p><p>……连个本科生（复杂度计算本科生都会）都比不过，我自裁罢。</p><h1 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h1><p>斐波那契数列 $f_n (n \in \mathbb{N})​$ 的定义如下：</p><script type="math/tex; mode=display">f_n = \begin{cases}    0,\quad &n \lt 1\\    1,\quad &1 \le n \le 2\\    f_{n-1} + f_{n-2},\quad &n \gt 2\end{cases}</script><p>之后的代码以此为准。</p><p>为了简单起见，在之后的代码中使用 <code>int</code>，而不是更大的 <code>long long</code>，懒得用无符号数，也没有防溢出机制。</p><h1 id="三、直接的代码解法"><a href="#三、直接的代码解法" class="headerlink" title="三、直接的代码解法"></a>三、直接的代码解法</h1><p>这部分的方法就是只用到代码、基础算法和优化，几乎不需要数学。</p><h2 id="3-1-递归法"><a href="#3-1-递归法" class="headerlink" title="3.1 递归法"></a>3.1 递归法</h2><p>递归就是最简单直接的方法了，代码形式和数学形式接近，理解很好理解，大部分工作交给计算机完成。</p><h3 id="3-1-1-朴素递归"><a href="#3-1-1-朴素递归" class="headerlink" title="3.1.1 朴素递归"></a>3.1.1 朴素递归</h3><p>朴素递归应该学过代码都会，代码就不需要多讲了。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的调用如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> result = fib(<span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><p>这个算法的空间复杂度比较好分析（虽然有点绕），是 $O(n)$。令初始调用为第0层，调用一次加深一层。可以知道，在某一层的所有调用结束之前，不会产生新的调用（即，栈深不会增加）。那么栈深最深的是什么时候呢？画一棵调用树就可以看出，是从 <code>fib(n)</code> 开始到 <code>fib(1)</code>（实际上可以算到 <code>fib(2)</code> 为止）的这条“单刀直入”的路径。或者可以这么想，每次 <code>fib(n)</code> 执行实际计算（求和）的时候，<code>fib(n - 1)</code> 已经计算完成了。所以空间复杂度是 $O(n)$（更准确地说是 $\Theta(n)$）。</p><p>那么，时间复杂度是多少呢？许多文章直接就说结论是 $O(2^n)$，但是也没给出推导过程，或许也是因为太简单了。观察调用树可以知道，一个非叶子节点最多有两个子节点，而树的深度是 $O(n)$；在每个节点的操作都是简单加法，时间为 $\Theta(1)$；所以总计就是 $O(2^n)$。</p><p>但是大多数人没想过，这是一个好的估算吗？我们知道，大 O 函数只是给出上界；给出比一个已知上界更高的上界也不算错。也就是说，我可以胡扯说复杂度是 $O(2^{2^n})$，你也不能说我错了，只能说这个上界“质量不好”。</p><p>再次观察调用树，可以很明显地发现不管树高度如何增长，总是有不可忽视的一部分节点“缺失”了。因此，很明显还能找出比 $O(2^n)$ 更紧的上界。</p><p>为了计算这个上界，我们不妨来观察函数调用的过程。设 <code>fib(n)</code> 的调用时间为 $t<em>{n}​$ ，我们可以知道：$t</em>{n} = \Theta(1) + t<em>{n-1} + t</em>{n-2}​$。那么，这不是和原来的斐波那契数列形式完全一样吗？回到原点了。</p><p>但是等一下！斐波那契数列是可以求出通项的（见 <a href="4-3-%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F">4.3 节</a>）。提取“公因式” $\Theta(1)$（不是公因式，不过在复杂度分析中可以视作等量级；另外这个 $\Theta(1)$ 虽然上面是出现在递归式里，但是在通项中可以化为一个系数——这么讲不是很准确，不过意思就是这样）之后可以知道：</p><script type="math/tex; mode=display">\begin{align}T(n) &= \Theta(1) O((\frac{1+\sqrt{5}}{2})^n + (\frac{1-\sqrt{5}}{2})^n)\\     &= O((\frac{1+\sqrt{5}}{2})^n)\end{align}</script><p>$\frac{1+\sqrt{5}}{2} \approx 1.618$，虽说看起来好像比2差不了多少，不过对于 $n$ 很大的时候差距就比较明显了。这个上界明显比 $O(2^n)$ 要好，也是能获得的最紧的上界。</p><h3 id="3-1-2-尾递归"><a href="#3-1-2-尾递归" class="headerlink" title="3.1.2 尾递归"></a>3.1.2 尾递归</h3><p>既然朴素递归开销这么大，有没有可能用无敌的尾递归想想办法呢？毕竟一些现代编译器是支持尾递归优化为循环（迭代）的。（注：其实尾递归并不是无敌的，有着严格的应用条件；这里只是玩梗。）</p><p>我们知道，尾递归的一个重要条件是对调用自身后返回的结果不可以进行处理（即，尾调用——对自身的调用必须是返回前的最后一条指令）。那么我们将对之前的两个状态的操作（相加）转移到参数中，不就成了尾递归了吗。代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> x1 + x2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fib(x2, x1 + x2, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的调用如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> result = fib(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><p>这个的复杂度分析要考虑一下编译器。对于支持尾递归优化的编译器，这实际上跟下面的迭代是一样的，所以时间复杂度同为 $O(n)$，空间复杂度同为 $O(1)$。对于不支持的编译器，时间和空间的复杂度都很好分析，看参数 <code>n</code> 的变化就行——单次调用开销为 $\Theta(1)$，所以总复杂度同为 $O(n)$。</p><h2 id="3-2-迭代法"><a href="#3-2-迭代法" class="headerlink" title="3.2 迭代法"></a>3.2 迭代法</h2><p>不管是否想到了尾递归的方法，迭代都应该比较容易想到。如果想到了尾递归的话，很自然地可以进一步到迭代。</p><p>想法直截了当：既然每次只需要前两项的结果（状态），而 $f<em>{n-3}$ 并不会被 $f_n$ 及之后的计算直接用到，那么为什么要保存其他状态呢？$f</em>{n-1}$ 和 $f_{n-2}$ 已经很好地充当了“缓存”的功能。代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> n1 = <span class="hljs-number">1</span>, n2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> tmp;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; n; ++i) &#123;<br>            tmp = n1 + n2;<br>            n1 = n2;<br>            n2 = tmp;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> n2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> result = fib(<span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><p>显而易见，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$（更准确地说是 $\Theta(1)​$）。我觉得分析都不用写了。</p><h1 id="四、含数学分析的解法"><a href="#四、含数学分析的解法" class="headerlink" title="四、含数学分析的解法"></a>四、含数学分析的解法</h1><p>简单暴力的代码解法毕竟是太拿衣服。要往深了优化（或者给出无法继续优化的证据）还是得要数学。</p><h2 id="4-1-数列分析"><a href="#4-1-数列分析" class="headerlink" title="4.1 数列分析"></a>4.1 数列分析</h2><p>为了理解接下来的分析，首先要知道特征方程。数列的特征方程我记得是高中讲过的，可是后来一直都没怎么用过（高数里也是）；加上本来我数学就弱，所以基本就是忘光了。对不起了，宋老师。</p><p>斐波那契数列是一个二阶的递推数列，一般形式为 $x<em>{n} = c</em>{1}x<em>{n-1} + c</em>{2}x<em>{n-2}$。假设能找到两个数 $p$ 和 $q$，使得 $x</em>{n} - px<em>{n-1} = q(x</em>{n-1} - px<em>{n-2})$，移项得 $x_n = (p+q)x</em>{n-1} - pqx<em>{n-2}$。所以有 $p + q = c_1$，$pq = -c_2$。不难看出 $p$ 和 $q$ 的地位是相等的，因此消去任意一个（以 $q$ 为例）可得 $p^2 - c</em>{1}p - c_2 = 0$。这就是二阶递推数列的特征方程。求解该二次方程，两个实根（如果有）就是 $p$ 和 $q$。</p><p>代回原来的数列形式，若 $p \ne q$，则通项为 $x_n = \frac{x_2-qx_1}{p(p-q)}p^n + \frac{px_1-x_2}{q(p-q)}q^n$；若 $p=q$，则通项为 $x_n = (\frac{px_1-x_2}{p^2} + \frac{x_2-px_1}{p^2}n)p^n$。</p><p>将斐波那契数列代入（即 $c_1 = 1, c_2 = 1$）可以解得 $p = \frac{1+\sqrt{5}}{2}$，$q = \frac{1-\sqrt{5}}{2}$（$p$ 和 $q​$ 可互换）。</p><h2 id="4-2-改进的迭代：矩阵快速幂"><a href="#4-2-改进的迭代：矩阵快速幂" class="headerlink" title="4.2 改进的迭代：矩阵快速幂"></a>4.2 改进的迭代：矩阵快速幂</h2><p>（是搜索之后才知道有可以应用“矩阵快速幂”这么一类问题的。我没参加过 ACM，所以渣了。）</p><p>从 <a href="#4-1-%E6%95%B0%E5%88%97%E5%88%86%E6%9E%90">4.1 节</a>可知，存在符合条件的 $p$ 和 $q$。于是，就可以将每次求值化为矩阵乘法。</p><p>对于 $k$ 阶线性递推数列 $x<em>n = c</em>{1}x<em>{n-1} + c</em>{2}x<em>{n-2} + \cdots + c</em>{k}x_{n-k}$，每次递推可以表示为：</p><script type="math/tex; mode=display">[x_n, x_{n-1}, \dots, x_{n-(k-1)}] = [x_{n-1}, x_{n-2}, \dots, x_{n-k}] \times \mathbf{M}</script><p>其中大小为 $k \times k$ 的矩阵 $\mathbf{M}$ 就是……呃，好像没有标准称呼？就叫递推矩阵好了。由此可见，由于 $\mathbf{M}$ 在递推过程中不变，计算 $x_n$ 就被转化为了计算矩阵的幂的问题。这个矩阵受初始值选取和递推公式两方面的影响。</p><p>对于斐波那契数列，给定初始值 $[1, 1]$，可以得到</p><script type="math/tex; mode=display">\mathbf{M} = \begin{bmatrix}    1 & 1\\    1 & 0\end{bmatrix}</script><p>虽说是矩阵快速幂，但是对幂函数的计算优化其实和数的是一样的，只不过乘法的定义略有不同。</p><p>要计算一个数 $a$ 的 $n$ 次幂，最直接的想法是连乘，时间复杂度为 $O(n)$。但是只要见过质数筛这类的问题，或者是插值函数优化，就马上会意识到，其中许多次的乘法是多余的，结果是可以缓存的（甚至可以不用缓存）。那么，如何剔除这些多余的计算呢？</p><p>不是有对数函数嘛。大杀器。</p><p>考虑到实现的便利性，一般就取 2 为底了。将幂次 $n$ 分解为 2 的幂的和：$n = c<em>{0}2^0 + c</em>{1}2^1 + \cdots + c<em>{m}2^{m}$，其中 $c_i \in {0, 1} (0 \le i \lt m), c_m = 1$。进一步展开到乘法，就可以看到，$a^n = a^{c</em>{0}2^0} \times a^{c<em>{1}2^1} \times \cdots \times a^{c</em>{m}2^m}$。这样，从前往后“扫描”，由于 $a^{2^n} \times a^{2^n} = a^{2^{n+1}}$（废话），所以只需要保存最近的中间结果，就可以依次得到正确的乘积，并最终得到 $a^n$。代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 简洁起见，仅处理 a &gt; 0, n &gt;= 0 的情况</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pown_fast</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> cur = a;<br>    <br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            result = result * cur;<br>        &#125;<br>        <br>        cur = cur * cur;<br>        n = n &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以见到，<code>pown_fast()</code> 的时间复杂度为 $O(\log n)​$，空间复杂度为 $O(1)​$（$\Theta(1)​$）。对于矩阵的幂，由于斐波那契数列相关的递推矩阵大小是常数，所以时间和空间复杂度都和计算数的幂是一样的。再考虑初始值的输入等等，最终的时间复杂度为 $O(\log n) + \Theta(1) = O(\log n)​$，空间复杂度为 $\Theta(1) + \Theta(1) = \Theta(1)​$。</p><p>也有用类似思想，但不是快速幂的解法，而是采用新的递推公式，参见<a href="http://blog.zhengyi.one/fibonacci-in-logn.html">[1]</a>。</p><h2 id="4-3-通项公式"><a href="#4-3-通项公式" class="headerlink" title="4.3 通项公式"></a>4.3 通项公式</h2><p>将 $p​$ 和 $q​$ 的值代入 <a href="#4-1-%E6%95%B0%E5%88%97%E5%88%86%E6%9E%90">4.1 节</a>的通项公式可得： $f_n = \frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^n + (\frac{1-\sqrt{5}}{2})^n)​$。</p><p>按照这个通项计算 $f_n​$，理论上可以达到 $O(1)​$ 的时间复杂度。</p><p>很美妙，不是吗？$O(1)$ 和 $O(1)$ 啊！但是简单地计算依然会出问题。这个公式中，多处涉及了（在最终结果前）无法约简的无理数。在现代的计算框架中，如果按照一般的思维，用浮点数来表示这些无理数，进行计算的话，一定有因浮点数的不精确性导致的误差。$n$ 越大，误差越大。且不说“四舍五入”这个行为在此正不正确，当误差超过 0.5 的时候，舍入都救不回来了。所以在实践中，这个方法是不可取的。</p><p>当然不是没有能保证精度的方法。采用符号代数就可以了。而且这个计算过程中的无理数只有 $\sqrt{5}$ 一个，而且 $(\sqrt{5})^2 = 5$ 还是个整数。不过计算过程就得根据二项式定理展开，然后累加并分类求和，所花的时间肯定会多于 $O(n)$，空间开销也不会小。</p><h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>以上我们见到了五种计算 $f_n$ 的方法：</p><ul><li>朴素递归，$T(n) = O((\frac{1+\sqrt{5}}{2})^n)$，$S(n) = O(n)$；</li><li>尾递归，在有优化的情况下 $T(n) = O(n)$，$S(n) = O(1)$；</li><li>迭代，$T(n) = O(n)$，$S(n) = O(1)$；</li><li>快速幂，$T(n) = O(\log n)$，$S(n) = O(1)$；</li><li>通项，$T(n) = O(1)$，$S(n) = O(1)​$。</li></ul><p>在几种方法中，时间和空间复杂度都是从前往后越来越好。但是通项由于需要用浮点数表示无理数的值会导致误差所以基本上不能用。所以综合各种因素考虑，最优的算法是采用快速幂计算 $f_n$。</p><hr><p>参考：</p><ul><li>[1] <a href="http://blog.zhengyi.one/fibonacci-in-logn.html">五种方法计算斐波那契数列的第n项</a></li><li>[2] <a href="https://blog.csdn.net/dangzhangjing97/article/details/78778536">斐波那契数列的三种解法及时间复杂度</a></li><li>[3] <a href="https://blog.csdn.net/u012684062/article/details/76330075">斐波那契数列数列的三种时间复杂度的实现方法</a></li><li>[4] <a href="https://www.geeksforgeeks.org/time-complexity-recursive-fibonacci-program/">Time complexity of recursive Fibonacci program</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 &lt;a href=&quot;http://bangumi.tv/subject/227102&quot;&gt;BEATLESS&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;“回字有四样写法，你知道么？”&lt;/p&gt;
&lt;p&gt;而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="算法" scheme="https://blog.mottomo.moe/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随便写点什么</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/</id>
    <published>2019-03-05T17:33:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>GRIS 的文章呢？</p><p>别急，不会鸽的。</p><hr><p>二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。</p><p>那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。）</p><p>反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。</p><span id="more"></span><hr><p>昨晚又小小地反向了一把，对象是<del>京东娃娃项目</del><a href="http://www.projecttokyodolls.jp/">东京偶像计划</a>（プロジェクト東京ドールズ）。关于结果 esterTion 应该已经更新在他的<a href="https://estertion.win/2019/03/project-tokyo-dolls-%e6%8b%86%e8%a7%a3%e7%9b%b8%e5%85%b3/">文章</a>里了。</p><p>其实只是蹲坑的时候刷 Google Play，给我推荐了一个这玩意儿。看着画风还行，打开看看。嘛游戏内容（小人打架加一些反应要素）我就不感兴趣了（而且世界观的建构更是让人一脸问号），但是一些图啊模型啊还是不错的。（“穿着偶像衣服却不干偶像的事。” by 群友）饰品分离目前我只见过 Square Enix（<a href="http://schoolgirlstrikers.jp/">SGS</a>、京东娃娃）和 Konami（<a href="https://www.konami.com/games/tokimeki-idol/">心跳凉凉</a>）做过，大概还有一些参考价值？心跳偶像本来我想着跟土豆一样反向的，但是安卓严重混淆，我又没有越狱的 iPhone，没办法；后来……它就停服了。</p><p>有点远了。这次反向其实还挺简单的，esterTion 已经找到了关键的类和方法，所以省了很多事，只要耐心读就行了。他大概只是心急失手了而已。如果他又想吹我，您别听他的；我只是个弱渣。</p><p>IL2CPP 的反向比一般的原生代码要简单的一点是，它保留了很多 IL 的特征，C++ 编译器无法完全将它们优化。比如在这次挨个设置密钥数组元素的时候，就出现了很明显的一种模式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (array.metadata.length &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">throw_index_out_of_range_exception</span>();<br>array.elements[<span class="hljs-number">0</span>] = elem0;<br><span class="hljs-keyword">if</span> (array.metadata.length &lt; <span class="hljs-number">1</span>) <span class="hljs-built_in">throw_index_out_of_range_exception</span>();<br>array.elements[<span class="hljs-number">1</span>] = elem1;<br><span class="hljs-keyword">if</span> (array.metadata.length &lt; <span class="hljs-number">2</span>) <span class="hljs-built_in">throw_index_out_of_range_exception</span>();<br>array.elements[<span class="hljs-number">2</span>] = elem2;<br><span class="hljs-keyword">if</span> (array.metadata.length &lt; <span class="hljs-number">3</span>) <span class="hljs-built_in">throw_index_out_of_range_exception</span>();<br>array.elements[<span class="hljs-number">3</span>] = elem3;<br></code></pre></td></tr></table></figure><p>在反编译的代码中，上面都是用偏移表示的。虽然在没看 IL2CPP <code>Array</code> 的源代码的情况下，并不清楚这个结构每个偏移是什么（快去看，懒虫），但是根据这么几个连续的偏移规律，也能摸个大概。再想想对应的 C# 是怎么样的：</p><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">arr[<span class="hljs-number">0</span>] = elem0;<br>arr[<span class="hljs-number">1</span>] = elem1;<br>arr[<span class="hljs-number">2</span>] = elem2;<br>arr[<span class="hljs-number">3</span>] = elem3;<br></code></pre></td></tr></table></figure><p>在实际使用中，这个索引测试一般不是手工做的。因此可以猜测是在 IL2CPP 变换的过程中自动插入的片段，以保持语义一致（<code>ldelem.*</code>）。</p><p>与此类似的还有 IL2CPP 类型初始化（不是 <code>.cctor</code>）、IL2CPP 实例初始化（不是 <code>.ctor</code>）、加载静态的引用类型字段等等，生成的代码一看就知道是干什么的。这些重复的模式比起“一般的” C++ 来说要仁慈多了。</p><p>当然 C++ 编译器也不是吃素的，明显能优化的地方一定会优化。比如简单的 getter/setter，尤其是简单类型的自动属性，会被直接内联。我就说怎么一些属性的 getter/setter 无法被 xref，结果一看只要是简单赋值，全都跑到实际使用位置去了。而且恶心的是，这通常指的是指针+偏移访问。这就防住了简单的使用检索（find usage），如果是关键属性的话会非常头疼。</p><p>IDA 的 F5 并不能完美地反编译，有时候需要进入函数再出来，让它更新函数签名，特别是变参函数和看上去参数奇怪的函数调用。再比如，在 <code>MakeUrlCore()</code> 的关键调用签名更新完毕后，会发现有返回值没被使用的情况。而这些函数并没有修改 call site 所在实例的内部状态，这时就根据下文推断返回值使用的地方，而且可以回到汇编窗口验证。对，我说的是获取 UTF-8 字节数组之后计算 MD5 hash 的那一块。</p><p>如果对 .NET 比较了解，少数虚函数表里的调用也可以根据上下文推断。<code>string + Encoding.MethodX() -&gt; A; HashAlgorithm.ComputeHash(A)</code>，那么这个 <code>MethodX()</code> 就极有可能是 <code>GetBytes()</code>，即使是虚函数，而且（在 F5 中）缺少实参来判断。再比如，<code>StringBuilder.MethodY() -&gt; B; string.Concat(B, ...)</code>，那么这个 <code>MethodY()</code> 就极有可能是 <code>ToString()</code>，即使因为虚函数表+静态分析的原因无法看到实际调用的是哪个函数。这种思路跟中学的化合物推断是很相似的。</p><hr><p>说到反向，还有有趣的事情。上一周有一次组会的时候，我们预订的是学校最新的大楼的一个房间。那里面就有一个无线屏幕，可以把设备的屏幕无线地投射到显示器上。一个组员（本科生）说，他在另一门课（好像是 IoT Security 还是什么的）的小组就对这个屏幕使用的客户端下手了，写了一个非官方的客户端，能绕过一些限制来登录。</p><p>这肯定让我玩心大发啦。简单看了一下客户端，是一个无任何混淆的 WPF 应用程序。迅速扒光。然后跟着进入 P/Invoke 的原生库，稍微摸了一下结构。另一个是 C++/CLI 的 wrapper，依赖的是 C++ 的。在找不到公开文档和调试信息的情况下，后者基本是不可能静态分析的。</p><p>根据我原来看到的信息，我觉得这个系统的验证是存在漏洞的，理论上可以很容易地伪造用户登录和播放任意内容。不过刚才我看了更多的资料和代码之后否定了之前的想法。任意登录下降为<em>可能的</em>，在服务器配置存在特定配置缺陷的情况下；同时对登录有比之前所见的更大的限制。这就带来了攻击成本的上升和回报的下降，导致显得不划算。不过，反跟踪仍然是可以使用低成本的方式做到。</p><p>关于这个 WPF 程序的软件质量，我要称赞它，是软件工程的范本。遍地都是契约检查、防御性编程、打印日志（而且模糊了隐私信息），很专业嘛。</p><p>啊，本来还想着也许能做个白帽黑客的，不过现在看起来这个案例可能没什么能让我出手的地方了。</p><p>不过等到假期结束，我还是想亲手试试。</p><p>毕竟人家本科生都能做到的事情，我要是做不到，就太丢脸了。我虽然不知道他们做到了哪一步，但是必须要假设我想到的都已经完成了。</p><hr><p>说到假期，这个星期是<a href="https://en.wikipedia.org/wiki/Carnival_in_the_Netherlands">狂欢节</a>假期。因为艾因霍温在南部嘛，而狂欢节是南部地区在庆祝，所以我们就有了这么一个假期咯。</p><p>上周六和昨天晚上去超市的时候，路上偶尔会看见一些穿着“奇装异服”的人。在上面的维基百科链接中可以看到大概的样子。你也可以在<a href="https://www.local-life.com/eindhoven/articles/carnaval-in-eindhoven">这里</a>读到去年的样子。不过我没事又不经常出门，而且这还是在晚上，所以只能看见整个节日的一点点。狂欢游行什么的根本没有参与过，但是的确能在市中心看到不少散发着啤酒味的一次性杯子和几个临时的 live house。</p><hr><p>前几天开始我的左耳突然出毛病了。最开始的时候是时不时堵着，就跟坐飞机一样；但无法通过活动咽喉来解决，只能手动按压通气。而后一天晚上玩了一下 <a href="https://store.steampowered.com/app/210970/The_Witness/">The Witness</a>，不过饱和度太高，不久就中等恶心（我玩大多数游戏都没有3D眩晕），受不了了。第二天起来还没发现什么异常，但是联机打了一局黑魂之后就发现对敌人的听觉定位不准了——正中的声源，会听起来偏右。再自言自语的时候就感觉颅内传导的声音，右耳出去了，但左耳好像碰到了什么，反射回来一部分，形成了混响。</p><p>虽说现在已经要找医生了，但是还得先处理别的麻烦事——验证邮件收不到，就无法完成电子身份认证，就无法预约。而现在正是狂欢节假期，不知道会不会影响。即使是能预约了，按照我的经验，也得等至少一个星期。这时候我就很怀念国内的挂号了。</p><p>所以……没办法咯，只好先习惯目前的处境，调整大脑的处理方式，希望之后不会耽误什么。</p><p>哇，如果听不见声音的话（或者只能借助于骨传导），我可会很难过的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GRIS 的文章呢？&lt;/p&gt;
&lt;p&gt;别急，不会鸽的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。&lt;/p&gt;
&lt;p&gt;那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。）&lt;/p&gt;
&lt;p&gt;反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。&lt;/p&gt;</summary>
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="逆向工程" scheme="https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="手游" scheme="https://blog.mottomo.moe/tags/%E6%89%8B%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>新年</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/</id>
    <published>2019-02-04T23:42:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。</p><p>如果有人关注我最近的活动的话或许会注意到，这半年来我推代码的频次相较以往同期要少。嗯，首先是 CS 确实很有意思，而且以我的基础可以看得比较全面（能自然地看见“点”之间的“线”），这样要深挖的就多多了。HTI……我的思维运转方式不是那样的，所以除了课上讲的冰山一角，基本都看不清，所以业余时间都投入到代码上了。</p><p>还有一个原因是我希望做一个更<em>有趣</em>的人。除了抽象的代码，我也乐于欣赏艺术创作。欣赏久了，自然就产生了投身于创作的想法。就像笼中之鸟羡慕飞翔的鸟儿一样。以我的性格，要是只能代码一条路走到黑我肯定要抹脖子了。临渊羡鱼，不如退而结网。</p><p>在B站上我之前一般是做烧笋的创作谱面；去年因为造一些轮子所以发了一些成果视频。这是我放松的一个选择。但是这毕竟形式非常单一而且（我认为）总是摆脱不了无生命感。——写谱面，在许许多多的规则之下，发挥的余地其实比较少（我不是硬核玩家），而且普遍关注的是技术难度，缺少要表达的主题。每一种艺术都不过是表达的方式，私以为代码也是这么一种手段；有的人擅长这种，有的人擅长那种，仅此而已。当然观众也得有相应的鉴赏能力。</p><p>所以我就想了，要是投入等量的时间，能让一种技能从70上升到75，或者让另一种从0上升到15，该如何选择呢？事实上这和 RPG 游戏加点一样是个一直困扰着我的难题。我选择在艺术上从0加到15，很清楚这并不会带来“一技傍身”的优势，而是希望借由将自身化为艺术创作者，去理解他们的视角和思维，会遇到什么问题，我的方案比别人差在哪里或者好在哪里。</p><p>继最开始的简单剪辑（<a href="https://www.bilibili.com/video/av34419159">1</a>、<a href="https://www.bilibili.com/video/av36992638">2</a>）之后，我开始尝试其他的形式：混搭（<a href="https://www.bilibili.com/video/av37445247">1</a>、<a href="https://www.bilibili.com/video/av37593014">2</a>）、手书（<a href="https://www.bilibili.com/video/av38332164">1</a>、<a href="https://www.bilibili.com/video/av42680447">2</a>）、<a href="https://www.bilibili.com/video/av39367371">MAD</a> 和<a href="https://www.bilibili.com/video/av40274183">改谱</a>（远算不上编曲）。每个作品的个中滋味恐怕都不是一两段话能说完的，也并不只是视频简介里的那些。当然，创作水平肯定是无法一蹴而就的。所以除了我自己的练习和体悟之外，我希望寻找更新的<em>想法</em>，希望它们也确实地传达给观众了。反正又不图名又不图利，若是能被欣赏，或进一步地，在此基础上衍生创作，丰富大环境，那就是更好的了。</p><p>那么近况如何呢？我确实在大脑没退化的前提下比之前更快乐了。比之前整天在代码上挖掘，望天叹气要好多了。我觉得这偶尔的音乐、绘画和视频创作是有一份功劳的。自己有趣不有趣……还不知道。至于产出的效益，那要等时间来回答。</p><p>胡乱说了一些话，权当跨（农历）年的一篇吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。&lt;/p&gt;
&lt;p&gt;如果有人关注我最近</summary>
      
    
    
    
    <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>NW.js 的上下文问题</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/</id>
    <published>2018-12-19T11:03:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>NW.js 有一个或两个上下文，使用时要多加小心。</p><span id="more"></span><hr><p>最近因为做项目，需要用到 NW.js。在搭环境的时候，我自然要写一个最简单的功能来测试了。我的例子是一个关闭按钮。简明起见，下面的代码复现的是在第二次试验。注释“2”的是第二次测试添加的输出，“1”是第一次的。</p><p><code>bootstrap.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;imported&quot;</span>); <span class="hljs-comment">// 2</span><br>main.<span class="hljs-title function_">bindCloseKey</span>();<br></code></pre></td></tr></table></figure><p><code>bootstrap.ts</code> 是编译为 ECMAScript 5 之后，加了个简单的兼容片段（解决 <code>exports</code> 找不到的问题），直接从页面链接的。</p><p><code>main.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;exported&quot;</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bindCloseKey</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;called&quot;</span>); <span class="hljs-comment">// 2</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">button</span>: <span class="hljs-title class_">HTMLButtonElement</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#close&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!button) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button not found: &quot;</span> + selector); <span class="hljs-comment">// 1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button found&quot;</span>); <span class="hljs-comment">// 1</span><br><br>        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">close</span>();<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要功能如上所示，功能很简单，如果找到按钮就尝试绑定事件，不管找没找到都有一个输出。</p><p>但奇怪的是，实际运行的时候，点击按钮没有反应；打开开发者控制台（直接按 <kbd>F12</kbd>）却看不见任何输出。</p><p>于是加了几条注释之后再跑，只见到了第一条输出，也就是“imported”。</p><p>那么其他的输出在哪里？功能到底执行了没有？我猜想是目标问题，于是切换到 ECMAScript 6，顺便认识和试用了一下 <a href="https://nodejs.org/api/esm.html">ESM</a>（就是那些 <code>.mjs</code> 文件），但问题还是没有解决。</p><p>无奈之下只好谷歌了。但是大多数人是希望将开发者控制台的输出重定向到系统控制台（确实有<a href="https://stackoverflow.com/a/38972028">解决方案</a>，在     <code>package.json</code> 里加入 <code>&quot;chromium-args&quot;: &quot;--enable-logging=stderr&quot;</code>），我是纳闷为什么看不见开发者控制台的输出。结果发现了<a href="https://stackoverflow.com/a/35127692">答案</a>，也就是该做的是手动右键检查背景页；<kbd>F12</kbd> 是审查应用的当前页，而 NW.js 的 app 是作为扩展载入的，所以两个页面不同。</p><p>考虑到项目完工时手动右键检查背景页未必可用，我想了一个变通的方法。<code>console</code> 看上去是个全局对象，实际上是 <code>window</code> 的属性。那么我将 <code>window</code> 的引用传过去不就好了？</p><p><code>bootstrap.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main&quot;</span>;<br><br>main.<span class="hljs-title function_">setWindow</span>(<span class="hljs-variable language_">window</span>);<br>main.<span class="hljs-title function_">bindCloseKey</span>();<br></code></pre></td></tr></table></figure><p><code>main.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">$window</span>: <span class="hljs-title class_">Window</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">setWindow</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span>: Window</span>): <span class="hljs-built_in">void</span> &#123;<br>    $window = <span class="hljs-variable language_">window</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bindCloseKey</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">button</span>: <span class="hljs-title class_">HTMLButtonElement</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#close&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!button) &#123;<br>        $window.<span class="hljs-property">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button not found: &quot;</span> + selector); <span class="hljs-comment">// 1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        $window.<span class="hljs-property">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button found&quot;</span>); <span class="hljs-comment">// 1</span><br><br>        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            $window.<span class="hljs-title function_">close</span>();<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次能看到输出了。但是显示的居然是“Button not found”！</p><p>我再次确认了，HTML 页面是能找到这个按钮的元素的。好吧，手动执行一下试试。分别在 app 页和背景页的开发者控制台执行 <code>document.querySelector(&quot;#close&quot;)</code>，前者返回的是 <code>null</code>，而后者返回了一个 <code>&lt;button&gt;</code>。</p><p>这下我就知道为什么了。两个页面之间有一堵无形的“墙”，一个负责前台（Chromium 端），一个负责逻辑（Node.js 端），有点类似 WebWorker。但和 WebWorker 不同的是，这个隔离的双方都能访问通用全局对象（<code>window</code> 等等），然而访问的却不是同一个对象。上面 <code>$window.console</code> 来自“能和页面交互的” <code>window</code>，<code>document</code>（实际上是 <code>window.document</code>）来自“不能和页面交互的” <code>window</code>。</p><p>后来再看，原来是 0.13 加入的上下文分离，在 NW.js 的<a href="http://docs.nwjs.io/en/latest/For%20Users/Advanced/JavaScript%20Contexts%20in%20NW.js/">文档</a>里其实也写明白了。调试不同上下文的代码则需要分<a href="http://docs.nwjs.io/en/latest/For%20Users/Debugging%20with%20DevTools/#nodejs-modules-debugging">不同的开发者工具</a>。用 <code>require()</code> 加载的模块都会运行在 Node.js 上下文中，路径解析和能访问的对象都是和浏览器上下文不同的。Node.js 上下文中确实有一个 <code>window</code> 对象，但指向的是<strong>背景页</strong>。如果需要在 Node.js 上下文中访问浏览器的对象，包括全局对象，必须要将这个对象传递过去（就像我上面做的那样）。当然如果偷懒可以用文档后面提到的上下文混合模式（mixed context mode），但它有潜在的上下文不同导致的问题（路径、原型链；见文档）。所以最保险的方法就是在设计的时候就注意，尽量将前后完全分离，消息交换只用上下文无关的对象（例如普通的 <code>&#123;&#125;</code>、<code>Object.create(null)</code> 创建的对象）。</p><p>那么既然上面说在上下文混合模式下会有问题，那么默认的上下文分离模式（separate context mode）下，传递对象会不会出错呢？答案是不会。NW.js 自动处理了对象封送，在传递的时候切换了上下文。我们可以做一个小实验。</p><p><code>bootstrap.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;From Chromium? &quot;</span> + (<span class="hljs-variable language_">window</span>.<span class="hljs-property">close</span> <span class="hljs-keyword">instanceof</span> (<span class="hljs-variable language_">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">Function</span>));<br><br>main.<span class="hljs-title function_">testWindow</span>(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><p><code>main.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testWindow</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span>: Window</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Context of Node? &quot;</span> + (<span class="hljs-variable language_">window</span>.<span class="hljs-property">close</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>));<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Context of Chromium? &quot;</span> + (<span class="hljs-variable language_">window</span>.<span class="hljs-property">close</span> <span class="hljs-keyword">instanceof</span> (<span class="hljs-variable language_">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">Function</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">From Chromium? true<br>Context of Node? true<br>Context of Chromium? false<br></code></pre></td></tr></table></figure><p>由于 <code>main.ts</code> 是被用 <code>require()</code> 加载的，所以它运行在 Node.js 的上下文下，直接访问全局的 <code>Function</code> 访问到的是 Node.js 的 <code>Function</code>。而传入的 <code>window</code> 参数，原对象是在 Chromium 上下文中的。访问它带的 <code>Function</code>（不会被重新指派上下文）访问的到的是 Chromium 的 <code>Function</code>。由此可见，在对象传递过来的时候，也包括传递回去的时候，对象的上下文都会自动发生变化。</p><p>可能要问了，既然是上古版本更新引入的分离，为什么我以前没发现呢？因为以前为了做即时示例，要在没有 Node.js 的浏览器环境下运行，所以都用了 Browserify。这样在 NW.js 中实际上所有代码都是在 Chromium 的上下文里执行的，不会引发问题。而这次我并没有想把它完全部署为普通网页，就用了分文件、模块加载（毕竟 NW.js 也支持 <code>require()</code>），这下上下文分离的事实立马就暴露了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NW.js 有一个或两个上下文，使用时要多加小心。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="NW.js" scheme="https://blog.mottomo.moe/tags/NW-js/"/>
    
  </entry>
  
  <entry>
    <title>老虎和兔子中的一段浪漫悲剧</title>
    <link href="https://blog.mottomo.moe/categories/ACGN/zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny/"/>
    <id>https://blog.mottomo.moe/categories/ACGN/zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny/</id>
    <published>2018-11-12T12:33:00.000Z</published>
    <updated>2023-04-09T06:24:26.202Z</updated>
    
    <content type="html"><![CDATA[<p>以前我写过<a href="/categories/ACGN/zh/2016-04-27-Regios-Kokuhaku/">钢壳都市雷吉欧斯中的告白台词</a>。今天我又看到了一出打动人的浪漫戏，《老虎和兔子》（Tiger and Bunny）第15集。嗯，这集本身是一个插曲，但也是主线剧情的关键转折点之一。</p><p><strong>注意：本文有（严重）剧透。</strong></p><span id="more"></span><hr><p>这一集的主角是空天（スカイハイ，Sky High）。空天是所有英雄中最为单纯的一个人，这点在前面的剧情已经提及了。动作细节（本想直接拿苹果，但想了想，在衣服上擦了擦才伸手）和语言（还要算上声优表现出的语气）说明，他也是一个正统的绅士。</p><p>空天和神秘少女在公园的喷泉前相遇了。怦然心动。空天每天晚上都会巡逻。空天多次在喷泉前碰到少女。身在低谷期、人又不擅表达的空天，在多次向一直“聆听”的少女倾诉后，逐渐发现了怎么走出低谷。同时他也意识到了自己的想法。因为偶然，老虎和兔子在夜间抓到了邪恶的博士。博士说出了真相。</p><p>悲剧的因素齐了。</p><p>空天在不知情的情况下，亲手击毁了已经化为武器的人造人少女。讽刺的是，在处决面前这个“怪物”的时候，空天作为动力所回忆的，是那个少女。</p><p>虽说我早已猜到是这样，但是在表现手法等种种因素的作用之下，我还是唏嘘不已。</p><p>不过这还没完！事件结束后的这一段，才是最让我惊叹和赞美的。</p><p>从鼓励完老虎和兔子（约20:45）开始，是本集的第二高潮：空天前去和少女道谢。接下来的<strong>所有</strong>卡，空天的兴奋之情都溢出了屏幕。（分镜和演出，精彩啊！）</p><ul><li>空天从镜头前走过。由于太近，只能看到他身体的中间部分。但是这个卡的重点是背景二人的惊讶表情。以他们这么久的合作对空天所知，在那么短的时间内就采取这么激进的措施，实在不像平常所为。很可能是冒失了。因此他们才会十分惊讶。</li><li>空天走出更衣室。这时候镜头给的是从后方，略低于小腿处看过去的背影。背景的视场（field of view）相比于上一卡突然变小了，观感上就增加了深度（过道的长度）。这个过道的另一端是白光，就跟影视作品常用的 HDR 效果差不多（现实中 HDR 没有这么强烈）。但是同时也有可能是在暗示“向着他的光明”（也就是少女）。这里的空天虽然还是在走，但是和前面对比可以知道，是加快了步伐的。</li><li>接下来是在花店买花。两个卡，一个背面的中景，一个前侧的近景。表情上看不出来什么，因为空天一般情况下都是微笑的。但是当他接过了红玫瑰和白玫瑰组成的花束后，停顿了一小会儿，把它微微地抱得更紧了。</li><li>镜头转到橱窗前。从倒影中（没想到啊，突然来了这么少用的一手）看出，空天无意间扭头，注意力转向了橱窗里的商品，面露少许疑惑。橱窗里是裙子、挎包和新款式裙子的宣传海报。他用手指轻轻了两下敲太阳穴，表情渐渐变回了微笑。（我一开始觉得也有把橱窗当作镜子，照镜子的可能；但是仔细一想，橱窗内无灯，外面是自然光，这样对着橱窗是看不清自己的镜像的。）他可能是在想如果成功后送给她的礼物。毕竟英雄这份职业的收入不算高（想想其他几位就知道了），价格是要考虑考虑的。这说明空天对这次见面的准备十分用心。</li><li>下一个卡中，空天已经来到了公园。镜头给了个大半身的中景。他从右向左走过画面。在画面正中央，扭头发现远景中在长椅上靠在一起的情侣时，他略微停了一下，接着快速把头转回他的前方，微微弓身前倾，小步跑了起来。</li><li>紧接着的卡，大楼的巨幕播放着他作为英雄时的英姿（之前，这块屏幕播放的是大红大紫的老虎和兔子）。这块屏幕也很有意思，从空中往下看，它是放在大楼这个长方形的角上的；为了容纳这么大的屏幕，大楼的最上面四层都像蛋糕被切开一样，从而造出一个大平台。屏幕中，作为英雄的空天是巨大的。屏幕下，与渺小的路人无异的他依然抱着花束，弓着身，急匆匆地跑过路口。一方面是公众身份，一个英雄；另一方面是个人身份，一个普通市民。他在之前与少女的交流中一直隐藏着英雄的身份，然而那却其实是他更广为人知的一面，他作为普通人，更是作为英雄，被少女所激励。经典的身份二重性。</li><li>接下来的卡，镜头大约在腰部的位置，朝向侧上方。空天从右下角的“远处”跑来（此时已经不弓着身了），到画面正中。他进入画面后本想呼唤少女的，但是嘴才微微张开（逐帧观察，不像是作画或上色失误；表情也略显得焦急），就立即合上了。接着立定，闭眼整理了一下心情，将花轻轻抱得更紧一点，恢复微笑之后，空天缓缓走向左下角的“近处”。为什么有这个反应呢？联系接下来的三个卡就知道了。</li><li>接下来的三个卡。<ul><li>近景，半身，空天在画面右半边坐下。这里的镜头距离是，如果两个人靠在一起坐着，那么画面底部就刚好能被填满。可是这里长椅的一端是空的。但是感觉画面不算太空，是因为还有花束在。空天稍微定了定神之后微微扭头看向空出来的位置；镜头也配合地向左平移，虽然只有不到一秒。</li><li>他看到的只有长椅。此时镜头居然在拉远。为什么不是顺着空天的愿望去推近，而是要拉远呢？因为这是在陈述客观事实。</li><li>镜头再转回来的时候，已经看不到椅子，也就看不到另一端了。空天的肩膀占满了画面的底部。又这么凝视了一会儿，空天眨了眨眼，扭头，保持着标准微笑，目视前方（正对镜头）。</li></ul></li><li>最后的一卡，用的是他们初次见面时最后的远景和拉远。但是这次，长椅上只在半边坐了一个人。喷泉没有喷。原本周边空荡荡的，仿佛二人世界；这回变成了空天一人，和空地上的数个市民。他或许找回了最初的动力，作为市民的榜样。但是也如暗示的，她已经不会再来了。作为观众，我们知道这个等待注定是徒劳的。但是按照空天的性格，他一定会等到最后。（知道真相的话会受到多大打击！然而他们这件事也没别人知道，见过少女外形的除了他，只有老虎和兔子。问的话那对粗心基友大概会想不起来，根本没留意。所以就更纠结了。）</li></ul><p>其实喷泉很明显是经典爱情电影的隐喻，至少是桥段，比如《罗马假日》。这一集的配乐，对，就是那首舒缓的弦乐，仅出现在这一集；风格上我觉得会类似爱情电影吧。最后这段的镜头设计比起电视动画，更像是电影。哎其实我也没看过爱情电影，想想套路就觉得肉麻到不行，看别的去了。所以在讲述上面的镜头设计时文字苍白无力。</p><p>看了这第15集后，我就没再往下看了。剧情已经大概了解，但是很难说接下来会不会出现更亮的点，没有的话就会索然无味。</p><hr><p>2022-05-10：</p><p>突然想起来，相爱但因为种种巧合认不出最后相杀的剧情设计，上述也早就不是第一个了：<a href="https://zh.moegirl.org.cn/%E5%B7%B4%E7%BA%B3%E5%BE%B7%C2%B7%E6%80%80%E5%85%B9%E6%9B%BC">已经可以不用再战斗了，巴尼。</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前我写过&lt;a href=&quot;/categories/ACGN/zh/2016-04-27-Regios-Kokuhaku/&quot;&gt;钢壳都市雷吉欧斯中的告白台词&lt;/a&gt;。今天我又看到了一出打动人的浪漫戏，《老虎和兔子》（Tiger and Bunny）第15集。嗯，这集本身是一个插曲，但也是主线剧情的关键转折点之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：本文有（严重）剧透。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACGN" scheme="https://blog.mottomo.moe/categories/ACGN/"/>
    
    
    <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>The &quot;New&quot; Encryption of HCA Audio</title>
    <link href="https://blog.mottomo.moe/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/"/>
    <id>https://blog.mottomo.moe/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/</id>
    <published>2018-10-12T13:34:00.000Z</published>
    <updated>2020-03-30T22:34:35.362Z</updated>
    
    <content type="html"><![CDATA[<p>中文版本见<a href="/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/">这里</a>。</p><p>Recently CRI Middleware updated their latest ACB archives’ format, and they seemed to have updated encryption of HCA files as well. As a result, the old toolsets can do nothing on the updated files. After about 20 hours of research I finally found what they changed on the decryption. Might be the first in the world, again. This is what’s called “highlight moment” in reverse engineering. XD</p><p>The final answer is somewhat simple: transform the decryption key, and use the transformed key to initialize the decryption table. The formula is <code>key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))</code> where <code>key</code> is the input key and <code>k2</code> is a secondary key stored in the higher 16 bits of “field alignment” field, in each ACB/AWB file.</p><p>This article is about the way and thoughts of finding this transformation. It is roughly recorded in time order. I hope these materials may help someone in the future.</p><p>My result is based on various people’s works. Without thoses pieces, the whole puzzle cannot be completed. So a big thank you for everyone involved.</p><p><span style="color: red;"><strong>Be noted again: the contents in this article must not be used for commercial purposes.</strong></span></p><span id="more"></span><hr><p>* “Decode” in the text below may mean decode after decrypting when applicable.</p><p>* Sorry about the broken tenses in the last paragraphs. I was too tired to fix them all.</p><h1 id="1-Prelude"><a href="#1-Prelude" class="headerlink" title="1. Prelude"></a>1. Prelude</h1><p>As the new game Dragalia Lost (ドラガリアロスト) is released, CRI Middleware revealed their updated audio technology. As for me, a guy who does not play games in the “normal” way, I care about resource extraction more than how it displays in the game. Forward thinking is what I should do as a game developer, and reversed thinking is for the cracker identity (not “cracker” as in “cookie” :P).</p><p>This update updates ACB version from 1.29 to 1.30. Although it is a minor upgrade, it brings a trouble that, HCAs cannot be decrypted even with the correct key. It began with an <a href="https://github.com/hozuki/libcgss/issues/4">issue</a> created by FZFalzar. When I received the email, I didn’t know or understood what was going on. In the next day, esterTion posted a screenshot of a comment in his <a href="https://estertion.win/2018/09/dragalialost%E9%80%9F%E8%A7%88/">blog article</a>, saying that someone is not able to decode extracted HCA with the game provided. I recalled that the key is the one I saw in that issue, so this must not be a coincidence. Together with the information FZFalzar provided, the new tools should have changed something, which might break backward compatibility. I could imagine if the same measure is applied on CGSS or MLTD, or other games, maybe, a doom for audio extraction. So I decided to challenge it.</p><h1 id="2-Initial-Analyses"><a href="#2-Initial-Analyses" class="headerlink" title="2. Initial Analyses"></a>2. Initial Analyses</h1><h2 id="2-1-File-Analyses"><a href="#2-1-File-Analyses" class="headerlink" title="2.1 File Analyses"></a>2.1 File Analyses</h2><p>The first thing to do is analyzing the files to see whether there are some “odd” values.</p><p>Since I already had an ACB extraction tool (<code>AcbUnzip</code>), I directly dragged the attached ACB on it. Unexpectedly, <code>AcbUnzip</code> crashed, only throwing an exception and creating an empty file. I also tried VGMToolbox, which created 6 files, but all of the files were empty too.</p><p>Since I wrote <code>AcbUnzip</code>, I could debug it. I found that the difference of the number of files is caused by the difference of the numbers of cues and tracks. There was only one cue, but there were 6 tracks (3 in internal AWB and 3 in external AWB). But the bigger problem was that, though I had the information of file entries, I could not extract them. The file sizes were negative numbers with extremely large absolute values! After narrowing down by instrumentation, I saw that the value of “field alignment” fields in AFS2 (the file structure used by AWB) was quite strange. According to VGMToolbox, it should be a 32-bit unsigned integer. From the past experience, the value is usually 32. However this time, it was far larger than the file size.</p><p>The most common guess should be there is a mask. So I looked at the value in hex digits. The lower 16 bits were <code>0x0020</code>, which is 32; the higher 16 bits were something unknown. Obviously, it is masked by <code>0x0000ffff</code>. I successfully extracted all HCA files after doing this.</p><p>The exception was the first piece of the puzzle. Besides applying a mask, it also exposed the fact that the layout of AWB had changed. As I said, since the field offset (32-bit unsigned integer) was usually 32, which is far smaller than 65535 (<code>0xffff</code>), its higher 16 bits were actually reserved. Here I began to doubt if CRI did use the higher bits as reserved and attached some other meanings to them. But I still could not determine whether they were random numbers (to disturb analysis) or they do have a meaning.</p><p>After the HCAs were extracted, it was time to take a view on them. They looked normal: no unknown header parts or blocks, no out-of-range values, and no additional information added. The only recognizable thing was the size of HCA header extended from 96 (CGSS/MLTD) to 397. But except for known fields, the header was filled with zeros.</p><p>Here I made 3 assumptions:</p><ol><li>The actual size of the HCA header can affect the decoding choices of the decoder. You can think it as a hidden version information apart from the “version” field in the HCA header.</li><li><code>comp1</code> to <code>comp10</code> (referring to the HCA decoder) were set to some meaning values that affect the decoding process. I did not know what those fields mean so I was unable to proof or deduce only by observing.</li><li>Nothing was changed. The file was still a traditional HCA.</li></ol><p>All these assumptions were possible, requiring more materials to proof or falsify.</p><p>At this point, the limit of file analyses was reached.</p><h2 id="2-2-Next-Directions-of-Investigation"><a href="#2-2-Next-Directions-of-Investigation" class="headerlink" title="2.2 Next Directions of Investigation"></a>2.2 Next Directions of Investigation</h2><p>Just as I replied in the issue, after some observations, considering the updating speed of the technology, iteration cost (time and finance), I thought of 4 most possible possibilities:</p><ol><li>The decoding process was changed.</li><li>New branches were introduced in the decoding process.</li><li>Precomputed tables were changed.</li><li>Real decryption key was different from the input key.</li></ol><p>Of course their combinations were also possible in reality. Here let me explain the details of each possibility.</p><p><em>The first possibility.</em> The new decoder employed an entire new theory. This means huge changes in theory and code, which can be seen as a new audio format. CRI should not have enough time and financial support to do this.</p><p><em>The second possibility.</em> Think about the values of <code>comp1</code> to <code>comp10</code> mentioned above. Considering known code structure of the public decoder, if new branches were introduced to handle values that never appeared before (in the context of code, <code>if</code>), then new branches or new tables would be logical. I thought it possible, but proving is hard. It depends on the decompiled code.</p><p><em>The third possibility.</em> Since the core of decoding is value mapping using the precomputed tables, could the tables themselves were modified (the code should also be updated) so that input were mapped to different outputs? This thought also depends on decompilation.</p><p><em>The fourth possibility.</em> This is a two-phase encryption. The overall process was untouched but the key was transformed internally, or a decryption table different than the previous one was generated using the same key. Obviously this is the most probable way. All you need to do is adding a few lines of code, and all the public decoders stop working. The cost is close to zero. Combining with the decoding workflow of HCA, in validation, decryption and decoding, a process does not influence the previous one(s). So the key can be easily set to a new one. (By the way, this is also how <code>hcacc</code> <a href="https://github.com/hozuki/libcgss/blob/master/docs/behind-the-scenes.md">works</a>.)</p><p>However my guess was that the key was modified before initializing the decryption table. For that I was wrong.</p><h2 id="2-3-Initial-Feedback"><a href="#2-3-Initial-Feedback" class="headerlink" title="2.3 Initial Feedback"></a>2.3 Initial Feedback</h2><p>Because I could only obtain a lite version of the SDK (ADX2LE SDK), which does not support encryption and decryption, and FZFalzar had the full SDK (ADX2 SDK), I asked him to start with some tests. While those tests are in progress, I began the initial reverse engineering on tools in ADX2LE SDK.</p><p>I had a question above: is the new SDK backward-compatible? It can play the latest ACB, but can it play old ones? Whatever the answer is, it would help eliminate false guesses. My personal guess was the new SDK is not backward-compatible, but the test results disagreed. According to the fact I believed that there was not an all-new <del>all-different</del> decoder and tables were unlikely to change. The greatest change would be adding branches and tables, at most. If we got lucky, it would be much easier.</p><h1 id="3-Following-Analyses"><a href="#3-Following-Analyses" class="headerlink" title="3. Following Analyses"></a>3. Following Analyses</h1><h2 id="3-1-Following-Analyses-of-ACB"><a href="#3-1-Following-Analyses-of-ACB" class="headerlink" title="3.1 Following Analyses of ACB"></a>3.1 Following Analyses of ACB</h2><p>FZFalzar found out that the SDK cannot play extracted HCAs (not being packed inside ACB/AWB) with correct keys. He thought maybe the something got into the metadata of ACB. So I checked the new structure of ACB using <a href="https://github.com/hcs64/vgm_ripping/tree/master/multi/utf_tab"><code>utf_tab</code></a>. The first apparent change was the update of format version. CGSS uses version 1.23.1, MLTD uses 1.29.0, while this one was in 1.30.0.</p><p>From my experience learned from MLTD’s ACB upgrade (compared to CGSS), upgrading usually means adding new tables. Current ACB format can only use a limited number of fields (for easy coding?), so it reserved several slots in the end. CGSS (1.23.1) had 18 reserved slots (R0 to R17), and in MLTD (1.29.0) there were only 12 (R0 to R11). And this time (1.30.0), a new table <code>SoundGeneratorTable</code> was added compared to MLTD. Could this table influence HCA decoding? I thought not. In the sample ACB, the size of this table was zero. If this table is used as a switch, CRI could have chosen a much simpler type. If it is a table and it does have influence, it should not be empty, but filled with some meaningful data.</p><p>I did not find other important differences in this sample ACB besides this new table. Some control tables, such as <code>TrackCommandTable</code>, <code>SynthCommandTable</code> and <code>TrackEventTable</code> is not yet parsed, they should not play such row because of their usages in history. To be sure, I modified some values and tested, with no luck.</p><p>At this time, FZFalzer sent the player (Atom Viewer, 2.25.14) in the latest full SDK. Finally I was able to test the keys.</p><p>During testing, I discovered something interesting. I mentioned before that in the header of AWB there were 16 unknown bits (2 bytes) in “field alignment” field. This time I tried to modify those two “garbage” bytes. I tested these combinations with the new player:</p><ol><li>ACB from CGSS (internal AWB), with no modification. (These 2 bytes were always <code>00 00</code> in previous ACBs.)</li><li>ACB from CGSS, with modification.</li><li>ACB from Dragalia Lost (external AWB), with no modification.</li><li>ACB from Dragalia Lost, modified internal “garbage” bytes only.</li><li>ACB from Dragalia Lost, modified external “garbage” bytes only.</li><li>ACB from Dragalia Lost, modified internal and external “garbage” bytes.</li><li>ACB from Dragalia Lost (internal AWB), with no modification.</li><li>ACB from Dragalia Lost, modified “garbage” bytes.</li></ol><p>If the AWB is an external one, the information in ACB will declare that the AWB is a streaming one. Inside ACB it will also store a copy of the header of the AWB. So I thought it was necessary to test both internal and external modifications.</p><p>Guess which ones could be played normally? The answer is 1, 3, 4, 5, 6 and 7. Yes, all combinations from 3 to 6 could be played. This was a bit strange but it might be a mistake during test. Now that the decryption is already retrieved, there is no need to test them again. But you can still try it if you like.</p><p>The results showed that even ACBs in old versions could not be played with those two bytes modified. So these two bytes must be playing some kind of roles. But where the switch is and how are the bytes involved, were still unknown.</p><p>Later FZFalzer tested 2017 version of the SDK (possibly the one MLTD uses) and reported that it could not play the new ACBs. Therefore, the breaking change exists between these two versions.</p><h2 id="3-2-Other-Simple-Trials"><a href="#3-2-Other-Simple-Trials" class="headerlink" title="3.2 Other Simple Trials"></a>3.2 Other Simple Trials</h2><p>Considering that there were 6 HCAs in the ACB, and they were in two groups, members in which were of the similar size. Could they be XORed? I tested this possibility but the answer was no.</p><p>What about between groups? Like simple cyclical passwords with short key and long encrypted text? Nope.</p><p>How about direct key manipulation? Assuming that those two bytes are used, but none of adding, substracting, shifting or masking worked.</p><h1 id="4-Decompiling"><a href="#4-Decompiling" class="headerlink" title="4. Decompiling"></a>4. Decompiling</h1><p>All other methods were run out. I had to use the last resort, decompling. Decompling can almost solve all problems, but also with very high costs. It requires massive time, energy, techniques and experience. I was not sure if I can solve the problem before I reach my limit.</p><p>The materials i had were ADX2LE SDK (mainly Win/X86) and the APK from Dragalia Lost (Android/ARM32). Later the new player (Win/X86-64) was also used.</p><h2 id="4-1-Initial-Analyses-on-Setting-the-Key"><a href="#4-1-Initial-Analyses-on-Setting-the-Key" class="headerlink" title="4.1 Initial Analyses on Setting the Key"></a>4.1 Initial Analyses on Setting the Key</h2><p>This step began at the same time when I asked FZFalzar to do the compatibility tests. My intention was looking at the usages of the key after it is set. The entry point was quite obvious, the well-known <code>criWareUnity_SetDecryptionKey()</code>.</p><p><img src="/images/crack-hca-dragalia/01.jpg" alt="Decryption setting in Dragalia Lost, level 1"></p><p>Statically trace to the location above. The first thing we can see is that the input key is not changed during this process. Another noticable point is, the input key, or the original key, has passed the file verification. Now follow the decryption setting of Atom (audio decoding component) to the next level.</p><p><img src="/images/crack-hca-dragalia/02.jpg" alt="Decryption setting in Dragalia Lost, level 2"></p><p>Here we run into some troubles. There are lots of global variables and unknown arrays or class members. But by looking carefully you can see that the key is only printed out (to the debug output) here, with some data whose meanings are unknown. If you know a little about the C language, you may have noticed that the call to <code>sub_CEF9C()</code> is problematic. According to its arguments, it should be something like <code>printf_s()</code>, or at least a function with variable arguments. But in the assembly code it is still like this in the picture. The problem is we don’t know what that function outputted. Statical tracing shows the original value of the key is assigned to <code>dword_17AC90</code>, which was not used in the decompiled code. In assembly code, it is set to a register (then its value is assigned to a class member) but not pushed into the stack. Well I can’t get anything more from this, because I don’t know too much about ARM stuff. This lead ends here.</p><h2 id="4-2-Analyzing-ACB-Generation-and-Reading-Processes"><a href="#4-2-Analyzing-ACB-Generation-and-Reading-Processes" class="headerlink" title="4.2 Analyzing ACB Generation and Reading Processes"></a>4.2 Analyzing ACB Generation and Reading Processes</h2><p>FZFalzar mentioned the library <code>CpkMaker.dll</code> in the SDK. He said in the new versions the alignment is set to a large value, while it is 32 unless manually assigned in the old SDKs. Let’s take a look.</p><p>Although I don’t have the full SDK, but LE is sufficient for making an impression of code structure. <code>CpkMaker.dll</code> is a .NET assembly, which is out of my estimation. It is written in C++/CLI, apparently. So what are the other libraries that are easy to decompile? From previous exprience I already knew <code>AudioStream.dll</code> is an assembly. From its UI, Atom Craft is obviously a Windows Forms application. With these as an entry point, I found <code>CriAtomGears.dll</code> and <code>AcCore.dll</code>. <code>AtomPreview.dll</code> (who exports some APIs similar to the runtimes of CRI products) and <code>AtomPreviewer_PC.exe</code> are native PE binaries. Managed code for encoding/decoding, or packing/unpacking are not found in these assemblies, so they are definitely inside those native binaries.</p><p>Atom Craft has two playback modes. If you import an audio file (which they call “material”) and play it in the Materials panel, it is the audio file itself that is played. But, if you add the audio file into one of the cues, open Session window (in menu View - Session Window), drag the cue onto the list in Session window, and then click the play button, Atom Craft will generate and ACB (content encoding is specified  in project settings) and play the ACB file. This difference means behind the different playback handling, there is a invocation from managed code to native code; whether it is P/Invoke or C++/CLI is yet to be tested.</p><p>Therefore I try to find the click event. The window name itself is a hint. After painful searches I found it. (I have to say, the code sucks, and assemblies are not well divided.) But the mechanism is not so direct as I think. It uses a C/S architecture. Sending (commands) and receiving (events) are all based on messages. The messaging seems to be wired through sockets. So at run time, Atom Craft starts a native server, and the calls are actually RPCs. As for encoding and packing, it references <code>AudioStream.dll</code> and <code>CpkMaker.dll</code>, inside which the functions are completed using P/Invoke. I have to decompile <code>AtomPreview.dll</code> and <code>AtomPreviewer_PC.exe</code>.</p><p>The immediate choice is <code>AtomPreview.dll</code>, because it exposes some APIs. This time, I enter the library from code for ACB to look at the reading process. Well, this is much harder than reading decryption settings. I can only perform three levels of static analysis and the analysis is heavily interfered by class members, so I cannot find something interesting. It is not easy to be dynamically analyzed (can attach to the process though). The code structure is far different from expected and the key signature <code>@UTF</code> is not found anywhere so I don’t know where to start.</p><p>Analyzing this from the shared library in Draglia Lost’s APK is as difficult as above.</p><p>Atom Viewer in ADX2LE SDK can play the bundle files too. But it does not have public APIs. In the issue comments FZFalzar said the related code is “baked” into the library (in fact this is called static linking :P). Even it does not expose public APIs, there is still a way to locate the code, just make good use of its logs. According to the log, search for string <code>Open ACB:</code> and follow the references. In the end you will find a function with characteristics very similar to <code>criAtomExAcb_LoadAcbFile()</code>. However it is still hard to analyze.</p><h2 id="4-3-Analyzing-HCA-Decoding"><a href="#4-3-Analyzing-HCA-Decoding" class="headerlink" title="4.3 Analyzing HCA Decoding"></a>4.3 Analyzing HCA Decoding</h2><p>Compared to the key settings and ACB, HCA-related functions look harder to catch because they are not exposed anywhere. In addition, the decoding process runs in a background thread, so there is no way to find a direct entry (like from <code>criAtomExPlayer_Start</code>).</p><p>Now what? Scan for tiny traces they leak to the surface. Reading the public decoder code, the most impressive thing is those precomputed tables. These tables will lead us to the hidden functions. As a commercial decoder, speed is another important consideration, apart from precision. Sometimes you will have to balance between them. The official decoder is also likely to choose a trading-space-for-time strategy, and it would be even better if they use the same tables. Anyway, try our luck first.</p><p>Based on the public HCA decoder, the decoding framework is like:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decode_block</span><span class="hljs-params">(Block *block)</span> </span>&#123;<br>    <span class="hljs-built_in">validate_block</span>(block);<br>    <span class="hljs-built_in">decrypt_block</span>(block);<br>    <br>    <span class="hljs-keyword">for</span> each channel &#123; <span class="hljs-built_in">decode1</span>(channel); &#125;    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0.</span><span class="hljs-number">.7</span>) &#123;<br>        <span class="hljs-keyword">for</span> each channel &#123; <span class="hljs-built_in">decode2</span>(channel); &#125;<br>        <span class="hljs-keyword">for</span> each channel &#123; <span class="hljs-built_in">decode3</span>(channel); &#125;<br>        <span class="hljs-keyword">for</span> each channel &#123; <span class="hljs-built_in">decode4</span>(channel); &#125;<br>        <span class="hljs-keyword">for</span> each channel &#123; <span class="hljs-built_in">decode5</span>(channel); &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">to_wave</span>(channels);<br>&#125;<br></code></pre></td></tr></table></figure><p>Just have a first expectation in mind. Now let’s see if the official decoder use the same tables.</p><p>Here we choose the first element in the second table inside <code>decode5()</code>, <code>0xBD0A8B04</code>. The reason to choose <code>decode5()</code> is, it lies on the last location in the innermost loop. Its feature serves well as a beacon. As for which table, that is a casual choice. In the worst case just try them all. During searching beware the endianess. Here I use the Atom Viewer from the full SDK (because I prefer X86/X86-64 to ARM), so the search pattern is <code>D4 8B 0A BD</code>.</p><p><img src="/images/crack-hca-dragalia/03.jpg" alt="Search result for 0xBD0A8BD4 (Hex Editor)"></p><p><img src="/images/crack-hca-dragalia/04.jpg" alt="Search result for 0xBD0A8BD4 (IDA)"></p><p>As expected, it is found in the global variable segment. Having a glance at its previous and next elements, it is obvious that this is the table we are interested in. Now switch from Hex View to IDA view and do a xref (cross referencing). Results show that this address is only referenced by one function, whose address is <code>0x00007FF606770718</code>. Do some more searches on the tables used in this function, we can also find the first table in <code>decode5()</code>. This means the function we are looking is probably <code>decode5()</code> or at least a part of it. The caller of this function contains the third table, and another part of <code>decode5()</code>.</p><p><img src="/images/crack-hca-dragalia/05.jpg" alt="decode5()"></p><p>Repeating the same operations, find all referenced known tables until the top level of known region is reached. Here is a function <code>decode_block()</code>. In this process you may find multiple references to the same function. Just try them one by one.</p><p><img src="/images/crack-hca-dragalia/06.jpg" alt="decode_block()"></p><p>Don’t mind the mild differences of code structure between this and the framework above. The interesting thing is their key characteristics. Keep in mind that compiler optimization is quite powerful.</p><p>Again, go up until the top level is reached and there is no obvious caller. Now you should reach a function at <code>0x00007FF6067688F4</code>. xref-ing shows it becomes a function pointer, which means dynamic invocation, for example registering in a function table or as callback. Inside this function we can find a string literal <code>Failed to decode HCA header.</code>, next to which is a function reading the HCA header (located at <code>0x00007FF60676A274</code>; I name it <code>FindAndLoadHcaHeader</code> because it include some code to search for the offset of the header). Reading the HCA header and audio data block decoding appear inside the same function. What is the function like? Yep, a common (and bad) pattern:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (flag == PARSE_HCA_HEADER) &#123;<br>    <span class="hljs-built_in">FindAndLoadHcaHeader</span>(pData);<br>    <span class="hljs-built_in">DecodeAudioBlock</span>(pData + headerSize); <span class="hljs-comment">// Immediately reads the first audio block after reading the HCA header</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == DECODE_AUDIO_BLOCK) &#123;<br>    <span class="hljs-built_in">DecodeAudioBlock</span>(pData);<br>&#125;<br></code></pre></td></tr></table></figure><p>Now put that aside. Maybe you will question about the disparity between <code>decode_block()</code> and the public decoding framework. Now let’s check what the code is like in tools in an old version SDK (ADX2LE). Using the same technique to locate the corresponding <code>decode_block()</code> inside <code>AtomPreviewer_PC.exe</code>. It seems the general structures are alike. Forget not, that we are not comparing the decompiled code and the public code, but between old and new versions of the SDK. As there is no (obvious) difference, the decoding procedure should not have changed, and neither should the tables.</p><p>Now there is only one question left. What are the meanings of <code>comp1</code> to <code>comp10</code> (<code>comp9</code> and <code>comp10</code> are calculated using the other <code>comp</code> values)? How do they affect encoding and decoding? Can they take “strange” values? At this time, I suddenly found <a href="https://github.com/Thealexbarney/VGAudio">VGAudio</a>. It was like hitting by a lightning when I read its readme. The shocking fact (to me) is that, the repository includes the principles and details of HCA encoding. There is even an HCA encoder! From this repository I know that those values have fixed meanings, which cannot be, “strange”.</p><p>So only one of the four possibilities in the beginning still stands. All of other “hard” (not easily changed) functionalities are unchanged. The key is the only thing modified. But this is contradict to what I discovered above, so there should be something I missed.</p><h2 id="4-4-Analyzing-Usages-of-the-Key"><a href="#4-4-Analyzing-Usages-of-the-Key" class="headerlink" title="4.4 Analyzing Usages of the Key"></a>4.4 Analyzing Usages of the Key</h2><p>Finally, the finale. This time let’s trace the <code>criWarePC_SetDecryptionKey()</code> (well, the name is a guess) inside Atom Viewer.</p><p>But… isn’t this function not exported? How can we find it? Fear not. We use the same technique as locating from log. The place in <code>criWareUnity_SetDecryptionKey()</code>, where I stuck before, has a variable argument function that could not be understood. There is a format string in that function: <code>%s, %lld, %lld, %s, 0x%08X, 0x%08X, %d</code>, hard-coded. This means in Atom Viewer, there should also be the same, hard-coded string. Open Strings View and search for it. Next step, searching for references.</p><p><img src="/images/crack-hca-dragalia/07.jpg" alt="Referenced locations"></p><p>Considering that C/C++ compilers will merge the same strings, it is normal to see such a number of results. A little patience is all we need. Luckily, the first result brings us to the correct location.</p><p><img src="/images/crack-hca-dragalia/08.jpg" alt="Isn&#39;t it familiar?"></p><p>The picture above is what it is like after I annotated. But before annotation the high similarity between it and the previous function we analyzed.</p><p>Here is a tip. The Hex-Rays Decompiler (F5 in IDA) is not very good a processing variable argument functions. You have to enter that function and exit, to see its correct arguments. (This does not work on ARM. I don’t know why.) After a simple static tracing of one level, most of the symbol names can be deduced. If you are familiar with HCA encryption and decryption, you can pick out <code>InitDecrypter()</code> quickly. Some information requires dynamic debugging, for example finding strings in tables.</p><p>Enter <code>InitDecrypter()</code>. A little tracing will show the initialization of type-0, type-1 and type-56 encryptions. The value it returns, according to the log, is “DecrypterHn”, which looks like “decryptor handle”. But if you read it more carefully, you will know that this value is a pointer to the decryption table. This pointer is used by two global variables (one at <code>0x00007FF606818CC8</code>, another one at <code>0x00007FF606819628</code>). But neither of these two reveals a meaningful result for tracing.</p><p><img src="/images/crack-hca-dragalia/09.jpg" alt="Inside InitDecrypter()"></p><p>As we can see, after the normal initialization of this decryption table, it is used as the decryption table for both HCA and HCA-MX. You can confirm the usage name from doing one more xref. So here is where the decoding code analyses and decryption code analyses converge.</p><p>I did a simple dynamic debugging. Until setting the decryption tables for HCA and HCA-MX, the contents of the table is still the same as computed using public tools. So there is nothing abnormal until here. But what I am looking for is <em>all</em> references of the key and the decryption table, so I am able to notice this assignment:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">v8 = <span class="hljs-built_in">sub_7FF606712670</span>();<br>*v8 = keyLit2;<br></code></pre></td></tr></table></figure><p>Obviously, the key is passed to somewhere else, in addition to the normal usages we see before. Why should this redundant move be introduced?</p><p>Expand <code>sub_7FF606712670()</code> and you can see that all it does is returning the address of a global variable:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">sub_7FF606712670</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &amp;unk_7FF606821B30;<br>&#125;<br></code></pre></td></tr></table></figure><p>Where is <code>unk_7FF606821B30</code> used? Static analysis tells us it is only referenced inside this function. But <code>sub_7FF606712670()</code>, is used at two locations.</p><p><img src="/images/crack-hca-dragalia/10.jpg" alt="References to sub_7FF606712670()"></p><p>After checking these references, jackpot.</p><p><img src="/images/crack-hca-dragalia/11.jpg" alt="Second encryption"></p><p>Tracing the pointer <code>v4</code>, which received the pointer to the key, it’s easy to find that it is used in another round of computation, and<code>v6</code> should be the new key. As expected, the function which uses <code>v6</code> is for generating a type-56 decryption table. (So why bother writing the same function two times? I don’t understand what CRI guys think.) The problem is how does <code>v5</code> come from. I add a breakpoint at the assignment of <code>v6</code>, open an ACB, but the breakpoint is not hit. Well, this is an ACB from CGSS. When using an ACB from Dragalia Lost, I get a hit. The value of <code>v5</code> is <code>0x80b2</code>, a familar number. I immediately recognized that, this is the two “garbage” bytes inside the ACB/AWB. Although <code>v5</code> comes from the call result of <code>sub_7FF6066F28C0()</code>, which is the value of a class member, but it is obvious that this <em>is</em> those two bytes. Observing the referencing status of <code>sub_7FF6067006CC()</code>, which is strongly related ACB reading, the inference has a high probability to be a right one.</p><p>So I did a little modification to the existing HCA decoder and put in the transformation. And yes, the decoding was successful. Another test on the ACB inside Dragalia Lost’s APK was also successful. Now we can conclude that the reverse engineering this time completed in success.</p><p>Let’s read the formula again: <code>key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))</code>. <code>key</code> is the input key, and <code>k2</code> is a 16-bit integer stored in every AWB. Mind the signed/unsigned and length truncation. Also, it does not throw exceptions when the muplication overflows.</p><p>If <code>k2 == 0</code>, the key is not transformed. See the decision on <code>v5</code>. For example, esterTion found out Princess Connect Re:Dive also uses ACB 1.30, but the HCAs extracted is still able to be handled by existing tools. This is because the bytes at field alignment is <code>20 00 00 00</code>.</p><h1 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h1><h2 id="5-1-The-Future-of-HCA-Extraction-and-Decoding"><a href="#5-1-The-Future-of-HCA-Extraction-and-Decoding" class="headerlink" title="5.1 The Future of HCA Extraction and Decoding"></a>5.1 The Future of HCA Extraction and Decoding</h2><p>After this update, HCA can use de facto dynamic keys. Directly decoding HCA files using the static keys will not be safe anymore. Batch decoding HCAs are not possible, but it is still doable when having ACB/AWB. It’s just adding another shell. All the tools are still public, and all you need to do is writing a small fix. LOL.</p><p>* Update on Oct 16: The vgmstream guys (whose members also watched the issue) already pushed the changes on Oct 14. Wow.</p><h2 id="5-2-Some-Comments"><a href="#5-2-Some-Comments" class="headerlink" title="5.2 Some Comments"></a>5.2 Some Comments</h2><p>Well you don’t have to read this in the English version. Just my personal comments.</p><h2 id="5-3-The-Gain"><a href="#5-3-The-Gain" class="headerlink" title="5.3 The Gain?"></a>5.3 The Gain?</h2><p>To be short, the flexible use of data for attacks. For detailed explanations please read the Chinese version.</p><h2 id="5-4-Thank-List"><a href="#5-4-Thank-List" class="headerlink" title="5.4 Thank List"></a>5.4 Thank List</h2><p>Written in the order I think of, when I write this section.</p><ul><li><a href="https://github.com/FZFalzar">FZFalzar</a> raising the problem, some experiments, and supplying Atom Viewer</li><li><a href="https://github.com/Thealexbarney">Alex Barney</a> and his amazing <a href="https://github.com/Thealexbarney/VGAudio">VGAudio</a></li><li><a href="https://sourceforge.net/projects/vgmtoolbox/">VGMToolbox</a> from <a href="https://sourceforge.net/u/snakemeat/profile/">snakemeat</a></li><li>The anonymous guy who provided the HCA decoder code (ancient code published on 2ch before 2014)</li><li><a href="https://github.com/hozuki/libcgss/issues/4">Everyone discussed in the issue</a></li><li>And me (:D) (←You already participated in the discussion!</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;中文版本见&lt;a href=&quot;/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Recently CRI Middleware updated their latest ACB archives’ format, and they seemed to have updated encryption of HCA files as well. As a result, the old toolsets can do nothing on the updated files. After about 20 hours of research I finally found what they changed on the decryption. Might be the first in the world, again. This is what’s called “highlight moment” in reverse engineering. XD&lt;/p&gt;
&lt;p&gt;The final answer is somewhat simple: transform the decryption key, and use the transformed key to initialize the decryption table. The formula is &lt;code&gt;key&amp;#39; = key * ((uint64_t)(k2 &amp;lt;&amp;lt; 16) | (uint16_t)(~k2 + 2))&lt;/code&gt; where &lt;code&gt;key&lt;/code&gt; is the input key and &lt;code&gt;k2&lt;/code&gt; is a secondary key stored in the higher 16 bits of “field alignment” field, in each ACB/AWB file.&lt;/p&gt;
&lt;p&gt;This article is about the way and thoughts of finding this transformation. It is roughly recorded in time order. I hope these materials may help someone in the future.&lt;/p&gt;
&lt;p&gt;My result is based on various people’s works. Without thoses pieces, the whole puzzle cannot be completed. So a big thank you for everyone involved.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red;&quot;&gt;&lt;strong&gt;Be noted again: the contents in this article must not be used for commercial purposes.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    <category term="RE" scheme="https://blog.mottomo.moe/categories/Tech/RE/"/>
    
    
    <category term="Reverse Engineering" scheme="https://blog.mottomo.moe/tags/Reverse-Engineering/"/>
    
    <category term="English Version" scheme="https://blog.mottomo.moe/tags/English-Version/"/>
    
    <category term="HCA" scheme="https://blog.mottomo.moe/tags/HCA/"/>
    
    <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
    <category term="Dragalia Lost" scheme="https://blog.mottomo.moe/tags/Dragalia-Lost/"/>
    
    <category term="CGSS" scheme="https://blog.mottomo.moe/tags/CGSS/"/>
    
  </entry>
  
</feed>
