<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花嫁達の部屋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.mottomo.moe/"/>
  <updated>2020-03-31T15:37:07.100Z</updated>
  <id>https://blog.mottomo.moe/</id>
  
  <author>
    <name>头蟹床(Headcrabbed)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Foobar2000 中直接播放网易云音乐的缓存文件</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2020-03-23-FB2K-NEM-Component/</id>
    <published>2020-03-23T06:20:00.000Z</published>
    <updated>2020-03-31T15:37:07.100Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。</p><a id="more"></a><p>昨天晚上本来是计划做乐曲改编的。虽然源用的是网易云音乐，但是播放器我就不想用它，而是 Foobar2000。但是当我尝试下载的时候，却被提示仅允许付费/会员下载。</p><p>行吧，你是哪天买的版权（如果真买了的话，笑）我不知道；但是反正我没有很高的码率要求，默认播放的 128 Kbps 就行；而且如果这也不行，还有别的手段。这时候我就想到，虽然不可以下载，但是还是可以播放的啊。既然能播放，那么应该就缓存在本地了，除非产品设计抽风。</p><p>于是我就看了看缓存目录。结果发现了很多大小接近 128 Kbps MP3 的文件。（是不是有一种<a href="/categories/Tech/RE/zh/2016-03-10-Reversing-CGSS-2/">既视感</a>？）主体内容应该是音频没错，但是经过了某种形式的加密。不过这次不是 CTF 了，所以就直接 Google 吧。已经<a href="https://github.com/mbinary/netease-music-cracker" target="_blank" rel="noopener">有人搞定了</a>。果然还是屈服于性能，只采用了简单的异或。哈。</p><p>那么现在的目标就是把这个逻辑封装为一个 Foobar2000 的组件，这样就可以直接在 Foobar2000 中播放了。虽然我<a href="https://github.com/hozuki/foo_input_hca" target="_blank" rel="noopener">写过简单的组件</a>，不过这次不一样，用到的东西比 <code>input_stub</code> 要多一些。</p><p>这次稍微触及到了 Foobar2000 组件系统的核心之一，<code>service_base</code>。工程的目标是：实现一个文件流，对原文件流做一个读写封装。其实这次还算简单，是无状态的，简单异或每个字节就行了。但是麻烦在于 <code>service_base</code> 的设计。如果在 .NET 里面实现这个可是太简单了，继承并重写，重写中调用父类方法就行。<code>service_base</code> 是引用计数的，有点像 COM（接口查找和接口升级更像），但是（在 release 模式下）并没有虚表（V-table），成员查找完全依赖于模板。成员一般不使用原生指针，而是使用 <code>service_ptr_t&lt;T&gt;</code>。我本来就没做过 COM 开发，而且这玩意儿还是没有虚表的。</p><p>根据 SDK 附带的简单说明，继承自 <code>service_base</code> 的“类”实际上是接口（类似 <code>IUnknown</code>），不应该有任何字段和方法实现，实现细节相关应该在在对应的 <code>*_impl</code> 类中提供。等等，那我该怎么实例化我的 <code>service</code> 呢？我的指针模板应该填什么类型呢？怎么转换接口呢？</p><p>看一下相关的定义。如果你知道 COM 的话这个看起来绝对不陌生。</p><pre><code class="lang-cpp">class NOVTABLE service_base{public:    virtual int service_release() throw() = 0;    virtual int service_add_ref() throw() = 0;    virtual bool service_query(service_ptr &amp; p_out,const GUID &amp; p_guid) = 0;    // ...}class NOVTABLE file : public service_base, public stream_reader, public stream_writer{    // ...}</code></pre><p>但是要注意的是那些 <code>NOVTABLE</code> 修饰，这是和 COM 最大的不同。在 VC++ 的 release 模式下，它会被扩展为 <code>__declspec(novtable)</code>。<del>这样尽管在逻辑上，<code>file</code> 继承自 <code>service_base</code>，但是在编译后它们并没有 V-table，因此不可以进行虚函数调用，<code>dynamic_cast</code> 也应该会失效。</del>关于 <code>__declspec(novtable)</code> 对虚表和 vptr（虚指针）的影响可以参考<a href="https://stackoverflow.com/a/1836063" target="_blank" rel="noopener">这个回答</a>。简单说，就是修饰 <code>__declspec(novtable)</code> 没关系，RTTI 和虚函数照常工作（除了在构造/析构函数中）。所以，直观的结论是，要让代码正常工作的话，抽象类（也就是 Foobar2000 中的接口）可以修饰，但是抽象类的非抽象子类不可以；抽象类自身也不能在构造/析构函数中使用虚表或虚指针相关。</p><p><strong>怎么实例化呢？</strong>一种方法是使用工厂类（<code>service_factory_base</code>），不过过程就非常麻烦了。对于简单的接口，SDK 提供了一个非常方便的函数 <code>fb2k::service_new()</code>。只需要创建实现的实例，赋值给接口指针就行了。</p><p>在代码中，我定义了一个自定义文件流类型和它的实现：</p><pre><code class="lang-cpp">class NOVTABLE mapped_file : public file{    // ...}// 注意这个 NOVTABLE，可以这么写是因为 mapped_file_impl_t 还是抽象的，实例化由 service_impl_t 负责，见下文class NOVTABLE mapped_file_impl_t : public mapped_file{    // ...}</code></pre><p>在使用上就可以这样：</p><pre><code class="lang-cpp">service_ptr_t&lt;mapped_file&gt; ptr = fb2k::service_new&lt;mapped_file_impl_t&gt;(...);// 或者service_ptr_t&lt;file&gt; ptr = fb2k::service_new&lt;mapped_file_impl_t&gt;(...);</code></pre><p>有趣的是，<code>service_new()</code> 内部使用了 <code>service_impl_t&lt;T&gt;</code>。这个类型继承自 <code>implement_service_query&lt;T&gt;</code>，而正是 <code>implement_service_query&lt;T&gt;</code> 提供了新的 <code>service_query()</code> 的默认实现。<code>service_impl_t&lt;T&gt;</code> 则进一步提供了 <code>service_add_ref()</code> 和 <code>service_release()</code> 的默认实现。所以在写自己的类型实现（比如 <code>mapped_file_impl_t</code>）时，是不需要提供这三个方法的。因此，此时这个“类型实现”对于编译器而言还是抽象类型，不可以直接使用 <code>new</code> 实例化——将所有实例的创建过程进行托管，可以有效地消除某些 bug——这是一个附加的好处。<code>service_impl_t&lt;T&gt;</code> 正好可以作为使用模板来创建 mixin 的一个例子。</p><p><strong>指针模板应该填什么类型呢？</strong>由于巧妙的向上查找方式（见下文），所以可以使用实现类型或者其任意的父类型。</p><p><strong>怎么转换接口呢？</strong>其实这个组件的功能并没有涉及到这个问题，但是在开始摸索的时候，我也是实现了整个 <code>mapped_file</code>，所以大略知道一点。每个继承自 <code>service_base</code> 的类都要提供一个静态成员 <code>GUID class_guid</code>（用于特征萃取），在 <code>service_query()</code>（1.4 以后是 <code>handle_service_query()</code>）中进行判断。查询整体就是一个沿着继承链往上找的过程。思想则是，一个子类声明它能被转换为哪些父类。而这个继承链，实际上是编译期的，利用模板而不是虚表。可以看 <code>handle_service_query()</code> 的实现：</p><pre><code class="lang-cpp">static bool service_query_walk(service_ptr &amp;, const GUID &amp;, service_base *) {    return false;}template&lt;typename interface_t&gt; static bool service_query_walk(service_ptr &amp; out, const GUID &amp; guid, interface_t * in) {    if (guid == interface_t::class_guid) {        out = in; return true;    }    typename interface_t::t_interface_parent * chain = in;    return service_query_walk(out, guid, chain);}template&lt;typename class_t&gt; static bool handle_service_query(service_ptr &amp; out, const GUID &amp; guid, class_t * in) {    typename class_t::t_interface * in2 = in;    return service_query_walk( out, guid, in2 );}</code></pre><p>其中 <code>t_interface</code> 和 <code>t_interface_parent</code> 在接口的 <code>FB2K_MAKE_SERVICE_INTERFACE</code> 中被自动定义。其实就是宏的那两个参数。这里实现了自动沿着继承链向上查找的语义，终止则利用是模板参数的退化（不是无参特化，但是我不确定该怎么称呼）用一个重载实现的。</p><p>看来 Peter 也是把 C++ 吃透了。这些 API 的设计非常巧妙。</p><p>最终的成果是个<a href="https://github.com/hozuki/foo_input_nemuc" target="_blank" rel="noopener">小玩意儿</a>。使用 VS 2019 编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个奇怪的需求：用 Foobar2000 播放网易云音乐缓存的文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Foobar2000" scheme="https://blog.mottomo.moe/tags/Foobar2000/"/>
    
  </entry>
  
  <entry>
    <title>春天没有花儿</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-12-20-Spring-Leaves-No-Flowers/</id>
    <published>2019-12-20T18:03:00.000Z</published>
    <updated>2020-03-30T22:34:35.453Z</updated>
    
    <content type="html"><![CDATA[<p><em>欢迎到作品的 <a href="https://npckc.itch.io/spring-leaves-no-flowers" target="_blank" rel="noopener">Itch.io 页面</a>去支持作者。另外这个系列目前由三个连续的故事组成：<a href="https://npckc.itch.io/one-night-hot-springs" target="_blank" rel="noopener">one night, hot springs</a>、<a href="https://npckc.itch.io/last-day-of-spring" target="_blank" rel="noopener">last day of spring</a> 和本作 <a href="https://npckc.itch.io/spring-leaves-no-flowers" target="_blank" rel="noopener">spring leaves no flowers</a>。</em></p><p><strong>本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。</strong></p><p>我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。</p><a id="more"></a><hr><p>我玩过的游戏中，针对单人、强调情感体验的不多；而让我称奇，甚至是给予我某个方面启蒙的，则是屈指可数。<a href="https://store.steampowered.com/app/683320/GRIS/" target="_blank" rel="noopener">GRIS</a> 和 <a href="https://store.steampowered.com/app/1122720/Sayonara_Wild_Hearts/" target="_blank" rel="noopener">Sayonara Wild Hearts</a> 聚焦于短期心理状态，<a href="https://store.steampowered.com/app/206440/To_the_Moon/" target="_blank" rel="noopener">To the Moon</a> 和本（系列）作品则偏向于展示某种长期的“异常”。（Sayonara Wild Hearts 我虽然很感兴趣但是没玩，因为光是看实况录播，它的美术风格就已经让我生物意义上地头疼了。）</p><p>故事的三个主角：</p><ul><li><ruby>立花<rp>(</rp><rt>タチバナ</rt><rp>)</rp></ruby>　<ruby>愛美<rp>(</rp><rt>マナミ</rt><rp>)</rp></ruby>（本故事主角）</li><li><ruby>永田<rp>(</rp><rt>ナガタ</rt><rp>)</rp></ruby>　エリカ（第二部主角）</li><li><ruby>鈴木<rp>(</rp><rt>スズキ</rt><rp>)</rp></ruby>　<ruby>悠人<rp>(</rp><rt>ハルト</rt><rp>)</rp></ruby>/ハル（第一部主角）</li></ul><p>マナミ和ハル是青梅竹马，和エリカ是高中同学。三人对“少数”的一致认同和宽容，才使得故事顺利展开。</p><p>游戏系统并不复杂，比 AVG 还要纯粹的 AVG。叙事并没有什么出人意料的地方。不过有意思的是，虽然很多选项被划了删除线而且是灰色的，是一般意义上的“不可用”状态，但是实际上那些才是让游戏进入正轨的选项。我想，这大概是作者 npckc 设计的隐藏表现方式，意思是说在角色心中这个选项就是默认不可选择的。这可能是个亮点吧。</p><p>剧情其实没那么复杂，不需要怎么解释。マナミ无法理解“亲吻”的特殊含义（在现代语境下），因此无法推断出另外两人关系的变化——更重要的是，无法真正理解自己的处境。给我冲击力的是角色所面临的问题。是的，我知道有的人是不擅长理解暗示，或者一些词汇的含义（常见于自闭症），但这些都是作用域更广泛的社会行为的，我并不知道更“私人”的感情受到这样影响是怎么样的。我曾经听说过“无性恋”，但我只是以为这代表“不喜欢任何人/对任何人都保持着中立的态度”。读到了这个故事之后我才知道，我错了。</p><p>タツヤ，您真是勇士。虽然在故事里，マナミ得到了所有人的接受（毕竟她们都有着各自的“异常”），但是现实生活中，恐怕活得要艰难太多了。</p><p>整个游戏令我震惊的就是新概念的引入。而且是实事求是的平铺直叙，不是被包装的拜金主义，因此才能给（就算不是这样的）人以共鸣。词条的解释是很可能客观公正的，但是它没有活生生的人。当你从一个人的视角，而不是从上帝视角，去看的时候，才会真正地萌生一种想法：“这个困难的根源在哪里？”进而再去思考需求和生产力的关系等等。</p><hr><p>后来我把前两作读了一遍。这一读不要紧，第三部的印象崩塌了大半。不，不是因为歧视，而是因为总体的人物和剧情设置。</p><p>这次来总结一下，在看完三部曲后，完整的人物描述。虽然像是贴标签，但是对不起了，政治正确的气息太浓厚了。</p><ul><li>マナミ：无性恋（asexual）、无浪漫（aromantic）</li><li>エリカ：双性恋（bisexual）、纯素食主义者（vegan）</li><li>ハル：跨性别者（transgender）、潜在的同性恋（推测）</li></ul><p>她们都希望正常地活着——不是“矫正”，而是和其他人一样相互尊重。</p><p>但是一些剧情就有点……匪夷所思，或者说，如果真的发生了，想想还是可以理解的，但是概率太小了。</p><p>（第一部）ハル告诉エリカ说自己喜欢マナミ，不过マナミ已经有男朋友了所以说不出口。ハル可是认知性别为女的。……是心理上的百合倾向？还是生理上的激素作用？不得而知。而且喜欢很久了。</p><p>（第二部）与ハル的对话中，选错一个就会导致故事提早结束（bad end）。和另外两部不同，这里ハル在闹别扭，总觉得自己不值得参加活动，所以一旦选择了坦诚的选项，ハル就要不不接电话不回消息，要不就说干脆所有的活动都取消算了。但是老妹，你之前不是都去过温泉了吗？从那次事件中就可以见到人家品行如何。你这么缩着，说着不要再麻烦人家了，不是更给人添麻烦吗？</p><p>这么看来，第二部的真的是死亡选项。其他两部就友好一些，第一部有“心”的提示（左上角；可以关闭），第三部选项状态就是提示（见前文），就是这第二部麻烦多了。</p><p>（第一部/第二部）エリカ费老劲地照顾ハル，从化解ハル（不想见到マナミ的男朋友）的尴尬提出和ハル一起去市内转（最后真的去了），到给ハル准备生日活动，到真情流露，最后甚至说想亲上去了。而且经历了上面的死亡选项后，明显能看出，虽然エリカ认为自己是在尽一个朋友的责任，但是这负担起的已经超出了朋友的范围……更何况エリカ还是个双（很早就跟ハル说过）。然而结局是 as a friend。（摊手）</p><p>第二部的后日谈中，ハル表示要真诚地跟マナミ谈一谈。虽然不知道是想谈第二部里各种别扭的根本原因，还是谈她对マナミ的感情。不管是哪一种，总之从第三部可以看到，作为本故事的引子，ハル和エリカ在一起了。等等？嗯？这跳跃是怎么回事？跃迁吗？</p><p>（第三部）ハル引导マナミ去寻找解答。虽然于情于理这个指引者都应该是ハル，但是考虑到ハル的想法……作者真喜欢插刀子。</p><hr><p>ハル的话可以引起思考，也大致体现了真实的想法：</p><blockquote><p>ハル：我在各个意义上都是破碎的……怎么还会有人会被这样的我所吸引呢？</p></blockquote><p>以及：</p><blockquote><p>エリカ：（“悠人”）是你从前男生时的名字吗？</p><p>ハル：从前也不是男生……</p></blockquote><hr><p>有意思的是，一些词汇被意译的情况下，另一些作为专有概念被音译了。温泉（<ruby>温泉<rp>(</rp><rt>おんせん</rt><rp>)</rp></ruby>）就被普普通通地翻译成了“hot spring”。而旅馆（<ruby>旅館<rp>(</rp><rt>りょかん</rt><rp>)</rp></ruby>）、公共澡堂（<ruby>銭湯<rp>(</rp><rt>せんとう</rt><rp>)</rp></ruby>）、蜜柑（みかん）则分别被翻译成了“ryokan”、“sentou”和“mikan”。我想，这些玩意儿在西方语境下，哪一个都不是新鲜事物或者说异域风情啊。问问你们的先祖，要不听听人家<a href="https://movie.douban.com/subject/6037517/" target="_blank" rel="noopener">吐槽</a>也可以。<del>精罗震怒</del></p><hr><p>本文涉及的主题可能是目前我所有的博文中最容易引起争议的。游戏中说了这么多，其实都是陈述一些客观事实，以及中立的处理方式。真要从法律法规层面上实施起来，就开始碰到主观观点、碰到蛋糕了，和其他行为公认的（但是根据各种标准再细分，或“先进”或“落后”的）行为准则一冲突，也是很麻烦的事。比如，奥巴马的<a href="https://en.wikipedia.org/wiki/Bathroom_bill" target="_blank" rel="noopener">公共厕所指导条例</a>，就是十分粗暴的尝试。如果你要问我怎么解决，我只能耸耸肩，说，我不是神，不知道最优解是什么，也不知道那个最优的平衡在哪里；但是也许可以渐进，近似出这个特定的函数。退一步来说，这个群体内部也是分裂的——就像是多组相互独立、每组内容易相互排斥的选项，就算是第一组都选了同一个，第二组不同，就会看不顺眼。从宏观到微观，人就是这么分裂。感受不到的话……可能是很幸运地选到了大众选项。</p><p>不管如何，我依然将其视为社会生产力发展的证明。这个观点来自于<a href="https://book.douban.com/subject/1286994/" target="_blank" rel="noopener">《在时间的长河里》</a>中对于毕达哥拉斯学派素食规定的解读。小众的特化需求得到满足，必须是以高生产力为条件的。否则，他们就会成为主流（提供人类这一物种生存的保障的人）的负担，从而遭到排挤。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;欢迎到作品的 &lt;a href=&quot;https://npckc.itch.io/spring-leaves-no-flowers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Itch.io 页面&lt;/a&gt;去支持作者。另外这个系列目前由三个连续的故事组成：&lt;a href=&quot;https://npckc.itch.io/one-night-hot-springs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;one night, hot springs&lt;/a&gt;、&lt;a href=&quot;https://npckc.itch.io/last-day-of-spring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;last day of spring&lt;/a&gt; 和本作 &lt;a href=&quot;https://npckc.itch.io/spring-leaves-no-flowers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring leaves no flowers&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文内容涉及剧透，建议自行游玩后再阅读。同时，故事之间有一些关联，阅读一部或多部可能会带来不同的游戏体验。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我一开始是在 QooApp 上浏览最近发行的游戏，偶然间被标题和图标画风的某种组合给吸引了。看了简介之后我决定下载下来玩一玩。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>小谈 .NET 和 Java 的并发容器 API 设计</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-12-19-Dot-Net-and-Java-Concurrent-Container-API/</id>
    <published>2019-12-19T14:49:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>今天看博客园，看到<a href="https://www.cnblogs.com/thisiswhy/p/12059240.html" target="_blank" rel="noopener">一篇文章</a>。它的主要内容是：</p><ul><li>为什么 <code>ConcurrentHashMap&lt;K, V&gt;</code> 不支持 <code>null</code> 值？因为这样就无法区分给定的键不存在还是对应值就是 <code>null</code>。</li><li>为什么 <code>ConcurrentHashMap&lt;K, V&gt;</code> 不支持 <code>null</code> 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。</li></ul><p>文章内容不赘述了。</p><p>我看完之后想到的是，.NET 的并发容器（<code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的坑联系在一起，可能会发现什么。</p><a id="more"></a><p>以前我笑话过 .NET 的容器 API 设计。我们知道，.NET 的 <code>Stack&lt;T&gt;</code> 和 <code>Queue&lt;T&gt;</code> 是基于数组的。这给予了它们一定的随机访问能力（不过没什么卵用，想想它们是做什么的），保持内存连续性（提高缓存命中率），但是坏处就是不适合频繁的扩容和收缩。（在提高数组的利用率上，<code>Stack&lt;T&gt;</code> 比较好办，<code>Queue&lt;T&gt;</code> 用的是循环缓冲区。）我想实现基于 <code>LinkedListNode&lt;T&gt;</code> 的版本，却发现 .NET 并没有提供 <code>IStack&lt;T&gt;</code> 和 <code>IQueue&lt;T&gt;</code>。简单搜索就可以找到 StackOverflow 上的<a href="https://stackoverflow.com/questions/4367893/why-is-there-no-iqueuet-or-istackt-interface-in-the-net-framework" target="_blank" rel="noopener">问题</a>。其中有那么一句话：</p><blockquote><p>As it pointed <code>Queue</code> and <code>ConcurrentQueue</code> don’t have that much similar to make them implement single interface.</p></blockquote><p>我就顺着看了一下 <code>ConcurrentQueue&lt;T&gt;</code> 的 API，接着就被震撼到了。其他的容器也是类似的。这是什么玩意儿！相比之下，人家 Java，<code>ConcurrentHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;</code>，多么优雅。也就是说，理论上，我可以将某个类型为 <code>Map&lt;K, V&gt;</code> 的成员字段啊参数啊变量啊，从原来赋值为 <code>HashMap&lt;K, V&gt;</code> 的实例改为 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的实例，然后瞬间就不担心这里的多线程问题了（假设其余部分正确实现）。这不是很爽吗？而如果我使用了 <code>Dictionary&lt;TKey, TValue&gt;</code>，由于其和 <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 没有共同的基类或者适合的接口，所以我无法只使用一个变量就兼容二者。太麻烦了，就为了这个区别，也得开始使用策略模式吗……</p><p>今天突然理解了。<code>ConcurrentHashMap&lt;K, V&gt;</code> 中的 <code>null</code> 是一个坑，而且“这种限制”这样的无聊问题会成为 Java 开发者懂不懂并发的其中一个筛子，很大程度上就是因为它实现了 <code>Map&lt;K, V&gt;</code>，而后者在设计之初就计划使用 <code>null</code> 作为键不存在的表示，从而没有其余携带信息的手段。这是不是设计失误我不敢下结论（不知道 Bloch 当初是怎么想的），但是一定是有问题的。</p><p>我们先来看看 <code>ConcurrentHashMap&lt;K, V&gt;</code> 的存取 API。由于实现了 <code>Map&lt;K, V&gt;</code>，所以签名是一样的：</p><pre><code class="lang-java">interface Map&lt;K, V&gt; /* ... */ {    // ...    public V get(Object key);    public V put(K key, V value);    // ...}class ConcurrentHashMap&lt;K, V&gt; /* ... */    implements Map&lt;K, V&gt; /* ... */ {    // ...    public V get(Object key);    public V put(K key, V value);    public V putIfAbsent(K key, V value);    // ...}</code></pre><p>“无法使用 <code>null</code> 值”可以从“需要实现 <code>Map&lt;K, V&gt;</code>”这个前提推断出来：</p><ol><li>必须实现 <code>Map&lt;K, V&gt;</code>，因此存取必须使用 <code>get(K)</code> 和 <code>put(K, V)</code>。</li><li>在 <code>Map&lt;K, V&gt;</code> 的大多数实现中，<code>get(K)</code> 对于不存在的键会返回 <code>null</code> 而不是抛出异常。</li><li>怎么判断返回 <code>null</code> 是代表键不存在，还是代表设置的值就是 <code>null</code> 呢？那就得在获取值之前先使用 <code>contains(K)</code> 检查了。</li><li>假设允许 <code>null</code> 值。一样会遇到2所示的问题。那么此时怎么判断是哪一种情况呢？还是先用 <code>contains(K)</code> 吗？这可是可能处于并发状态下的啊，两次操作之间或许这个容器状态就改变了，引发别的问题。因此，不可以使用预先判断。</li><li>现在唯一能表示键不存在的只有返回值了。在这里做文章，规定一个特殊值 <code>null</code>（有经验都知道使用特殊值一般不是个好主意），用它来表示键不存在。</li><li>由于 <code>null</code> 返回值在这个操作的上下文中有了“键不存在”的特殊意义，为了不引发冲突，容器内的所有值都不允许为 <code>null</code>。</li></ol><p>可以注意到，状态附加、原子性保证，使得应用前提发生了变化。因此，<code>ConcurrentHashMap&lt;K, V&gt;</code> 不适合实现 <code>Map&lt;K, V&gt;</code>。</p><p>再来看看 .NET 这边。</p><pre><code class="lang-csharp">interface IDictionary&lt;TKey, TValue&gt; /* ... */ {    // ...    void Add(TKey key, TValue value);    bool TryGetValue(TKey key, out TValue value);    // ...}class ConcurrentDictionary&lt;TKey, TValue&gt;    : IDictionary&lt;TKey, TValue&gt; /* ... */ {    // ...    public bool TryGetValue(TKey key, out TValue value);    public TValue GetOrAdd(TKey key, TValue value);    public bool TryAdd(TKey key, TValue value);    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);    // ...}</code></pre><p>（或许你要问，其余对 <code>IDictionary&lt;TKey, TValue&gt;</code> 的方法实现，比如 <code>Add(TKey, TValue)</code> 呢？答案是它们都成了显式接口实现。）</p><p>可见，虽然同样是实现了字典接口，但是由于 .NET 这边并未采用特殊值，所以 <code>TryGetValue(TKey, out TValue)</code> 有很高的并发接口适应性。开发者不需要关心特殊值的问题，而是可以和普通的 <code>Dictionary&lt;TKey, TValue&gt;</code> 一样，使用 <code>null</code> 作为项的值，不需要抓破脑袋。</p><p>.NET 这样设计的一部分原因也可能是不得已而为之。因为在 <a href="https://docs.microsoft.com/en-us/dotnet/standard/common-type-system" target="_blank" rel="noopener">CTS</a> 中是有严格的值类型和引用类型的区分的。<code>ConcurrentDictionary&lt;T&gt;</code> 并没有泛型类型约束，因此可以用于这两种类型。如果想像 Java 那样找 <code>null</code> 这样的特殊值，是找不到的——值类型没有“空”（null）的概念，但是不排除有“空”（empty）的值，包括默认的全零值。因此，为了携带状态，就得多加参数。</p><p>这个设计带来的一个（可能是）意想不到的好处是，它将“检测并获取”作为一个原子操作（API 层面，当然不是指令层面），而且没有副作用。这样开发者过渡到并发反而容易了。</p><p>我们再来看看在队列上的区别。</p><pre><code class="lang-java">interface Queue&lt;E&gt; /* ... */ {    // ...    // 失败抛出异常    public boolean add(E e);    public E remove();    public E element();    // 失败返回特殊值    public boolean offer(E e);    public E poll();    public E peek();    // ...}// 和 Queue&lt;E&gt; 一样，不赘述class ConcurrentLinkedQueue&lt;E&gt; /* ... */    implements Queue&lt;E&gt; /* ... */ {    // ...}</code></pre><pre><code class="lang-csharp">class Queue&lt;T&gt; /* ... */ {    // ...    public void Enqueue(T item);    public T Dequeue();    public T Peek();    // ...}class ConcurrentQueue&lt;T&gt; /* ... */ {    // ...    public void Enqueue(T item);    public bool TryDequeue(out T result);    public bool TryPeek(out T result);    // ...}</code></pre><p>在这个设计上，Java 提供了两套令人迷惑的 API。它们提供相同的功能，但是在失败时的行为完全不同。一套是快速失败（fail-fast），抛出异常，另一套是安全失败（fail-safe），返回特殊值 <code>null</code>。（说实话，如果不是这次我看了文档，否则我也不会知道两套的区别。）很明显，抛出异常适用于简单开发，而在复杂的并发系统中返回“失败”这个状态更好。但是由于使用的特殊值也是个合法值（<code>null</code>），因此 <code>Queue&lt;E&gt;</code> <strong>一般</strong>是不允许其中的项是 <code>null</code> 的。（但是也有例外：<code>LinkedList&lt;E&gt;</code> 是允许 <code>null</code> 项的，因为用内部的 <code>Node&lt;E&gt;</code> 包装了。新的坑。）且不论两套 API 是否让人头大，针对 <code>null</code> 的行为已经让人头大。不过，和 <code>Map&lt;K, V</code> 到 <code>HashMap&lt;K, V&gt;</code>/<code>ConcurrentHashMap&lt;K, V&gt;</code> 的暗坑，<code>Queue&lt;E&gt;</code> 到 <code>LinkedList&lt;E&gt;</code>/<code>ConcurrentLinkedQueue&lt;E&gt;</code> 反而没什么坑。</p><p>当然，你也可以说 <code>null</code> 本身就是个 <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" target="_blank" rel="noopener">billion dollar mistake</a>。在这种意义上，<code>null</code> 本来就不该出现。可惜广泛应用的语言大多都没有禁止 <code>null</code>……</p><p>.NET 这边的设计就有意思了。对于普通场景的 <code>Queue&lt;T&gt;</code>，失败都是抛出异常的。而 <code>ConcurrentQueue&lt;T&gt;</code> 入队失败抛出异常，后两者失败时是返回 <code>false</code> 的（从命名就可以看出来）。而且 <code>ConcurrentQueue&lt;T&gt;</code> 和 <code>Queue&lt;T&gt;</code> 没有关系（见上文），因此不提供相同的 API。失败行为和 API 对于是否支持并发时线程安全（和性能！）完全不同——这虽然“适应”了不同场景，让开发者只需要“自然地”使用，但这差异同样增加了认知的负担。</p><hr><p>另外还有一个有意思的讨论。我们知道有 <code>ConcurrentHashMap&lt;K, V&gt;</code>，但是线程安全的<em>随机访问</em>列表实现只有 <code>Vector&lt;E&gt;</code>（或者使用 <code>Collections.synchronizedList()</code> 包装），而且原理还是全部加锁的。<a href="http://ifeve.com/why-is-there-not-concurrent-arraylist-in-java-util-concurrent-package/" target="_blank" rel="noopener">为什么没有 <code>ConcurrentArrayList</code></a>？（原文链接已经失效，所以只好引用译文。）</p><p>回答是：</p><blockquote><p>很难去开发一个通用并且没有并发瓶颈的线程安全的 <code>List</code>。</p><p>像 <code>ConcurrentHashMap</code> 这样的类的真正价值并不是它们保证了线程安全，而在于它们在保证线程安全的同时不存在并发瓶颈。……</p></blockquote><p>比如，调用 <code>contains()</code> 或者 <code>indexOf()</code> 的时候，最坏的情况下需要搜索整个列表，所以必须锁定整个列表。这个时候如果要修改列表（增删改）那必然会引发瓶颈。</p><p>相比之下，<code>ConcurrentHashMap&lt;K, V&gt;</code> 在修改/搜索的最坏情况下最多只需要锁住其一部分（如果你疯狂构造哈希冲突；另参考 Java 7 到 Java 8 的实现变更）。<code>ConcurrentLinkedQueue&lt;E&gt;</code>/<code>ConcurrentLinkedDeque&lt;E&gt;</code> 则更简单，无法搜索，修改也只有一个/两个方向。因此它们的使用不会构成瓶颈。</p><hr><p>我本来还想吐槽一下 wildcard capture 的，因为我记得以前在哪里看到过，它的不恰当应用会得出合乎语法却毫无意义的结果。我写这篇文章的时候找了很久，可是就是找不到了。不过反而有了其他的发现，比如<a href="http://wouter.coekaerts.be/2018/java-type-system-broken" target="_blank" rel="noopener">这个</a>和<a href="https://doi.org/10.1145/2983990.2984004" target="_blank" rel="noopener">这个</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看博客园，看到&lt;a href=&quot;https://www.cnblogs.com/thisiswhy/p/12059240.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇文章&lt;/a&gt;。它的主要内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 不支持 &lt;code&gt;null&lt;/code&gt; 值？因为这样就无法区分给定的键不存在还是对应值就是 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 不支持 &lt;code&gt;null&lt;/code&gt; 键？可能只是 Lea 自己的喜好——因为从逻辑上来说，允许也没有什么问题（虽然有潜在的语义错误）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章内容不赘述了。&lt;/p&gt;
&lt;p&gt;我看完之后想到的是，.NET 的并发容器（&lt;code&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; 等等）的 API 设计和它的普通容器有着巨大的不同。把它们和这个 &lt;code&gt;ConcurrentHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 的坑联系在一起，可能会发现什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Java" scheme="https://blog.mottomo.moe/tags/Java/"/>
    
      <category term=".NET" scheme="https://blog.mottomo.moe/tags/NET/"/>
    
      <category term="并发" scheme="https://blog.mottomo.moe/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python 加速好帮手：Numba</title>
    <link href="https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/"/>
    <id>https://blog.mottomo.moe/categories/Tech/zh/2019-12-06-Numba/</id>
    <published>2019-12-06T21:08:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>一次无可奈何的 Python 提速。</p><a id="more"></a><hr><p>先简单介绍一下背景。</p><p>这门课是 Visualization，由两个作业组成。第一个作业的代码部分，要求补完一个体渲染器（volume renderer）。这个渲染器是完全软件渲染的，而且需要支持几种渲染方式（也就是几种软件着色器）：切片（代码已给出）、<a href="https://en.wikipedia.org/wiki/Maximum_intensity_projection" target="_blank" rel="noopener">最大密度投影（MIP）</a>、体元合成（compositing）。不管哪一种，核心都是 <a href="https://en.wikipedia.org/wiki/Volume_ray_casting" target="_blank" rel="noopener">ray casting</a>。严格来说，每一个都有“合成”步骤，不过最后一个实际上指的是最常见的、使用 Phong 模型的着色。</p><p>今年我就被一个认识我的人叫过去帮忙了。去年我修这门课的时候，用的是 Java。今年据说因为 Java 入门（一个 master level 的课程，本来在 Q1，也就是 visualization 的前一个 quartile）移到了 bachelor level 3，所以在改革之后这门课默认所有选课的人都没有 Java 基础。因此，使用的语言改为了 Python。</p><p>我不得不严重吐槽今年的老师，虽然我并不认识他。内容比较长而且跟题目切合度不算太大，所以就放在文末。</p><p>好，接着就讲优化的事。下文的渲染时间以提供的橘子的数据为准。</p><p>由于各种坑爹因素的综合作用，切片的每帧渲染时间就已经超过了2秒。至于体元合成，因为所有体元基本都要至少被投射一次，总时间可达每帧10分钟（600秒）左右。其他的已经实现了这个的小组也反馈说，用时10分钟“是非常正常的”。</p><p>正常个毛！作为读者而不是这个坑爹软件的使用者，你可能不是很清楚它对人精神的打击有多大。首先，切换到体元合成模式，渲染初始帧，10分钟。接着，你会发现默认的迁移函数（transfer function）效果很差，需要调整曲线。当你调整第一个数值的时候，新的渲染开始了，又是10分钟。在这段时间内，你对迁移函数的调整完全不会反映出来——因为上一帧还没有渲染完成，所有更改都不会应用。你根据密度直方图大致估摸出了一个曲线，但为了它能起作用，你必须在上一帧渲染完成后，再次触发更改（比如调整颜色）才能获得正确的渲染结果，于是又要等10分钟。然后，你会看到默认的视角并不能看到什么有意义的东西，于是你得尝试调整视角。跟迁移函数一样，如果正在渲染，则新的视角不会应用。这就是多个10分钟。在你获得最后的满意的图像之前，精神上要受到长时间的折磨。说“折磨”，是因为这个时间根本就是因为种种错误导致的浪费生命，而且不止是一个人的生命。</p><p>怎么办呢？我们来想想方案的必要条件：</p><ul><li>使用 Python（恶心的规定）</li><li>非侵入式的</li><li>支持 GUI 实例</li></ul><p>补充条件：</p><ul><li>应用容易</li></ul><p>其实说到底，就是加速。加速，无外乎就是提高硬件利用率、合理利用硬件。例如，并行（CPU、GPU）、更高效率的代码（设计上、编译后）、提高缓存命中等等。</p><p>各位或许听说过 <a href="https://cython.org/" target="_blank" rel="noopener">Cython</a>。但是很可惜，虽然 Python 代码是合法的 Cython 代码，但是为了让 Cython 达到最高效率，必须要将代码改写成其方言。这就违反了非侵入式的条件，代码提交后别人也不容易运行这些代码。</p><p>Python 以性能为代价提供了极高的自由，而这给解释器设计让生成高效率的机器码带来的巨大的困难。所以不可能寄希望于 Python 解释器自身给我们提供极致性能。</p><p>我也试过用 <code>multiprocessing</code> 模块来加速。然而这并没有什么卵用。需要优化的函数是一个虚函数，而且位于事件回调，跟 GUI 有相当的耦合。这就不像一些常用 <code>multiprocessing</code> 优化的模块，那些模块基本是用于数值计算。而且它们的函数是全局的（对于子进程来说是入口），参数也利于封送，运行时产生的都是后台进程。当我简单使用 <code>multiprocessing</code> 的时候，这个程序直接弹出了好几个窗口，把我吓了一跳——而且它们没有一个在干活。</p><p><code>threading</code>？别忽悠人了。</p><p>还有一些其他的方法，不过投入的成本太高，对于一个作业，精力有限，做不起。（见文末讨论。）</p><hr><p>这时候偶然搜索到了 <a href="http://numba.pydata.org/" target="_blank" rel="noopener">Numba</a>。它和 Cython 的思路是相似的，在一定条件下，转换成 C 代码后编译运行，利用 C 的速度优势（“C 的速度优势”不是很准确，但是在此不展开了），提高代码执行效率。在满足一些苛刻的条件时，甚至还可以<a href="https://numba.pydata.org/numba-doc/dev/user/vectorize.html" target="_blank" rel="noopener">应用并行化</a>，进一步提高执行效率。</p><p>就使用体验而言，Numba 总体来说还是相当友好的。在正式用到作业项目之前，我用<a href="http://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/" target="_blank" rel="noopener">一篇文章中的示例</a>简单测试了一下优化效率。</p><pre><code class="lang-python">import timefrom typing import Callableimport numpy as npfrom numba import jitdef pairwise_python(X: np.ndarray) -&gt; np.ndarray:    M = X.shape[0]    N = X.shape[1]    D = np.empty((M, M), dtype=np.float)    for i in range(M):        for j in range(M):            d = 0.0            for k in range(N):                tmp = X[i, k] - X[j, k]                d += tmp * tmp            D[i, j] = np.sqrt(d)    return D@jit(nopython=True)def pairwise_numba(X: np.ndarray) -&gt; np.ndarray:    M = X.shape[0]    N = X.shape[1]    # https://github.com/numba/numba/issues/3993    # Use float_/int_ instead of float{XX}/int{XX}    D = np.empty((M, M), dtype=np.float_)    for i in range(M):        for j in range(M):            d = 0.0            for k in range(N):                tmp = X[i, k] - X[j, k]                d += tmp * tmp            D[i, j] = np.sqrt(d)    return Ddef pairwise_numpy(X: np.ndarray) -&gt; np.ndarray:    return np.sqrt(((X[:, None, :] - X) ** 2).sum(-1))def run_python() -&gt; None:    X = np.random.random((1000, 3))    pairwise_python(X)def run_numba() -&gt; None:    X = np.random.random((1000, 3))    pairwise_numba(X)def run_numpy() -&gt; None:    X = np.random.random((1000, 3))    pairwise_numpy(X)def time_it(name: str, func: Callable[[], None]) -&gt; None:    time_start = time.time()    func()    time_end = time.time()    print(f&quot;{name} used {time_end - time_start} second(s)&quot;)if __name__ == &quot;__main__&quot;:    time_it(&quot;raw python&quot;, run_python)    time_it(&quot;numba&quot;, run_numba)    time_it(&quot;numpy&quot;, run_numpy)</code></pre><p>在我的机器上运行，结果：</p><pre><code class="lang-plain">raw python used 5.295958518981934 second(s)numba used 0.3148195743560791 second(s)numpy used 0.05596804618835449 second(s)</code></pre><p>可见，仅仅是转换成等价 C 代码（还没有并行）并编译，就已经获得了巨大的效率提升。当然，这还是比不过 NumPy 的向量化操作（<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html" target="_blank" rel="noopener">ufunc</a>）。</p><p>不过，在这个作业里，每个最终像素点的实际生成过程是异构（heterogeneous）的，因此无法将其向量化，自然无法充分利用 NumPy。使用 Numba 并行是可能的；考虑到作业中的这个函数远比上面的简单例子复杂，尤其是输入的参数，所以尽管理论上可能，我也没这么多精力去适配它的条件了。</p><p>我们继续来看 Numba。Numba 提供了两种模式，一种是 <a href="https://numba.pydata.org/numba-doc/latest/glossary.html#term-nopython-mode" target="_blank" rel="noopener"><code>nopython</code> 模式</a>，一种是 <a href="https://numba.pydata.org/numba-doc/latest/glossary.html#term-object-mode" target="_blank" rel="noopener"><code>object</code> 模式</a>。前者不需要涉及 Python 的解释器，后者需要。什么时候需要呢？访问除了特定受支持的数据类型（<code>int</code>、<code>float</code>、<code>numpy.ndarray</code> 等等）之外的，尤其是自定义的复杂类型（简单类型可以用 <a href="https://numba.pydata.org/numba-doc/dev/user/jitclass.html" target="_blank" rel="noopener"><code>@jitclass</code></a>）。很明显，一旦和 Python 解释器扯上关系，那么效率就得大打折扣。再加上 JIT 是有开销的，所以最后总体甚至会慢于直接在解释器中执行。因此，一般都得用 <code>nopython</code> 模式。</p><p>接下来就是痛苦的转换了。毕竟 Numba 要能应用，是有限制条件的。</p><p>所以第一步，就是尽量做到与 OO 无关，而是回退到面向过程的方式。毕竟文档自己说了“越像 C 越好”（笑）。拆！拆！拆！好在原程序大部分都是不需要跟对象进行交互的，因此将主体变换为面向过程的方式并没有太复杂，就是繁琐一些，花一个小时就搞定了。同时考虑到 Python 无法内联的特性，分块大小偏大，减少调用开销。</p><p>不过里面有一个问题如鲠在喉；甚至说，如果不将它解决，那么其他的优化都无法生效，Numba 必然会回退到 <code>object</code> 模式。在循环的最深处，需要根据迁移函数获取在该视角（viewpoint）下某个体素（voxel）的对应颜色值。这可是插在层层循环中最深的地方的一个钉子。而必需的迁移函数，在实现上是一个复杂对象，<code>@jitclass</code> 还不支持。嗯，仔细观察一下，颜色计算其实是根据一张表实现的，而这张表在单次渲染中不发生变化。所以我就写了一个计算量不大的函数，将迁移函数的内部状态提取到了一个 <code>ndarray</code> 中，并修改颜色计算使其用这个 <code>ndarray</code> 而不是原来的迁移函数对象。这样核心计算就可以在 <code>nopython</code> 模式下进行了。</p><p>目前（0.46）Numba 还不支持 <code>MAKE_FUNCTION</code> opcode。Numba 只会报错说“<code>op_MAKE_FUNCTION</code> 未实现”。这么一个莫名其妙的错误信息还是得猜一下。结果是，它不支持函数内定义的函数，无论内部的函数是否形成闭包。所以我只好又违反了模块化原则，把一些内部的小函数提出来放到全局范围里。</p><p>最后优化到了什么程度呢？原先的每帧渲染时间是大约600秒，优化后冷启动24秒（含 JIT 时间），多次运行18秒。整整33倍！而且这仅仅是将 Python 代码 JIT 的结果，甚至都没有并行化。这个函数输入太多，签名复杂，所以我就不浪费时间去做并行化了——软件本身只是用来出结果的，后面还有报告呢，这时候离截止日期已经不远了。比起再花几个小时尝试优化到最佳状态，还不如就18秒先用着，毕竟看模型又不是重复数十次上百次的重复劳动，最后总计花费时间也不会太久。</p><hr><p>接下来就是纸上谈兵环节了。</p><p>我们看到了解释代码到原生代码的效率提升。如果要进一步优化异构任务的话，该怎么办呢？在这里再加一个前提：跟宿主语言无关，也就是要找一个相对通用的解。</p><p>一个很容易想到的方案是使用传统的 GPU。将计算逻辑变换成 shader，输入变换为顶点数据，输出从图像中解码。使用的 API 可以是 OpenGL（vertex/fragment）、Direct3D。这种做法别说现代 GPU，老一点的 GPU 都支持。缺点就是结果的复杂度不能太高，毕竟单元输出最多只有4个单精度浮点数。</p><p>如果使用 GPGPU，就可以避开许多输入输出的限制。可以使用的有 OpenGL（compute）、DirectCompute，以及 OpenCL 和 CUDA。其中一些还支持异构设备计算。</p><p>以上的方案，只要所使用的语言提供对应的绑定，就可以使用。</p><p>如果放宽“语言无关”限制，只针对 C/C++ 的话，有 OpenMP、OpenACC 和 SYCL。它们的效率提升方式不尽相同，有自动多线程并行的，有（合适时）使用 GPU 的。但是它们几乎可以和 C/C++ 无缝集成，而不需要将计算逻辑分离到独立的管线中。</p><hr><p>对这个老师的吐槽。</p><p>客观来讲，他犯了一个严重的选型错误。他应该是这么想的，Python 不是什么“新时代的基础语言”、“万能胶水语言”，“上手十分简单”嘛。但是很明显，Python 和 VB 一样，学习曲线的上升幅度开始平缓，接着立马就极端地陡峭，也就是易于上手，难于深入，更难于精通。Python 的运行效率不能说差，但是很不擅长计算密集型的任务（至少在包括默认的 CPython 上的大部分实现，因为有 <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock" target="_blank" rel="noopener">GIL</a>）。（另外插一句，<a href="https://www.python.org/dev/peps/pep-0554/" target="_blank" rel="noopener">PEP-554</a> 安排在 Python 3.9 了，所以现在也用不了。）而这门课要做的是一个<strong>软件</strong>渲染器，不仅是一个计算密集型的任务，而且是一个异构任务（不能简单地通过向量化完成）。写出逻辑是很简单的，但是一旦运行起来，就会发现它的运行时间无法忍受。想优化？对不起，优化异构任务的难度，已经远远超出了花样使用 NumPy（优化同构任务）；后者也早就不是初学者范围内的东西了。也就是说，这个作业在目标之外设置了一个巨大的障碍，而所有人不得不做出选择——要不就克服这个障碍，要不就得忍受折磨——而几乎没有人有能力克服。这是完全没有意义的精神消耗，至少对于学生而言。（现实工作中也有可能会遇到这样的问题，不过都已经到了工作了，自然就不能假设有保护了。）</p><p>他貌似对自己的水平没有准确的估计。由于很多人被折磨得死去活来，所以他似乎收到了一些问问题的邮件。将这些整理成 FAQ 之后，其中就有令人哭笑不得的回答。在程序中有一个 bug，它导致计算出的图像不会绘制到窗口中，也就是体现为“看不见”。这几乎是致命的问题，自然有人会问。而他的回答呢？“看不见图像的原因，很可能是因为你的计算机在计算上出了问题。”我真不知道该说什么好。</p><p>在代码上，可以明显看出 Java 移植的痕迹。在命名上和一些辅助类的结构上就看出来。除了 GUI 部分的代码遵循 wxPython 的一般规则、OpenGL（仅用来画包围盒）用 PyOpenGL，其他都是 Java 的简单移植。不过要说命名，Python 本身就已经很混乱了，缩写的、连写（无分隔）的、snake_case 的、camelCase 的，乱成一锅粥。以颜色的记录来说，OO 的组织方式比较利于理解，而直接使用 <code>ndarray</code> 更利于和 NumPy 交互，也利于优化。这更多地是一种设计选择，但是我认为有经验的话不会做出这样的选择。</p><p>程序本身交互极差。上面也提到了一部分。这个作业在最后还要完成第四种模式，将你所选定的可视化方式应用于分块的体数据。这相当于有一个一级列表，让你选择某个物体，然后再有一个二级列表，选择其在某个时间点下的数据。但是要进入这第四种模式可不是那么简单。这个模式对应的单选框默认是无效（灰色）的，你得先手工选择两个文件夹（体数据索引、各个时间），再选定了其中一个物体的其中一个时间点后，这个单选框才会激活。要不然，想切换都没法切换。这个操作本身就非常反直觉，如果没有那同学的讲解，我恐怕也得摸索个几分钟。在代码逻辑上，单物体（直接打开体数据）和多物体（本段所述的分块选择）的交互是两套代码……</p><p>由于不断地有人哀嚎渲染一帧实在是太久了，这老师在截止日期前几天发了一则公告，说如果想加速的话推荐使用 Numba。然而他在给出的例子是切片——最简单的渲染模式，基本上就是简单的 <code>ndarray</code> 读取，没有复杂循环，没有合成。这个直接套个 <code>@jit(nopython=True)</code> 就搞定了，非常简单。然而真正有优化需求的体元合成，要用上 Numba，那得知道 Numba 是怎么工作的、它对数据结构是怎么支持的、Python 本身的瓶颈在哪里、什么时候 Python 解释器是必需的（例如让人又爱又恨的 <code>inspect</code>），这样才能知道什么能加速什么不行，如果不行能不能换成等价的写法使得它能被加速。这在我看来，对知识厚度的要求远远超过这门课。将这种任务放在一个作业里，就是高射炮打蚊子。而且看来，他也没有对任务难度的合理估计，以为后面都只是像他给的例子那样，直接加个装饰器（decorator）那么简单。</p><p>不过，不是没有厉害的老师的。在我选过的课里面，就发生过：</p><ul><li>Foundations of Machine Learning。老师讲得很好，而且看代码也是简明扼要，清晰易懂，几乎没有冗余。</li><li>Recommender Systems，和 FML 是同一个老师。在第四个作业中，我们要实现一个 <a href="https://en.wikipedia.org/wiki/Autoencoder#Variational_autoencoder_%28VAE%29" target="_blank" rel="noopener">VAE</a>。其中助教提示的是“别忘了用 <a href="https://keras.io/backend/#flatten" target="_blank" rel="noopener"><code>flatten()</code></a> 调整数据的形状”，但是在查阅资料后我判断应该用 <a href="https://keras.io/backend/#batch_flatten" target="_blank" rel="noopener"><code>batch_flatten()</code></a>，就这么写了。后来在作业的点评里这一条被专门指了出来，说确实应该用 <code>batch_flatten()</code>，是他失误了。</li><li>VLSI Programming。就是我<a href="/categories/Misc/zh/2019-04-23-Misc/">之前</a>写过的老先生。图的构造代码写得非常漂亮，而且指出过我的一些 pythonic 的写法（例如<a href="https://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">列表推导</a>）有效率问题——在这门课里，效率是一个很重要的衡量因素。</li><li>Programming Methods。这门课其实是一个本科3级的课程，偏向于软件工程，我自愿选的。最后的一个作业是写一个 <a href="https://en.wikipedia.org/wiki/Takuzu" target="_blank" rel="noopener">Takuzu</a>（类似于数独，不过只填入0和1）的求解器，而且是可视化的。这个程序本来是用作各种设计模式的练习的，不过它的交互设计和代码水平都很不错。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次无可奈何的 Python 提速。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Python" scheme="https://blog.mottomo.moe/tags/Python/"/>
    
      <category term="Numba" scheme="https://blog.mottomo.moe/tags/Numba/"/>
    
  </entry>
  
  <entry>
    <title>C++ 模板类的非待决名查找</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-10-06-Non-Dependent-Lookup/</id>
    <published>2019-10-06T15:30:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>今天要做某个功能，其中我想用一个<em>单一参数的</em>宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）：</p><pre><code class="lang-cpp">#define DECLARE_CLASS(this_class, base_class) \    typedef base_class MyBase; \    typedef this_class MyClass</code></pre><p>对于普通的类，实现起来是这个样子：</p><pre><code class="lang-cpp">#define DECLARE_ROOT_CLASS(class_name) \    typedef class_name MyClass#define DECLARE_CLASS(class_name) \    typedef MyClass MyBase; \    typedef class_name MyClass</code></pre><p>使用：</p><pre><code class="lang-cpp">class Base {    DECLARE_ROOT_CLASS(Base);};class Derived : public Base {    DECLARE_CLASS(Derived);};</code></pre><p>很明显，这样利用 <code>typedef</code> 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 <code>typedef</code> 而不是更现代的 <code>using</code>，这在这里只是风格问题，对语义无影响。</p><p>对于模板类，我打算如法炮制。可是，问题出现了。</p><a id="more"></a><p>我的宏定义是这样的：</p><pre><code class="lang-cpp">#define DECLARE_ROOT_CLASS_TEMPLATE(class_name, TArgs...) \    typedef class_name&lt;TArgs&gt; MyClass#define DECLARE_CLASS_TEMPLATE(class_name, TArgs...) \    typedef MyClass MyBase; \    typedef class_name&lt;TArgs&gt; MyClass</code></pre><p>然而在编译的时候，在第4行产生了错误：</p><ul><li>（Clang 提示说，）VC++ 认为，<code>MyBase</code> 等同于 <code>MyClass</code>（假设仍然使用后文的例子，则 <code>Derived::MyBase</code> 等同于 <code>Derived</code> 而不是期望的 <code>Base</code>）；</li><li>Clang 和 GCC 认为，<code>MyBase</code> 未定义。</li></ul><p>我就不理解了，为什么是未定义呢？似乎以前 stat 给 UB（两个把 C++ 玩出花的大佬）讲过 VC++ 有符号名称查找（name lookup）上的错误，与标准的不符。但是，Clang 和 GCC 是怎么回事？这里的 VC++ 又是怎么回事？</p><p>所以我就问了 stat，如下的例子中为什么 <code>TBase</code> 处出错了。</p><pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;class Base {    typedef Base&lt;T1, T2&gt; TBase;    typedef TBase TThis;}template&lt;typename T1&gt;class Derived : public Base&lt;T1, T1*&gt; {    // 后注：在提问时我手写的；不过这样写在所有编译器中都不能通过编译，出问题的还是“typedef TThis TBase;”    typedef typename TBase::TThis TBase;    typedef Derived TThis;}</code></pre><p>stat 想了一会儿，说：“<code>TBase</code> 是 non-dependent，第一遍解析的时候找不到。”</p><p>什么是 non-dependent 呢，就是 dependent 的反义词咯。那什么又是 dependent 呢？我就搜索了一下。全称应该叫做 <a href="https://en.cppreference.com/w/cpp/language/dependent_name" target="_blank" rel="noopener">dependent name</a>，具体还可以分为 type-dependent 和 value-dependent。（不是 <a href="https://www.modernescpp.com/index.php/c-core-guidelines-argument-dependent-lookup-or-koenig-lookup" target="_blank" rel="noopener">argument-dependent lookup</a>！）</p><p>stat 所说的“第一遍解析的时候找不到”，指的是对模板类中符号的<a href="https://stackoverflow.com/a/1643190" target="_blank" rel="noopener">二次查找</a>。这里由于 <code>MyBase</code>（<code>TBase</code>）是一个普通符号，而不是 type-dependent（<code>SomeTemplate&lt;T&gt;::TBase</code>、<code>TBase&lt;T&gt;</code>）也不是 value-dependent（<code>SomeTemplate&lt;N&gt;::TBase</code>、<code>TBase&lt;N&gt;</code>），所以不能通过一次扫描来确定合适的上下文。也就是 stat 说的：“（解析）模版的时候 <code>TBase</code> 是不知道是基类的 <code>typedef</code> 的”。</p><p>不过，我并不知道中文该叫什么，本文标题里的“待决名”是将语言切换到中文后显示的翻译。</p><p>下一个问题，VC++ 这里的行为是怎么回事。让我们看看<a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance" target="_blank" rel="noopener">文档</a>和<a href="https://devblogs.microsoft.com/cppblog/permissive-switch/" target="_blank" rel="noopener">开发博客</a>里是怎么说的。VC++ 默认遵照的不是标准行为，而是往里面加了点毒。在进行二次查找时，查找的<a href="https://devblogs.microsoft.com/cppblog/two-phase-name-lookup-support-comes-to-msvc/" target="_blank" rel="noopener">位置错了</a>。就从文章中的例子来看看：</p><pre><code class="lang-cpp">#include &lt;cstdio&gt;void func(void*) {    std::puts(&quot;The call resolves to void*&quot;);}template&lt;typename T&gt;void g(T x) {    func(0);}void func(int) {    std::puts(&quot;The call resolves to int&quot;);}int main() {    g(3.14);}</code></pre><p>标准行为是，在模板类/模板函数中使用的符号，其查找位置为<em>定义处</em>，也就是说，要查找这个符号，范围应该从开头至此处。“定义”指的是模板的定义。而 VC++ 的行为是，查找位置在实际使用处。</p><p>按照这么个逻辑，上面的例子结果就很明显了。</p><ul><li>在标准行为下：<code>g()</code> 对 <code>func(0)</code> 的调用会被解析到 <code>void func(void*)</code>。因为在此时（直到 <code>func(0)</code>）编译器只知道这个声明，而且隐式转换是可以接受的。</li><li>在 VC++ 行为下，会被解析到 <code>void func(int)</code>。因为在此时（直到 <code>g(3.14)</code>）编译器知道两个重载了的声明（<code>void func(void*)</code> 和 <code>void func(int)</code>，而其中根据参数类型决断，更合适的是后者。</li></ul><p>同理，也就产生了上面的问题。在代码中，如果 <code>MyBase</code> 的使用晚于 <code>MyClass</code>，就会产生 <code>MyClass</code> 已经被重新 <code>typedef</code> 的情况，从而让 <code>MyBase</code> 指向错误的类型。当然，就算是顺序恰巧对了，在某些情况下（比如调用前出现了多种特化/偏特化），还有可能因为非标准行为而产生难以预料的后果。</p><hr><p>另外偶然看到的一个有意思的“可选命名参数”<a href="https://www.fluentcpp.com/2018/12/14/named-arguments-cpp/" target="_blank" rel="noopener">实现思路</a>和<a href="https://gitlab.com/tillheinzel/unorderednamedarguments" target="_blank" rel="noopener">代码</a>。调用效果类似 C# 的可选命名参数：</p><pre><code class="lang-cpp">void Test() {    CallSomeMethod(param2 = &quot;Param2Value&quot;, param1 = param1Value);    CallSomeMethod(param1 = param1Value, &quot;Param2Value&quot;);    CallSomeMethod(param1Value, &quot;Param2Value&quot;);}</code></pre><p>副作用就是会有少许污染。</p><hr><p>在移植的时候，在变量上我使用了和原来代码相同的命名，其中就包括 <code>xor</code>。结果编译器就报错了。</p><p>一查，才知道原来 C++ 还有一串<a href="https://en.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">运算符的替代表示法</a>。在默认情况下，这些替代名称是启用的，除非使用选项关闭。以链接中的例子来说，这样的代码虽然看上去很奇怪，但也是可以正常编译的：</p><pre><code class="lang-cpp">%:include &lt;iostream&gt;struct X&lt;%    compl X() &lt;%%&gt; // 析构函数    X() &lt;%%&gt;    X(const X bitand) = delete; // 复制构造函数    bool operator not_eq(const X bitand other)    &lt;%       return this not_eq bitand other;    %&gt;%&gt;;int main(int argc, char* argv&lt;::&gt;) &lt;%    // 带引用捕获的 lambda    auto greet = &lt;:bitand:&gt;(const char* name)    &lt;%        std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name                  &lt;&lt; &quot; from &quot; &lt;&lt; argv&lt;:0:&gt; &lt;&lt; &#39;\n&#39;;    %&gt;;    if (argc &gt; 1 and argv&lt;:1:&gt; not_eq nullptr) &lt;%        greet(argv&lt;:1:&gt;);    %&gt;%&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要做某个功能，其中我想用一个&lt;em&gt;单一参数的&lt;/em&gt;宏，来实现基类访问。毕竟两个参数的谁都会（我故意漏掉了末尾的分号，这样强制在使用时加上分号）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;#define DECLARE_CLASS(this_class, base_class) \
    typedef base_class MyBase; \
    typedef this_class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于普通的类，实现起来是这个样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;#define DECLARE_ROOT_CLASS(class_name) \
    typedef class_name MyClass

#define DECLARE_CLASS(class_name) \
    typedef MyClass MyBase; \
    typedef class_name MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;class Base {
    DECLARE_ROOT_CLASS(Base);
};

class Derived : public Base {
    DECLARE_CLASS(Derived);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显，这样利用 &lt;code&gt;typedef&lt;/code&gt; 的覆盖规则，省去了再抄一遍基类名称的麻烦。另外，我用了老式的 &lt;code&gt;typedef&lt;/code&gt; 而不是更现代的 &lt;code&gt;using&lt;/code&gt;，这在这里只是风格问题，对语义无影响。&lt;/p&gt;
&lt;p&gt;对于模板类，我打算如法炮制。可是，问题出现了。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="C++" scheme="https://blog.mottomo.moe/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>哈哈</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-04-23-Misc/</id>
    <published>2019-04-23T16:56:00.000Z</published>
    <updated>2020-03-30T22:34:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>技术长草。</p><a id="more"></a><hr><p>今天讲到 <a href="https://en.wikipedia.org/wiki/Kahn_process_networks" target="_blank" rel="noopener">Kahn Process Network</a>（KPN），我看到图示之后立刻反应过来，这结构不就是消息队列（message queue）吗。噫，消息队列“天然地”支持分布式架构，我理所当然地就接受了，因为有一点工程经验它就显得很自然了。没想到也是有一个理论支持的。</p><p>讲到并行化的实现思路（也即 parallelism），一般分为两类。<a href="https://ieeexplore.ieee.org/abstract/document/1631937" target="_blank" rel="noopener">多线程</a>实现的“并行”，虽然在具体实现中是不可或缺的，但是只能说是技巧（technique），而不是架构（architecture）。这门课针对的是 parallelism by design，是架构上的并行，而且在系统设计时就有着确定的行为。（注：KPN 中各个过程是可以并行的，但是整个系统仍然有着确定的行为。这是 KPN 的一个特性。）在课程描述里还讲到有一个叫做 parallelism by compilation 的，我不知道是什么（毕竟 compilation 可能指常见的“编译”之外的更泛的意思），所以就去问了。教授（略有学究气的老先生）回答说，如果编译器足够智能的话，就可以将过程分离（注：原话用的是“process”，不过并不是指进程，而是抽象出的过程——粒度可以是大到功能模块，也可以小到一个原子操作），并抽取出可以并行的部分，自动并行。说完之后，他盯着我，很认真地（从语气和眼神里可以体会到）说：“我<em>坚信</em>确定的并行化（parallelism by design）是最好的方案，虽然很少人这么想。”我不知道该说什么好了。我大概能猜到他的心情；不过总有一种“力挽狂澜”之感，专门开这么一门课。</p><p>这又让我想起了复杂系统的设计方式，构造和自组织。我的思想仍然受到<a href="https://www.techug.com/post/python-ai.html" target="_blank" rel="noopener">这篇文章</a>的影响。或许以前我引用过，但是在这里我还是想引用一次：</p><blockquote><p>但我并不认为 Java 有很大的机会，因为它本质上是为构造大型复杂系统而设计的。什么是大型复杂系统？就是由人清清楚楚描述和构造出来的系统，其规模和复杂性是外生的，或者说外界赋予的。</p><p>而 AI 的本质是一个自学习、自组织的系统，其规模和复杂性是一个数学模型在数据的喂养下自己长出来的，是内生的。</p></blockquote><p>不过，我仍然认为关键系统需要人为地设计其架构。“it just works”地在精细尺度上的、不可预测的并行，虽然显得很迷人，却是非常危险的。</p><hr><p>想起编译器优化的同时我又想起了之前和“博导”（我以前的一个同学，高中去了美国，大学读的……好像是电子工程；反正一直碾压同龄人）的一段对话。以下是节选：</p><blockquote><p>（前略）</p><p>我：这算什么，原教旨？<em>（注：指纯 C 写移动设备 app）</em></p><p>博导：算是吧，C 系手动内存正统，Java 等 GC 语言异端！我要确定性，掌控每一行代码！</p><p>我：抱歉，指令预测真的可以为所欲为。除非不断加 memory barrier，要不严格来说你无法掌控“每一行代码”。</p><p>博导：我知道 Intel 内部运作，知道 reordering 和 uop，所以是掌控的。<em>（注：uop = micro-operation）</em></p><p>博导：当然更加知道 GCC 每一行代码会编译成什么。</p><p>我：（图片：熊猫膜拜）</p><p>博导：其实 Intel 8卷读一遍就知道了。</p><p>我：（图片：许多熊猫一起膜拜）</p></blockquote><hr><p>不知道放哪里好，就放这里吧。</p><p><a href="https://www.semanticscholar.org/paper/Background-%3A-Physics-and-Math-of-Shading-Hoffman/237a3b12974e4bcf3d527dfd771271251133c3b6" target="_blank" rel="noopener">原文</a>：</p><blockquote><p>In a sense, the specular term gets “dibs” on the incoming light energy, and the diffuse term<br>can only use its “leftovers”. </p></blockquote><p><a href="https://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-3.html" target="_blank" rel="noopener">译文</a>：</p><blockquote><p>某种意义上，specular项指着入射光能量大喊“归我了”，然后diffuse项只能用“剩下的”。</p></blockquote><p>我读到这里的时候哈哈大笑。虽然这个翻译仍然有可以提高的地方，但是这个版本很有画面感。</p><blockquote><p>某种意义上，高光（specular）项占了入射光能量的大头，散射（diffuse）项就只能利用余下的能量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术长草。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>几种斐波那契数列项算法的复杂度分析</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2019-04-07-Fibonacci-Implementations/</id>
    <published>2019-04-07T18:44:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 <a href="http://bangumi.tv/subject/227102" target="_blank" rel="noopener">BEATLESS</a>。</p><hr><p>“回字有四样写法，你知道么？”</p><p>而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。</p><a id="more"></a><hr><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天在面试的时候被问到了这样一个问题：求斐波那契数列的第 $n$ 项，你能想到多少种算法？</p><p>自然，猴子都知道简单递归。再进一步，黑猩猩都能看出来递归可以用一个额外的表来速查（空间换时间）。有递归就自然要想能不能迭代。稍稍想一下的话可以知道是能迭代的。</p><p>然后又问，时间和空间复杂度是多少？</p><p>迭代简单，$T(n) = O(n)$，$S(n) = O(1)$。递归我就炸了（所以说我太水了），时间分析就满脸问号（用表的话……优化是优化了，但是和迭代也没差多少了，却还多了调用开销；简单递归分析卡壳了），没答上来，面试官也就没问空间复杂度。所以我当时只想到了两种；后来因为提到迭代的空间复杂度为 $O(1)$，面试官可能没太听清，说道：“（时间复杂度）$O(1)$ 的解法也是有的，不过你用了迭代只能是 $O(n)$ 了。”虽然和我的回答意思相差了一些，但是我还是惊诧了一下（没出声）：“这个 $O(1)$ 是怎么来的？”</p><p>所以下午我就搜索了一下。</p><p>……连个本科生（复杂度计算本科生都会）都比不过，我自裁罢。</p><h1 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h1><p>斐波那契数列 $f_n (n \in \mathbb{N})​$ 的定义如下：</p><script type="math/tex; mode=display">f_n = \begin{cases}    0,\quad &n \lt 1\\    1,\quad &1 \le n \le 2\\    f_{n-1} + f_{n-2},\quad &n \gt 2\end{cases}</script><p>之后的代码以此为准。</p><p>为了简单起见，在之后的代码中使用 <code>int</code>，而不是更大的 <code>long long</code>，懒得用无符号数，也没有防溢出机制。</p><h1 id="三、直接的代码解法"><a href="#三、直接的代码解法" class="headerlink" title="三、直接的代码解法"></a>三、直接的代码解法</h1><p>这部分的方法就是只用到代码、基础算法和优化，几乎不需要数学。</p><h2 id="3-1-递归法"><a href="#3-1-递归法" class="headerlink" title="3.1 递归法"></a>3.1 递归法</h2><p>递归就是最简单直接的方法了，代码形式和数学形式接近，理解很好理解，大部分工作交给计算机完成。</p><h3 id="3-1-1-朴素递归"><a href="#3-1-1-朴素递归" class="headerlink" title="3.1.1 朴素递归"></a>3.1.1 朴素递归</h3><p>朴素递归应该学过代码都会，代码就不需要多讲了。</p><pre><code class="lang-c">int fib(int n) {    if (n &lt; 1) {        return 0;    } else if (n &lt;= 2) {        return 1;    } else {        return fib(n - 1) + fib(n - 2);    }}</code></pre><p>对应的调用如下：</p><pre><code class="lang-c">int result = fib(15);</code></pre><p>这个算法的空间复杂度比较好分析（虽然有点绕），是 $O(n)$。令初始调用为第0层，调用一次加深一层。可以知道，在某一层的所有调用结束之前，不会产生新的调用（即，栈深不会增加）。那么栈深最深的是什么时候呢？画一棵调用树就可以看出，是从 <code>fib(n)</code> 开始到 <code>fib(1)</code>（实际上可以算到 <code>fib(2)</code> 为止）的这条“单刀直入”的路径。或者可以这么想，每次 <code>fib(n)</code> 执行实际计算（求和）的时候，<code>fib(n - 1)</code> 已经计算完成了。所以空间复杂度是 $O(n)$（更准确地说是 $\Theta(n)$）。</p><p>那么，时间复杂度是多少呢？许多文章直接就说结论是 $O(2^n)$，但是也没给出推导过程，或许也是因为太简单了。观察调用树可以知道，一个非叶子节点最多有两个子节点，而树的深度是 $O(n)$；在每个节点的操作都是简单加法，时间为 $\Theta(1)$；所以总计就是 $O(2^n)$。</p><p>但是大多数人没想过，这是一个好的估算吗？我们知道，大 O 函数只是给出上界；给出比一个已知上界更高的上界也不算错。也就是说，我可以胡扯说复杂度是 $O(2^{2^n})$，你也不能说我错了，只能说这个上界“质量不好”。</p><p>再次观察调用树，可以很明显地发现不管树高度如何增长，总是有不可忽视的一部分节点“缺失”了。因此，很明显还能找出比 $O(2^n)$ 更紧的上界。</p><p>为了计算这个上界，我们不妨来观察函数调用的过程。设 <code>fib(n)</code> 的调用时间为 $t<em>{n}​$ ，我们可以知道：$t</em>{n} = \Theta(1) + t<em>{n-1} + t</em>{n-2}​$。那么，这不是和原来的斐波那契数列形式完全一样吗？回到原点了。</p><p>但是等一下！斐波那契数列是可以求出通项的（见 <a href="4-3-%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F">4.3 节</a>）。提取“公因式” $\Theta(1)$（不是公因式，不过在复杂度分析中可以视作等量级；另外这个 $\Theta(1)$ 虽然上面是出现在递归式里，但是在通项中可以化为一个系数——这么讲不是很准确，不过意思就是这样）之后可以知道：</p><script type="math/tex; mode=display">\begin{align}T(n) &= \Theta(1) O((\frac{1+\sqrt{5}}{2})^n + (\frac{1-\sqrt{5}}{2})^n)\\     &= O((\frac{1+\sqrt{5}}{2})^n)\end{align}</script><p>$\frac{1+\sqrt{5}}{2} \approx 1.618$，虽说看起来好像比2差不了多少，不过对于 $n$ 很大的时候差距就比较明显了。这个上界明显比 $O(2^n)$ 要好，也是能获得的最紧的上界。</p><h3 id="3-1-2-尾递归"><a href="#3-1-2-尾递归" class="headerlink" title="3.1.2 尾递归"></a>3.1.2 尾递归</h3><p>既然朴素递归开销这么大，有没有可能用无敌的尾递归想想办法呢？毕竟一些现代编译器是支持尾递归优化为循环（迭代）的。（注：其实尾递归并不是无敌的，有着严格的应用条件；这里只是玩梗。）</p><p>我们知道，尾递归的一个重要条件是对调用自身后返回的结果不可以进行处理（即，尾调用——对自身的调用必须是返回前的最后一条指令）。那么我们将对之前的两个状态的操作（相加）转移到参数中，不就成了尾递归了吗。代码如下：</p><pre><code class="lang-c">int fib(int x1, int x2, int n) {    if (n &lt; 1) {        return 0;    } else if (n &lt;= 2) {        return 1;    } else if (n == 3) {        return x1 + x2;    } else {        return fib(x2, x1 + x2, n - 1);    }}</code></pre><p>对应的调用如下：</p><pre><code class="lang-c">int result = fib(1, 1, 15);</code></pre><p>这个的复杂度分析要考虑一下编译器。对于支持尾递归优化的编译器，这实际上跟下面的迭代是一样的，所以时间复杂度同为 $O(n)$，空间复杂度同为 $O(1)$。对于不支持的编译器，时间和空间的复杂度都很好分析，看参数 <code>n</code> 的变化就行——单次调用开销为 $\Theta(1)$，所以总复杂度同为 $O(n)$。</p><h2 id="3-2-迭代法"><a href="#3-2-迭代法" class="headerlink" title="3.2 迭代法"></a>3.2 迭代法</h2><p>不管是否想到了尾递归的方法，迭代都应该比较容易想到。如果想到了尾递归的话，很自然地可以进一步到迭代。</p><p>想法直截了当：既然每次只需要前两项的结果（状态），而 $f<em>{n-3}$ 并不会被 $f_n$ 及之后的计算直接用到，那么为什么要保存其他状态呢？$f</em>{n-1}$ 和 $f_{n-2}$ 已经很好地充当了“缓存”的功能。代码如下：</p><pre><code class="lang-c">int fib(int n) {    if (n &lt; 1) {        return 0;    } else if (n &lt;= 2) {        return 1;    } else {        int n1 = 1, n2 = 1;        int tmp;        for (int i = 3; i &lt; n; ++i) {            tmp = n1 + n2;            n1 = n2;            n2 = tmp;        }        return n2;    }}</code></pre><p>调用如下：</p><pre><code class="lang-c">int result = fib(15);</code></pre><p>显而易见，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$（更准确地说是 $\Theta(1)​$）。我觉得分析都不用写了。</p><h1 id="四、含数学分析的解法"><a href="#四、含数学分析的解法" class="headerlink" title="四、含数学分析的解法"></a>四、含数学分析的解法</h1><p>简单暴力的代码解法毕竟是太拿衣服。要往深了优化（或者给出无法继续优化的证据）还是得要数学。</p><h2 id="4-1-数列分析"><a href="#4-1-数列分析" class="headerlink" title="4.1 数列分析"></a>4.1 数列分析</h2><p>为了理解接下来的分析，首先要知道特征方程。数列的特征方程我记得是高中讲过的，可是后来一直都没怎么用过（高数里也是）；加上本来我数学就弱，所以基本就是忘光了。对不起了，宋老师。</p><p>斐波那契数列是一个二阶的递推数列，一般形式为 $x<em>{n} = c</em>{1}x<em>{n-1} + c</em>{2}x<em>{n-2}$。假设能找到两个数 $p$ 和 $q$，使得 $x</em>{n} - px<em>{n-1} = q(x</em>{n-1} - px<em>{n-2})$，移项得 $x_n = (p+q)x</em>{n-1} - pqx<em>{n-2}$。所以有 $p + q = c_1$，$pq = -c_2$。不难看出 $p$ 和 $q$ 的地位是相等的，因此消去任意一个（以 $q$ 为例）可得 $p^2 - c</em>{1}p - c_2 = 0$。这就是二阶递推数列的特征方程。求解该二次方程，两个实根（如果有）就是 $p$ 和 $q$。</p><p>代回原来的数列形式，若 $p \ne q$，则通项为 $x_n = \frac{x_2-qx_1}{p(p-q)}p^n + \frac{px_1-x_2}{q(p-q)}q^n$；若 $p=q$，则通项为 $x_n = (\frac{px_1-x_2}{p^2} + \frac{x_2-px_1}{p^2}n)p^n$。</p><p>将斐波那契数列代入（即 $c_1 = 1, c_2 = 1$）可以解得 $p = \frac{1+\sqrt{5}}{2}$，$q = \frac{1-\sqrt{5}}{2}$（$p$ 和 $q​$ 可互换）。</p><h2 id="4-2-改进的迭代：矩阵快速幂"><a href="#4-2-改进的迭代：矩阵快速幂" class="headerlink" title="4.2 改进的迭代：矩阵快速幂"></a>4.2 改进的迭代：矩阵快速幂</h2><p>（是搜索之后才知道有可以应用“矩阵快速幂”这么一类问题的。我没参加过 ACM，所以渣了。）</p><p>从 <a href="#4-1-%E6%95%B0%E5%88%97%E5%88%86%E6%9E%90">4.1 节</a>可知，存在符合条件的 $p$ 和 $q$。于是，就可以将每次求值化为矩阵乘法。</p><p>对于 $k$ 阶线性递推数列 $x<em>n = c</em>{1}x<em>{n-1} + c</em>{2}x<em>{n-2} + \cdots + c</em>{k}x_{n-k}$，每次递推可以表示为：</p><script type="math/tex; mode=display">[x_n, x_{n-1}, \dots, x_{n-(k-1)}] = [x_{n-1}, x_{n-2}, \dots, x_{n-k}] \times \mathbf{M}</script><p>其中大小为 $k \times k$ 的矩阵 $\mathbf{M}$ 就是……呃，好像没有标准称呼？就叫递推矩阵好了。由此可见，由于 $\mathbf{M}$ 在递推过程中不变，计算 $x_n$ 就被转化为了计算矩阵的幂的问题。这个矩阵受初始值选取和递推公式两方面的影响。</p><p>对于斐波那契数列，给定初始值 $[1, 1]$，可以得到</p><script type="math/tex; mode=display">\mathbf{M} = \begin{bmatrix}    1 & 1\\    1 & 0\end{bmatrix}</script><p>虽说是矩阵快速幂，但是对幂函数的计算优化其实和数的是一样的，只不过乘法的定义略有不同。</p><p>要计算一个数 $a$ 的 $n$ 次幂，最直接的想法是连乘，时间复杂度为 $O(n)$。但是只要见过质数筛这类的问题，或者是插值函数优化，就马上会意识到，其中许多次的乘法是多余的，结果是可以缓存的（甚至可以不用缓存）。那么，如何剔除这些多余的计算呢？</p><p>不是有对数函数嘛。大杀器。</p><p>考虑到实现的便利性，一般就取 2 为底了。将幂次 $n$ 分解为 2 的幂的和：$n = c<em>{0}2^0 + c</em>{1}2^1 + \cdots + c<em>{m}2^{m}$，其中 $c_i \in {0, 1} (0 \le i \lt m), c_m = 1$。进一步展开到乘法，就可以看到，$a^n = a^{c</em>{0}2^0} \times a^{c<em>{1}2^1} \times \cdots \times a^{c</em>{m}2^m}$。这样，从前往后“扫描”，由于 $a^{2^n} \times a^{2^n} = a^{2^{n+1}}$（废话），所以只需要保存最近的中间结果，就可以依次得到正确的乘积，并最终得到 $a^n$。代码如下：</p><pre><code class="lang-c">// 简洁起见，仅处理 a &gt; 0, n &gt;= 0 的情况int pown_fast(int a, int n) {    int result = 1;    int cur = a;    while (n &gt; 0) {        if (n &amp; 1) {            result = result * cur;        }        cur = cur * cur;        n = n &gt;&gt; 1;    }    return result;}</code></pre><p>可以见到，<code>pown_fast()</code> 的时间复杂度为 $O(\log n)​$，空间复杂度为 $O(1)​$（$\Theta(1)​$）。对于矩阵的幂，由于斐波那契数列相关的递推矩阵大小是常数，所以时间和空间复杂度都和计算数的幂是一样的。再考虑初始值的输入等等，最终的时间复杂度为 $O(\log n) + \Theta(1) = O(\log n)​$，空间复杂度为 $\Theta(1) + \Theta(1) = \Theta(1)​$。</p><p>也有用类似思想，但不是快速幂的解法，而是采用新的递推公式，参见<a href="http://blog.zhengyi.one/fibonacci-in-logn.html" target="_blank" rel="noopener">[1]</a>。</p><h2 id="4-3-通项公式"><a href="#4-3-通项公式" class="headerlink" title="4.3 通项公式"></a>4.3 通项公式</h2><p>将 $p​$ 和 $q​$ 的值代入 <a href="#4-1-%E6%95%B0%E5%88%97%E5%88%86%E6%9E%90">4.1 节</a>的通项公式可得： $f_n = \frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^n + (\frac{1-\sqrt{5}}{2})^n)​$。</p><p>按照这个通项计算 $f_n​$，理论上可以达到 $O(1)​$ 的时间复杂度。</p><p>很美妙，不是吗？$O(1)$ 和 $O(1)$ 啊！但是简单地计算依然会出问题。这个公式中，多处涉及了（在最终结果前）无法约简的无理数。在现代的计算框架中，如果按照一般的思维，用浮点数来表示这些无理数，进行计算的话，一定有因浮点数的不精确性导致的误差。$n$ 越大，误差越大。且不说“四舍五入”这个行为在此正不正确，当误差超过 0.5 的时候，舍入都救不回来了。所以在实践中，这个方法是不可取的。</p><p>当然不是没有能保证精度的方法。采用符号代数就可以了。而且这个计算过程中的无理数只有 $\sqrt{5}$ 一个，而且 $(\sqrt{5})^2 = 5$ 还是个整数。不过计算过程就得根据二项式定理展开，然后累加并分类求和，所花的时间肯定会多于 $O(n)$，空间开销也不会小。</p><h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>以上我们见到了五种计算 $f_n$ 的方法：</p><ul><li>朴素递归，$T(n) = O((\frac{1+\sqrt{5}}{2})^n)$，$S(n) = O(n)$；</li><li>尾递归，在有优化的情况下 $T(n) = O(n)$，$S(n) = O(1)$；</li><li>迭代，$T(n) = O(n)$，$S(n) = O(1)$；</li><li>快速幂，$T(n) = O(\log n)$，$S(n) = O(1)$；</li><li>通项，$T(n) = O(1)$，$S(n) = O(1)​$。</li></ul><p>在几种方法中，时间和空间复杂度都是从前往后越来越好。但是通项由于需要用浮点数表示无理数的值会导致误差所以基本上不能用。所以综合各种因素考虑，最优的算法是采用快速幂计算 $f_n$。</p><hr><p>参考：</p><ul><li>[1] <a href="http://blog.zhengyi.one/fibonacci-in-logn.html" target="_blank" rel="noopener">五种方法计算斐波那契数列的第n项</a></li><li>[2] <a href="https://blog.csdn.net/dangzhangjing97/article/details/78778536" target="_blank" rel="noopener">斐波那契数列的三种解法及时间复杂度</a></li><li>[3] <a href="https://blog.csdn.net/u012684062/article/details/76330075" target="_blank" rel="noopener">斐波那契数列数列的三种时间复杂度的实现方法</a></li><li>[4] <a href="https://www.geeksforgeeks.org/time-complexity-recursive-fibonacci-program/" target="_blank" rel="noopener">Time complexity of recursive Fibonacci program</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GRIS 的文章，没鸽。真的。星月妹妹什么时候骗过你了？而且我还准备开新坑讲一下 &lt;a href=&quot;http://bangumi.tv/subject/227102&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BEATLESS&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;“回字有四样写法，你知道么？”&lt;/p&gt;
&lt;p&gt;而且似乎不少人写过这玩意儿了。所以您也可以将本文作为茶余饭后的消遣，乐乐就好。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="算法" scheme="https://blog.mottomo.moe/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随便写点什么</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-03-06-Misc/</id>
    <published>2019-03-06T00:33:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>GRIS 的文章呢？</p><p>别急，不会鸽的。</p><hr><p>二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。</p><p>那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。）</p><p>反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。</p><a id="more"></a><hr><p>昨晚又小小地反向了一把，对象是<del>京东娃娃项目</del><a href="http://www.projecttokyodolls.jp/" target="_blank" rel="noopener">东京偶像计划</a>（プロジェクト東京ドールズ）。关于结果 esterTion 应该已经更新在他的<a href="https://estertion.win/2019/03/project-tokyo-dolls-%e6%8b%86%e8%a7%a3%e7%9b%b8%e5%85%b3/" target="_blank" rel="noopener">文章</a>里了。</p><p>其实只是蹲坑的时候刷 Google Play，给我推荐了一个这玩意儿。看着画风还行，打开看看。嘛游戏内容（小人打架加一些反应要素）我就不感兴趣了（而且世界观的建构更是让人一脸问号），但是一些图啊模型啊还是不错的。（“穿着偶像衣服却不干偶像的事。” by 群友）饰品分离目前我只见过 Square Enix（<a href="http://schoolgirlstrikers.jp/" target="_blank" rel="noopener">SGS</a>、京东娃娃）和 Konami（<a href="https://www.konami.com/games/tokimeki-idol/" target="_blank" rel="noopener">心跳凉凉</a>）做过，大概还有一些参考价值？心跳偶像本来我想着跟土豆一样反向的，但是安卓严重混淆，我又没有越狱的 iPhone，没办法；后来……它就停服了。</p><p>有点远了。这次反向其实还挺简单的，esterTion 已经找到了关键的类和方法，所以省了很多事，只要耐心读就行了。他大概只是心急失手了而已。如果他又想吹我，您别听他的；我只是个弱渣。</p><p>IL2CPP 的反向比一般的原生代码要简单的一点是，它保留了很多 IL 的特征，C++ 编译器无法完全将它们优化。比如在这次挨个设置密钥数组元素的时候，就出现了很明显的一种模式：</p><pre><code class="lang-c++">if (array.metadata.length &lt; 0) throw_index_out_of_range_exception();array.elements[0] = elem0;if (array.metadata.length &lt; 1) throw_index_out_of_range_exception();array.elements[1] = elem1;if (array.metadata.length &lt; 2) throw_index_out_of_range_exception();array.elements[2] = elem2;if (array.metadata.length &lt; 3) throw_index_out_of_range_exception();array.elements[3] = elem3;</code></pre><p>在反编译的代码中，上面都是用偏移表示的。虽然在没看 IL2CPP <code>Array</code> 的源代码的情况下，并不清楚这个结构每个偏移是什么（快去看，懒虫），但是根据这么几个连续的偏移规律，也能摸个大概。再想想对应的 C# 是怎么样的：</p><pre><code class="lang-c#">arr[0] = elem0;arr[1] = elem1;arr[2] = elem2;arr[3] = elem3;</code></pre><p>在实际使用中，这个索引测试一般不是手工做的。因此可以猜测是在 IL2CPP 变换的过程中自动插入的片段，以保持语义一致（<code>ldelem.*</code>）。</p><p>与此类似的还有 IL2CPP 类型初始化（不是 <code>.cctor</code>）、IL2CPP 实例初始化（不是 <code>.ctor</code>）、加载静态的引用类型字段等等，生成的代码一看就知道是干什么的。这些重复的模式比起“一般的” C++ 来说要仁慈多了。</p><p>当然 C++ 编译器也不是吃素的，明显能优化的地方一定会优化。比如简单的 getter/setter，尤其是简单类型的自动属性，会被直接内联。我就说怎么一些属性的 getter/setter 无法被 xref，结果一看只要是简单赋值，全都跑到实际使用位置去了。而且恶心的是，这通常指的是指针+偏移访问。这就防住了简单的使用检索（find usage），如果是关键属性的话会非常头疼。</p><p>IDA 的 F5 并不能完美地反编译，有时候需要进入函数再出来，让它更新函数签名，特别是变参函数和看上去参数奇怪的函数调用。再比如，在 <code>MakeUrlCore()</code> 的关键调用签名更新完毕后，会发现有返回值没被使用的情况。而这些函数并没有修改 call site 所在实例的内部状态，这时就根据下文推断返回值使用的地方，而且可以回到汇编窗口验证。对，我说的是获取 UTF-8 字节数组之后计算 MD5 hash 的那一块。</p><p>如果对 .NET 比较了解，少数虚函数表里的调用也可以根据上下文推断。<code>string + Encoding.MethodX() -&gt; A; HashAlgorithm.ComputeHash(A)</code>，那么这个 <code>MethodX()</code> 就极有可能是 <code>GetBytes()</code>，即使是虚函数，而且（在 F5 中）缺少实参来判断。再比如，<code>StringBuilder.MethodY() -&gt; B; string.Concat(B, ...)</code>，那么这个 <code>MethodY()</code> 就极有可能是 <code>ToString()</code>，即使因为虚函数表+静态分析的原因无法看到实际调用的是哪个函数。这种思路跟中学的化合物推断是很相似的。</p><hr><p>说到反向，还有有趣的事情。上一周有一次组会的时候，我们预订的是学校最新的大楼的一个房间。那里面就有一个无线屏幕，可以把设备的屏幕无线地投射到显示器上。一个组员（本科生）说，他在另一门课（好像是 IoT Security 还是什么的）的小组就对这个屏幕使用的客户端下手了，写了一个非官方的客户端，能绕过一些限制来登录。</p><p>这肯定让我玩心大发啦。简单看了一下客户端，是一个无任何混淆的 WPF 应用程序。迅速扒光。然后跟着进入 P/Invoke 的原生库，稍微摸了一下结构。另一个是 C++/CLI 的 wrapper，依赖的是 C++ 的。在找不到公开文档和调试信息的情况下，后者基本是不可能静态分析的。</p><p>根据我原来看到的信息，我觉得这个系统的验证是存在漏洞的，理论上可以很容易地伪造用户登录和播放任意内容。不过刚才我看了更多的资料和代码之后否定了之前的想法。任意登录下降为<em>可能的</em>，在服务器配置存在特定配置缺陷的情况下；同时对登录有比之前所见的更大的限制。这就带来了攻击成本的上升和回报的下降，导致显得不划算。不过，反跟踪仍然是可以使用低成本的方式做到。</p><p>关于这个 WPF 程序的软件质量，我要称赞它，是软件工程的范本。遍地都是契约检查、防御性编程、打印日志（而且模糊了隐私信息），很专业嘛。</p><p>啊，本来还想着也许能做个白帽黑客的，不过现在看起来这个案例可能没什么能让我出手的地方了。</p><p>不过等到假期结束，我还是想亲手试试。</p><p>毕竟人家本科生都能做到的事情，我要是做不到，就太丢脸了。我虽然不知道他们做到了哪一步，但是必须要假设我想到的都已经完成了。</p><hr><p>说到假期，这个星期是<a href="https://en.wikipedia.org/wiki/Carnival_in_the_Netherlands" target="_blank" rel="noopener">狂欢节</a>假期。因为艾因霍温在南部嘛，而狂欢节是南部地区在庆祝，所以我们就有了这么一个假期咯。</p><p>上周六和昨天晚上去超市的时候，路上偶尔会看见一些穿着“奇装异服”的人。在上面的维基百科链接中可以看到大概的样子。你也可以在<a href="https://www.local-life.com/eindhoven/articles/carnaval-in-eindhoven" target="_blank" rel="noopener">这里</a>读到去年的样子。不过我没事又不经常出门，而且这还是在晚上，所以只能看见整个节日的一点点。狂欢游行什么的根本没有参与过，但是的确能在市中心看到不少散发着啤酒味的一次性杯子和几个临时的 live house。</p><hr><p>前几天开始我的左耳突然出毛病了。最开始的时候是时不时堵着，就跟坐飞机一样；但无法通过活动咽喉来解决，只能手动按压通气。而后一天晚上玩了一下 <a href="https://store.steampowered.com/app/210970/The_Witness/" target="_blank" rel="noopener">The Witness</a>，不过饱和度太高，不久就中等恶心（我玩大多数游戏都没有3D眩晕），受不了了。第二天起来还没发现什么异常，但是联机打了一局黑魂之后就发现对敌人的听觉定位不准了——正中的声源，会听起来偏右。再自言自语的时候就感觉颅内传导的声音，右耳出去了，但左耳好像碰到了什么，反射回来一部分，形成了混响。</p><p>虽说现在已经要找医生了，但是还得先处理别的麻烦事——验证邮件收不到，就无法完成电子身份认证，就无法预约。而现在正是狂欢节假期，不知道会不会影响。即使是能预约了，按照我的经验，也得等至少一个星期。这时候我就很怀念国内的挂号了。</p><p>所以……没办法咯，只好先习惯目前的处境，调整大脑的处理方式，希望之后不会耽误什么。</p><p>哇，如果听不见声音的话（或者只能借助于骨传导），我可会很难过的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GRIS 的文章呢？&lt;/p&gt;
&lt;p&gt;别急，不会鸽的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;二月份都比较忙，所以除了试着玩了一下基础的光线追踪以及用它尝试了一把 OpenCL/SYCL 之外，没做什么自己的玩意儿。啊说到 OpenCL，用过之后觉得，它的限制和坑还是挺多的。也许有时间我写一篇文章讲讲这些；毕竟关于如何“正常地”使用，许多人都写过了。&lt;/p&gt;
&lt;p&gt;那就讲讲最近的事情吧。（本来想显示全文的，结果写完发现太长了，就写了简单的关键词。）&lt;/p&gt;
&lt;p&gt;反向工程：东京偶像计划、无线屏幕；狂欢节；杂事。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="逆向工程" scheme="https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="手游" scheme="https://blog.mottomo.moe/tags/%E6%89%8B%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>新年</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2019-02-05-New-Year/</id>
    <published>2019-02-05T06:42:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。</p><p>如果有人关注我最近的活动的话或许会注意到，这半年来我推代码的频次相较以往同期要少。嗯，首先是 CS 确实很有意思，而且以我的基础可以看得比较全面（能自然地看见“点”之间的“线”），这样要深挖的就多多了。HTI……我的思维运转方式不是那样的，所以除了课上讲的冰山一角，基本都看不清，所以业余时间都投入到代码上了。</p><p>还有一个原因是我希望做一个更<em>有趣</em>的人。除了抽象的代码，我也乐于欣赏艺术创作。欣赏久了，自然就产生了投身于创作的想法。就像笼中之鸟羡慕飞翔的鸟儿一样。以我的性格，要是只能代码一条路走到黑我肯定要抹脖子了。临渊羡鱼，不如退而结网。</p><p>在B站上我之前一般是做烧笋的创作谱面；去年因为造一些轮子所以发了一些成果视频。这是我放松的一个选择。但是这毕竟形式非常单一而且（我认为）总是摆脱不了无生命感。——写谱面，在许许多多的规则之下，发挥的余地其实比较少（我不是硬核玩家），而且普遍关注的是技术难度，缺少要表达的主题。每一种艺术都不过是表达的方式，私以为代码也是这么一种手段；有的人擅长这种，有的人擅长那种，仅此而已。当然观众也得有相应的鉴赏能力。</p><p>所以我就想了，要是投入等量的时间，能让一种技能从70上升到75，或者让另一种从0上升到15，该如何选择呢？事实上这和 RPG 游戏加点一样是个一直困扰着我的难题。我选择在艺术上从0加到15，很清楚这并不会带来“一技傍身”的优势，而是希望借由将自身化为艺术创作者，去理解他们的视角和思维，会遇到什么问题，我的方案比别人差在哪里或者好在哪里。</p><p>继最开始的简单剪辑（<a href="https://www.bilibili.com/video/av34419159" target="_blank" rel="noopener">1</a>、<a href="https://www.bilibili.com/video/av36992638" target="_blank" rel="noopener">2</a>）之后，我开始尝试其他的形式：混搭（<a href="https://www.bilibili.com/video/av37445247" target="_blank" rel="noopener">1</a>、<a href="https://www.bilibili.com/video/av37593014" target="_blank" rel="noopener">2</a>）、手书（<a href="https://www.bilibili.com/video/av38332164" target="_blank" rel="noopener">1</a>、<a href="https://www.bilibili.com/video/av42680447" target="_blank" rel="noopener">2</a>）、<a href="https://www.bilibili.com/video/av39367371" target="_blank" rel="noopener">MAD</a> 和<a href="https://www.bilibili.com/video/av40274183" target="_blank" rel="noopener">改谱</a>（远算不上编曲）。每个作品的个中滋味恐怕都不是一两段话能说完的，也并不只是视频简介里的那些。当然，创作水平肯定是无法一蹴而就的。所以除了我自己的练习和体悟之外，我希望寻找更新的<em>想法</em>，希望它们也确实地传达给观众了。反正又不图名又不图利，若是能被欣赏，或进一步地，在此基础上衍生创作，丰富大环境，那就是更好的了。</p><p>那么近况如何呢？我确实在大脑没退化的前提下比之前更快乐了。比之前整天在代码上挖掘，望天叹气要好多了。我觉得这偶尔的音乐、绘画和视频创作是有一份功劳的。自己有趣不有趣……还不知道。至于产出的效益，那要等时间来回答。</p><p>胡乱说了一些话，权当跨（农历）年的一篇吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我最近在写关于 GRIS 的文章。由于种种原因，现在进度只有大约三分之一，所以更新要等到之后了。不过我尽量赶在时间节点之前写完。为什么要写，简单说来，就是冲击太大了，“余音绕梁，三日不绝”。回头再看一些我所知道的玩意儿，瞬间就觉得索然无味。&lt;/p&gt;
&lt;p&gt;如果有人关注我最近
      
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>NW.js 的上下文问题</title>
    <link href="https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/"/>
    <id>https://blog.mottomo.moe/categories/Tech/Coding/zh/2018-12-19-NWJS-Context/</id>
    <published>2018-12-19T18:03:00.000Z</published>
    <updated>2020-03-30T22:34:35.451Z</updated>
    
    <content type="html"><![CDATA[<p>NW.js 有一个或两个上下文，使用时要多加小心。</p><a id="more"></a><hr><p>最近因为做项目，需要用到 NW.js。在搭环境的时候，我自然要写一个最简单的功能来测试了。我的例子是一个关闭按钮。简明起见，下面的代码复现的是在第二次试验。注释“2”的是第二次测试添加的输出，“1”是第一次的。</p><p><code>bootstrap.ts</code>：</p><pre><code class="lang-typescript">import * as main from &quot;./main&quot;;console.log(&quot;imported&quot;); // 2main.bindCloseKey();</code></pre><p><code>bootstrap.ts</code> 是编译为 ECMAScript 5 之后，加了个简单的兼容片段（解决 <code>exports</code> 找不到的问题），直接从页面链接的。</p><p><code>main.ts</code>：</p><pre><code class="lang-typescript">console.log(&quot;exported&quot;); // 2export function bindCloseKey(): void {    console.log(&quot;called&quot;); // 2    const button: HTMLButtonElement = document.querySelector(&quot;#close&quot;);    if (!button) {        console.log(&quot;Button not found: &quot; + selector); // 1    } else {        console.log(&quot;Button found&quot;); // 1        button.addEventListener(&quot;close&quot;, () =&gt; {            window.close();        });    }}</code></pre><p>主要功能如上所示，功能很简单，如果找到按钮就尝试绑定事件，不管找没找到都有一个输出。</p><p>但奇怪的是，实际运行的时候，点击按钮没有反应；打开开发者控制台（直接按 <kbd>F12</kbd>）却看不见任何输出。</p><p>于是加了几条注释之后再跑，只见到了第一条输出，也就是“imported”。</p><p>那么其他的输出在哪里？功能到底执行了没有？我猜想是目标问题，于是切换到 ECMAScript 6，顺便认识和试用了一下 <a href="https://nodejs.org/api/esm.html" target="_blank" rel="noopener">ESM</a>（就是那些 <code>.mjs</code> 文件），但问题还是没有解决。</p><p>无奈之下只好谷歌了。但是大多数人是希望将开发者控制台的输出重定向到系统控制台（确实有<a href="https://stackoverflow.com/a/38972028" target="_blank" rel="noopener">解决方案</a>，在     <code>package.json</code> 里加入 <code>&quot;chromium-args&quot;: &quot;--enable-logging=stderr&quot;</code>），我是纳闷为什么看不见开发者控制台的输出。结果发现了<a href="https://stackoverflow.com/a/35127692" target="_blank" rel="noopener">答案</a>，也就是该做的是手动右键检查背景页；<kbd>F12</kbd> 是审查应用的当前页，而 NW.js 的 app 是作为扩展载入的，所以两个页面不同。</p><p>考虑到项目完工时手动右键检查背景页未必可用，我想了一个变通的方法。<code>console</code> 看上去是个全局对象，实际上是 <code>window</code> 的属性。那么我将 <code>window</code> 的引用传过去不就好了？</p><p><code>bootstrap.ts</code>：</p><pre><code class="lang-typescript">import * as main from &quot;./main&quot;;main.setWindow(window);main.bindCloseKey();</code></pre><p><code>main.ts</code>：</p><pre><code class="lang-typescript">let $window: Window = null;export function setWindow(window: Window): void {    $window = window;}export function bindCloseKey(): void {    const button: HTMLButtonElement = document.querySelector(&quot;#close&quot;);    if (!button) {        $window.console.log(&quot;Button not found: &quot; + selector); // 1    } else {        $window.console.log(&quot;Button found&quot;); // 1        button.addEventListener(&quot;close&quot;, () =&gt; {            $window.close();        });    }}</code></pre><p>这次能看到输出了。但是显示的居然是“Button not found”！</p><p>我再次确认了，HTML 页面是能找到这个按钮的元素的。好吧，手动执行一下试试。分别在 app 页和背景页的开发者控制台执行 <code>document.querySelector(&quot;#close&quot;)</code>，前者返回的是 <code>null</code>，而后者返回了一个 <code>&lt;button&gt;</code>。</p><p>这下我就知道为什么了。两个页面之间有一堵无形的“墙”，一个负责前台（Chromium 端），一个负责逻辑（Node.js 端），有点类似 WebWorker。但和 WebWorker 不同的是，这个隔离的双方都能访问通用全局对象（<code>window</code> 等等），然而访问的却不是同一个对象。上面 <code>$window.console</code> 来自“能和页面交互的” <code>window</code>，<code>document</code>（实际上是 <code>window.document</code>）来自“不能和页面交互的” <code>window</code>。</p><p>后来再看，原来是 0.13 加入的上下文分离，在 NW.js 的<a href="http://docs.nwjs.io/en/latest/For%20Users/Advanced/JavaScript%20Contexts%20in%20NW.js/" target="_blank" rel="noopener">文档</a>里其实也写明白了。调试不同上下文的代码则需要分<a href="http://docs.nwjs.io/en/latest/For%20Users/Debugging%20with%20DevTools/#nodejs-modules-debugging" target="_blank" rel="noopener">不同的开发者工具</a>。用 <code>require()</code> 加载的模块都会运行在 Node.js 上下文中，路径解析和能访问的对象都是和浏览器上下文不同的。Node.js 上下文中确实有一个 <code>window</code> 对象，但指向的是<strong>背景页</strong>。如果需要在 Node.js 上下文中访问浏览器的对象，包括全局对象，必须要将这个对象传递过去（就像我上面做的那样）。当然如果偷懒可以用文档后面提到的上下文混合模式（mixed context mode），但它有潜在的上下文不同导致的问题（路径、原型链；见文档）。所以最保险的方法就是在设计的时候就注意，尽量将前后完全分离，消息交换只用上下文无关的对象（例如普通的 <code>{}</code>、<code>Object.create(null)</code> 创建的对象）。</p><p>那么既然上面说在上下文混合模式下会有问题，那么默认的上下文分离模式（separate context mode）下，传递对象会不会出错呢？答案是不会。NW.js 自动处理了对象封送，在传递的时候切换了上下文。我们可以做一个小实验。</p><p><code>bootstrap.ts</code>：</p><pre><code class="lang-typescript">import * as main from &quot;./main&quot;;console.log(&quot;From Chromium? &quot; + (window.close instanceof (window as any).Function));main.testWindow(window);</code></pre><p><code>main.ts</code>：</p><pre><code class="lang-typescript">export function testWindow(window: Window): void {    window.console.log(&quot;Context of Node? &quot; + (window.close instanceof Function));    window.console.log(&quot;Context of Chromium? &quot; + (window.close instanceof (window as any).Function));}</code></pre><p>运行，结果：</p><pre><code class="lang-plain">From Chromium? trueContext of Node? trueContext of Chromium? false</code></pre><p>由于 <code>main.ts</code> 是被用 <code>require()</code> 加载的，所以它运行在 Node.js 的上下文下，直接访问全局的 <code>Function</code> 访问到的是 Node.js 的 <code>Function</code>。而传入的 <code>window</code> 参数，原对象是在 Chromium 上下文中的。访问它带的 <code>Function</code>（不会被重新指派上下文）访问的到的是 Chromium 的 <code>Function</code>。由此可见，在对象传递过来的时候，也包括传递回去的时候，对象的上下文都会自动发生变化。</p><p>可能要问了，既然是上古版本更新引入的分离，为什么我以前没发现呢？因为以前为了做即时示例，要在没有 Node.js 的浏览器环境下运行，所以都用了 Browserify。这样在 NW.js 中实际上所有代码都是在 Chromium 的上下文里执行的，不会引发问题。而这次我并没有想把它完全部署为普通网页，就用了分文件、模块加载（毕竟 NW.js 也支持 <code>require()</code>），这下上下文分离的事实立马就暴露了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NW.js 有一个或两个上下文，使用时要多加小心。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="Coding" scheme="https://blog.mottomo.moe/categories/Tech/Coding/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="NW.js" scheme="https://blog.mottomo.moe/tags/NW-js/"/>
    
  </entry>
  
  <entry>
    <title>老虎和兔子中的一段浪漫悲剧</title>
    <link href="https://blog.mottomo.moe/categories/ACGN/zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny/"/>
    <id>https://blog.mottomo.moe/categories/ACGN/zh/2018-11-12-Romantic-Tragedy-in-Tiger-and-Bunny/</id>
    <published>2018-11-12T19:33:00.000Z</published>
    <updated>2020-03-30T22:34:35.450Z</updated>
    
    <content type="html"><![CDATA[<p>以前我写过<a href="/categories/ACGN/zh/2016-04-27-Regios-Kokuhaku/">钢壳都市雷吉欧斯中的告白台词</a>。今天我又看到了一出打动人的浪漫戏，《老虎和兔子》（Tiger and Bunny）第15集。嗯，这集本身是一个插曲，但也是主线剧情的关键转折点之一。</p><p><strong>注意：本文有（严重）剧透。</strong></p><a id="more"></a><hr><p>这一集的主角是空天（スカイハイ，Sky High）。空天是所有英雄中最为单纯的一个人，这点在前面的剧情已经提及了。动作细节（本想直接拿苹果，但想了想，在衣服上擦了擦才伸手）和语言（还要算上声优表现出的语气）说明，他也是一个正统的绅士。</p><p>空天和神秘少女在公园的喷泉前相遇了。怦然心动。空天每天晚上都会巡逻。空天多次在喷泉前碰到少女。身在低谷期、人又不擅表达的空天，在多次向一直“聆听”的少女倾诉后，逐渐发现了怎么走出低谷。同时他也意识到了自己的想法。因为偶然，老虎和兔子在夜间抓到了邪恶的博士。博士说出了真相。</p><p>悲剧的因素齐了。</p><p>空天在不知情的情况下，亲手击毁了已经化为武器的人造人少女。讽刺的是，在处决面前这个“怪物”的时候，空天作为动力所回忆的，是那个少女。</p><p>虽说我早已猜到是这样，但是在表现手法等种种因素的作用之下，我还是唏嘘不已。</p><p>不过这还没完！事件结束后的这一段，才是最让我惊叹和赞美的。</p><p>从鼓励完老虎和兔子（约20:45）开始，是本集的第二高潮：空天前去和少女道谢。接下来的<strong>所有</strong>卡，空天的兴奋之情都溢出了屏幕。（分镜和演出，精彩啊！）</p><ul><li>空天从镜头前走过。由于太近，只能看到他身体的中间部分。但是这个卡的重点是背景二人的惊讶表情。以他们这么久的合作对空天所知，在那么短的时间内就采取这么激进的措施，实在不像平常所为。很可能是冒失了。因此他们才会十分惊讶。</li><li>空天走出更衣室。这时候镜头给的是从后方，略低于小腿处看过去的背影。背景的视场（field of view）相比于上一卡突然变小了，观感上就增加了深度（过道的长度）。这个过道的另一端是白光，就跟影视作品常用的 HDR 效果差不多（现实中 HDR 没有这么强烈）。但是同时也有可能是在暗示“向着他的光明”（也就是少女）。这里的空天虽然还是在走，但是和前面对比可以知道，是加快了步伐的。</li><li>接下来是在花店买花。两个卡，一个背面的中景，一个前侧的近景。表情上看不出来什么，因为空天一般情况下都是微笑的。但是当他接过了红玫瑰和白玫瑰组成的花束后，停顿了一小会儿，把它微微地抱得更紧了。</li><li>镜头转到橱窗前。从倒影中（没想到啊，突然来了这么少用的一手）看出，空天无意间扭头，注意力转向了橱窗里的商品，面露少许疑惑。橱窗里是裙子、挎包和新款式裙子的宣传海报。他用手指轻轻了两下敲太阳穴，表情渐渐变回了微笑。（我一开始觉得也有把橱窗当作镜子，照镜子的可能；但是仔细一想，橱窗内无灯，外面是自然光，这样对着橱窗是看不清自己的镜像的。）他可能是在想如果成功后送给她的礼物。毕竟英雄这份职业的收入不算高（想想其他几位就知道了），价格是要考虑考虑的。这说明空天对这次见面的准备十分用心。</li><li>下一个卡中，空天已经来到了公园。镜头给了个大半身的中景。他从右向左走过画面。在画面正中央，扭头发现远景中在长椅上靠在一起的情侣时，他略微停了一下，接着快速把头转回他的前方，微微弓身前倾，小步跑了起来。</li><li>紧接着的卡，大楼的巨幕播放着他作为英雄时的英姿（之前，这块屏幕播放的是大红大紫的老虎和兔子）。这块屏幕也很有意思，从空中往下看，它是放在大楼这个长方形的角上的；为了容纳这么大的屏幕，大楼的最上面四层都像蛋糕被切开一样，从而造出一个大平台。屏幕中，作为英雄的空天是巨大的。屏幕下，与渺小的路人无异的他依然抱着花束，弓着身，急匆匆地跑过路口。一方面是公众身份，一个英雄；另一方面是个人身份，一个普通市民。他在之前与少女的交流中一直隐藏着英雄的身份，然而那却其实是他更广为人知的一面，他作为普通人，更是作为英雄，被少女所激励。经典的身份二重性。</li><li>接下来的卡，镜头大约在腰部的位置，朝向侧上方。空天从右下角的“远处”跑来（此时已经不弓着身了），到画面正中。他进入画面后本想呼唤少女的，但是嘴才微微张开（逐帧观察，不像是作画或上色失误；表情也略显得焦急），就立即合上了。接着立定，闭眼整理了一下心情，将花轻轻抱得更紧一点，恢复微笑之后，空天缓缓走向左下角的“近处”。为什么有这个反应呢？联系接下来的三个卡就知道了。</li><li>接下来的三个卡。<ul><li>近景，半身，空天在画面右半边坐下。这里的镜头距离是，如果两个人靠在一起坐着，那么画面底部就刚好能被填满。可是这里长椅的一端是空的。但是感觉画面不算太空，是因为还有花束在。空天稍微定了定神之后微微扭头看向空出来的位置；镜头也配合地向左平移，虽然只有不到一秒。</li><li>他看到的只有长椅。此时镜头居然在拉远。为什么不是顺着空天的愿望去推近，而是要拉远呢？因为这是在陈述客观事实。</li><li>镜头再转回来的时候，已经看不到椅子，也就看不到另一端了。空天的肩膀占满了画面的底部。又这么凝视了一会儿，空天眨了眨眼，扭头，保持着标准微笑，目视前方（正对镜头）。</li></ul></li><li>最后的一卡，用的是他们初次见面时最后的远景和拉远。但是这次，长椅上只在半边坐了一个人。喷泉没有喷。原本周边空荡荡的，仿佛二人世界；这回变成了空天一人，和空地上的数个市民。他或许找回了最初的动力，作为市民的榜样。但是也如暗示的，她已经不会再来了。作为观众，我们知道这个等待注定是徒劳的。但是按照空天的性格，他一定会等到最后。（知道真相的话会受到多大打击！然而他们这件事也没别人知道，见过少女外形的除了他，只有老虎和兔子。问的话那对粗心基友大概会想不起来，根本没留意。所以就更纠结了。）</li></ul><p>其实喷泉很明显是经典爱情电影的隐喻，至少是桥段，比如《罗马假日》。这一集的配乐，对，就是那首舒缓的弦乐，仅出现在这一集；风格上我觉得会类似爱情电影吧。最后这段的镜头设计比起电视动画，更像是电影。哎其实我也没看过爱情电影，想想套路就觉得肉麻到不行，看别的去了。所以在讲述上面的镜头设计时文字苍白无力。</p><p>看了这第15集后，我就没再往下看了。剧情已经大概了解，但是很难说接下来会不会出现更亮的点，没有的话就会索然无味。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前我写过&lt;a href=&quot;/categories/ACGN/zh/2016-04-27-Regios-Kokuhaku/&quot;&gt;钢壳都市雷吉欧斯中的告白台词&lt;/a&gt;。今天我又看到了一出打动人的浪漫戏，《老虎和兔子》（Tiger and Bunny）第15集。嗯，这集本身是一个插曲，但也是主线剧情的关键转折点之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：本文有（严重）剧透。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACGN" scheme="https://blog.mottomo.moe/categories/ACGN/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>The &quot;New&quot; Encryption of HCA Audio</title>
    <link href="https://blog.mottomo.moe/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/"/>
    <id>https://blog.mottomo.moe/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/</id>
    <published>2018-10-12T19:34:00.000Z</published>
    <updated>2020-03-30T22:34:35.362Z</updated>
    
    <content type="html"><![CDATA[<p>中文版本见<a href="/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/">这里</a>。</p><p>Recently CRI Middleware updated their latest ACB archives’ format, and they seemed to have updated encryption of HCA files as well. As a result, the old toolsets can do nothing on the updated files. After about 20 hours of research I finally found what they changed on the decryption. Might be the first in the world, again. This is what’s called “highlight moment” in reverse engineering. XD</p><p>The final answer is somewhat simple: transform the decryption key, and use the transformed key to initialize the decryption table. The formula is <code>key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))</code> where <code>key</code> is the input key and <code>k2</code> is a secondary key stored in the higher 16 bits of “field alignment” field, in each ACB/AWB file.</p><p>This article is about the way and thoughts of finding this transformation. It is roughly recorded in time order. I hope these materials may help someone in the future.</p><p>My result is based on various people’s works. Without thoses pieces, the whole puzzle cannot be completed. So a big thank you for everyone involved.</p><p><span style="color: red;"><strong>Be noted again: the contents in this article must not be used for commercial purposes.</strong></span></p><a id="more"></a><hr><p>* “Decode” in the text below may mean decode after decrypting when applicable.</p><p>* Sorry about the broken tenses in the last paragraphs. I was too tired to fix them all.</p><h1 id="1-Prelude"><a href="#1-Prelude" class="headerlink" title="1. Prelude"></a>1. Prelude</h1><p>As the new game Dragalia Lost (ドラガリアロスト) is released, CRI Middleware revealed their updated audio technology. As for me, a guy who does not play games in the “normal” way, I care about resource extraction more than how it displays in the game. Forward thinking is what I should do as a game developer, and reversed thinking is for the cracker identity (not “cracker” as in “cookie” :P).</p><p>This update updates ACB version from 1.29 to 1.30. Although it is a minor upgrade, it brings a trouble that, HCAs cannot be decrypted even with the correct key. It began with an <a href="https://github.com/hozuki/libcgss/issues/4" target="_blank" rel="noopener">issue</a> created by FZFalzar. When I received the email, I didn’t know or understood what was going on. In the next day, esterTion posted a screenshot of a comment in his <a href="https://estertion.win/2018/09/dragalialost%E9%80%9F%E8%A7%88/" target="_blank" rel="noopener">blog article</a>, saying that someone is not able to decode extracted HCA with the game provided. I recalled that the key is the one I saw in that issue, so this must not be a coincidence. Together with the information FZFalzar provided, the new tools should have changed something, which might break backward compatibility. I could imagine if the same measure is applied on CGSS or MLTD, or other games, maybe, a doom for audio extraction. So I decided to challenge it.</p><h1 id="2-Initial-Analyses"><a href="#2-Initial-Analyses" class="headerlink" title="2. Initial Analyses"></a>2. Initial Analyses</h1><h2 id="2-1-File-Analyses"><a href="#2-1-File-Analyses" class="headerlink" title="2.1 File Analyses"></a>2.1 File Analyses</h2><p>The first thing to do is analyzing the files to see whether there are some “odd” values.</p><p>Since I already had an ACB extraction tool (<code>AcbUnzip</code>), I directly dragged the attached ACB on it. Unexpectedly, <code>AcbUnzip</code> crashed, only throwing an exception and creating an empty file. I also tried VGMToolbox, which created 6 files, but all of the files were empty too.</p><p>Since I wrote <code>AcbUnzip</code>, I could debug it. I found that the difference of the number of files is caused by the difference of the numbers of cues and tracks. There was only one cue, but there were 6 tracks (3 in internal AWB and 3 in external AWB). But the bigger problem was that, though I had the information of file entries, I could not extract them. The file sizes were negative numbers with extremely large absolute values! After narrowing down by instrumentation, I saw that the value of “field alignment” fields in AFS2 (the file structure used by AWB) was quite strange. According to VGMToolbox, it should be a 32-bit unsigned integer. From the past experience, the value is usually 32. However this time, it was far larger than the file size.</p><p>The most common guess should be there is a mask. So I looked at the value in hex digits. The lower 16 bits were <code>0x0020</code>, which is 32; the higher 16 bits were something unknown. Obviously, it is masked by <code>0x0000ffff</code>. I successfully extracted all HCA files after doing this.</p><p>The exception was the first piece of the puzzle. Besides applying a mask, it also exposed the fact that the layout of AWB had changed. As I said, since the field offset (32-bit unsigned integer) was usually 32, which is far smaller than 65535 (<code>0xffff</code>), its higher 16 bits were actually reserved. Here I began to doubt if CRI did use the higher bits as reserved and attached some other meanings to them. But I still could not determine whether they were random numbers (to disturb analysis) or they do have a meaning.</p><p>After the HCAs were extracted, it was time to take a view on them. They looked normal: no unknown header parts or blocks, no out-of-range values, and no additional information added. The only recognizable thing was the size of HCA header extended from 96 (CGSS/MLTD) to 397. But except for known fields, the header was filled with zeros.</p><p>Here I made 3 assumptions:</p><ol><li>The actual size of the HCA header can affect the decoding choices of the decoder. You can think it as a hidden version information apart from the “version” field in the HCA header.</li><li><code>comp1</code> to <code>comp10</code> (referring to the HCA decoder) were set to some meaning values that affect the decoding process. I did not know what those fields mean so I was unable to proof or deduce only by observing.</li><li>Nothing was changed. The file was still a traditional HCA.</li></ol><p>All these assumptions were possible, requiring more materials to proof or falsify.</p><p>At this point, the limit of file analyses was reached.</p><h2 id="2-2-Next-Directions-of-Investigation"><a href="#2-2-Next-Directions-of-Investigation" class="headerlink" title="2.2 Next Directions of Investigation"></a>2.2 Next Directions of Investigation</h2><p>Just as I replied in the issue, after some observations, considering the updating speed of the technology, iteration cost (time and finance), I thought of 4 most possible possibilities:</p><ol><li>The decoding process was changed.</li><li>New branches were introduced in the decoding process.</li><li>Precomputed tables were changed.</li><li>Real decryption key was different from the input key.</li></ol><p>Of course their combinations were also possible in reality. Here let me explain the details of each possibility.</p><p><em>The first possibility.</em> The new decoder employed an entire new theory. This means huge changes in theory and code, which can be seen as a new audio format. CRI should not have enough time and financial support to do this.</p><p><em>The second possibility.</em> Think about the values of <code>comp1</code> to <code>comp10</code> mentioned above. Considering known code structure of the public decoder, if new branches were introduced to handle values that never appeared before (in the context of code, <code>if</code>), then new branches or new tables would be logical. I thought it possible, but proving is hard. It depends on the decompiled code.</p><p><em>The third possibility.</em> Since the core of decoding is value mapping using the precomputed tables, could the tables themselves were modified (the code should also be updated) so that input were mapped to different outputs? This thought also depends on decompilation.</p><p><em>The fourth possibility.</em> This is a two-phase encryption. The overall process was untouched but the key was transformed internally, or a decryption table different than the previous one was generated using the same key. Obviously this is the most probable way. All you need to do is adding a few lines of code, and all the public decoders stop working. The cost is close to zero. Combining with the decoding workflow of HCA, in validation, decryption and decoding, a process does not influence the previous one(s). So the key can be easily set to a new one. (By the way, this is also how <code>hcacc</code> <a href="https://github.com/hozuki/libcgss/blob/master/docs/behind-the-scenes.md" target="_blank" rel="noopener">works</a>.)</p><p>However my guess was that the key was modified before initializing the decryption table. For that I was wrong.</p><h2 id="2-3-Initial-Feedback"><a href="#2-3-Initial-Feedback" class="headerlink" title="2.3 Initial Feedback"></a>2.3 Initial Feedback</h2><p>Because I could only obtain a lite version of the SDK (ADX2LE SDK), which does not support encryption and decryption, and FZFalzar had the full SDK (ADX2 SDK), I asked him to start with some tests. While those tests are in progress, I began the initial reverse engineering on tools in ADX2LE SDK.</p><p>I had a question above: is the new SDK backward-compatible? It can play the latest ACB, but can it play old ones? Whatever the answer is, it would help eliminate false guesses. My personal guess was the new SDK is not backward-compatible, but the test results disagreed. According to the fact I believed that there was not an all-new <del>all-different</del> decoder and tables were unlikely to change. The greatest change would be adding branches and tables, at most. If we got lucky, it would be much easier.</p><h1 id="3-Following-Analyses"><a href="#3-Following-Analyses" class="headerlink" title="3. Following Analyses"></a>3. Following Analyses</h1><h2 id="3-1-Following-Analyses-of-ACB"><a href="#3-1-Following-Analyses-of-ACB" class="headerlink" title="3.1 Following Analyses of ACB"></a>3.1 Following Analyses of ACB</h2><p>FZFalzar found out that the SDK cannot play extracted HCAs (not being packed inside ACB/AWB) with correct keys. He thought maybe the something got into the metadata of ACB. So I checked the new structure of ACB using <a href="https://github.com/hcs64/vgm_ripping/tree/master/multi/utf_tab" target="_blank" rel="noopener"><code>utf_tab</code></a>. The first apparent change was the update of format version. CGSS uses version 1.23.1, MLTD uses 1.29.0, while this one was in 1.30.0.</p><p>From my experience learned from MLTD’s ACB upgrade (compared to CGSS), upgrading usually means adding new tables. Current ACB format can only use a limited number of fields (for easy coding?), so it reserved several slots in the end. CGSS (1.23.1) had 18 reserved slots (R0 to R17), and in MLTD (1.29.0) there were only 12 (R0 to R11). And this time (1.30.0), a new table <code>SoundGeneratorTable</code> was added compared to MLTD. Could this table influence HCA decoding? I thought not. In the sample ACB, the size of this table was zero. If this table is used as a switch, CRI could have chosen a much simpler type. If it is a table and it does have influence, it should not be empty, but filled with some meaningful data.</p><p>I did not find other important differences in this sample ACB besides this new table. Some control tables, such as <code>TrackCommandTable</code>, <code>SynthCommandTable</code> and <code>TrackEventTable</code> is not yet parsed, they should not play such row because of their usages in history. To be sure, I modified some values and tested, with no luck.</p><p>At this time, FZFalzer sent the player (Atom Viewer, 2.25.14) in the latest full SDK. Finally I was able to test the keys.</p><p>During testing, I discovered something interesting. I mentioned before that in the header of AWB there were 16 unknown bits (2 bytes) in “field alignment” field. This time I tried to modify those two “garbage” bytes. I tested these combinations with the new player:</p><ol><li>ACB from CGSS (internal AWB), with no modification. (These 2 bytes were always <code>00 00</code> in previous ACBs.)</li><li>ACB from CGSS, with modification.</li><li>ACB from Dragalia Lost (external AWB), with no modification.</li><li>ACB from Dragalia Lost, modified internal “garbage” bytes only.</li><li>ACB from Dragalia Lost, modified external “garbage” bytes only.</li><li>ACB from Dragalia Lost, modified internal and external “garbage” bytes.</li><li>ACB from Dragalia Lost (internal AWB), with no modification.</li><li>ACB from Dragalia Lost, modified “garbage” bytes.</li></ol><p>If the AWB is an external one, the information in ACB will declare that the AWB is a streaming one. Inside ACB it will also store a copy of the header of the AWB. So I thought it was necessary to test both internal and external modifications.</p><p>Guess which ones could be played normally? The answer is 1, 3, 4, 5, 6 and 7. Yes, all combinations from 3 to 6 could be played. This was a bit strange but it might be a mistake during test. Now that the decryption is already retrieved, there is no need to test them again. But you can still try it if you like.</p><p>The results showed that even ACBs in old versions could not be played with those two bytes modified. So these two bytes must be playing some kind of roles. But where the switch is and how are the bytes involved, were still unknown.</p><p>Later FZFalzer tested 2017 version of the SDK (possibly the one MLTD uses) and reported that it could not play the new ACBs. Therefore, the breaking change exists between these two versions.</p><h2 id="3-2-Other-Simple-Trials"><a href="#3-2-Other-Simple-Trials" class="headerlink" title="3.2 Other Simple Trials"></a>3.2 Other Simple Trials</h2><p>Considering that there were 6 HCAs in the ACB, and they were in two groups, members in which were of the similar size. Could they be XORed? I tested this possibility but the answer was no.</p><p>What about between groups? Like simple cyclical passwords with short key and long encrypted text? Nope.</p><p>How about direct key manipulation? Assuming that those two bytes are used, but none of adding, substracting, shifting or masking worked.</p><h1 id="4-Decompiling"><a href="#4-Decompiling" class="headerlink" title="4. Decompiling"></a>4. Decompiling</h1><p>All other methods were run out. I had to use the last resort, decompling. Decompling can almost solve all problems, but also with very high costs. It requires massive time, energy, techniques and experience. I was not sure if I can solve the problem before I reach my limit.</p><p>The materials i had were ADX2LE SDK (mainly Win/X86) and the APK from Dragalia Lost (Android/ARM32). Later the new player (Win/X86-64) was also used.</p><h2 id="4-1-Initial-Analyses-on-Setting-the-Key"><a href="#4-1-Initial-Analyses-on-Setting-the-Key" class="headerlink" title="4.1 Initial Analyses on Setting the Key"></a>4.1 Initial Analyses on Setting the Key</h2><p>This step began at the same time when I asked FZFalzar to do the compatibility tests. My intention was looking at the usages of the key after it is set. The entry point was quite obvious, the well-known <code>criWareUnity_SetDecryptionKey()</code>.</p><p><img src="/images/crack-hca-dragalia/01.jpg" alt="Decryption setting in Dragalia Lost, level 1"></p><p>Statically trace to the location above. The first thing we can see is that the input key is not changed during this process. Another noticable point is, the input key, or the original key, has passed the file verification. Now follow the decryption setting of Atom (audio decoding component) to the next level.</p><p><img src="/images/crack-hca-dragalia/02.jpg" alt="Decryption setting in Dragalia Lost, level 2"></p><p>Here we run into some troubles. There are lots of global variables and unknown arrays or class members. But by looking carefully you can see that the key is only printed out (to the debug output) here, with some data whose meanings are unknown. If you know a little about the C language, you may have noticed that the call to <code>sub_CEF9C()</code> is problematic. According to its arguments, it should be something like <code>printf_s()</code>, or at least a function with variable arguments. But in the assembly code it is still like this in the picture. The problem is we don’t know what that function outputted. Statical tracing shows the original value of the key is assigned to <code>dword_17AC90</code>, which was not used in the decompiled code. In assembly code, it is set to a register (then its value is assigned to a class member) but not pushed into the stack. Well I can’t get anything more from this, because I don’t know too much about ARM stuff. This lead ends here.</p><h2 id="4-2-Analyzing-ACB-Generation-and-Reading-Processes"><a href="#4-2-Analyzing-ACB-Generation-and-Reading-Processes" class="headerlink" title="4.2 Analyzing ACB Generation and Reading Processes"></a>4.2 Analyzing ACB Generation and Reading Processes</h2><p>FZFalzar mentioned the library <code>CpkMaker.dll</code> in the SDK. He said in the new versions the alignment is set to a large value, while it is 32 unless manually assigned in the old SDKs. Let’s take a look.</p><p>Although I don’t have the full SDK, but LE is sufficient for making an impression of code structure. <code>CpkMaker.dll</code> is a .NET assembly, which is out of my estimation. It is written in C++/CLI, apparently. So what are the other libraries that are easy to decompile? From previous exprience I already knew <code>AudioStream.dll</code> is an assembly. From its UI, Atom Craft is obviously a Windows Forms application. With these as an entry point, I found <code>CriAtomGears.dll</code> and <code>AcCore.dll</code>. <code>AtomPreview.dll</code> (who exports some APIs similar to the runtimes of CRI products) and <code>AtomPreviewer_PC.exe</code> are native PE binaries. Managed code for encoding/decoding, or packing/unpacking are not found in these assemblies, so they are definitely inside those native binaries.</p><p>Atom Craft has two playback modes. If you import an audio file (which they call “material”) and play it in the Materials panel, it is the audio file itself that is played. But, if you add the audio file into one of the cues, open Session window (in menu View - Session Window), drag the cue onto the list in Session window, and then click the play button, Atom Craft will generate and ACB (content encoding is specified  in project settings) and play the ACB file. This difference means behind the different playback handling, there is a invocation from managed code to native code; whether it is P/Invoke or C++/CLI is yet to be tested.</p><p>Therefore I try to find the click event. The window name itself is a hint. After painful searches I found it. (I have to say, the code sucks, and assemblies are not well divided.) But the mechanism is not so direct as I think. It uses a C/S architecture. Sending (commands) and receiving (events) are all based on messages. The messaging seems to be wired through sockets. So at run time, Atom Craft starts a native server, and the calls are actually RPCs. As for encoding and packing, it references <code>AudioStream.dll</code> and <code>CpkMaker.dll</code>, inside which the functions are completed using P/Invoke. I have to decompile <code>AtomPreview.dll</code> and <code>AtomPreviewer_PC.exe</code>.</p><p>The immediate choice is <code>AtomPreview.dll</code>, because it exposes some APIs. This time, I enter the library from code for ACB to look at the reading process. Well, this is much harder than reading decryption settings. I can only perform three levels of static analysis and the analysis is heavily interfered by class members, so I cannot find something interesting. It is not easy to be dynamically analyzed (can attach to the process though). The code structure is far different from expected and the key signature <code>@UTF</code> is not found anywhere so I don’t know where to start.</p><p>Analyzing this from the shared library in Draglia Lost’s APK is as difficult as above.</p><p>Atom Viewer in ADX2LE SDK can play the bundle files too. But it does not have public APIs. In the issue comments FZFalzar said the related code is “baked” into the library (in fact this is called static linking :P). Even it does not expose public APIs, there is still a way to locate the code, just make good use of its logs. According to the log, search for string <code>Open ACB:</code> and follow the references. In the end you will find a function with characteristics very similar to <code>criAtomExAcb_LoadAcbFile()</code>. However it is still hard to analyze.</p><h2 id="4-3-Analyzing-HCA-Decoding"><a href="#4-3-Analyzing-HCA-Decoding" class="headerlink" title="4.3 Analyzing HCA Decoding"></a>4.3 Analyzing HCA Decoding</h2><p>Compared to the key settings and ACB, HCA-related functions look harder to catch because they are not exposed anywhere. In addition, the decoding process runs in a background thread, so there is no way to find a direct entry (like from <code>criAtomExPlayer_Start</code>).</p><p>Now what? Scan for tiny traces they leak to the surface. Reading the public decoder code, the most impressive thing is those precomputed tables. These tables will lead us to the hidden functions. As a commercial decoder, speed is another important consideration, apart from precision. Sometimes you will have to balance between them. The official decoder is also likely to choose a trading-space-for-time strategy, and it would be even better if they use the same tables. Anyway, try our luck first.</p><p>Based on the public HCA decoder, the decoding framework is like:</p><pre><code class="lang-cpp">void decode_block(Block *block) {    validate_block(block);    decrypt_block(block);    for each channel { decode1(channel); }        for (i = 0..7) {        for each channel { decode2(channel); }        for each channel { decode3(channel); }        for each channel { decode4(channel); }        for each channel { decode5(channel); }    }    to_wave(channels);}</code></pre><p>Just have a first expectation in mind. Now let’s see if the official decoder use the same tables.</p><p>Here we choose the first element in the second table inside <code>decode5()</code>, <code>0xBD0A8B04</code>. The reason to choose <code>decode5()</code> is, it lies on the last location in the innermost loop. Its feature serves well as a beacon. As for which table, that is a casual choice. In the worst case just try them all. During searching beware the endianess. Here I use the Atom Viewer from the full SDK (because I prefer X86/X86-64 to ARM), so the search pattern is <code>D4 8B 0A BD</code>.</p><p><img src="/images/crack-hca-dragalia/03.jpg" alt="Search result for 0xBD0A8BD4 (Hex Editor)"></p><p><img src="/images/crack-hca-dragalia/04.jpg" alt="Search result for 0xBD0A8BD4 (IDA)"></p><p>As expected, it is found in the global variable segment. Having a glance at its previous and next elements, it is obvious that this is the table we are interested in. Now switch from Hex View to IDA view and do a xref (cross referencing). Results show that this address is only referenced by one function, whose address is <code>0x00007FF606770718</code>. Do some more searches on the tables used in this function, we can also find the first table in <code>decode5()</code>. This means the function we are looking is probably <code>decode5()</code> or at least a part of it. The caller of this function contains the third table, and another part of <code>decode5()</code>.</p><p><img src="/images/crack-hca-dragalia/05.jpg" alt="decode5()"></p><p>Repeating the same operations, find all referenced known tables until the top level of known region is reached. Here is a function <code>decode_block()</code>. In this process you may find multiple references to the same function. Just try them one by one.</p><p><img src="/images/crack-hca-dragalia/06.jpg" alt="decode_block()"></p><p>Don’t mind the mild differences of code structure between this and the framework above. The interesting thing is their key characteristics. Keep in mind that compiler optimization is quite powerful.</p><p>Again, go up until the top level is reached and there is no obvious caller. Now you should reach a function at <code>0x00007FF6067688F4</code>. xref-ing shows it becomes a function pointer, which means dynamic invocation, for example registering in a function table or as callback. Inside this function we can find a string literal <code>Failed to decode HCA header.</code>, next to which is a function reading the HCA header (located at <code>0x00007FF60676A274</code>; I name it <code>FindAndLoadHcaHeader</code> because it include some code to search for the offset of the header). Reading the HCA header and audio data block decoding appear inside the same function. What is the function like? Yep, a common (and bad) pattern:</p><pre><code class="lang-cpp">if (flag == PARSE_HCA_HEADER) {    FindAndLoadHcaHeader(pData);    DecodeAudioBlock(pData + headerSize); // Immediately reads the first audio block after reading the HCA header} else if (flag == DECODE_AUDIO_BLOCK) {    DecodeAudioBlock(pData);}</code></pre><p>Now put that aside. Maybe you will question about the disparity between <code>decode_block()</code> and the public decoding framework. Now let’s check what the code is like in tools in an old version SDK (ADX2LE). Using the same technique to locate the corresponding <code>decode_block()</code> inside <code>AtomPreviewer_PC.exe</code>. It seems the general structures are alike. Forget not, that we are not comparing the decompiled code and the public code, but between old and new versions of the SDK. As there is no (obvious) difference, the decoding procedure should not have changed, and neither should the tables.</p><p>Now there is only one question left. What are the meanings of <code>comp1</code> to <code>comp10</code> (<code>comp9</code> and <code>comp10</code> are calculated using the other <code>comp</code> values)? How do they affect encoding and decoding? Can they take “strange” values? At this time, I suddenly found <a href="https://github.com/Thealexbarney/VGAudio" target="_blank" rel="noopener">VGAudio</a>. It was like hitting by a lightning when I read its readme. The shocking fact (to me) is that, the repository includes the principles and details of HCA encoding. There is even an HCA encoder! From this repository I know that those values have fixed meanings, which cannot be, “strange”.</p><p>So only one of the four possibilities in the beginning still stands. All of other “hard” (not easily changed) functionalities are unchanged. The key is the only thing modified. But this is contradict to what I discovered above, so there should be something I missed.</p><h2 id="4-4-Analyzing-Usages-of-the-Key"><a href="#4-4-Analyzing-Usages-of-the-Key" class="headerlink" title="4.4 Analyzing Usages of the Key"></a>4.4 Analyzing Usages of the Key</h2><p>Finally, the finale. This time let’s trace the <code>criWarePC_SetDecryptionKey()</code> (well, the name is a guess) inside Atom Viewer.</p><p>But… isn’t this function not exported? How can we find it? Fear not. We use the same technique as locating from log. The place in <code>criWareUnity_SetDecryptionKey()</code>, where I stuck before, has a variable argument function that could not be understood. There is a format string in that function: <code>%s, %lld, %lld, %s, 0x%08X, 0x%08X, %d</code>, hard-coded. This means in Atom Viewer, there should also be the same, hard-coded string. Open Strings View and search for it. Next step, searching for references.</p><p><img src="/images/crack-hca-dragalia/07.jpg" alt="Referenced locations"></p><p>Considering that C/C++ compilers will merge the same strings, it is normal to see such a number of results. A little patience is all we need. Luckily, the first result brings us to the correct location.</p><p><img src="/images/crack-hca-dragalia/08.jpg" alt="Isn&#39;t it familiar?"></p><p>The picture above is what it is like after I annotated. But before annotation the high similarity between it and the previous function we analyzed.</p><p>Here is a tip. The Hex-Rays Decompiler (F5 in IDA) is not very good a processing variable argument functions. You have to enter that function and exit, to see its correct arguments. (This does not work on ARM. I don’t know why.) After a simple static tracing of one level, most of the symbol names can be deduced. If you are familiar with HCA encryption and decryption, you can pick out <code>InitDecrypter()</code> quickly. Some information requires dynamic debugging, for example finding strings in tables.</p><p>Enter <code>InitDecrypter()</code>. A little tracing will show the initialization of type-0, type-1 and type-56 encryptions. The value it returns, according to the log, is “DecrypterHn”, which looks like “decryptor handle”. But if you read it more carefully, you will know that this value is a pointer to the decryption table. This pointer is used by two global variables (one at <code>0x00007FF606818CC8</code>, another one at <code>0x00007FF606819628</code>). But neither of these two reveals a meaningful result for tracing.</p><p><img src="/images/crack-hca-dragalia/09.jpg" alt="Inside InitDecrypter()"></p><p>As we can see, after the normal initialization of this decryption table, it is used as the decryption table for both HCA and HCA-MX. You can confirm the usage name from doing one more xref. So here is where the decoding code analyses and decryption code analyses converge.</p><p>I did a simple dynamic debugging. Until setting the decryption tables for HCA and HCA-MX, the contents of the table is still the same as computed using public tools. So there is nothing abnormal until here. But what I am looking for is <em>all</em> references of the key and the decryption table, so I am able to notice this assignment:</p><pre><code class="lang-cpp">v8 = sub_7FF606712670();*v8 = keyLit2;</code></pre><p>Obviously, the key is passed to somewhere else, in addition to the normal usages we see before. Why should this redundant move be introduced?</p><p>Expand <code>sub_7FF606712670()</code> and you can see that all it does is returning the address of a global variable:</p><pre><code class="lang-cpp">void *sub_7FF606712670() {  return &amp;unk_7FF606821B30;}</code></pre><p>Where is <code>unk_7FF606821B30</code> used? Static analysis tells us it is only referenced inside this function. But <code>sub_7FF606712670()</code>, is used at two locations.</p><p><img src="/images/crack-hca-dragalia/10.jpg" alt="References to sub_7FF606712670()"></p><p>After checking these references, jackpot.</p><p><img src="/images/crack-hca-dragalia/11.jpg" alt="Second encryption"></p><p>Tracing the pointer <code>v4</code>, which received the pointer to the key, it’s easy to find that it is used in another round of computation, and<code>v6</code> should be the new key. As expected, the function which uses <code>v6</code> is for generating a type-56 decryption table. (So why bother writing the same function two times? I don’t understand what CRI guys think.) The problem is how does <code>v5</code> come from. I add a breakpoint at the assignment of <code>v6</code>, open an ACB, but the breakpoint is not hit. Well, this is an ACB from CGSS. When using an ACB from Dragalia Lost, I get a hit. The value of <code>v5</code> is <code>0x80b2</code>, a familar number. I immediately recognized that, this is the two “garbage” bytes inside the ACB/AWB. Although <code>v5</code> comes from the call result of <code>sub_7FF6066F28C0()</code>, which is the value of a class member, but it is obvious that this <em>is</em> those two bytes. Observing the referencing status of <code>sub_7FF6067006CC()</code>, which is strongly related ACB reading, the inference has a high probability to be a right one.</p><p>So I did a little modification to the existing HCA decoder and put in the transformation. And yes, the decoding was successful. Another test on the ACB inside Dragalia Lost’s APK was also successful. Now we can conclude that the reverse engineering this time completed in success.</p><p>Let’s read the formula again: <code>key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))</code>. <code>key</code> is the input key, and <code>k2</code> is a 16-bit integer stored in every AWB. Mind the signed/unsigned and length truncation. Also, it does not throw exceptions when the muplication overflows.</p><p>If <code>k2 == 0</code>, the key is not transformed. See the decision on <code>v5</code>. For example, esterTion found out Princess Connect Re:Dive also uses ACB 1.30, but the HCAs extracted is still able to be handled by existing tools. This is because the bytes at field alignment is <code>20 00 00 00</code>.</p><h1 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h1><h2 id="5-1-The-Future-of-HCA-Extraction-and-Decoding"><a href="#5-1-The-Future-of-HCA-Extraction-and-Decoding" class="headerlink" title="5.1 The Future of HCA Extraction and Decoding"></a>5.1 The Future of HCA Extraction and Decoding</h2><p>After this update, HCA can use de facto dynamic keys. Directly decoding HCA files using the static keys will not be safe anymore. Batch decoding HCAs are not possible, but it is still doable when having ACB/AWB. It’s just adding another shell. All the tools are still public, and all you need to do is writing a small fix. LOL.</p><p>* Update on Oct 16: The vgmstream guys (whose members also watched the issue) already pushed the changes on Oct 14. Wow.</p><h2 id="5-2-Some-Comments"><a href="#5-2-Some-Comments" class="headerlink" title="5.2 Some Comments"></a>5.2 Some Comments</h2><p>Well you don’t have to read this in the English version. Just my personal comments.</p><h2 id="5-3-The-Gain"><a href="#5-3-The-Gain" class="headerlink" title="5.3 The Gain?"></a>5.3 The Gain?</h2><p>To be short, the flexible use of data for attacks. For detailed explanations please read the Chinese version.</p><h2 id="5-4-Thank-List"><a href="#5-4-Thank-List" class="headerlink" title="5.4 Thank List"></a>5.4 Thank List</h2><p>Written in the order I think of, when I write this section.</p><ul><li><a href="https://github.com/FZFalzar" target="_blank" rel="noopener">FZFalzar</a> raising the problem, some experiments, and supplying Atom Viewer</li><li><a href="https://github.com/Thealexbarney" target="_blank" rel="noopener">Alex Barney</a> and his amazing <a href="https://github.com/Thealexbarney/VGAudio" target="_blank" rel="noopener">VGAudio</a></li><li><a href="https://sourceforge.net/projects/vgmtoolbox/" target="_blank" rel="noopener">VGMToolbox</a> from <a href="https://sourceforge.net/u/snakemeat/profile/" target="_blank" rel="noopener">snakemeat</a></li><li>The anonymous guy who provided the HCA decoder code (ancient code published on 2ch before 2014)</li><li><a href="https://github.com/hozuki/libcgss/issues/4" target="_blank" rel="noopener">Everyone discussed in the issue</a></li><li>And me (:D) (←You already participated in the discussion!</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中文版本见&lt;a href=&quot;/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Recently CRI Middleware updated their latest ACB archives’ format, and they seemed to have updated encryption of HCA files as well. As a result, the old toolsets can do nothing on the updated files. After about 20 hours of research I finally found what they changed on the decryption. Might be the first in the world, again. This is what’s called “highlight moment” in reverse engineering. XD&lt;/p&gt;
&lt;p&gt;The final answer is somewhat simple: transform the decryption key, and use the transformed key to initialize the decryption table. The formula is &lt;code&gt;key&amp;#39; = key * ((uint64_t)(k2 &amp;lt;&amp;lt; 16) | (uint16_t)(~k2 + 2))&lt;/code&gt; where &lt;code&gt;key&lt;/code&gt; is the input key and &lt;code&gt;k2&lt;/code&gt; is a secondary key stored in the higher 16 bits of “field alignment” field, in each ACB/AWB file.&lt;/p&gt;
&lt;p&gt;This article is about the way and thoughts of finding this transformation. It is roughly recorded in time order. I hope these materials may help someone in the future.&lt;/p&gt;
&lt;p&gt;My result is based on various people’s works. Without thoses pieces, the whole puzzle cannot be completed. So a big thank you for everyone involved.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red;&quot;&gt;&lt;strong&gt;Be noted again: the contents in this article must not be used for commercial purposes.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="RE" scheme="https://blog.mottomo.moe/categories/Tech/RE/"/>
    
    
      <category term="English Version" scheme="https://blog.mottomo.moe/tags/English-Version/"/>
    
      <category term="Reverse Engineering" scheme="https://blog.mottomo.moe/tags/Reverse-Engineering/"/>
    
      <category term="Dragalia Lost" scheme="https://blog.mottomo.moe/tags/Dragalia-Lost/"/>
    
      <category term="CGSS" scheme="https://blog.mottomo.moe/tags/CGSS/"/>
    
      <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
      <category term="HCA" scheme="https://blog.mottomo.moe/tags/HCA/"/>
    
  </entry>
  
  <entry>
    <title>HCA 的“新式”加密</title>
    <link href="https://blog.mottomo.moe/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/"/>
    <id>https://blog.mottomo.moe/categories/Tech/RE/zh/2018-10-12-New-HCA-Encryption/</id>
    <published>2018-10-12T19:34:00.000Z</published>
    <updated>2020-03-30T22:34:35.450Z</updated>
    
    <content type="html"><![CDATA[<p>English version can be found <a href="/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/">here</a>.</p><p>近日 CRI ACB 格式更新，连带着 HCA 加密“升级”，旧轮子全员阵亡。在经过二十多个小时的研究后，我找到了关键的修改，搞定了解密。可能又是全球第一个呢。做反向，最激动人心的就是这样的时刻。XD</p><p>最终的答案很简单，就是在解密之前，进行密钥变换，并二次初始化解密表：<code>key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))</code>，其中 <code>k2</code> 保存在每个 AWB 中的字段对齐的值的高16位。</p><p>这篇文章讲的是我找出这个变换的过程，包括思路和操作，基本上按照时间顺序记录。希望在未来会对某人有所帮助。</p><p>总的来说，这次的成果是建立在众人的工作基础上，没有这些碎片，就无法拼成完整的拼图。在此要向各位致谢。</p><p><span style="color: red;"><strong>再次强调，本文内容不可用于商业用途。</strong></span></p><a id="more"></a><hr><p>* 下文中，“解码”表示解密（decrypt）之后解码（decode），除非特别指明。</p><h1 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h1><p>随着新的游戏 Dragalia Lost（ドラガリアロスト，中文译名“失落的龙约”）的推出，CRI Middleware 也展示了更新的音频技术。对于我这种不好好玩游戏的人来说，更有意思的不是它在游戏中的表现，而是如何提取资源。正向思考是游戏开发者身份做的事，反向思考是破解者身份做的事。</p><p>这次更新带来了 ACB 的版本更新，从1.29升级到1.30。虽说只是一个小版本升级，但是引发了一个问题：即使知道正确的密钥，也无法解密。一开始是 FZFalzar 提了一个 <a href="https://github.com/hozuki/libcgss/issues/4" target="_blank" rel="noopener">issue</a>。我收到了邮件，但是我并不知道，也没意识到发生了什么。在一天之后 esterTion 在群里发了一个他的<a href="https://estertion.win/2018/09/dragalialost%E9%80%9F%E8%A7%88/" target="_blank" rel="noopener">博文</a>评论截图，显示有人用已知的密钥也无法解码提取出的 HCA。我看着这个密钥觉得很眼熟，突然想起这不是 issue 里的那个嘛。看来不是个例。结合 FZFalzar 提供的信息，新版的工具确实改变了一些关键的东西，可能无法向后兼容。一想到如果以后烧笋和土豆也更新了那就完了，我决定是时候出手了。</p><h1 id="二、初步分析"><a href="#二、初步分析" class="headerlink" title="二、初步分析"></a>二、初步分析</h1><h2 id="2-1-文件分析"><a href="#2-1-文件分析" class="headerlink" title="2.1 文件分析"></a>2.1 文件分析</h2><p>首先要做的是进行文件分析，看看新的文件有没有什么不正常的地方。</p><p>由于我已经有了 ACB 的提取工具（<code>AcbUnzip</code>），我就直接把附的 ACB 拖上去。但是出乎意料地，<code>AcbUnzip</code> 崩溃了，而且只创建了一个空文件。接着我打开 VGMToolbox，它创建了6个文件，然而也都是空的。</p><p>那么就没办法了，反正我有源代码，上调试。调试中发现，文件数量的差异是因为条目（cue）和音轨（track）的数量不同，只有一个条目，却有内部 AWB 和外部 AWB 各三个音轨。但是更大的问题是，明明我读取到了文件信息，却无法提取，每次都抛出异常。观察字段的值——文件大小居然是一个绝对值很大的负数！通过逐步插桩确定范围，发现是 AFS2（AWB 使用的文件结构）中的字段对齐被设置为了一个莫名其妙的数。根据 VGMToolbox，这个值是一个32位无符号整数。从过往的文件提取经验中，它一般是32。然而读取后，它的值远远超出了文件大小。</p><p>这时候最常见的猜想就是有一个额外的掩码（mask）。于是我看了一下它的十六进制表示，发现低16位是 <code>0x0020</code>，也就是32，而高16位不知道是什么东西。很明显，它应用的是一个 <code>0x0000ffff</code> 的掩码。加上这个处理后，很顺利地就提取出了内部的所有 HCA。</p><p>这就是第一块拼图。从这个异常中，除了得知加了掩码这个信息，还可以知道，AWB 的字段意义发生了变化。如我所说，由于字段对齐一般只是取32，远远小于65535（<code>0xffff</code>），所以高16位其实是相当于保留的。这里我就开始怀疑 CRI 是不是将这里看成了保留位，加了私货。但是我还不能确定这高16位是随机数（扰乱分析用的），还是确实有其意义。</p><p>解出 HCA 之后，就该观察 HCA 了。不过 HCA 倒是很正常，没有未知块和头，没有超出已知范围的取值，也没有加什么奇怪的东西。HCA 头长度从以前烧笋和土豆常见的96加到了397，但是除了已知字段，其他的部分都是用0填充的。</p><p>在这里我有三个假设：</p><ol><li>实际头大小会影响 HCA 解码器的解码选择。可以认为这是除了 HCA 头的版本字段外，一个隐藏的版本记录。</li><li><code>comp1</code> 到 <code>comp10</code>（见 HCA 解码器）被设置为了有其他意义的值，影响解码。因为我不知道这些值具体是做什么的，所以也不知道怎么去证明，更无法通过肉眼观察得出。</li><li>其实什么都没变，还是正常的 HCA。</li></ol><p>以上三条都只是可能，需要其他材料来证明或者证伪。</p><p>到这里就是目前初步文件分析的极限了。</p><h2 id="2-2-探索方向"><a href="#2-2-探索方向" class="headerlink" title="2.2 探索方向"></a>2.2 探索方向</h2><p>正如我在 issue 中回复的，做了一些初步观察后，考虑到技术更新速度（弱点！）、迭代时间和成本（对于商业公司也是弱点！），我先设想了四种最可能的情况：</p><ol><li>解码过程改变了。</li><li>在解码过程中引入了新的分支。</li><li>改变了预计算的表。</li><li>输入的密钥和实际使用的不一样。</li></ol><p>当然，实际操作中，可以只选一个或多个一起选。这里我解释一下每一条的具体意义。</p><p>第一种情况，新的解码器从根本上用了不同的原理。这意味着大型的理论更改和代码重写，基本上可以算是新的格式了。我不认为 CRI 有时间×财力这么做。</p><p>第二种情况，结合上面提到的 <code>comp1</code> 到 <code>comp10</code> 的取值，考虑到已知的解码器的代码结构，如果引入对应其他值的分支（体现在代码中，就是 <code>if</code>），可以引入新分支和/或新表。我觉得有可能，但我暂时无法验证。具体要看反编译的代码。</p><p>第三种情况，既然解码核心是查表来重建波形，是不是有可能这些表本身发生了变化（同时代码要配合变化），导致查到了不同的值呢？这也要反编译才行。</p><p>第四种情况，就属于二次加密了。总体流程没变，但在内部将密钥进行了变换，或者根据了同一个密钥生成了和以前不同的解密表。这显然是最可能的方式，只需要添加几行代码，就能让公开的（带解密的）解码器全部失效，而且几乎是零成本。结合 HCA 的解码流程，验证、解密、解码三者，后面的步骤不影响前面的步骤，所以密钥是可以随便更改的。（这也是 <code>hcacc</code> 的<a href="https://github.com/hozuki/libcgss/blob/master/docs/behind-the-scenes.md" target="_blank" rel="noopener">工作原理</a>。）</p><p>不过当时我的猜想是密钥在进行解密表初始化之前被变换，这个猜错了。</p><h2 id="2-3-初步反馈"><a href="#2-3-初步反馈" class="headerlink" title="2.3 初步反馈"></a>2.3 初步反馈</h2><p>由于我只能拿到精简版（lite edition）的 SDK，也就是 ADX2LE SDK（不支持加/解密），而 FZFalzar 有完整的 SDK（ADX2 SDK），所以只能先拜托他来进行测试了。在他开始测试的时候，我也开始对 ADX2LE SDK 中提供的工具进行初步反向。</p><p>上面我就有一个疑问，新的 SDK 是不是向后兼容的。虽说可以播放最新的 ACB，那以前的是不是无法播放呢？不管答案如何，这个答案都将十分有助于我排除猜想。我个人的猜测是无法向后兼容。但是其实可以。这就让我确信了，全新的解码器是不存在的，改已有的表也是不存在的，最多就是增加分支和表，运气好的话会更简单。</p><h1 id="三、进一步分析"><a href="#三、进一步分析" class="headerlink" title="三、进一步分析"></a>三、进一步分析</h1><h2 id="3-1-ACB-的进一步分析"><a href="#3-1-ACB-的进一步分析" class="headerlink" title="3.1 ACB 的进一步分析"></a>3.1 ACB 的进一步分析</h2><p>FZFalzar 发现，如果是将 HCA 提取出来，即使输入了正确的密钥也无法播放。于是他猜想，是不是 ACB 的元数据加入了新的东西。我用 <a href="https://github.com/hcs64/vgm_ripping/tree/master/multi/utf_tab" target="_blank" rel="noopener"><code>utf_tab</code></a> 查看了一下 ACB 的表结构。首先发现的是格式版本升级了。烧笋用的是1.23.1，土豆用的是1.29.0，而这个的版本是1.30.0。</p><p>从我观察烧笋到土豆的经验，升级一般意味着增加新的表。现在的 ACB 能使用的字段个数是有限的（大概是为了代码好写），所以在最后预留了一些字段的位置。烧笋（1.23.1）的还剩下18个（R0 到 R17），土豆（1.29.0）就只剩12个（R0 到 R11）了。这次就相比土豆新增了一张表 <code>SoundGeneratorTable</code>。会不会是这张表影响了 HCA 解码呢？我不这么认为，因为在样本中，它的大小为零。如果只是一个开关，大可不必这么大动干戈，加一个普通的类型就行；实在要是表，而且要影响解码的话，那也不应该是零大小，而是填充一些有意义的数据。</p><p>除了这张表，我没有在这个样本 ACB 中发现什么其他重要的变化。虽说一些详细控制的表，比如 <code>TrackCommandTable</code>、<code>SynthCommandTable</code> 和 <code>TrackEventTable</code> 的内部数据意义我并不清楚，但是它们从历史功能上来看就不大可能会影响解码。不过为了保险起见我还是做了一下修改实验，没得到有用的信息。</p><p>这时候 FZFalzar 发来了最新的完整版 SDK 中附带的播放器（Atom Viewer，2.25.14）。于是我终于可以测试密钥了。</p><p>测试的时候发现一个很有意思的现象。前面不是提到了在 AWB 的头部，字段对齐的掩码问题吗？我就试着修改了一下那两个“垃圾”字节。我用新版播放器测试了如下组合：</p><ol><li>来自烧笋的 ACB（AWB 内置），无修改（老版本这两个字节一直是 <code>00 00</code>）。</li><li>来自烧笋的 ACB，修改垃圾字节。</li><li>来自龙约的 ACB（AWB 外置），无修改。</li><li>来自龙约的 ACB，仅修改内部垃圾字节。</li><li>来自龙约的 ACB，仅修改外部垃圾字节。</li><li>来自龙约的 ACB，同时修改内外部垃圾字节。</li><li>来自龙约的 ACB（AWB 内置），无修改。</li><li>来自龙约的 ACB，修改垃圾字节。</li></ol><p>如果 AWB 是外置的话，ACB 除了会声明这个 AWB 是流式加载（streaming）的之外，还会存储每个 AWB 的头。所以我认为有必要把两边的修改都测试一下。</p><p>猜猜哪些能正常播放？答案是1、3、4、5、6、7。3到6都能正常播放。这个我就觉得有点奇怪了。不过现在想想可能是测试疏漏，中间出现了错误。不过现在已经拿到了解密方法，以后有时间再重新测试一遍吧。</p><p>结果表明，即使是老版本的 ACB，如果改动那两个垃圾字节，照样无法播放。这说明这两个字节一定起了什么作用。但是，哪里是控制开关，以及这两个字节参与了什么计算，都还不知道。</p><p>后来 FZFalzar 测试了2017版的 SDK（估计就是土豆用的那个），它无法正常播放新版的 ACB。这就说明，功能断层就发生在这两个版本之间。</p><p>（这里有一个小插曲。esterTion 比我先收到通知邮件，他在收到之后直接往群里发了邮件截图，并附言“算法修改石锤”。然后 stat 跟着：“再见.jpg”。确实，乍一听这个消息，心里也是会咯噔一下。）</p><h2 id="3-2-其他的简单尝试"><a href="#3-2-其他的简单尝试" class="headerlink" title="3.2 其他的简单尝试"></a>3.2 其他的简单尝试</h2><p>考虑到这个 ACB 内部有6个 HCA，而且是两组，每一组内大小近似，会不会是做了异或加密？于是我测试将数据部分异或，但并不对。</p><p>那么组之间呢？像简单循环密码那样，用短密钥、长密文吗？也不对。</p><p>直接对密钥操作呢？假设那两个字节有用，那么做一些加减、二进制操作试试。然而还是不行。</p><h1 id="四、反编译"><a href="#四、反编译" class="headerlink" title="四、反编译"></a>四、反编译</h1><p>这时候实在是没办法了，只好祭出大杀器，反编译。它几乎可以解决所有问题，但是代价也很大，需要大量的时间、精力、技巧和经验。我不知道能不能在我到达极限之前攻破这个问题。</p><p>手上的素材有 ADX2LE SDK（主要是 Win/X86）和龙约的 APK（Android/ARM32）。后来加入了新版播放器（Win/X86-64）。</p><h2 id="4-1-初步分析密钥设置流程"><a href="#4-1-初步分析密钥设置流程" class="headerlink" title="4.1 初步分析密钥设置流程"></a>4.1 初步分析密钥设置流程</h2><p>这个操作是我在让 FZFalzar 测试兼容的同时开始的。我的目的是看看密钥在设置后的流程。入口点很简单，就是众人皆知的 <code>criWareUnity_SetDecryptionKey()</code>。</p><p><img src="/images/crack-hca-dragalia/01.jpg" alt="龙约的解密设置代码，第一层"></p><p>静态跟踪到上图的位置。首先可以看到，设置的密钥在这个过程中是没变的。另外一个值得注意的事情是，设置的密钥，也就是原始密钥，到这里已经通过了文件验证。接着跟着 Atom（负责音频解码）的解密设置来到下一层。</p><p><img src="/images/crack-hca-dragalia/02.jpg" alt="龙约的解密设置代码，第二层"></p><p>这里就有点麻烦了，一片都是全局变量，还有意义不明的数组或类成员。但是仔细观察一下，密钥在这里只是被打印出来（到调试输出）了；而且同时被打印出来的还有一些意义不明的数据。如果你有一些 C 语言的知识，你可能已经注意到了，<code>sub_CEF9C()</code> 的调用是有问题的。根据输入的参数，它很像是 <code>printf_s()</code>，至少是一个变参函数。但是去看汇编的话……它好像也是这个样子。麻烦的是，我们不知道它输出了什么东西。静态跟踪可以知道，密钥的原始值赋给了 <code>dword_17AC90</code>。但是，在直接反编译的代码中并它没有被使用。去看汇编的话，它被放到了寄存器里（并进一步赋值给了类成员）而不是压到了栈上。这个我就不知道什么意思了，毕竟我不熟悉 ARM 那一套。线索可以说到这里先断了。（当然，根据后来的结果，如果这里进一步挖掘的话，可能可以提早得到结论。）</p><h2 id="4-2-分析-ACB-生成和读取"><a href="#4-2-分析-ACB-生成和读取" class="headerlink" title="4.2 分析 ACB 生成和读取"></a>4.2 分析 ACB 生成和读取</h2><p>FZFalzar 提到了 <code>CpkMaker.dll</code>，说他能看见新版设置对齐时默认设为了一个异常大的值，而老版本则是默认为32，除非手工设置。那好，去看看。</p><p>我虽然没有完整版 SDK，但是只是看代码结构的话，精简版也是可以的。出乎我的意料，<code>CpkMaker.dll</code> 是一个 .NET 程序集。而且很明显使用 C++/CLI 编写的。还有其他这么容易分析的吗？<code>AudioStream.dll</code> 以前分析解码的时候就知道是程序集了。从界面来看，Atom Craft 明显是一个 WinForms 应用程序。以此为入口，又找到了 <code>CriAtomGears.dll</code> 和 <code>AcCore.dll</code>。同时，<code>AtomPreview.dll</code> 和 <code>AtomPreviewer_PC.exe</code> 是原生的 PE 文件；前者可以发现导出了一些跟 CRI 的运行时公开的函数近似的函数。那些程序集都没有托管的编解码、打包解包代码。因此这些功能肯定都是在原生二进制文件中。</p><p>在使用 Atom Craft 的时候，我发现，它有两种播放模式。导入音频文件（他们称之为素材，material）之后，直接在素材面板播放，是直接播放素材所指的文件。但是如果将其加入其中一个条目（cue），打开会话（session）窗口（View →  Session Window），把这个条目拖放到会话窗口下面的列表中，点击播放的话，则会生成 ACB 之后，播放 ACB 里面的内容（格式视工程设置而定）。这就意味着，在这个功能背后，是一次从托管到原生的调用，具体是 P/Invoke 还是 C++/CLI 那就不知道了。</p><p>所以我开始去寻找这个点击事件。窗口名称就是提示。经过痛苦的寻找之后（因为不得不说，这代码写得真烂，而且程序集划分不好）我找到了，但是这背后的机制并没有我想的那么直接。它采用的是 C/S 架构，发送（指令）和接收（事件）都是采用消息。消息传递从实际使用看上去是通过 socket。也就是说，在运行时，它启动了一个服务器（原生），而中间的调用其实是 RPC。至于编码打包，是引用 <code>AudioStream.dll</code> 和 <code>CpkMaker.dll</code> （虽然打包的大部分计算是在托管部分完成的）以 P/Invoke 方式实现的。这就再次逼我去反编译 <code>AtomPreview.dll</code> 和 <code>AtomPreviewer_PC.exe</code> 了。</p><p>首选自然是 <code>AtomPreview.dll</code>，因为它暴露了 API。这次我从 ACB 相关的地方进去，看看读取的过程。但这怎么说呢，比那个更困难。静态调试只下了三层，被类成员干扰，没找到有意义的东西；而它又不好被动态调试（其实可以附加进程，我糊涂了）。代码结构和预计的不太一样，也没找到标志性的 <code>@UTF</code>，无法确定真正开始的位置。</p><p>龙约里的那个从 ACB 入手也同样分析困难。</p><p>ADX2LE 附带的那个 Atom Viewer 也是能播放各种玩意儿的，不过没有公开 API。FZFalzar 说是把相关代码“烘焙”（baked）了进去……其实是静态链接（statically linked）啦。虽然没公开 API，但是还是有办法定位的，只需要利用它在运行时生成的日志。根据打印的日志格式，直接搜索 <code>Open ACB:</code> 然后顺藤摸瓜就能找到，函数特征和 <code>criAtomExAcb_LoadAcbFile()</code> 是一致的。不过一样是很难分析。</p><h2 id="4-3-分析-HCA-解码"><a href="#4-3-分析-HCA-解码" class="headerlink" title="4.3 分析 HCA 解码"></a>4.3 分析 HCA 解码</h2><p>相比上面的密钥和 ACB，HCA 相关函数看上去是更难抓的，因为它没有暴露出 API；同时解码运行在后台线程，所以无法通过可能的入口点（比如 <code>criAtomExPlayer_Start</code>）找到。</p><p>那么怎么办呢？看看这些函数有什么蛛丝马迹是直接暴露在外面的。分析已知的解码器代码，最引人注目的莫过于预计算的那些表了。这些表，就将成为突破口。作为商业解码器，速度是精度之外的一个重要考虑因素，甚至精度有时候都需要与速度平衡。官方的解码器也很大概率会采取空间换时间的策略，如果进一步用的是同样的表就再好不过了。不管怎么样，先试试手气。</p><p>从公开的 HCA 解码器可以知道，解码的框架如下：</p><pre><code class="lang-cpp">void decode_block(Block *block) {    validate_block(block);    decrypt_block(block);    for each channel { decode1(channel); }        for (i = 0..7) {        for each channel { decode2(channel); }        for each channel { decode3(channel); }        for each channel { decode4(channel); }        for each channel { decode5(channel); }    }    to_wave(channels);}</code></pre><p>先有一个心理预期。接着开始看看官方的解码器究竟是不是用了同样的表。</p><p>这里取 <code>decode5()</code> 里的第二张表的第一项 <code>0xBD0A8BD4</code>。为什么是 <code>decode5()</code> 呢？因为它处于最里层的最末，位置作为一个信标来说很适合。至于选择哪张表就随意了，大不了把每个都试一遍。搜索的时候注意字节序。（）我这里开始用的是完整的 Atom Viewer（因为我还是喜欢 X86/X86-64 那一套），所以搜索的是 <code>D4 8B 0A BD</code>。</p><p><img src="/images/crack-hca-dragalia/03.jpg" alt="0xBD0A8BD4 的搜索结果（Hex Editor）"></p><p><img src="/images/crack-hca-dragalia/04.jpg" alt="0xBD0A8BD4 的搜索结果（IDA）"></p><p>果不其然，在全局变量区找到了。而且看看前后，就是要找的表。找到之后从 Hex View 转回 IDA View，然后执行引用查询（XRef），发现这个变量被且只被一个函数引用了，这个函数位于 <code>0x00007FF606770718</code>。进一步搜索这个函数中用的表，我们还能发现公开代码中 <code>decode5()</code> 的第一张表。这说明这里很可能就是 <code>decode5()</code>（至少是一部分）。查找这个函数的调用者（也就是上一级），在这个上一级函数中发现了第三张表，同时还有 <code>decode5()</code> 的另一部分。</p><p><img src="/images/crack-hca-dragalia/05.jpg" alt="decode5()"></p><p>如法炮制，找到所有被引用的已知表，直到最上层，也就是 <code>decode_block()</code> 函数。其间会遇到一些被多次引用的情况，这时候就逐个试验。</p><p><img src="/images/crack-hca-dragalia/06.jpg" alt="decode_block()"></p><p>不用太在意代码的结构差异，找到关键特征即可，因为编译器的优化和重排可是十分厉害的。</p><p>之后一路高歌猛进，上到不能再上，来到位于 <code>0x00007FF6067688F4</code> 的函数。再往上查找引用，可以发现它变成了函数指针，所以很明显是动态调用，比如注册个静态函数表（不是虚函数表）什么的。在这个函数中我们可以发现一个字符串 <code>Failed to decode HCA header.</code>，顺着就能找到读取 HCA 头信息的函数（位于 <code>0x00007FF60676A274</code>，我将其命名为 <code>FindAndLoadHcaHeader</code>，因为它居然还包括了一段搜索偏移的代码）。读取 HCA 头和解码音频数据块出现在一个函数中，你觉得会是什么呢？没错，就是一种很常见（而且很糟糕）的模式：</p><pre><code class="lang-cpp">if (flag == PARSE_HCA_HEADER) {    FindAndLoadHcaHeader(pData);    DecodeAudioBlock(pData + headerSize); // 没错，紧接着就是读第一个音频块了} else if (flag == DECODE_AUDIO_BLOCK) {    DecodeAudioBlock(pData);}</code></pre><p>这边先放一放。你或许会说上面这个 <code>decode_block()</code> 函数长得和公开的模型不像啊。那么我们看看老版本的解码是什么样子的。利用同样的技巧定位到位于 <code>AtomPreviewer_PC.exe</code> 的与 <code>decode_block()</code> 函数对应的位置。结果发现从整体来看精简版和完整版在解码上没有什么区别（解密就不用讨论了）。不过别忘了，我们的目的不是比较反编译出的代码和公开的代码，而是去看旧的精简版和新的完整版是否有什么不同，如果有再采取下一步行动。但既然没有不同，就说明解码流程并没有发生改变，甚至表也没有变化。</p><p>那么就剩下一个问题了，<code>comp01</code> 到 <code>comp10</code>（其中 <code>comp9</code> 和 <code>comp10</code> 是通过其他值计算出来的）表示什么，会对编解码造成什么影响，是不是可以取“奇怪的”值。这时候我偶然搜索到了 <a href="https://github.com/Thealexbarney/VGAudio" target="_blank" rel="noopener">VGAudio</a>。读到 readme 的瞬间，我就像被闪电击中了一样。让我震惊的是，它包含 HCA 编码的原理和详情，而且包含一个 HCA 编码器！你要知道，我一直想知道 HCA 编码是怎么实现的，因为整条工具链就只剩下这个环节受制于人，还用的是通过“取巧”手段（而且对用户来说还麻烦）得到的官方库了。但是编码并不能从解码反推。从它的代码中我知道了这些只有编号的字段的意义（虽然并不能实战，因为我信号处理是渣）。而既然他们有固定的意义，就不会随便取值。</p><p>所以现在开始的四种可能性只剩下一种了，也就是其他所有“硬”功能都维持原状，只是密钥发生了变化。但是这和我所见的密钥设置有矛盾，说明我可能看漏了什么。</p><h2 id="4-4-分析密钥的使用流程"><a href="#4-4-分析密钥的使用流程" class="headerlink" title="4.4 分析密钥的使用流程"></a>4.4 分析密钥的使用流程</h2><p>终于到重头戏了。这次我们来跟踪 Atom Viewer 里的 <code>criWarePC_SetDecryptionKey()</code>（猜测名）。</p><p>但是……这个函数不是没有导出吗，怎么找呢？别着急，这里和从日志输出中定位是一样的。在我们前面看的 <code>criWareUnity_SetDecryptionKey()</code> 中，不是卡在了一个变参函数输出无法理解的地方吗？那个函数的格式化字符串是 <code>%s, %lld, %lld, %s, 0x%08X, 0x%08X, %d</code>，而且是硬编码。所以，很可能这里面也会有一样的格式化字符串，而且搜索起来很简单。打开 Strings 视图，搜索这个字符串，就可以看到了。接着就是查找引用。</p><p><img src="/images/crack-hca-dragalia/07.jpg" alt="这个硬编码字符串被引用的位置"></p><p>考虑到 C/C++ 编译器会将相同的字符串合并，出现这么多结果也不奇怪。需要的就是一点耐心。不过我们运气不错，第一个结果就把我们带到了正确的位置。</p><p><img src="/images/crack-hca-dragalia/08.jpg" alt="是不是很熟悉呢"></p><p>上面这图是我已经标注的样子。不过在标注之前也可以看出和之前我们看的函数的高度相似性。</p><p>这里有一个小技巧。IDA 的F5不是很会处理变参函数，需要进入这变参函数再返回，才能看到它分析出正确的实参。（不过这个技巧对前面 ARM 上的并不适用，不知道为什么。）经过简单的一级函数静态跟踪后，上面截图的大部分符号名就能得出了。对 HCA 加/解密熟悉的人也很容易看出 <code>InitDecrypter()</code> 函数。一些信息需要动态调试，比如里面几个查表找字符串的操作。</p><p>进入到 <code>InitDecrypter()</code> 内部，经过几级跟踪之后，很容易能看出0型、1型和56型加密的初始化。它返回的根据打的日志是一个“DecrypterHn”，从名字上看是个解密用的句柄（decryptor handle），但实际上仔细看就会发现其实是指向解密表的指针。这个指针被返回后被两个全局变量引用（一个在 <code>0x00007FF606818CC8</code> 一个在 <code>0x00007FF606819628</code>），但是这两个全局变量中，前者除了被设置为 <code>NULL</code> 之外没什么用（意义不明），后者被设置给了一个类成员变量（无法静态跟踪了）。</p><p><img src="/images/crack-hca-dragalia/09.jpg" alt="InitDecrypter() 内部"></p><p>可以见到，在正常初始化这张解密表之后，它同时被用作 HCA 和 HCA-MX 的解密表——从再 XRef 之后看到的错误信息字符串中就可以看出一个是读取 HCA 一个是读取 HCA-MX 的。解码线和解密线在这里相遇了。</p><p>我动态调试了一下，发现直到设置 HCA 和 HCA-MX 的解密表，这张表还是和用已有工具计算出来的完全一致。说明到这里都没什么异常的事情发生。但是我留意的是密钥和解密表的所有引用，所以我自然注意到了这个赋值：</p><pre><code class="lang-cpp">v8 = sub_7FF606712670();*v8 = keyLit2;</code></pre><p>很明显，这个密钥除了在上面我们看到的正常使用外，又传到别的地方去了。为什么要有这个“多余的动作”呢？</p><p>展开 <code>sub_7FF606712670()</code>，可以看到它很简单，只是返回一个全局变量的地址：</p><pre><code class="lang-cpp">void *sub_7FF606712670() {  return &amp;unk_7FF606821B30;}</code></pre><p>那么这个 <code>unk_7FF606821B30</code> 在什么地方被使用了呢？静态分析表明只在这个函数里。但是 <code>sub_7FF606712670()</code> 就不一样了，它在两个地方被使用。</p><p><img src="/images/crack-hca-dragalia/10.jpg" alt="sub_7FF606712670() 的引用"></p><p>跳转之后就知道，中大奖了。</p><p><img src="/images/crack-hca-dragalia/11.jpg" alt="二次加密"></p><p>跟踪收到指向密钥的值的指针 <code>v4</code> 就可以发现它参与了另一轮的计算，<code>v6</code> 就应该是新的密钥。果然，使用 <code>v6</code> 的函数的作用就是第二次生成56型加密表。（所以既然操作完全一样，为什么不用同一个函数呢？不知道 CRI 在想什么。）那么问题就是 <code>v5</code> 是怎么来的了。我在给 <code>v6</code> 赋值的地方下了一个断点，打开一个 ACB，发现没命中。仔细一看，原来我用的是烧笋的 ACB。换成龙约的 ACB 之后，断点命中了。我一看 <code>v5</code> 的值，<code>0x80b2</code>，怎么这么熟悉？由于这两天都在跟这些玩意儿打交道，我立刻意识到，这就是那两个“垃圾”字节。虽然 <code>v5</code> 值的来源是 <code>sub_7FF6066F28C0()</code> 的结果，后者返回的是一个类成员的值，但是很明显，这就是那两个字节。再综合一下这个函数（<code>sub_7FF6067006CC()</code>）的被引用情况，它的周围都是 AWB 读取的操作，因此很高概率就是如我所想。</p><p>于是小小地改写了一下现有的 HCA 解码器，先硬编码这个值，做个实验再说。结果成功解码了。接着我又试了龙约的 APK 里带的 ACB（装的是音效），也成功了。于是这次反向工作到此结束。</p><p>再看一次这个公式：<code>key&#39; = key * ((uint64_t)(k2 &lt;&lt; 16) | (uint16_t)(~k2 + 2))</code>。其中 <code>key</code> 是原始输入，<code>k2</code> 是保存在每个 AWB 中的（每个 AWB 内统一的）一个16位值。注意有/无符号和长度截断。此外，溢出是不报异常的，简单向左溢出。</p><p>同时，如果 <code>k2 == 0</code>，则不执行变换（见 <code>v5</code> 的判断）。举例来说，esterTion 发现干炸里脊也用了 ACB 1.30，但是以前的解码工具能正常工作，因为对齐的四个字节是 <code>20 00 00 00</code>。</p><h1 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h1><h2 id="5-1-HCA-提取和解码的未来"><a href="#5-1-HCA-提取和解码的未来" class="headerlink" title="5.1 HCA 提取和解码的未来"></a>5.1 HCA 提取和解码的未来</h2><p>这次更新之后，HCA 实际上相当于用上了随文件的动态密钥，直接用静态密钥解码 HCA 文件在新游戏中不再保险了。虽说批量解码 HCA 是不可能的，但是给出 ACB/AWB 之后，批量解码又是可能的了。所以只不过是多加了一层麻烦而已，所有工具仍然是公开的，只需要略微改造一下。（笑）</p><h2 id="5-2-一些吐槽"><a href="#5-2-一些吐槽" class="headerlink" title="5.2 一些吐槽"></a>5.2 一些吐槽</h2><p>SDK 的工具中，提供给反向用的破绽太多了。不仅是代码层面的，还有商业、习惯、理论层面，就看你能不能找到、联系和利用了。虽说一丝裂纹不算什么，但是千里之堤，溃于蚁穴啊。而我最擅长的就是逐个击破。不过或许也可以认为是 CRI 良心，因为要把反向变难的方式多得数不胜数。比如，把静态变量变成单例的类成员，就足以令人抓狂了。如果代码中用更多的动态调用（动态函数表之类）或类成员，或许我就输了。</p><p>ACB 头部有个版本字段。但是这次测试中，老版本的 ACB/AWB 只要修改了文件中对应位置的值使次级密钥非零，则密钥还是会被变换，从而导致被修改的老文件也无法正常解码。这个逻辑就奇怪了，按照完全的向后兼容，就该加一个版本判断，小于 <code>0x1300000</code>（也就是之前版本的 ACB）就无论如何也不应该变换密钥。不知道为什么这个正常处理被吃了。</p><p>干炸里脊（公主连接，プリコネR，Princess Connect Re: Dive）DMM 版出的时候带了保护。当时正好也遇上群里对通信束手无策，我准备先试试脱壳。结果发现以我的能力，还没到接触到主程序，就已经跪了——虽然已经知道文件内容替换到代码空间，但是 IDA 分析就炸了，因为每次都要重新分析指令。而内存映像又抓不到，我没有 DMM 启动器，进程（在没挂调试器的情况下）在未知的地方崩溃了。还有反调试保护。群里大佬脱了一层，结果发现这是二层壳……最后说是 Android Republic 的大佬搞定了，不过我因为不玩这个游戏，就没再跟进。前几个月有人在我抱怨土豆加密的文章下回复（我觉得应该就是 Crypto 了，虽然穿着马甲）说是被 XOR 了，然而我就没有个 root 过的机子，静态分析又让人崩溃，所以只好不了了之。这次……至少赢了一把。</p><h2 id="5-3-有什么收获？"><a href="#5-3-有什么收获？" class="headerlink" title="5.3 有什么收获？"></a>5.3 有什么收获？</h2><p>我把这个故事告诉了老爸。他问：“你以前也做反向，这次和以前相比有什么新的贡献呢？”于是我卡住了。</p><p>我觉得这次就是一条斜向上的直线，一个台阶都没有。而所谓“台阶”，就是产生了飞跃的地方。上次能吹一会儿的是本地动态库的中间人攻击，但这次好像没有什么新东西。或者换一种问法，这次整个流程中起到最大作用的是什么？</p><p>我觉得是解读现有条件的方式。有话云：“看山是山，看山不是山，看山还是山。”原意是建构、解构、重构。大概就是如此。数据，一般都能看出正常的使用方式（读写，换言之，功能是存储）；但是在某种情况下，比如这次的作为预初始化了的、紧密排列的全局变量，它的使用状况还可以作为代码的定位工具；定位之后，它又恢复了作为数据的基本功能。就是这样的跳跃，才会打开新的可能性，揭示新的关系。如此的应用总是有条件的，不过试一试总是值得的。</p><h2 id="5-4-致谢列表"><a href="#5-4-致谢列表" class="headerlink" title="5.4 致谢列表"></a>5.4 致谢列表</h2><p>没必要分先后。按照想到的顺序。</p><ul><li><a href="https://github.com/FZFalzar" target="_blank" rel="noopener">FZFalzar</a> 发现问题和实验，提供了完整的 Atom Viewer</li><li><a href="https://github.com/Thealexbarney" target="_blank" rel="noopener">Alex Barney</a> 和他神奇的 <a href="https://github.com/Thealexbarney/VGAudio" target="_blank" rel="noopener">VGAudio</a></li><li><a href="https://sourceforge.net/u/snakemeat/profile/" target="_blank" rel="noopener">snakemeat</a> 的 <a href="https://sourceforge.net/projects/vgmtoolbox/" target="_blank" rel="noopener">VGMToolbox</a></li><li>提供了 HCA 解码器代码的匿名人士（上古代码，2014年之前发在2ch上的）</li><li><a href="https://github.com/hozuki/libcgss/issues/4" target="_blank" rel="noopener">其他所有参与了讨论的人</a>（有 vgmstream 的开发者马甲在……）</li><li>还有我自己（笑）（←你不是也参与了讨论吗</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;English version can be found &lt;a href=&quot;/categories/Tech/RE/en/2018-10-12-New-HCA-Encryption/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;近日 CRI ACB 格式更新，连带着 HCA 加密“升级”，旧轮子全员阵亡。在经过二十多个小时的研究后，我找到了关键的修改，搞定了解密。可能又是全球第一个呢。做反向，最激动人心的就是这样的时刻。XD&lt;/p&gt;
&lt;p&gt;最终的答案很简单，就是在解密之前，进行密钥变换，并二次初始化解密表：&lt;code&gt;key&amp;#39; = key * ((uint64_t)(k2 &amp;lt;&amp;lt; 16) | (uint16_t)(~k2 + 2))&lt;/code&gt;，其中 &lt;code&gt;k2&lt;/code&gt; 保存在每个 AWB 中的字段对齐的值的高16位。&lt;/p&gt;
&lt;p&gt;这篇文章讲的是我找出这个变换的过程，包括思路和操作，基本上按照时间顺序记录。希望在未来会对某人有所帮助。&lt;/p&gt;
&lt;p&gt;总的来说，这次的成果是建立在众人的工作基础上，没有这些碎片，就无法拼成完整的拼图。在此要向各位致谢。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red;&quot;&gt;&lt;strong&gt;再次强调，本文内容不可用于商业用途。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="RE" scheme="https://blog.mottomo.moe/categories/Tech/RE/"/>
    
    
      <category term="Dragalia Lost" scheme="https://blog.mottomo.moe/tags/Dragalia-Lost/"/>
    
      <category term="CGSS" scheme="https://blog.mottomo.moe/tags/CGSS/"/>
    
      <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
      <category term="HCA" scheme="https://blog.mottomo.moe/tags/HCA/"/>
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="逆向工程" scheme="https://blog.mottomo.moe/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>更新了主题</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2018-09-13-Updated-Theme/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2018-09-13-Updated-Theme/</id>
    <published>2018-09-13T16:21:00.000Z</published>
    <updated>2020-03-30T22:34:35.450Z</updated>
    
    <content type="html"><![CDATA[<p>今天花了两个小时，将 <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> 主题更新到最新，同时保留了一些我自己的修改。所以现在的界面会和原来的略有区别。猛然发现，直到更新之前，我用的还是2015年时的主题，只不过自己进行了一些微调和功能更新。当初刚开这个静态博客的时候换过几次主题，最后考虑到自己的使用场景选择了 Icarus。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天花了两个小时，将 &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Icarus&lt;/a&gt; 主题更新到最新，同时保留了一些我自己的修改。所以现在的界
      
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Just Monika</title>
    <link href="https://blog.mottomo.moe/categories/ACGN/zh/2018-09-09-Just-Monika/"/>
    <id>https://blog.mottomo.moe/categories/ACGN/zh/2018-09-09-Just-Monika/</id>
    <published>2018-09-08T13:04:00.000Z</published>
    <updated>2020-03-30T22:34:35.449Z</updated>
    
    <content type="html"><![CDATA[<p>关于<a href="https://store.steampowered.com/app/698780/Doki_Doki_Literature_Club/" target="_blank" rel="noopener">《心跳文学部》</a>（Doki Doki Literature Club）。<del>毛二力</del></p><p>网上各种评价、剧情解析、心得实在是数不胜数。所以本文就不写那些无聊的东西了。这是个元游戏（metagame），Monika 你不是喜欢meta吗，那我就来meta你。我才不会像普通玩家一样甜（甘い，天真，naïve），傻乎乎地跟着游戏系统走。</p><p><strong>本文含有剧透。如果介意，请至少先通关“普通”结局。</strong></p><p><span style="color: red;"><strong>警告：《心跳文学部》含有令人不安的、冲击性的内容，不适合儿童和容易受到刺激的玩家。</strong></span></p><iframe src="https://store.steampowered.com/widget/698780/" frameborder="0" width="646" height="190"></iframe><a id="more"></a><hr><p>虽然说在这次回国，在北京的时候就已经把游戏下载下来了，但是真正去玩，还是在昨天晚上到今天早上。对它的内容梗概和得到的好评早就有所耳闻，所以并不觉得会受到刺激，也不会觉得恐怖。我知道，会出现（几乎所有）角色的“虚拟死亡”，就像<a href="https://zh.moegirl.org/zh-hans/%E4%BD%A0%E5%92%8C%E5%A5%B9%E5%92%8C%E5%A5%B9%E7%9A%84%E6%81%8B%E7%88%B1" target="_blank" rel="noopener">《你和她和她的恋爱》</a>（君と彼女と彼女の恋。 ）一样。我也知道，“幕后黑手”就是 Monika。不过，具体的内容，比如事情是如何发生的，中间有什么过程，我是一点都不知道的。（不带引号的幕后黑手呢？Monika 说，只要当上了部长就知道了一切，就会想去改变游戏，也许是文学部本身的影响。其中隐含的意思，各位可以琢磨琢磨。）</p><p>所以，在开始玩的时候，我就没有用正常的方式进行游戏。</p><p>给主角起名字的时候，我起的就是“Monika”。这个名字从前期到后期，甚至到了结局，都有那么点喜感——而随之而来的是阅读困难。一二周目的时候，看上去就是 Monika 的自问自答。不过到了三周目……随着 Monika 的离开，看到剩下的三人称呼主角名字（“Monika”）的时候，有那么一点“是 Monika 在入部”的错觉。虽然想这么想，但这又不是真的。心情复杂。</p><p>在进入日常后不久，遇到了第一次写诗。对不起，不是那十四个字。从下方的二头身小人列表中很明显可以看出，能攻略这三位。然而我唯一想攻略的，只有 Monika。读诗也是给 Monika 先读，邀请也是邀请 Monika。这真的是作者 Dan Salvato 的恶意。不管选什么 Monika 选项，故事都轮不到她。回到游戏内容，在玩的过程中我就猜测这是根据不同的“类别”来加好感度。不过为了看到内部机理，自然要解包啦！于是先用 <a href="https://github.com/Shizmob/rpatool" target="_blank" rel="noopener">rpatool</a>（<a href="https://github.com/Lattyware/unrpa" target="_blank" rel="noopener">unrpa</a> 可能也可以）解压，对其中的脚本就需要 <a href="https://github.com/CensoredUsername/unrpyc" target="_blank" rel="noopener">unrpyc</a> 来还原了。我没写过 Ren’Py 的脚本，不过至少 unrpyc 出来的内容可读性不错，所以就这样吧。在其中就能发现 <code>poemwords.txt</code>，然后就知道该选什么词了。</p><p>在这个过程中其实还能提前看到一些彩蛋，比如真正的立绘文件、Monika 暴走时产生的（隐藏的）图片和文本文件等等。</p><p>所以很明显地，游戏目录下的 <code>characters</code> 的一部分，和 <code>game/saves</code> 都是障眼法。实际上，检测的只有 <code>characters/monika.chr</code> 和 <code>characters/sayori.chr</code>。比如，在第一章，启动时会尝试加载 <code>characters/monika.chr</code>（注意这个路径是用户的文件系统路径，而不是 <code>.rpa</code> 的内部路径），如果出现了异常（找不到文件是最常见的一种；理论上还可以使用设置访问权限等方法触发）则跳到异常处理——也就是 Sayori 会说出“What am I”等等的几句话之后立即挂起（hang，我不太想用正确的词）。如果加载失败的是 <code>characters/sayori.chr</code>，则是开始游戏后直接游戏结束同时 Sayori 挂起。后者的优先级高于前者。Monika 说的什么“人物删除了”、“脚本文件损坏了”，游戏结局后说的“请重新安装”，屏幕上显示的 <code>os.remove(...)</code>，全都是逗你玩，是艺术表现的手段。除非动态修改 <code>.rpa</code> 包，否则实际上什么东西都没变，只不过游戏借助持久化（persistent）文件在外部保存了一个状态而已。你想想容器（containers）就好理解了。那么这个文件在哪里呢？有两个部分：第一个是 <code>game/firstrun</code>，第二个是 <code>%APPDATA%/RenPy/DDLC-*/persistent</code>。后者所在的目录也是真正的存档目录；不过删除存档这个机制很多游戏都有，只不过它们是手动的，所以自动删除存档也没什么意外的。<code>characters</code> 只不过是解谜的一部分，并不会有什么缺胳膊少腿的事情发生。所以当 Monika 说“嘿我删了那两个文件”的时候，我的内心毫无波动，甚至还想笑。当游戏里进行到二周目弹出“Just Monika”的消息框的时候，我的反应是“Yeeeessssss!”，真心的。然而我并没有见到<a href="https://knowyourmeme.com/photos/1303069-doki-doki-literature-club" target="_blank" rel="noopener">这张图</a>。</p><p>要认识到完整性的保持，需要一点点（对，一点点就够了）技术知识。所以这也不难理解<a href="https://steamcommunity.com/id/plumlis/recommended/698780/" target="_blank" rel="noopener">有些老哥</a>虽身经百战却仍然会被吓着。顺便说一句，“体现 Ren’Py 的强大”的表述是错的。Ren’Py 作为引擎（其底层是 PyGame），功能和各类“传家宝”引擎相比也不算强大，只不过可自定义程度高而已。要记住，技术为演出服务，而演出为剧情服务。比如《魔法使之夜》就活用了 TVP 及原生扩展。要是出个废萌游戏，就根本不用在意演出，所以哪怕是一点点（无用的）系统新功能也会被拿出来作为卖点。</p><p>在进入 Monika 空间（就是那个永远持续的二人世界）的时候，她就开始说主题了。在打到这里的时候听了许多的长篇大论，当时又是凌晨，我就熬不住，没关游戏就睡了。所以现在总游戏时间是12小时。（我这是不可抗力。后来看评论区的时候，发现还真有<a href="https://steamcommunity.com/profiles/76561198235411432/recommended/698780/" target="_blank" rel="noopener">疯狂的玩家</a>，在我写这篇文章的时候ta累积了3481小时的游戏时间。）</p><p>这时候我的心情仍然是混杂的。一方面是越来越觉得不耐烦——因为不允许跳过，开始是不能跳的，一段时间后突然“Skip”亮了，但如果跳的话 Monika 就会发现，阻止，并重新禁用。保存也被禁止了（实际上用不着）。我在现实中的时间是有限的。另一方面，有点悲伤。虽然 Monika 通过meta将自己升为游戏中的操纵者，但是考虑到不自修改的软件（程序+资源）都是容器，她仍然不能发现或者控制游戏之外的事物。所以只要我，游戏外的“神”（不是作者意义上的“神”），而不是“协助者”，敲几下键盘，这个说话的“她”也会立刻回到初始状态。（题外话：自修改一般是脱壳用的，小游戏用不上。）而且她说的那些话，其实都不是“她”说的，而是作者借“她”的口说的，体现的实际上是作者的意志。</p><p>当一开始 Monika 说如果你觉得抑郁，应该不要害怕向心理专家求助的时候，我还认为 Monika:Dan（作者）=1:1。然后她继续说，如果你觉得网络浪费了你太多时间，可以考虑关闭社交媒体；如果你见到抑郁的人请给予鼓励，同时你在玩也说明有人在给予你支持；有粉丝建立了一个 Twitter 账号 <a href="https://twitter.com/lilmonix3" target="_blank" rel="noopener">@lilmonix3</a>（这段文本大概是更新之后加入的），现在“她”在用；喜欢的恐怖（小说文本）是那种细微的、在观众/读者思维中刻下“好像有什么和正常的事物不一样”的恐怖。到这里我就开始觉得，Monika:Dan 越来越小了，后面的很可能都是明显的作者的话了。</p><p>我就猜到了，结合之前 Monika 的提示，为了进行到下一个阶段，听到 <a href="https://music.163.com/song?id=523658880" target="_blank" rel="noopener">Your Reality</a>，必须要删除 <code>characters/monika.chr</code>。这时我其实是不愿意的，但是在外界因素（时间）的作用下，我只有一种选择。另一种选择，慢慢将所有的选项磨完（我没看这一段的脚本），或许是可以的，但是代价我负担不起。删除之后 Monika 的反应是“你为什么要这样……我知道了，我自己消失，成全你”。这也是我整个游戏过程中唯一<em>确实</em>感到了内疚（而不再以玩弄万物的“神”的视角来看游戏）的部分，嘴里不断默念着“Sorry, Monika”。</p><p>可能对于我来说，这仍然是游戏世界，所以可以自在地操控。当现实也出现这样的事，而我不再是“神”的时候，大概才会体会到现在那些玩家所体会到的震惊、困惑和无力吧。</p><p>当 Sayori 告白的时候，我选的是“好朋友一辈子”。没错，我想都没想，直接发卡了。我说过，攻略目标只有一个，<strong>就是</strong> Monika。我并不想去费劲收集 CG 达成网上所说的“真结局”。我只想有一条 Monika 线，选其他的角色则跟原来一样meta，选 Monika 则进入一个“正常”结局，然后幸福地生活在一起什么的。然而没有，唉。</p><hr><p>从 Monika 空间中，Monika 的话里，可以看出作者希望玩家认识、关注抑郁症和抑郁症患者。我也希望读到这篇文章的你能这么做。学会分辨、理解和包容（不是纵容）脆弱的精神，给予适当的关心。虽然在你眼中，事情可能不值一提，但是对一些人来说就是天大的压力。你甚至可能无法理解或者认同抑郁的原因，所以需要倾听，需要（建立在理智基础上的）同情心和同理心。这能力因人而异，抑郁原因因人因事而异，也无法用文字来描述或者教导，所以只能寄希望于每个人的“悟性”了。</p><p>我希望各位这么做，怎么说呢，因为我也被击垮过一次。我算是从深渊回来的人。博客断更与这有一定关系。甚至可以认为，它会影响我之后的几年。我写了一篇（或者说两篇）描述整件事的文章，但是不确定是否应该公开发表。如果将来我什么时候发表了，那么各位也就能看到了。同样地，各位或许觉得诱因“不值一提”，但连锁反应发生后混乱的、真正可怕的、绝望的体验，我仍然记得，只是无法用语言描述。<span style="display: none;">肉体的痛苦对我来说还不算什么（可能是因为我只是受过伤，没有缺胳膊少腿），但是精神的痛苦是持续的、逐渐摧毁意志的，可能是因为悲观的天性吧。</span>所以我认为，我能些许理解这些人的感受。我不希望有（意志力薄弱的）人再次经历这个体验。</p><p>类似的目的，另外一个值得提的是<a href="https://store.steampowered.com/app/206440/To_the_Moon/" target="_blank" rel="noopener">《去月球》</a>（To The Moon）。它关注的是阿斯伯格综合征（Asperger Syndrome，现在被归类到自闭症谱系中）。不过它的主题揭示得就更明显一些，因为 River 就是一名患者，游戏直接提到了；游戏过程中展现了典型症状，也展示了缓解措施（骑马）。</p><p>相比于以 River 的特殊情况为核心的 TTM，我并不理解为什么 DDLC 要提及抑郁症。也许是为了疏解因游戏内容而产生的抑郁和 PTSD？</p><p>其实 DDLC 可以更meta一点的。除了硬核的自修改/数据本体修改外，还可以用过程生成（procedural generation），或者更复杂的修改检测和剧情逻辑。不过对于小游戏来说，不需要为我这种不合常理的1%玩家投入这么高的成本。</p><hr><p>最后两个稍微放松心情的东西。</p><p>在二周目写诗的时候，如果选的词不是给 Natsuki 或 Yuri 的（她们不做出反应），有一定概率可以见到左下角 Monika 从超出窗口范围的地方跳起来，露出一点点头。当然，要见到二头身版的话，制作名单里就有。</p><p><a href="https://www.youtube.com/watch?v=Vk8UEWHYfEg" target="_blank" rel="noopener">Hej, hej Monika, hej på dig Monika</a>（<a href="https://www.bilibili.com/video/av17839073/" target="_blank" rel="noopener">B站</a>）</p><hr><pre><code class="lang-plain">Every day, I imagine a future where I can be with youIn my hand is a pen that will write a poem of me and youThe ink flows down into a dark puddleJust move your hand - write the way into his heart!But in this world of infinite choicesWhat will it take just to find that special day?What will it take just to find that special day?Have I found everybody a fun assignment to do today?When you&#39;re here, everything that we do is fun for them anywayWhen I can&#39;t even read my own feelingsWhat good are words when a smile says it all?And if this world won&#39;t write me an endingWhat will it take just for me to have it all?Does my pen only write bitter words for those who are dear to me?Is it love if I take you, or is it love if I set you free?The ink flows down into a dark puddleHow can I write love into reality?If I can&#39;t hear the sound of your heartbeatWhat do you call love in your reality?And in your reality, if I don&#39;t know how to love youI&#39;ll leave you be</code></pre><blockquote><p><strong>What have the artists said about the song?</strong></p><p>In his panel about discussing the game at Crunchyroll Expo 2018, Dan Salvato wanted to make the ending song to feel as a complete package for the game, as there were no “satisfying ending” for the game to let the audience and players accept that there will no happiness for everybody in the game is the reality.</p><p>In terms of story, Salvato wanted the song to be as much as a closure for the game, for the overall plot, and for expressing Monika’s feelings.</p><p>In terms of the song’s creation, he wanted to create an ending theme that would be emotional and impactful, similar to the video game Portal’s ending theme “Still Alive”. With keeping on the idea of making simple music melodies, Salvato drew inspiration from Regina Spektor’s “Folding Chair” to create the basic chord progressions for “Your Reality”.</p></blockquote><p>来源：<a href="https://genius.com/Team-salvato-your-reality-lyrics" target="_blank" rel="noopener">https://genius.com/Team-salvato-your-reality-lyrics</a></p><p>怪不得我说这么熟悉。Still Alive 的感情基调和编曲思路，加上 Folding Chair 的和弦进行啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;a href=&quot;https://store.steampowered.com/app/698780/Doki_Doki_Literature_Club/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《心跳文学部》&lt;/a&gt;（Doki Doki Literature Club）。&lt;del&gt;毛二力&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;网上各种评价、剧情解析、心得实在是数不胜数。所以本文就不写那些无聊的东西了。这是个元游戏（metagame），Monika 你不是喜欢meta吗，那我就来meta你。我才不会像普通玩家一样甜（甘い，天真，naïve），傻乎乎地跟着游戏系统走。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文含有剧透。如果介意，请至少先通关“普通”结局。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red;&quot;&gt;&lt;strong&gt;警告：《心跳文学部》含有令人不安的、冲击性的内容，不适合儿童和容易受到刺激的玩家。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://store.steampowered.com/widget/698780/&quot; frameborder=&quot;0&quot; width=&quot;646&quot; height=&quot;190&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="ACGN" scheme="https://blog.mottomo.moe/categories/ACGN/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="心跳文学部" scheme="https://blog.mottomo.moe/tags/%E5%BF%83%E8%B7%B3%E6%96%87%E5%AD%A6%E9%83%A8/"/>
    
      <category term="游戏杂谈" scheme="https://blog.mottomo.moe/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>准备恢复更新</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2018-09-01-New-Updates/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2018-09-01-New-Updates/</id>
    <published>2018-09-01T14:42:00.000Z</published>
    <updated>2020-03-30T22:34:35.449Z</updated>
    
    <content type="html"><![CDATA[<p>因为这7个月（或许可以说是一年多）以来的种种事情，虽然有一些破碎的文字，但是没有写文章的动力，所以博客更新断了很多。雪球滚到后面，甚至都不想再打开来写了。</p><p>到现在情况稳定了一些。所以决定继续更新，并尽量将之前只有些许句子的东西写完。发布时间将仍然按照记录的时间，所以可能之后见到的一些更新是来自今年二月、三月等等的文章，首页可能就没太大的变化。还是 RSS 好啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为这7个月（或许可以说是一年多）以来的种种事情，虽然有一些破碎的文字，但是没有写文章的动力，所以博客更新断了很多。雪球滚到后面，甚至都不想再打开来写了。&lt;/p&gt;
&lt;p&gt;到现在情况稳定了一些。所以决定继续更新，并尽量将之前只有些许句子的东西写完。发布时间将仍然按照记录的时间
      
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>小事</title>
    <link href="https://blog.mottomo.moe/categories/Misc/zh/2018-08-20-Misc/"/>
    <id>https://blog.mottomo.moe/categories/Misc/zh/2018-08-20-Misc/</id>
    <published>2018-08-20T15:10:00.000Z</published>
    <updated>2020-03-30T22:34:35.449Z</updated>
    
    <content type="html"><![CDATA[<p>今天在北京遇见的三件事。从中大概能瞥见一丝市井百态。</p><a id="more"></a><hr><p>出租车司机的故事。</p><p>虽然举行了一次小型的同学聚会，但我是去北京办事的。</p><p>我原来就计划了地铁+步行的线路。不过出发的时候就已经掐着时间了。快走到地铁站的时候，发现有东西忘了拿，所以急忙跑回去。再坐地铁肯定是来不及的，那怎么办呢？打的吧。</p><p>路边基本都为了自行车道而设了栅栏，所以很难找到合适的位置。现在国内用得多的都是顺风车或者专车了，所以感觉出租车没有几年前本科在北京的时候那么好打了。最后总算在地铁口旁边找到一段看起来车流量较大，也容易停靠的地儿，拦下了一辆。</p><p>司机是一个壮实的天津汉子。我不擅长说话，所以最初的两分钟谁也没开口。不过就见他在车流中穿梭，驾轻就熟；“驾风”（如果以写文章作类比的话，就是文风吧）很犀利凶猛，大开大合。当时二环开始堵了，并稍微影响了我们上二环之前的道路。他看到其他的车道都开始拥塞了，就把车开上了公交专用道（上面写着是高峰时段专用，不过当时不是高峰时段）。我虽然心里着急赶时间啊，但是这种行为还是做不出来的，就说，师傅，不用这么着急。他说没什么，反正也不违规，他们不走这道是他们的事。从这里开始话匣子就打开了。</p><p>他说，开出租车要向公交车学习。为什么呢？公交车司机开一套路线，时间长得早就已经摸清了哪些路段在什么时候路况如何，（为了达到最高效率）在站和站之间走什么路，什么时候该变道，速度该开多快。于是我就问，听您说得这么熟悉，您也应该学到了这门本事吧。他说，差得远呢，不过每条路的“脾性”倒是略知一二。“毕竟到今年，我在北京开出租车已经开了15年了。”“那您之前是……？”“我之前是给领导开车的。”接着他就开始讲他以前的经历。</p><p>原来，在九十年代，他就出来做私人司机。当官员的司机可是一门很“讲究”的活儿。为什么呢？因为在接送的路上，乘客——也就是雇主官员，会在有意无意地透露出一些表面之下的消息。要不就是打电话，要不就是直接跟司机谈话。若是跟司机谈话，就会说起官场和天下之事，或者咨询（某种意义上也可以称之为考验）工作生活中遇到的问题。这司机要是机灵点（“这人可以用”），就有可能得到官员的赏识；要是不怎么机灵，比如智商、情商不够，那么多半过不了多久就会被解雇，毕竟这吃香的工作可是有不少人眼馋着呢。长此以往，被“筛选”出来的司机，除了为人处世得非常圆滑，还自然而然地掌握了官员的一些把柄。因此，司机也会被当做家人一般地看待，一方面是给予物质上的优待，收买人心，另一方面也是为了封口。当然，当司机可不仅仅是司机。由于司机基本上就只是为雇主服务，所以更像是被当做保姆使唤。接送家人（和小三，如果有）上下班/学，日常买菜买日用品，看到官员母亲咳嗽赶紧送到医院，都是基本功。当然这样累死累活的，也不是没有好处，只是需要熬出头。北京某厅长的司机，做了数年，深受赏识，被安排了个公安分局的局长（还是副局长来着）当，当着快活。二者就惺惺相惜，不仅是因为过去的关系，更是因为都对对方都知根知底。一方提拔有恩，另一方又知道内幕，形成了互相牵制的态势。</p><p>后来这位天津老哥为什么不做了呢？一部分原因是因为他洁身自好，虽然还吃得开，但是本来就不喜欢这个乌烟瘴气。最直接的动机是一次出差。雇他的领导带着几位小三去外地出差四五天，作为司机他当然得开车带着。但是这几天住还得跟着他们住啊（因为要短途接送），又不能自己跑回来。在这个时候他已经娶了媳妇（“又不是领导安排给的，怕啥”），她又是个暴脾气，就很不放心——你想想，两个男人，和几个女人，在外面好几天。过了不久，两人一合计，就把这个私人司机的工作给辞了。于是他改做出租车司机。</p><p>“一定要小心这种陷阱，万万不能贪图些啥把自己栽进去。”他说。</p><p>后来一路无话。</p><p>从这个故事中我也大致印证了玩政治的原理，就是组成利益集团。在组成的过程中，拿捏所在位置能提供的利益、实际提供的利益和提供利益造成的把柄（无论掌握的人是否处于利益集团内），是一项微妙的技能。同时由于这个链条图有传递性，所以一旦出现了一个老鼠屎，那么集团内的所有人很容易都变成老鼠屎；不变的人会在变的人处于优势时被尽快清除出这个集团。而夹在集团之间的人，没有太多力量，日子是最不好过的，所以大家会避免落到这样的境地。</p><p>同时我也知道了，在我很向往的“小时候”、中国信息技术拓荒的年代、这70年来中国经济发展速度最快的时候，底下仍旧容着千百年来同一滩死水。</p><p>可是我也不喜欢这一套。但或许这就是人性中恶心的一部分。</p><p>他没有改变什么。可能是因为他没想到过去改变什么，也可能是他也没法改变什么。</p><hr><p>搬家工人的故事。</p><p>朋友租的公寓位于东城区和朝阳区的边界上。这里楼房还是六七十年代的水泥箱子，也就是五六层的样子。但不仅外表，内在也并没有显示出多少朝气，处在居住和拆迁之间，衰败的气息都溢出了。但正因为如此，这里的房租才会低一些，虽然离地理意义上的“市中心”比较近。</p><p>在回来的时候经过一个这条街上比较繁华的十字路口。这个路口的一角有一家大型超市。而在路口的西边，停着一些小面包、三轮、小吃摊的手推车。在这里等待和歇息的人并没有多余的肉。</p><p>我经过的时候是中午，刚好碰上有一个搬家师傅，看上去是和媳妇一起干活的，有一辆小面包，体格结实。他在往地上放一块木质棋盘。与这个棋盘相称的，不是啤酒盖大小的小棋子，而是直径和一个乒乓球相当的、厚实的大棋子。坐在他对面的是另一个搬家师傅，精瘦。开面包车的师傅拿出两个小板凳；两人坐定。书上说的“在路边看人下棋”，我以前可是一次都没试过。所以我停了下来，站在一边观战。我注意到，（直到结束）加入围观的人只有三四个，而且除了我，都是四五十岁的农民工模样。</p><p>开战了。结实的师傅执红，精瘦的师傅执黑。开始的几手红黑双方都是毫不犹豫，迅速出招。寥寥数手，就已经一边丢了一匹马，一边丢了一架炮。移动和吃子的时候，棋子和棋盘磕得啪啪响。落子时还嚷嚷。“我吃你马！”“换子啊！好啊，换就换！”这并不“文雅”，却也不“俗”。</p><p>这时候双方陷入消耗战。红黑都在相互试探，试图打穿对方的防守；对方也在迂回，伺机反击。虽然一次次的攻防都不是很激烈，时常还是换子，但是随着时间推移，战局不知不觉进入了尾声。红方略占优势，士相全，仍有一车二马，四个兵；黑方缺一象，有一马一炮，三个卒。</p><p>这个时候精瘦师傅的手机响了。他掏出手机来，跟话筒另一边的人说了几句，“那你到路口的时候再打电话通知我一声啊”，挂了电话。然后他向结实的师傅解释，这个客户本来约定了这个时间搬家，但是现在对方有事，得推迟。于是棋局继续。然而精瘦师傅出招不慎，被对方用一个车卡住了脖子。虽然他仍然想要用马和炮，加上士、相逼将，但是（据我看）走错了一步，差距拉得更大了。在车和马的追击之下，他陷入了步步被将的局面，招架已经很难，已经显出穷途末路的样子，根本无力反击。这会儿精瘦师傅落子的速度明显慢了下来，而结实师傅每次都早有准备。黑炮没了。又过了几个回合，结实师傅把精瘦师傅给将死了，车和帅锁住两条线，马和兵将军。</p><p>收拾棋子的时候我就提出了对刚才错误的一步的想法。反正离终局也不远，这时候的棋子布局大家都记得。但是结实师傅说，你这样也没用啊，只要将车架到什么什么位置，依然会败下阵来。由于我太久没下象棋了，虽然他指出了之后的几步，但是我思考已经跟不上了。所以我只好含糊答应了几声，但并没有真正模拟出来。</p><p>第二局。风水轮流转，这次结实师傅在我还没反应过来的时候就已经落败了，所以我并不记得这局大概是怎么样的。时间总共也没五分钟。</p><p>恰好这时候精瘦师傅的手机又响了。这次客户是真的快到了，所以他就起身开始准备前往。棋局结束了，围观的人，包括我，就散了。</p><hr><p>一位小孩子的故事。</p><p>由于朋友租的公寓里的厨房处于事实上不用的状态（何等的惨状……），所以他们中午在公司解决，晚上都是出去吃。我也没办法，晚上就去附近的肯德基吃肥宅快乐餐。</p><p>我买了两份套餐，因为一份根本吃不饱，两份勉强。本来就这点的话我五六分钟就能解决，不过我恰巧听到有意思的对话，所以就放慢了速度，细嚼慢咽，装作一般人正常吃东西的样子。</p><p>在我斜对面的桌子，坐的是两位妇女，看上去都是三十来岁。一位比较……超重，从脸上看就是普通的肉乎，身材可是接近标准美国人。（后文就以“胖”“瘦”代称。）另一位比较正常。从她们的对话中我得知，这位胖阿姨有一个儿子，推测是四五岁。</p><p>胖：“小孩子长身体，要蛋白质嘛，我就特意去买了最贵的最高级的海参，做好了以后剁碎了加在饭里给他吃。但是他只是看了一眼，就直接说：‘不吃！’嫌这饭脏！第二天他爸把（海参末）加到面里，他还是不吃。最后还是他奶奶吃了。”</p><p>瘦：“哎哟这孩子怎么这样呢！”</p><p>胖：“还没完啊。小的时候他对鸡蛋过敏。后来长大了免疫力不是变强了吗，但是鸡蛋还是碰也不碰。……他一点都不吃肉。别的小朋友都喜欢吃麦当劳、肯德基，但他一点都不碰。”</p><p>瘦：“那他吃什么啊？”</p><p>胖：“他只吃素，只吃有限的几种蔬菜和水果。每天早上都是辣椒，中午是烙饼和大葱，晚上只吃白萝卜。……不光如此啊，就连水果，他也只吃苹果、桃子和□□（我没听清）。有一次我们一家去亲戚家摘樱桃。我说宝贝，这樱桃好吃，很甜的。他是看是我们自己（在亲戚家里）摘下来的才吃了几颗，给面子。要不然，他平时碰都不碰樱桃。……在幼儿园他也是不吃肉。老师也急了，中午就让他坐在中间吃饭，同学围成一圈看他吃饭，跟看戏一样，小朋友们看着都在笑。……我很喜欢吃零食，但怀他的时候就不敢乱吃东西，只吃素，所以他是胎里素。生他的时候我还担心他太瘦了。结果他出生的时候很健康，个头挺大的，重量中等偏上。虽然他只吃素，但是到现在也很健康……”</p><p>我就听到这里了。毕竟一我早就吃完了，二我还是不太喜欢干坐着，三我还得回去测试<a href="/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/">土豆的动作</a>。这就当故事记录下来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在北京遇见的三件事。从中大概能瞥见一丝市井百态。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="https://blog.mottomo.moe/categories/Misc/"/>
    
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>麻辣土豆模型和动作提取：六、物理</title>
    <link href="https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-07-MLTD-Dancing-6/"/>
    <id>https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-07-MLTD-Dancing-6/</id>
    <published>2018-08-07T07:12:00.000Z</published>
    <updated>2020-03-30T22:34:35.449Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/">系列目录</a></p><p>* “土豆”指的是<a href="https://millionlive.idolmaster.jp/theaterdays/" target="_blank" rel="noopener">偶像大师百万现场剧场时光</a>（ミリシタ/MLTD）</p><p>这篇文章讲一下土豆的物理。物理我没完全做好，但是至少做到了可以接受的程度。一些改进的想法我放到了代码注释中，有兴趣的人可以尝试实现一下。</p><a id="more"></a><hr><p>在每个身体和头的模型里，都有一个名为 <code>xxx_sway</code> 的 <code>TextAsset</code>。它里面就描述了这个模型的物理，包括 <code>SwayManager</code>、<code>SwayCollider</code> 和 <code>SwayBone</code>。我对 Unity 导入模型之后生成的 <code>GameObject</code> 不是很熟悉，所以不能下结论说土豆用的是什么样的物理系统。所以请忘记我在视频简介里说的“土豆用的不是 Unity 自带的物理系统”的话。不过，考虑到<a href="https://assetstore.unity.com/packages/tools/animation/dynamic-bone-16743" target="_blank" rel="noopener">类似的工具</a>是存在的，所以万代可能是自己做了一套。</p><p>上面不是关键的问题。关键的问题是，怎么把它转换成尽量和 MMD 兼容的东西？</p><p>MMD 使用的物理引擎是 Bullet，所以 PMX 支持三种碰撞体类型，分别是盒（box）、球（sphere）和胶囊（capsule）。还好，在土豆的物理数据中，大多数都是属于这三种类型的。如果忽略里面的一些参数，直接转换过去还是比较简单的。（不过我没做旋转的变换，所以胶囊都是沿着X/Y/Z轴方向的，如果是给 MMD 用的话，也就是做成 TDA 式，物理信息就是错误的。以后有空再说吧。）转换的同时要识别一下这些刚体属于哪个组，加上合适的非碰撞标志。还要注意的是，土豆的刚体的路径指的是其父关节。比如路径为 <code>MODEL_00/BODY_SCALE/BASE/KOSHI/skrt_GP/skrt_F0</code> 的 <code>SwayBone</code>，对应的骨骼就是 <code>MODEL_00/BODY_SCALE/BASE/KOSHI/skrt_GP/skrt_F0</code>（下一级是 <code>MODEL_00/BODY_SCALE/BASE/KOSHI/skrt_GP/skrt_F0/skrt_F1</code>）。这个刚体就该加在 <code>skrt_F0</code> 和 <code>skrt_F1</code> 之间。我一开始直接将刚体放在了对应名称的关节上，结果整个模型都软得不行，甚至会变成一滩水。这是典型的新手错误。</p><p>除了刚体，还需要加入一些铰链。铰链我就只在直接连接的刚体之间加了，比如头发的逐级连接。不过如果参考一些 MMD 的模型的话，应该在两根头发的同级刚体之间再加铰链。这跟我们上学期做的布料模型比较相似——当时我们只是加了结构弹簧，但实际上还有抗扭转弹簧（交叉位置的线性弹簧）和抗折叠弹簧（相邻三节点的角弹簧）。不过目前的简易方案已经能取得较为满意的效果，所以我就没去研究稍微复杂的铰链阵列了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;* “土豆”指的是&lt;a href=&quot;https://millionlive.idolmaster.jp/theaterdays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;偶像大师百万现场剧场时光&lt;/a&gt;（ミリシタ/MLTD）&lt;/p&gt;
&lt;p&gt;这篇文章讲一下土豆的物理。物理我没完全做好，但是至少做到了可以接受的程度。一些改进的想法我放到了代码注释中，有兴趣的人可以尝试实现一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="ACGN" scheme="https://blog.mottomo.moe/categories/Tech/ACGN/"/>
    
    
      <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="3D" scheme="https://blog.mottomo.moe/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>麻辣土豆模型和动作提取：五、表情和口型</title>
    <link href="https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-5/"/>
    <id>https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-5/</id>
    <published>2018-08-06T19:33:00.000Z</published>
    <updated>2020-03-30T22:34:35.448Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/">系列目录</a></p><p>* “土豆”指的是<a href="https://millionlive.idolmaster.jp/theaterdays/" target="_blank" rel="noopener">偶像大师百万现场剧场时光</a>（ミリシタ/MLTD）</p><p>这篇文章里，我讲一下土豆的面部操控（表情和口型）。</p><a id="more"></a><hr><p>在做土豆表情之前，我不知道土豆是用什么方法实现的。但是，MMD 的我知道啊。在 PMD/PMX 中，有一种东西叫做 morph，其中就包括 vertex morph。（当然还有其他的 material morph、UV morph 等等。）MMD 就是调整了每个 morph 的比重，来实现骨骼之外的模型变化。比如 vertex morph，存储的是一个列表，指定了受其影响的顶点在这个 morph 的比重达到1的时候，所加上的偏移。比如，在默认的姿势下位置在 <script type="math/tex">(1,2,3)</script> 的点，应用了比重0.5的偏移 <script type="math/tex">(2,3,4)</script>，就会移动到新坐标 <script type="math/tex">(2,3.5,5)</script>。据此一个模型可以做出不同的表情和口型及它们的混合。</p><p>我怀疑 Unity 中也有类似的东西，但是我不知道叫什么。我觉得，模型的 asset bundle 里就应该包含这个信息。所以我启动调试器，逐个属性地查看读取的模型信息（当然，要看头而不是身体啦）。随后我发现，<code>BlendShape</code> 的数组不是空的，而且它们的名字看起来就是操控面部的预定义变化的。于是我去找了找，原来这是 Maya 里的技术，Unity 同样<a href="https://docs.unity3d.com/Manual/BlendShapes.html" target="_blank" rel="noopener">支持</a>。在功能上，它就等价于 PMX 的 vertex morph。有了这个发现，之后的东西就简单了，因为就是两个等价的结构的互相转换。首先将这些 <code>BlendShape</code> 转换到 vertex morph，然后在 PMXEditor 中对它们进行测试，尽量找到对应的 MMD 常用面部控制名称，最后应用表情权重。</p><p>接下来就该看看是怎么动态控制的了。之前我探索过谱面所在的那个 <code>scrobj_xxxxxx.unity3d</code>，里面的 scenario 毫无疑问存放着表演数据。但是元素太多了，而且核心是个杂糅的结构体，经常出现字段共用。当时想，在无法看源代码的情况下，很难分离出不同类型的控制指令。这次我就对着 Blooming Star 的视频（因为只有一个人，干扰小，适合通过时间查找），先找出了控制口型的，然后是表情。其他我能肯定或者大概率是的一些类型也写在了代码中。口型还好办，对着歌词的时间看，就是直接设置为あ/い/う/え/お/ん或闭嘴。表情就麻烦一些，并不像 VMD 那样给出每个 morph 的权重，而是只有一个表情索引。也就是说，要先找出这个索引对应的是什么表情，然后再调出各个 morph 的权重，最后保存为表中的一个项。Blooming Star 还算简单，只有三种表情；其他的歌（和日常 commu）有更多的表情——至少有30种，而且受到 MV 摄像机限制，不是所有的都容易看到或者看清楚。不过这只是简单重复的工作，需要时间和耐心罢了。</p><p>表情的控制需要注意避免冲突。土豆的眨眼是和表情分离的，而有些表情需要闭眼（比如微笑）。所以一定要解决这个冲突，否则就要产生不合理的权重和诡异的表情了。（morph 的叠加只保证线性，权重归一化要自己保证。）口型也是如此，要注意口型变化的过渡时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;* “土豆”指的是&lt;a href=&quot;https://millionlive.idolmaster.jp/theaterdays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;偶像大师百万现场剧场时光&lt;/a&gt;（ミリシタ/MLTD）&lt;/p&gt;
&lt;p&gt;这篇文章里，我讲一下土豆的面部操控（表情和口型）。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="ACGN" scheme="https://blog.mottomo.moe/categories/Tech/ACGN/"/>
    
    
      <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="3D" scheme="https://blog.mottomo.moe/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>麻辣土豆模型和动作提取：四、摄像机</title>
    <link href="https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-4/"/>
    <id>https://blog.mottomo.moe/categories/Tech/ACGN/zh/2018-08-06-MLTD-Dancing-4/</id>
    <published>2018-08-06T13:50:00.000Z</published>
    <updated>2020-03-30T22:34:35.448Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/">系列目录</a></p><p>* “土豆”指的是<a href="https://millionlive.idolmaster.jp/theaterdays/" target="_blank" rel="noopener">偶像大师百万现场剧场时光</a>（ミリシタ/MLTD）</p><p>这篇文章讲解土豆的摄像机数据。</p><p><em>10月更新：近日在测试玩具的时候，发现 Unity 是直接支持 F-Curve 的（见 <a href="https://docs.unity3d.com/ScriptReference/Keyframe.html" target="_blank" rel="noopener"><code>KeyFrame</code></a> 的文档），而且其构造函数已经清楚地说明了值的意义。是我孤陋寡闻了。</em></p><a id="more"></a><hr><p>首先要清楚的是，摄像机的平移和旋转和模型、动作的一样，都是适用于 Unity 坐标系的。</p><p>打开摄像机数据的 asset bundle，里面同样有四个 <code>Imas.CharacterImasMotionAsset</code> 实例 idl、apa、apg 和 cam。同时还有两个用于竖屏（从名字可以看出，tate=縦）的镜头。（由此可以推测，apa 和 apg 是用于 fever 的特写镜头的。）</p><p>接着又看到了熟悉的 <code>Curve</code> 数组。但是有点不一样的是，这里的 <code>key_type</code> 都是 <code>FCurve</code>。<code>property_name</code> 的字段意义太过简单就不讲了。那么 <code>FCurve</code> 类型的 <code>Curve</code> 该怎么插值呢？我一开始也是不知道的，所以谷歌了一下。从 <a href="https://docs.blender.org/manual/en/dev/editors/graph_editor/fcurves/introduction.html" target="_blank" rel="noopener">Blender 的手册</a>中我对F曲线有了一个直观的认识。</p><blockquote><p>Although F-Curves are very similar to <a href="https://docs.blender.org/manual/en/dev/modeling/curves/structure.html#curve-bezier" target="_blank" rel="noopener">Bézier Curves</a>, there are some important differences.</p><p>For obvious reasons, a property represented by a Curve cannot have more than one value at a given time, hence:</p><ul><li>When you move a control point ahead of a control point that was previously ahead of the point that you are moving, the two control points switch their order in the edited curve, to avoid that the curve goes back in time.</li><li>For the above reason, it is impossible to have a closed F-Curve.</li></ul></blockquote><p>从这段话中，我推测，F曲线就是（三次）贝塞尔曲线在满足时间条件下的特殊情况。</p><p>从手册页面中，我们还可以得到一个重要的信息。在 Blender 中，调整F曲线形状用的是控制点（或者直译为句柄，handle）；从几种调整方式中可以看出，每个值点一般有三个控制点。（Vector 明显是可以指定离散值然后自动计算的。）其中有一个明显是调整值，那么另外两个呢？根据已有的知识，每个三次贝塞尔曲线段有四个点（两个值点，两个控制点），也就是说在这一段中，每个值有两个点（一个值点，一个控制点）。所以到此我们就可以猜想，F曲线的另外两个点是切线斜率的控制点了，分别控制左边和右边的斜率。虽然从数学角度想，它们也可以用来控制曲率，但这违反直观操作的习惯，而 Blender 不是面向数学家的，所以最有可能是斜率。</p><p>接着我们来解读存储的数据。从曲线数据中我们可以看出一些规律。我们取出 <a href="https://www.project-imas.com/wiki/Blooming_Star" target="_blank" rel="noopener">Blooming Star</a> 中的镜头数据。这段数据的属性如下：<code>path=&quot;CamBase&quot;</code>，<code>property_type=General</code>，<code>property_name=focalLength</code>，<code>key_type=FCurve</code>。</p><pre><code class="lang-plain">[0]float data = 0[1]float data = 35.19532[2]float data = ∞[3]float data = 0[4]float data = 5.666667[5]float data = 35.19532[6]float data = 0[7]float data = ∞[8]float data = 5.683333[9]float data = 64.44691[10]float data = ∞[11]float data = -6.156005</code></pre><p>首先，从数字的大小和增减幅度来看，有几个数字（第0、4、8个）很可能表示的是时间。如果如此的话，那这四些数据可能就是四个数字为一组的了。这个曲线用于焦距的插值，常用的焦距，以 35 mm 镜头为例，在 35 mm 到 60 mm 左右；焦距再小就是拍广角，再大就是拍远距离特写。第1、5、7个数据的范围就大致在这个区间，所以它们可能就是表示曲线该点的值（表示位置的时候就是坐标，以此类推）。那么剩下的两个呢？根据上面的预备知识，可以推测是左边和右边的斜率。合理性？观察一下，数字2（可能是第一个点的左斜率）是无穷，斜率无穷可以表示不存在，也就是这个点是不连续的。之后右斜率为0，下一个点左为0右不存在，再下一个左不存在右为-6.15。连续性匹配了，而且这些斜率（和标准视频）对比一下还挺合理的。因此就应该是左右斜率没错。</p><p>你可能要问，如果是真的不连续，那么两个相邻的曲线点的时间应该是一样的啊。不过你仔细看一下，5.666667和5.683333，考虑到单精度浮点数的精度，相差正好是<script type="math/tex">\frac{1}{60}</script>，这就是上一帧和下一帧嘛。</p><p>含义问题解决了，现在来看看怎么插值。我们有的数据是斜率，那么怎么找到两个控制点呢？从一份<a href="http://luthuli.cs.uiuc.edu/~daf/courses/cs-419/Week-12/Interpolation-2013.pdf" target="_blank" rel="noopener">讲义</a>（第26页）上可以知道，三次贝塞尔曲线（<script type="math/tex">b_{0}</script>、<script type="math/tex">b_{1}</script>、<script type="math/tex">b_{2}</script>、<script type="math/tex">b_{3}</script>）两端的斜率（也就是在该点的左/右导数）分别是 <script type="math/tex">3(b_{1}-b_{0})</script> 和 <script type="math/tex">3(b_{3}-b_{2})</script>。这样控制点就很容易算出来了……等等，知道了斜率，还需要知道长度才能计算控制点位置。经过实验，我发现这个长度不是常数，应该是与区间长度（时间）有关。最后取的长度是 <script type="math/tex">\frac{1}{3}(t_{2}-t_{1})</script>。</p><p>土豆的摄像机和 MMD 的略有不同。定位方式是小问题，前者用的是 eye+target，后者用的是 eye+orientation。最大的问题和身体动作一样，土豆的各属性插值曲线是独立的，MMD 又㕛叒叕是合在一起的。所以还是老方法，逐帧计算。在转换的过程中可能还有额外的变换（估计是因为我用 OpenTK），详见<a href="https://github.com/OpenMLTD/MLTDTools/blob/f0f7ee8d7f9e91d2f85f8e43fb26ad7b29aafd0e/src/MillionDance/Core/MvdCreator.Camera.cs" target="_blank" rel="noopener">代码</a>。结果可能还有一两个小错误，有时间再推敲一下？</p><p>需要注意的是，VMD 只支持整数 FOV，而逐帧计算必然会用到浮点 FOV，所以镜头导出到 VMD 不是一个好的选择。MVD（MMM 用的改进的 VMD）支持浮点 FOV，所以我默认选择生成的是 MVD。所以如果想看土豆的镜头，只能用 MMM 而不能用 MMD。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/categories/Tech/ACGN/zh/2018-08-03-MLTD-Dancing/&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;* “土豆”指的是&lt;a href=&quot;https://millionlive.idolmaster.jp/theaterdays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;偶像大师百万现场剧场时光&lt;/a&gt;（ミリシタ/MLTD）&lt;/p&gt;
&lt;p&gt;这篇文章讲解土豆的摄像机数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;10月更新：近日在测试玩具的时候，发现 Unity 是直接支持 F-Curve 的（见 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Keyframe.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;KeyFrame&lt;/code&gt;&lt;/a&gt; 的文档），而且其构造函数已经清楚地说明了值的意义。是我孤陋寡闻了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.mottomo.moe/categories/Tech/"/>
    
      <category term="ACGN" scheme="https://blog.mottomo.moe/categories/Tech/ACGN/"/>
    
    
      <category term="MLTD" scheme="https://blog.mottomo.moe/tags/MLTD/"/>
    
      <category term="日常" scheme="https://blog.mottomo.moe/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="3D" scheme="https://blog.mottomo.moe/tags/3D/"/>
    
  </entry>
  
</feed>
